{
  "timestamp": "2025-07-05T17:38:12.211Z",
  "projectMetrics": {
    "totalFiles": 307,
    "totalLines": 87196,
    "totalFunctions": 459,
    "totalClasses": 152,
    "duplicateCount": 92,
    "complexityScore": 12.636661211129296
  },
  "patterns": [
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "runMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\cli.ts",
          "startLine": 194,
          "endLine": 215,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      try {\r\n        const timestamp = new Date().toLocaleString();\r\n        console.log(`\\n🔄 Running monitoring cycle at ${timestamp}`);\r\n        \r\n        if (options.metrics) {\r\n          const collector = new MetricsCollector(projectRoot);\r\n          await collector.collectMetrics();\r\n          console.log('  ✅ Metrics collected');\r\n        }\r\n        \r\n        if (options.dashboard) {\r\n          await DashboardCLI.run(projectRoot, { notify: options.notifications });\r\n          console.log('  ✅ Dashboard updated');\r\n        }\r\n        \r\n        console.log(`  ⏰ Next update in ${options.interval} minutes`);\r\n        \r\n      } catch (error) {\r\n        console.error('  ❌ Error during monitoring cycle:', error);\r\n      }\r\n    }",
          "hash": "6c9f63bcb2d38c6225c70c3e8ecff174"
        },
        {
          "type": "function",
          "name": "runMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\cli.ts",
          "startLine": 193,
          "endLine": 214,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      try {\r\n        const timestamp = new Date().toLocaleString();\r\n        console.log(`\\n🔄 Running monitoring cycle at ${timestamp}`);\r\n        \r\n        if (options.metrics) {\r\n          const collector = new MetricsCollector(projectRoot);\r\n          await collector.collectMetrics();\r\n          console.log('  ✅ Metrics collected');\r\n        }\r\n        \r\n        if (options.dashboard) {\r\n          await DashboardCLI.run(projectRoot, { notify: options.notifications });\r\n          console.log('  ✅ Dashboard updated');\r\n        }\r\n        \r\n        console.log(`  ⏰ Next update in ${options.interval} minutes`);\r\n        \r\n      } catch (error) {\r\n        console.error('  ❌ Error during monitoring cycle:', error);\r\n      }\r\n    }",
          "hash": "6c9f63bcb2d38c6225c70c3e8ecff174"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 22
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "dfs",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 257,
          "endLine": 278,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (recursionStack.has(nodeId)) {\r\n        // Found a cycle\r\n        const cycleStart = path.indexOf(nodeId);\r\n        if (cycleStart !== -1) {\r\n          cycles.push(path.slice(cycleStart));\r\n        }\r\n        return;\r\n      }\r\n      \r\n      if (visited.has(nodeId)) return;\r\n      \r\n      visited.add(nodeId);\r\n      recursionStack.add(nodeId);\r\n      \r\n      const outgoingEdges = dependencyEdges.filter(e => e.source === nodeId);\r\n      for (const edge of outgoingEdges) {\r\n        dfs(edge.target, [...path, nodeId]);\r\n      }\r\n      \r\n      recursionStack.delete(nodeId);\r\n    }",
          "hash": "1695291ea10204c1b9eabc6e3710651f"
        },
        {
          "type": "function",
          "name": "dfs",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 257,
          "endLine": 278,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (recursionStack.has(nodeId)) {\r\n        // Found a cycle\r\n        const cycleStart = path.indexOf(nodeId);\r\n        if (cycleStart !== -1) {\r\n          cycles.push(path.slice(cycleStart));\r\n        }\r\n        return;\r\n      }\r\n      \r\n      if (visited.has(nodeId)) return;\r\n      \r\n      visited.add(nodeId);\r\n      recursionStack.add(nodeId);\r\n      \r\n      const outgoingEdges = dependencyEdges.filter(e => e.source === nodeId);\r\n      for (const edge of outgoingEdges) {\r\n        dfs(edge.target, [...path, nodeId]);\r\n      }\r\n      \r\n      recursionStack.delete(nodeId);\r\n    }",
          "hash": "1695291ea10204c1b9eabc6e3710651f"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 22
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 551,
          "endLine": 1153,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 552,
          "endLine": 1154,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 551,
          "endLine": 1153,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 552,
          "endLine": 1154,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        }
      ],
      "description": "Found 4 duplicate functions with identical logic",
      "severity": "high",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 1809
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 571,
          "endLine": 709,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 572,
          "endLine": 710,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        },
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 571,
          "endLine": 709,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 572,
          "endLine": 710,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        }
      ],
      "description": "Found 4 duplicate functions with identical logic",
      "severity": "high",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 417
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "angle",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 607,
          "endLine": 610,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      }",
          "hash": "c116f698852128781f2ea3156292fbbe"
        },
        {
          "type": "function",
          "name": "angle",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 607,
          "endLine": 610,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      }",
          "hash": "c116f698852128781f2ea3156292fbbe"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 4
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "updateVisualization",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 1124,
          "endLine": 1136,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }",
          "hash": "fb14ec7033c31b215819e64ba0424ee6"
        },
        {
          "type": "function",
          "name": "updateVisualization",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 1124,
          "endLine": 1136,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }",
          "hash": "fb14ec7033c31b215819e64ba0424ee6"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 13
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "countTestFiles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\metrics-collector.ts",
          "startLine": 190,
          "endLine": 204,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 15,
          "content": "{\r\n        if (!existsSync(dir)) return;\r\n        const files = readdirSync(dir);\r\n        files.forEach(file => {\r\n          const filePath = join(dir, file);\r\n          const stat = statSync(filePath);\r\n          if (stat.isDirectory()) {\r\n            countTestFiles(filePath);\r\n          } else if (file.endsWith('.test.ts') || file.endsWith('.test.js') || file.endsWith('.spec.ts')) {\r\n            testFiles++;\r\n            // Estimate tests per file (could be parsed more accurately)\r\n            totalTests += 3; // Average tests per file\r\n          }\r\n        });\r\n      }",
          "hash": "75fcac5c9767d118639f5b67092df99a"
        },
        {
          "type": "function",
          "name": "countTestFiles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\metrics-collector.ts",
          "startLine": 190,
          "endLine": 204,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 15,
          "content": "{\r\n        if (!existsSync(dir)) return;\r\n        const files = readdirSync(dir);\r\n        files.forEach(file => {\r\n          const filePath = join(dir, file);\r\n          const stat = statSync(filePath);\r\n          if (stat.isDirectory()) {\r\n            countTestFiles(filePath);\r\n          } else if (file.endsWith('.test.ts') || file.endsWith('.test.js') || file.endsWith('.spec.ts')) {\r\n            testFiles++;\r\n            // Estimate tests per file (could be parsed more accurately)\r\n            totalTests += 3; // Average tests per file\r\n          }\r\n        });\r\n      }",
          "hash": "75fcac5c9767d118639f5b67092df99a"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 15
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "change",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\metrics-collector.ts",
          "startLine": 385,
          "endLine": 424,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n    const progress = snapshot.projectMetrics.overallProgress;\r\n    const velocity = snapshot.projectMetrics.velocityPerWeek;\r\n    const blockedTasks = snapshot.projectMetrics.blockedTasks;\r\n    const testCoverage = snapshot.testMetrics?.testCoverage || 0;\r\n    \r\n    let score = 0;\r\n    \r\n    // Progress score (40% weight)\r\n    if (progress > 80) score += 40;\r\n    else if (progress > 60) score += 30;\r\n    else if (progress > 40) score += 20;\r\n    else score += 10;\r\n    \r\n    // Velocity score (30% weight)\r\n    if (velocity > 5) score += 30;\r\n    else if (velocity > 3) score += 20;\r\n    else if (velocity > 1) score += 10;\r\n    \r\n    // Quality score (20% weight)\r\n    if (testCoverage > 80) score += 20;\r\n    else if (testCoverage > 60) score += 15;\r\n    else if (testCoverage > 40) score += 10;\r\n    \r\n    // Risk score (10% weight) - negative impact\r\n    if (blockedTasks === 0) score += 10;\r\n    else if (blockedTasks < 3) score += 5;\r\n    \r\n    if (score >= 90) return 'excellent';\r\n    if (score >= 75) return 'good';\r\n    if (score >= 60) return 'warning';\r\n    return 'critical';\r\n  }\r\n\r\n  private generateExecutiveRecommendations(latest: MetricsSnapshot, trends: any): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (latest.projectMetrics.blockedTasks > 0) {\r\n      recommendations.push(`Immediate attention needed: ${latest.projectMetrics.blockedTasks} blocked tasks`);\r\n    }",
          "hash": "200161f2cce8f2a9cacc6d209fccf769"
        },
        {
          "type": "function",
          "name": "change",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\metrics-collector.ts",
          "startLine": 385,
          "endLine": 424,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n    const progress = snapshot.projectMetrics.overallProgress;\r\n    const velocity = snapshot.projectMetrics.velocityPerWeek;\r\n    const blockedTasks = snapshot.projectMetrics.blockedTasks;\r\n    const testCoverage = snapshot.testMetrics?.testCoverage || 0;\r\n    \r\n    let score = 0;\r\n    \r\n    // Progress score (40% weight)\r\n    if (progress > 80) score += 40;\r\n    else if (progress > 60) score += 30;\r\n    else if (progress > 40) score += 20;\r\n    else score += 10;\r\n    \r\n    // Velocity score (30% weight)\r\n    if (velocity > 5) score += 30;\r\n    else if (velocity > 3) score += 20;\r\n    else if (velocity > 1) score += 10;\r\n    \r\n    // Quality score (20% weight)\r\n    if (testCoverage > 80) score += 20;\r\n    else if (testCoverage > 60) score += 15;\r\n    else if (testCoverage > 40) score += 10;\r\n    \r\n    // Risk score (10% weight) - negative impact\r\n    if (blockedTasks === 0) score += 10;\r\n    else if (blockedTasks < 3) score += 5;\r\n    \r\n    if (score >= 90) return 'excellent';\r\n    if (score >= 75) return 'good';\r\n    if (score >= 60) return 'warning';\r\n    return 'critical';\r\n  }\r\n\r\n  private generateExecutiveRecommendations(latest: MetricsSnapshot, trends: any): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (latest.projectMetrics.blockedTasks > 0) {\r\n      recommendations.push(`Immediate attention needed: ${latest.projectMetrics.blockedTasks} blocked tasks`);\r\n    }",
          "hash": "200161f2cce8f2a9cacc6d209fccf769"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 40
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 13,
          "endLine": 30,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 18,
          "content": "{\r\n  isValid: boolean;\r\n  message: string;\r\n  suggestions?: string[];\r\n  autoFix?: () => void;\r\n}\r\n\r\nexport interface ValidationContext {\r\n  projectRoot: string;\r\n  tasksData: any;\r\n  validationConfig: ValidationConfig;\r\n}\r\n\r\nexport interface ValidationConfig {\r\n  rules: {\r\n    enabled: string[];\r\n    disabled: string[];\r\n  }",
          "hash": "5a43ad8019d7cffcff68664a6915871d"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 13,
          "endLine": 30,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 18,
          "content": "{\r\n  isValid: boolean;\r\n  message: string;\r\n  suggestions?: string[];\r\n  autoFix?: () => void;\r\n}\r\n\r\nexport interface ValidationContext {\r\n  projectRoot: string;\r\n  tasksData: any;\r\n  validationConfig: ValidationConfig;\r\n}\r\n\r\nexport interface ValidationConfig {\r\n  rules: {\r\n    enabled: string[];\r\n    disabled: string[];\r\n  }",
          "hash": "5a43ad8019d7cffcff68664a6915871d"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 18
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 299,
          "endLine": 326,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 28,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          if (!task.dependencies || task.dependencies.length === 0) {\r\n            return { isValid: true, message: 'No dependencies to check' };\r\n          }\r\n\r\n          const incompleteDeps = task.dependencies.filter((depId: string) => {\r\n            const depTask = this.findTask(allTasks, depId);\r\n            return !depTask || depTask.status !== 'done';\r\n          });\r\n\r\n          if (incompleteDeps.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is marked as done but has incomplete dependencies: ${incompleteDeps.join(', ')}`,\r\n              suggestions: [\r\n                'Complete dependency tasks first',\r\n                'Remove invalid dependencies',\r\n                'Change task status to in-progress or pending'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'All dependencies completed' };\r\n        }",
          "hash": "4529699d0651e3b1b53b7b504eabf1de"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 299,
          "endLine": 326,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 28,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          if (!task.dependencies || task.dependencies.length === 0) {\r\n            return { isValid: true, message: 'No dependencies to check' };\r\n          }\r\n\r\n          const incompleteDeps = task.dependencies.filter((depId: string) => {\r\n            const depTask = this.findTask(allTasks, depId);\r\n            return !depTask || depTask.status !== 'done';\r\n          });\r\n\r\n          if (incompleteDeps.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is marked as done but has incomplete dependencies: ${incompleteDeps.join(', ')}`,\r\n              suggestions: [\r\n                'Complete dependency tasks first',\r\n                'Remove invalid dependencies',\r\n                'Change task status to in-progress or pending'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'All dependencies completed' };\r\n        }",
          "hash": "4529699d0651e3b1b53b7b504eabf1de"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 28
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 334,
          "endLine": 376,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n          // Check if task has subtasks\r\n          if (task.subtasks && task.subtasks.length > 0) {\r\n            const completedSubtasks = task.subtasks.filter((st: any) => st.status === 'done').length;\r\n            const totalSubtasks = task.subtasks.length;\r\n            const completionRate = completedSubtasks / totalSubtasks;\r\n\r\n            // Parent task status should reflect subtask completion\r\n            if (completionRate === 1 && task.status !== 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but is not marked as done`,\r\n                suggestions: ['Mark task as done', 'Review subtask completion'],\r\n                autoFix: () => {\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n\r\n            if (completionRate === 0 && task.status === 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} is marked as done but has no completed subtasks`,\r\n                suggestions: ['Review task status', 'Complete subtasks first']\r\n              };\r\n            }\r\n\r\n            if (completionRate > 0 && completionRate < 1 && task.status === 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has partially completed subtasks but is still marked as pending`,\r\n                suggestions: ['Update status to in-progress'],\r\n                autoFix: () => {\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Status is consistent' };\r\n        }",
          "hash": "67878020f48c265ae3f3f74bf969f307"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 334,
          "endLine": 376,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n          // Check if task has subtasks\r\n          if (task.subtasks && task.subtasks.length > 0) {\r\n            const completedSubtasks = task.subtasks.filter((st: any) => st.status === 'done').length;\r\n            const totalSubtasks = task.subtasks.length;\r\n            const completionRate = completedSubtasks / totalSubtasks;\r\n\r\n            // Parent task status should reflect subtask completion\r\n            if (completionRate === 1 && task.status !== 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but is not marked as done`,\r\n                suggestions: ['Mark task as done', 'Review subtask completion'],\r\n                autoFix: () => {\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n\r\n            if (completionRate === 0 && task.status === 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} is marked as done but has no completed subtasks`,\r\n                suggestions: ['Review task status', 'Complete subtasks first']\r\n              };\r\n            }\r\n\r\n            if (completionRate > 0 && completionRate < 1 && task.status === 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has partially completed subtasks but is still marked as pending`,\r\n                suggestions: ['Update status to in-progress'],\r\n                autoFix: () => {\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Status is consistent' };\r\n        }",
          "hash": "67878020f48c265ae3f3f74bf969f307"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 43
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 347,
          "endLine": 350,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "9d7f15edb0d7502791ea3fa475e20d37"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 347,
          "endLine": 350,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "9d7f15edb0d7502791ea3fa475e20d37"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 4
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 367,
          "endLine": 370,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "a47801b94ec245173e29cf80b9bb0726"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 367,
          "endLine": 370,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "a47801b94ec245173e29cf80b9bb0726"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 4
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 384,
          "endLine": 420,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 37,
          "content": "{\r\n          if (task.status !== 'blocked') {\r\n            return { isValid: true, message: 'Task is not blocked' };\r\n          }\r\n\r\n          // Check if blocked task has blocking reasons\r\n          if (!task.blockers || task.blockers.length === 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has no specified blockers`,\r\n              suggestions: [\r\n                'Add blocker details to task',\r\n                'Change status if not actually blocked',\r\n                'Create issues for blockers'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if any tasks depend on this blocked task and are marked as done\r\n          const dependentTasks = allTasks.filter((t: any) => \r\n            t.dependencies && t.dependencies.includes(task.id.toString()) && t.status === 'done'\r\n          );\r\n\r\n          if (dependentTasks.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has dependent tasks marked as done: ${dependentTasks.map((t: any) => t.id).join(', ')}`,\r\n              suggestions: [\r\n                'Resolve blocking issues',\r\n                'Review dependent task statuses',\r\n                'Update task dependencies'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Blocking validation passed' };\r\n        }",
          "hash": "35a18eefd4a192eeba6c37abe943a0b9"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 384,
          "endLine": 420,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 37,
          "content": "{\r\n          if (task.status !== 'blocked') {\r\n            return { isValid: true, message: 'Task is not blocked' };\r\n          }\r\n\r\n          // Check if blocked task has blocking reasons\r\n          if (!task.blockers || task.blockers.length === 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has no specified blockers`,\r\n              suggestions: [\r\n                'Add blocker details to task',\r\n                'Change status if not actually blocked',\r\n                'Create issues for blockers'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if any tasks depend on this blocked task and are marked as done\r\n          const dependentTasks = allTasks.filter((t: any) => \r\n            t.dependencies && t.dependencies.includes(task.id.toString()) && t.status === 'done'\r\n          );\r\n\r\n          if (dependentTasks.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has dependent tasks marked as done: ${dependentTasks.map((t: any) => t.id).join(', ')}`,\r\n              suggestions: [\r\n                'Resolve blocking issues',\r\n                'Review dependent task statuses',\r\n                'Update task dependencies'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Blocking validation passed' };\r\n        }",
          "hash": "35a18eefd4a192eeba6c37abe943a0b9"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 37
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 428,
          "endLine": 460,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 33,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          // Check if task has required fields when marked as done\r\n          if (!task.details || task.details.trim().length < 10) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} lacks sufficient details`,\r\n              suggestions: [\r\n                'Add comprehensive task details',\r\n                'Document completion steps',\r\n                'Include verification information'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if test strategy is defined for completed tasks\r\n          if (!task.testStrategy) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} has no test strategy defined`,\r\n              suggestions: [\r\n                'Define test strategy',\r\n                'Add verification steps',\r\n                'Document quality assurance process'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Completion requirements met' };\r\n        }",
          "hash": "3eff6d069de472b8f89cbaa5d7f811ea"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 428,
          "endLine": 460,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 33,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          // Check if task has required fields when marked as done\r\n          if (!task.details || task.details.trim().length < 10) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} lacks sufficient details`,\r\n              suggestions: [\r\n                'Add comprehensive task details',\r\n                'Document completion steps',\r\n                'Include verification information'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if test strategy is defined for completed tasks\r\n          if (!task.testStrategy) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} has no test strategy defined`,\r\n              suggestions: [\r\n                'Define test strategy',\r\n                'Add verification steps',\r\n                'Document quality assurance process'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Completion requirements met' };\r\n        }",
          "hash": "3eff6d069de472b8f89cbaa5d7f811ea"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 33
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 468,
          "endLine": 507,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n          if (!task.subtasks || task.subtasks.length === 0) {\r\n            return { isValid: true, message: 'No subtasks to synchronize' };\r\n          }\r\n\r\n          const subtaskStatuses = task.subtasks.map((st: any) => st.status);\r\n          const uniqueStatuses = [...new Set(subtaskStatuses)];\r\n\r\n          // If all subtasks are done, parent should be done or in review\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'done') {\r\n            if (task.status !== 'done' && task.status !== 'review') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to done or review'],\r\n                autoFix: () => {\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          // If no subtasks are started, parent should be pending\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'pending') {\r\n            if (task.status !== 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks pending but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to pending'],\r\n                autoFix: () => {\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Parent-child status synchronized' };\r\n        }",
          "hash": "578795d15c5a365480987215ccf9c9be"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 468,
          "endLine": 507,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n          if (!task.subtasks || task.subtasks.length === 0) {\r\n            return { isValid: true, message: 'No subtasks to synchronize' };\r\n          }\r\n\r\n          const subtaskStatuses = task.subtasks.map((st: any) => st.status);\r\n          const uniqueStatuses = [...new Set(subtaskStatuses)];\r\n\r\n          // If all subtasks are done, parent should be done or in review\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'done') {\r\n            if (task.status !== 'done' && task.status !== 'review') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to done or review'],\r\n                autoFix: () => {\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          // If no subtasks are started, parent should be pending\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'pending') {\r\n            if (task.status !== 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks pending but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to pending'],\r\n                autoFix: () => {\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Parent-child status synchronized' };\r\n        }",
          "hash": "578795d15c5a365480987215ccf9c9be"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 40
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 483,
          "endLine": 486,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "0126a3ca9f90b171688b85ac86a0a187"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 483,
          "endLine": 486,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "0126a3ca9f90b171688b85ac86a0a187"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 4
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 498,
          "endLine": 501,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "808483eedb9d77ce53742fc56c3ded54"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 498,
          "endLine": 501,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "808483eedb9d77ce53742fc56c3ded54"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 4
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 515,
          "endLine": 550,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 36,
          "content": "{\r\n          if (!task.endDate) {\r\n            return { isValid: true, message: 'No deadline set' };\r\n          }\r\n\r\n          const deadline = new Date(task.endDate);\r\n          const now = new Date();\r\n\r\n          if (deadline < now && task.status !== 'done' && task.status !== 'cancelled') {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is overdue (deadline: ${deadline.toLocaleDateString()})`,\r\n              suggestions: [\r\n                'Update deadline if still relevant',\r\n                'Complete task urgently',\r\n                'Mark as cancelled if no longer needed',\r\n                'Escalate to project manager'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if deadline is unrealistic (in the past for pending tasks)\r\n          if (deadline < now && task.status === 'pending') {\r\n            return {\r\n              isValid: false,\r\n              message: `Pending task ${task.id} has deadline in the past`,\r\n              suggestions: [\r\n                'Update deadline to realistic date',\r\n                'Start task immediately',\r\n                'Review task priority'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Deadline validation passed' };\r\n        }",
          "hash": "e1ffc74d024d33bc2e311ac2393db1b2"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 515,
          "endLine": 550,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 36,
          "content": "{\r\n          if (!task.endDate) {\r\n            return { isValid: true, message: 'No deadline set' };\r\n          }\r\n\r\n          const deadline = new Date(task.endDate);\r\n          const now = new Date();\r\n\r\n          if (deadline < now && task.status !== 'done' && task.status !== 'cancelled') {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is overdue (deadline: ${deadline.toLocaleDateString()})`,\r\n              suggestions: [\r\n                'Update deadline if still relevant',\r\n                'Complete task urgently',\r\n                'Mark as cancelled if no longer needed',\r\n                'Escalate to project manager'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if deadline is unrealistic (in the past for pending tasks)\r\n          if (deadline < now && task.status === 'pending') {\r\n            return {\r\n              isValid: false,\r\n              message: `Pending task ${task.id} has deadline in the past`,\r\n              suggestions: [\r\n                'Update deadline to realistic date',\r\n                'Start task immediately',\r\n                'Review task priority'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Deadline validation passed' };\r\n        }",
          "hash": "e1ffc74d024d33bc2e311ac2393db1b2"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 36
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 558,
          "endLine": 598,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n          // High priority tasks shouldn't be pending for too long\r\n          if (task.priority === 'high' && task.status === 'pending') {\r\n            const lastUpdated = task.lastUpdated ? new Date(task.lastUpdated) : new Date();\r\n            const daysSinceUpdate = (Date.now() - lastUpdated.getTime()) / (1000 * 60 * 60 * 24);\r\n\r\n            if (daysSinceUpdate > 3) {\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          // Critical priority tasks should have clear dependencies\r\n          if (task.priority === 'critical') {\r\n            const dependentTasks = allTasks.filter((t: any) => \r\n              t.dependencies && t.dependencies.includes(task.id.toString())\r\n            );\r\n\r\n            if (dependentTasks.length === 0) {\r\n              return {\r\n                isValid: false,\r\n                message: `Critical priority task ${task.id} has no dependent tasks`,\r\n                suggestions: [\r\n                  'Review priority classification',\r\n                  'Identify dependent tasks',\r\n                  'Document critical path importance'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Priority consistency validated' };\r\n        }",
          "hash": "380fb52b2895355fdb40e5376f97d636"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 558,
          "endLine": 598,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n          // High priority tasks shouldn't be pending for too long\r\n          if (task.priority === 'high' && task.status === 'pending') {\r\n            const lastUpdated = task.lastUpdated ? new Date(task.lastUpdated) : new Date();\r\n            const daysSinceUpdate = (Date.now() - lastUpdated.getTime()) / (1000 * 60 * 60 * 24);\r\n\r\n            if (daysSinceUpdate > 3) {\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          // Critical priority tasks should have clear dependencies\r\n          if (task.priority === 'critical') {\r\n            const dependentTasks = allTasks.filter((t: any) => \r\n              t.dependencies && t.dependencies.includes(task.id.toString())\r\n            );\r\n\r\n            if (dependentTasks.length === 0) {\r\n              return {\r\n                isValid: false,\r\n                message: `Critical priority task ${task.id} has no dependent tasks`,\r\n                suggestions: [\r\n                  'Review priority classification',\r\n                  'Identify dependent tasks',\r\n                  'Document critical path importance'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Priority consistency validated' };\r\n        }",
          "hash": "380fb52b2895355fdb40e5376f97d636"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 41
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "daysSinceUpdate",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 562,
          "endLine": 573,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }",
          "hash": "7e88d083356ef01e016b03c52d7ee238"
        },
        {
          "type": "function",
          "name": "daysSinceUpdate",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 562,
          "endLine": 573,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }",
          "hash": "7e88d083356ef01e016b03c52d7ee238"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 12
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "scan",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\unified-analyzer.ts",
          "startLine": 762,
          "endLine": 778,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n      try {\r\n        const items = await this.readdir(dir);\r\n        for (const item of items) {\r\n          if (this.config.ignoredPaths.some((ignored: string) => item.includes(ignored))) continue;\r\n          const fullPath = path.join(dir, item);\r\n          const stats = await this.stat(fullPath);\r\n          if (stats.isDirectory()) {\r\n            await scan(fullPath);\r\n          } else if (stats.size < this.config.maxFileSize) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Ignore permission errors\r\n      }\r\n    }",
          "hash": "d63e59e47f9fde17e8f7c67ef53dc587"
        },
        {
          "type": "function",
          "name": "scan",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\understanding\\unified-analyzer.ts",
          "startLine": 762,
          "endLine": 778,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n      try {\r\n        const items = await this.readdir(dir);\r\n        for (const item of items) {\r\n          if (this.config.ignoredPaths.some((ignored: string) => item.includes(ignored))) continue;\r\n          const fullPath = path.join(dir, item);\r\n          const stats = await this.stat(fullPath);\r\n          if (stats.isDirectory()) {\r\n            await scan(fullPath);\r\n          } else if (stats.size < this.config.maxFileSize) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Ignore permission errors\r\n      }\r\n    }",
          "hash": "d63e59e47f9fde17e8f7c67ef53dc587"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 17
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "createUnifiedAnalyzer",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\unified-analyzer.ts",
          "startLine": 1048,
          "endLine": 1050,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return new UnifiedProjectAnalyzer(projectRoot, config);\r\n}",
          "hash": "4805b9997d165ca97d8cb628f7d0bfb5"
        },
        {
          "type": "function",
          "name": "createUnifiedAnalyzer",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\understanding\\unified-analyzer.ts",
          "startLine": 1048,
          "endLine": 1050,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return new UnifiedProjectAnalyzer(projectRoot, config);\r\n}",
          "hash": "4805b9997d165ca97d8cb628f7d0bfb5"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 3
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "runFixedBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\fixed-sma-backtest.ts",
          "startLine": 107,
          "endLine": 205,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 99,
          "content": "{\r\n  console.log('\\n----- RUNNING FIXED SMA CROSSOVER BACKTEST -----');\r\n  \r\n  // Generate sample price data with clear trends for testing\r\n  const candles = generateSampleData();\r\n  console.log(`Generated ${candles.length} sample candles`);\r\n  \r\n  // Create the fixed signal processor\r\n  const processor = new FixedSMASignalProcessor();\r\n  \r\n  // Trading state\r\n  let position: 'long' | 'short' | null = null;\r\n  let entryPrice = 0;\r\n  let totalProfit = 0;\r\n  let trades = 0;\r\n  \r\n  // Process candles with sliding window\r\n  const windowSize = 30; // Enough data for calculations\r\n  \r\n  console.log('\\nProcessing price data...');\r\n  for (let i = windowSize; i < candles.length; i++) {\r\n    // Get current window\r\n    const window = candles.slice(i - windowSize, i + 1);\r\n    \r\n    // Safety check\r\n    if (window.length === 0) {\r\n      continue;\r\n    }\r\n    \r\n    const lastCandle = window[window.length - 1];\r\n    if (!lastCandle) {\r\n      continue;\r\n    }\r\n    \r\n    const currentPrice = lastCandle.close;\r\n    console.log(`\\nWindow ${i}: Price ${currentPrice.toFixed(2)}`);\r\n    \r\n    // Process signal\r\n    const result = processor.process(window);\r\n    \r\n    // Track position and calculate P&L\r\n    if (result) {\r\n      if (result.signal > 0.7) { // Strong buy signal\r\n        if (position === 'short') {\r\n          // Close short position\r\n          const profit = entryPrice - currentPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close SHORT position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open long position\r\n          position = 'long';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open LONG position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      } else if (result.signal < -0.7) { // Strong sell signal\r\n        if (position === 'long') {\r\n          // Close long position\r\n          const profit = currentPrice - entryPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close LONG position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open short position\r\n          position = 'short';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open SHORT position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close any open position\r\n  if (position && candles.length > 0) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      const lastPrice = lastCandle.close;\r\n      const profit = position === 'long' ? \r\n        (lastPrice - entryPrice) : (entryPrice - lastPrice);\r\n      totalProfit += profit;\r\n      console.log(`Close final ${position} position at ${lastPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n    }\r\n  }\r\n  \r\n  // Print results\r\n  console.log('\\n----- BACKTEST RESULTS -----');\r\n  console.log(`Total trades: ${trades}`);\r\n  console.log(`Total profit: ${totalProfit.toFixed(2)}`);\r\n  console.log(`Final position: ${position || 'none'}`);\r\n  console.log('---------------------------\\n');\r\n}",
          "hash": "77322cfc9714c8c1f2dcf994c66daa1e"
        },
        {
          "type": "function",
          "name": "runFixedBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\fixed-sma-backtest.ts",
          "startLine": 107,
          "endLine": 205,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 99,
          "content": "{\r\n  console.log('\\n----- RUNNING FIXED SMA CROSSOVER BACKTEST -----');\r\n  \r\n  // Generate sample price data with clear trends for testing\r\n  const candles = generateSampleData();\r\n  console.log(`Generated ${candles.length} sample candles`);\r\n  \r\n  // Create the fixed signal processor\r\n  const processor = new FixedSMASignalProcessor();\r\n  \r\n  // Trading state\r\n  let position: 'long' | 'short' | null = null;\r\n  let entryPrice = 0;\r\n  let totalProfit = 0;\r\n  let trades = 0;\r\n  \r\n  // Process candles with sliding window\r\n  const windowSize = 30; // Enough data for calculations\r\n  \r\n  console.log('\\nProcessing price data...');\r\n  for (let i = windowSize; i < candles.length; i++) {\r\n    // Get current window\r\n    const window = candles.slice(i - windowSize, i + 1);\r\n    \r\n    // Safety check\r\n    if (window.length === 0) {\r\n      continue;\r\n    }\r\n    \r\n    const lastCandle = window[window.length - 1];\r\n    if (!lastCandle) {\r\n      continue;\r\n    }\r\n    \r\n    const currentPrice = lastCandle.close;\r\n    console.log(`\\nWindow ${i}: Price ${currentPrice.toFixed(2)}`);\r\n    \r\n    // Process signal\r\n    const result = processor.process(window);\r\n    \r\n    // Track position and calculate P&L\r\n    if (result) {\r\n      if (result.signal > 0.7) { // Strong buy signal\r\n        if (position === 'short') {\r\n          // Close short position\r\n          const profit = entryPrice - currentPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close SHORT position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open long position\r\n          position = 'long';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open LONG position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      } else if (result.signal < -0.7) { // Strong sell signal\r\n        if (position === 'long') {\r\n          // Close long position\r\n          const profit = currentPrice - entryPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close LONG position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open short position\r\n          position = 'short';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open SHORT position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close any open position\r\n  if (position && candles.length > 0) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      const lastPrice = lastCandle.close;\r\n      const profit = position === 'long' ? \r\n        (lastPrice - entryPrice) : (entryPrice - lastPrice);\r\n      totalProfit += profit;\r\n      console.log(`Close final ${position} position at ${lastPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n    }\r\n  }\r\n  \r\n  // Print results\r\n  console.log('\\n----- BACKTEST RESULTS -----');\r\n  console.log(`Total trades: ${trades}`);\r\n  console.log(`Total profit: ${totalProfit.toFixed(2)}`);\r\n  console.log(`Final position: ${position || 'none'}`);\r\n  console.log('---------------------------\\n');\r\n}",
          "hash": "77322cfc9714c8c1f2dcf994c66daa1e"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 99
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "runBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\sma-backtest.ts",
          "startLine": 26,
          "endLine": 180,
          "complexity": 18,
          "dependencies": [],
          "usageCount": 0,
          "size": 155,
          "content": "{\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}",
          "hash": "c0a8e331992cbf831ea3ca2272bbb9ba"
        },
        {
          "type": "function",
          "name": "runBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\sma-backtest.ts",
          "startLine": 26,
          "endLine": 180,
          "complexity": 18,
          "dependencies": [],
          "usageCount": 0,
          "size": 155,
          "content": "{\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}",
          "hash": "c0a8e331992cbf831ea3ca2272bbb9ba"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 155
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "generateSyntheticCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 28,
          "endLine": 34,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}",
          "hash": "5e5bed3186bbcd8fea06df21126954fd"
        },
        {
          "type": "function",
          "name": "generateSyntheticCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts",
          "startLine": 21,
          "endLine": 27,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}",
          "hash": "5e5bed3186bbcd8fea06df21126954fd"
        },
        {
          "type": "function",
          "name": "generateSyntheticCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 28,
          "endLine": 34,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}",
          "hash": "5e5bed3186bbcd8fea06df21126954fd"
        }
      ],
      "description": "Found 3 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 14
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "randomMovement",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 47,
          "endLine": 54,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "9b8fc06ce20784f6e7c9e94170a33760"
        },
        {
          "type": "function",
          "name": "randomMovement",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts",
          "startLine": 40,
          "endLine": 47,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "9b8fc06ce20784f6e7c9e94170a33760"
        },
        {
          "type": "function",
          "name": "randomMovement",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 47,
          "endLine": 54,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "9b8fc06ce20784f6e7c9e94170a33760"
        }
      ],
      "description": "Found 3 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 16
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "processAndTrade",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 75,
          "endLine": 178,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 104,
          "content": "{\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}",
          "hash": "dfba8b52503986219f2d6be3a07b5c4b"
        },
        {
          "type": "function",
          "name": "processAndTrade",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 75,
          "endLine": 178,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 104,
          "content": "{\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}",
          "hash": "dfba8b52503986219f2d6be3a07b5c4b"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 104
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "runComparisonTest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 181,
          "endLine": 248,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 68,
          "content": "{\r\n  console.log('Starting SMA Signal Processor Comparison Test');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 200,\r\n    volatility: 0.01,\r\n    trendStrength: 0.005,\r\n    trendChangeProbability: 0.05\r\n  });\r\n  \r\n  // Create processors\r\n  const originalProcessor = new SMASignalProcessor(config);\r\n  const improvedProcessor = new ImprovedSMASignalProcessor(config);\r\n  \r\n  // Process with both implementations\r\n  console.log('\\nRunning Original SMA Signal Processor...');\r\n  const originalResults = processAndTrade(originalProcessor, candles);\r\n  \r\n  console.log('\\nRunning Improved SMA Signal Processor...');\r\n  const improvedResults = processAndTrade(improvedProcessor, candles);\r\n  \r\n  // Log comparison results\r\n  console.log('\\n===== COMPARISON RESULTS =====');\r\n  console.log(`Original: ${originalResults.signals.length} signals, ${originalResults.trades.length} trades, P&L: ${originalResults.pnl.toFixed(2)}`);\r\n  console.log(`Improved: ${improvedResults.signals.length} signals, ${improvedResults.trades.length} trades, P&L: ${improvedResults.pnl.toFixed(2)}`);\r\n  \r\n  // Generate comparison report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      original: {\r\n        signalCount: originalResults.signals.length,\r\n        tradeCount: originalResults.trades.length,\r\n        pnl: originalResults.pnl\r\n      },\r\n      improved: {\r\n        signalCount: improvedResults.signals.length,\r\n        tradeCount: improvedResults.trades.length,\r\n        pnl: improvedResults.pnl\r\n      },\r\n      comparison: {\r\n        signalDifference: improvedResults.signals.length - originalResults.signals.length,\r\n        pnlDifference: improvedResults.pnl - originalResults.pnl\r\n      }\r\n    },\r\n    details: {\r\n      original: {\r\n        signals: originalResults.signals,\r\n        trades: originalResults.trades\r\n      },\r\n      improved: {\r\n        signals: improvedResults.signals,\r\n        trades: improvedResults.trades\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-comparison-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Comparison report saved to sma-comparison-report.json');\r\n}",
          "hash": "70bc8fa33e2d6ad9d570a686acc49340"
        },
        {
          "type": "function",
          "name": "runComparisonTest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 181,
          "endLine": 248,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 68,
          "content": "{\r\n  console.log('Starting SMA Signal Processor Comparison Test');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 200,\r\n    volatility: 0.01,\r\n    trendStrength: 0.005,\r\n    trendChangeProbability: 0.05\r\n  });\r\n  \r\n  // Create processors\r\n  const originalProcessor = new SMASignalProcessor(config);\r\n  const improvedProcessor = new ImprovedSMASignalProcessor(config);\r\n  \r\n  // Process with both implementations\r\n  console.log('\\nRunning Original SMA Signal Processor...');\r\n  const originalResults = processAndTrade(originalProcessor, candles);\r\n  \r\n  console.log('\\nRunning Improved SMA Signal Processor...');\r\n  const improvedResults = processAndTrade(improvedProcessor, candles);\r\n  \r\n  // Log comparison results\r\n  console.log('\\n===== COMPARISON RESULTS =====');\r\n  console.log(`Original: ${originalResults.signals.length} signals, ${originalResults.trades.length} trades, P&L: ${originalResults.pnl.toFixed(2)}`);\r\n  console.log(`Improved: ${improvedResults.signals.length} signals, ${improvedResults.trades.length} trades, P&L: ${improvedResults.pnl.toFixed(2)}`);\r\n  \r\n  // Generate comparison report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      original: {\r\n        signalCount: originalResults.signals.length,\r\n        tradeCount: originalResults.trades.length,\r\n        pnl: originalResults.pnl\r\n      },\r\n      improved: {\r\n        signalCount: improvedResults.signals.length,\r\n        tradeCount: improvedResults.trades.length,\r\n        pnl: improvedResults.pnl\r\n      },\r\n      comparison: {\r\n        signalDifference: improvedResults.signals.length - originalResults.signals.length,\r\n        pnlDifference: improvedResults.pnl - originalResults.pnl\r\n      }\r\n    },\r\n    details: {\r\n      original: {\r\n        signals: originalResults.signals,\r\n        trades: originalResults.trades\r\n      },\r\n      improved: {\r\n        signals: improvedResults.signals,\r\n        trades: improvedResults.trades\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-comparison-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Comparison report saved to sma-comparison-report.json');\r\n}",
          "hash": "70bc8fa33e2d6ad9d570a686acc49340"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 68
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "findAndFixIssues",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-processor.ts",
          "startLine": 14,
          "endLine": 205,
          "complexity": 31,
          "dependencies": [],
          "usageCount": 0,
          "size": 192,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR ISSUE FINDER -----');\r\n  \r\n  // Create test data with predictable pattern\r\n  const candles: Candle[] = [];\r\n  \r\n  // Start with a flat pattern\r\n  for (let i = 0; i < 20; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 102,\r\n      low: 98,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Add a clear uptrend - this should cause a bullish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 20) * 3600000,\r\n      open: 100 + i * 2,\r\n      high: 102 + i * 2,\r\n      low: 98 + i * 2,\r\n      close: 100 + i * 2.5,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Add a clear downtrend - this should cause a bearish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 125 - i * 2,\r\n      high: 127 - i * 2,\r\n      low: 123 - i * 2,\r\n      close: 125 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${candles.length} test candles with clear trend patterns`);\r\n  \r\n  // Configuration with very low thresholds to ensure we get signals\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.01, // Almost no threshold\r\n    minChangePercent: 0.01 // Almost no minimum change\r\n  };\r\n  \r\n  // Manually check when crossovers should happen\r\n  console.log('\\nAnalyzing data for expected crossover points:');\r\n  \r\n  for (let i = 20; i < candles.length; i++) {\r\n    // Calculate SMA values ourselves\r\n    const prices = candles.slice(0, i + 1).map(c => c.close);\r\n    const fastMA = calculateSMA(prices, config.fastPeriod);\r\n    const slowMA = calculateSMA(prices, config.slowPeriod);\r\n    \r\n    if (fastMA.length < 2 || slowMA.length < 2) {continue;}\r\n    \r\n    // Get current and previous values\r\n    const currFast = fastMA[fastMA.length - 1]; \r\n    const prevFast = fastMA[fastMA.length - 2];\r\n    const currSlow = slowMA[slowMA.length - 1];\r\n    const prevSlow = slowMA[slowMA.length - 2];\r\n    \r\n    // Check for crossovers manually\r\n    if (currFast && prevFast && currSlow && prevSlow) {\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log(`Candle ${i}: BULLISH CROSSOVER DETECTED - Should generate BUY signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log(`Candle ${i}: BEARISH CROSSOVER DETECTED - Should generate SELL signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Now test using the SMA processor\r\n  console.log('\\nTesting SMA processor with the same data:');\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Create a log of raw data for analysis\r\n  const logData: {\r\n    configuration: typeof config;\r\n    candleData: Array<{\r\n      index: number;\r\n      price: number;\r\n      fastMA: number;\r\n      slowMA: number;\r\n      difference: number;\r\n    }>;\r\n    signals: Array<{\r\n      index: number;\r\n      type: string;\r\n      confidence: number;\r\n      reason: string;\r\n    }>;\r\n  } = {\r\n    configuration: config,\r\n    candleData: [],\r\n    signals: []\r\n  };\r\n  \r\n  // Process each window\r\n  for (let i = 15; i < candles.length; i++) {\r\n    const window = candles.slice(0, i + 1);\r\n    \r\n    try {\r\n      const result = processor.process(window);\r\n      \r\n      // Calculate MAs directly for reference\r\n      const prices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(prices, config.fastPeriod);\r\n      const slowMA = calculateSMA(prices, config.slowPeriod);\r\n      \r\n      const lastFastMA = fastMA.length > 0 ? fastMA[fastMA.length - 1] : null;\r\n      const lastSlowMA = slowMA.length > 0 ? slowMA[slowMA.length - 1] : null;\r\n      \r\n      console.log(`\\nCandle ${i}: Fast MA = ${lastFastMA?.toFixed(2) || 'N/A'}, Slow MA = ${lastSlowMA?.toFixed(2) || 'N/A'}`);\r\n      \r\n      // Save data for analysis\r\n      if (lastFastMA !== null && lastSlowMA !== null && window.length > 0) {\r\n        const lastCandle = window[window.length - 1];\r\n        if (lastCandle) {\r\n          logData.candleData.push({\r\n            index: i,\r\n            price: lastCandle.close,\r\n            fastMA: lastFastMA,\r\n            slowMA: lastSlowMA,\r\n            difference: lastFastMA - lastSlowMA\r\n          });\r\n        }\r\n      }\r\n      \r\n      if (result) {\r\n        const signalType = result.signal > 0 ? 'BUY' : result.signal < 0 ? 'SELL' : 'NONE';\r\n        console.log(`*** SIGNAL: ${signalType} - Confidence: ${result.confidence.toFixed(2)} ***`);\r\n        console.log(`Reason: ${result.reason}`);\r\n        \r\n        logData.signals.push({\r\n          index: i,\r\n          type: signalType,\r\n          confidence: result.confidence,\r\n          reason: result.reason\r\n        });\r\n      } else {\r\n        console.log('No signal generated');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error processing window at index ${i}:`, error);\r\n    }\r\n  }\r\n  \r\n  // Save data for analysis\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const filename = path.join(outputDir, 'sma-debug-analysis.json');\r\n    fs.writeFileSync(filename, JSON.stringify(logData, null, 2));\r\n    console.log(`\\nDetailed analysis data saved to ${filename}`);\r\n  } catch (error) {\r\n    console.error('Error saving analysis data:', error);\r\n  }\r\n  \r\n  // Check the SMASignalProcessor implementation for issues\r\n  console.log('\\nChecking SMASignalProcessor implementation:');\r\n  console.log('1. Configuration used:', config);\r\n  console.log('2. Signals generated:', logData.signals.length);\r\n  \r\n  if (logData.signals.length === 0) {\r\n    console.log('\\nPOTENTIAL ISSUES IDENTIFIED:');\r\n    console.log(`- Confidence threshold may be too high (current: ${  config.confidenceThreshold  })`);\r\n    console.log('- Signal generation logic may have bugs');\r\n    console.log('- Crossover detection might not be working as expected');\r\n    console.log('\\nRECOMMENDATIONS:');\r\n    console.log('- Review the generateSignal method in SMASignalProcessor');\r\n    console.log('- Ensure crossover detection is correctly implemented');\r\n    console.log('- Lower the confidence threshold or modify confidence calculation');\r\n  }\r\n}",
          "hash": "f0efd78eda81f5ae2400a7a300506675"
        },
        {
          "type": "function",
          "name": "findAndFixIssues",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-processor.ts",
          "startLine": 14,
          "endLine": 205,
          "complexity": 31,
          "dependencies": [],
          "usageCount": 0,
          "size": 192,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR ISSUE FINDER -----');\r\n  \r\n  // Create test data with predictable pattern\r\n  const candles: Candle[] = [];\r\n  \r\n  // Start with a flat pattern\r\n  for (let i = 0; i < 20; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 102,\r\n      low: 98,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Add a clear uptrend - this should cause a bullish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 20) * 3600000,\r\n      open: 100 + i * 2,\r\n      high: 102 + i * 2,\r\n      low: 98 + i * 2,\r\n      close: 100 + i * 2.5,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Add a clear downtrend - this should cause a bearish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 125 - i * 2,\r\n      high: 127 - i * 2,\r\n      low: 123 - i * 2,\r\n      close: 125 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${candles.length} test candles with clear trend patterns`);\r\n  \r\n  // Configuration with very low thresholds to ensure we get signals\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.01, // Almost no threshold\r\n    minChangePercent: 0.01 // Almost no minimum change\r\n  };\r\n  \r\n  // Manually check when crossovers should happen\r\n  console.log('\\nAnalyzing data for expected crossover points:');\r\n  \r\n  for (let i = 20; i < candles.length; i++) {\r\n    // Calculate SMA values ourselves\r\n    const prices = candles.slice(0, i + 1).map(c => c.close);\r\n    const fastMA = calculateSMA(prices, config.fastPeriod);\r\n    const slowMA = calculateSMA(prices, config.slowPeriod);\r\n    \r\n    if (fastMA.length < 2 || slowMA.length < 2) {continue;}\r\n    \r\n    // Get current and previous values\r\n    const currFast = fastMA[fastMA.length - 1]; \r\n    const prevFast = fastMA[fastMA.length - 2];\r\n    const currSlow = slowMA[slowMA.length - 1];\r\n    const prevSlow = slowMA[slowMA.length - 2];\r\n    \r\n    // Check for crossovers manually\r\n    if (currFast && prevFast && currSlow && prevSlow) {\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log(`Candle ${i}: BULLISH CROSSOVER DETECTED - Should generate BUY signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log(`Candle ${i}: BEARISH CROSSOVER DETECTED - Should generate SELL signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Now test using the SMA processor\r\n  console.log('\\nTesting SMA processor with the same data:');\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Create a log of raw data for analysis\r\n  const logData: {\r\n    configuration: typeof config;\r\n    candleData: Array<{\r\n      index: number;\r\n      price: number;\r\n      fastMA: number;\r\n      slowMA: number;\r\n      difference: number;\r\n    }>;\r\n    signals: Array<{\r\n      index: number;\r\n      type: string;\r\n      confidence: number;\r\n      reason: string;\r\n    }>;\r\n  } = {\r\n    configuration: config,\r\n    candleData: [],\r\n    signals: []\r\n  };\r\n  \r\n  // Process each window\r\n  for (let i = 15; i < candles.length; i++) {\r\n    const window = candles.slice(0, i + 1);\r\n    \r\n    try {\r\n      const result = processor.process(window);\r\n      \r\n      // Calculate MAs directly for reference\r\n      const prices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(prices, config.fastPeriod);\r\n      const slowMA = calculateSMA(prices, config.slowPeriod);\r\n      \r\n      const lastFastMA = fastMA.length > 0 ? fastMA[fastMA.length - 1] : null;\r\n      const lastSlowMA = slowMA.length > 0 ? slowMA[slowMA.length - 1] : null;\r\n      \r\n      console.log(`\\nCandle ${i}: Fast MA = ${lastFastMA?.toFixed(2) || 'N/A'}, Slow MA = ${lastSlowMA?.toFixed(2) || 'N/A'}`);\r\n      \r\n      // Save data for analysis\r\n      if (lastFastMA !== null && lastSlowMA !== null && window.length > 0) {\r\n        const lastCandle = window[window.length - 1];\r\n        if (lastCandle) {\r\n          logData.candleData.push({\r\n            index: i,\r\n            price: lastCandle.close,\r\n            fastMA: lastFastMA,\r\n            slowMA: lastSlowMA,\r\n            difference: lastFastMA - lastSlowMA\r\n          });\r\n        }\r\n      }\r\n      \r\n      if (result) {\r\n        const signalType = result.signal > 0 ? 'BUY' : result.signal < 0 ? 'SELL' : 'NONE';\r\n        console.log(`*** SIGNAL: ${signalType} - Confidence: ${result.confidence.toFixed(2)} ***`);\r\n        console.log(`Reason: ${result.reason}`);\r\n        \r\n        logData.signals.push({\r\n          index: i,\r\n          type: signalType,\r\n          confidence: result.confidence,\r\n          reason: result.reason\r\n        });\r\n      } else {\r\n        console.log('No signal generated');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error processing window at index ${i}:`, error);\r\n    }\r\n  }\r\n  \r\n  // Save data for analysis\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const filename = path.join(outputDir, 'sma-debug-analysis.json');\r\n    fs.writeFileSync(filename, JSON.stringify(logData, null, 2));\r\n    console.log(`\\nDetailed analysis data saved to ${filename}`);\r\n  } catch (error) {\r\n    console.error('Error saving analysis data:', error);\r\n  }\r\n  \r\n  // Check the SMASignalProcessor implementation for issues\r\n  console.log('\\nChecking SMASignalProcessor implementation:');\r\n  console.log('1. Configuration used:', config);\r\n  console.log('2. Signals generated:', logData.signals.length);\r\n  \r\n  if (logData.signals.length === 0) {\r\n    console.log('\\nPOTENTIAL ISSUES IDENTIFIED:');\r\n    console.log(`- Confidence threshold may be too high (current: ${  config.confidenceThreshold  })`);\r\n    console.log('- Signal generation logic may have bugs');\r\n    console.log('- Crossover detection might not be working as expected');\r\n    console.log('\\nRECOMMENDATIONS:');\r\n    console.log('- Review the generateSignal method in SMASignalProcessor');\r\n    console.log('- Ensure crossover detection is correctly implemented');\r\n    console.log('- Lower the confidence threshold or modify confidence calculation');\r\n  }\r\n}",
          "hash": "f0efd78eda81f5ae2400a7a300506675"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 192
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "generateTestData",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-signals.ts",
          "startLine": 14,
          "endLine": 43,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 30,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  let price = 100;\r\n  const startTime = Date.now();\r\n  \r\n  // Use a simpler sine wave for clarity\r\n  for (let i = 0; i < length; i++) {\r\n    // Create obvious up and down trends (high amplitude)\r\n    const trend = Math.sin(i / 20) * 20; // 20% price swings\r\n    price = 100 + trend;\r\n    \r\n    const timestamp = startTime + i * 60 * 60 * 1000; // hourly data\r\n    const open = price * 0.99;\r\n    const close = price;\r\n    const high = price * 1.01;\r\n    const low = price * 0.98;\r\n    const volume = 1000;\r\n    \r\n    candles.push({\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "045654b871c890d2168388fda1d6b071"
        },
        {
          "type": "function",
          "name": "generateTestData",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-signals.ts",
          "startLine": 14,
          "endLine": 43,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 30,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  let price = 100;\r\n  const startTime = Date.now();\r\n  \r\n  // Use a simpler sine wave for clarity\r\n  for (let i = 0; i < length; i++) {\r\n    // Create obvious up and down trends (high amplitude)\r\n    const trend = Math.sin(i / 20) * 20; // 20% price swings\r\n    price = 100 + trend;\r\n    \r\n    const timestamp = startTime + i * 60 * 60 * 1000; // hourly data\r\n    const open = price * 0.99;\r\n    const close = price;\r\n    const high = price * 1.01;\r\n    const low = price * 0.98;\r\n    const volume = 1000;\r\n    \r\n    candles.push({\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "045654b871c890d2168388fda1d6b071"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 30
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "debugSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-signals.ts",
          "startLine": 46,
          "endLine": 212,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 167,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR DEBUG -----');\r\n  \r\n  // Generate 100 candles with clear price movements\r\n  const candles = generateTestData(100);\r\n  console.log(`Generated ${candles.length} test candles with sine wave pattern`);\r\n  \r\n  // Extract close prices for analysis\r\n  const prices = candles.map(c => c.close);\r\n  \r\n  // Calculate MAs directly to debug\r\n  const fast1 = calculateSMA(prices, 5);\r\n  const slow1 = calculateSMA(prices, 15);\r\n  console.log(`Calculated MAs directly: Fast(5) length=${fast1.length}, Slow(15) length=${slow1.length}`);\r\n  \r\n  // Create minimal configuration with proper types\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n    signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.1 // Very low threshold\r\n  };\r\n  \r\n  // Initialize processor\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Save raw data and MAs to file for inspection\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const dataFile = path.join(outputDir, 'sma-debug-data.json');\r\n    fs.writeFileSync(dataFile, JSON.stringify({\r\n      candles: candles.slice(0, 20), // First 20 candles sample\r\n      prices: prices.slice(0, 20),\r\n      fastMA: fast1.slice(0, 20),\r\n      slowMA: slow1.slice(0, 15)\r\n    }, null, 2));\r\n    \r\n    console.log(`Saved sample data to ${dataFile}`);\r\n  } catch (error) {\r\n    console.error('Error saving debug data:', error);\r\n  }\r\n  \r\n  // Process in a sliding window to debug\r\n  console.log('\\nTesting signal processing with sliding window:');\r\n  const startIdx = 20; // Start after enough data for MA calculations\r\n  \r\n  // Direct inspection of signal generation logic\r\n  for (let i = startIdx; i < Math.min(candles.length, startIdx + 10); i++) {\r\n    // Log the prices and MAs\r\n    const window = candles.slice(0, i + 1);\r\n    const windowPrices = window.map(c => c.close);\r\n    \r\n    // Calculate MAs directly for comparison\r\n    const fastMA = calculateSMA(windowPrices, config.fastPeriod);\r\n    const slowMA = calculateSMA(windowPrices, config.slowPeriod);\r\n    \r\n    const lastPrice = windowPrices[windowPrices.length - 1];\r\n    const lastFastMA = fastMA[fastMA.length - 1];\r\n    const lastSlowMA = slowMA[slowMA.length - 1];\r\n    \r\n    console.log(`\\nWindow ${i}: Last Price=${lastPrice.toFixed(2)}`);\r\n    console.log(`Fast MA: ${lastFastMA.toFixed(2)}, Slow MA: ${lastSlowMA.toFixed(2)}`);\r\n    \r\n    // Check for crossover conditions manually\r\n    if (fastMA.length >= 2 && slowMA.length >= 2) {\r\n      const currFast = fastMA[fastMA.length - 1];\r\n      const prevFast = fastMA[fastMA.length - 2];\r\n      const currSlow = slowMA[slowMA.length - 1];\r\n      const prevSlow = slowMA[slowMA.length - 2];\r\n      \r\n      console.log(`Previous: Fast=${prevFast.toFixed(2)}, Slow=${prevSlow.toFixed(2)}`);\r\n      console.log(`Current: Fast=${currFast.toFixed(2)}, Slow=${currSlow.toFixed(2)}`);\r\n      \r\n      // Check crossover manually\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate BUY signal (bullish crossover) ***');\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate SELL signal (bearish crossover) ***');\r\n      } else {\r\n        console.log('*** MANUAL CHECK: No crossover detected ***');\r\n      }\r\n    }\r\n    \r\n    // Now use the processor and see what it returns\r\n    try {\r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`PROCESSOR RESULT: Signal=${result.signal}, Confidence=${result.confidence.toFixed(2)}, Reason=${result.reason}`);\r\n      } else {\r\n        console.log('PROCESSOR RESULT: No signal returned');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error from processor:`, error);\r\n    }\r\n  }\r\n  \r\n  console.log('\\n----- DETAILED TESTING WITH FORCED CROSSOVER DATA -----');\r\n  \r\n  // Create data with guaranteed crossover\r\n  const crossoverData: Candle[] = [];\r\n  // First add candles with fast MA below slow MA\r\n  for (let i = 0; i < 30; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 90,\r\n      high: 95,\r\n      low: 85,\r\n      close: 90 + i * 0.1, // Slowly rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then add candles where fast MA will cross above slow MA\r\n  for (let i = 0; i < 10; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 95,\r\n      high: 110,\r\n      low: 95,\r\n      close: 95 + i * 2, // Sharply rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${crossoverData.length} candles with forced crossover pattern`);\r\n  \r\n  // Test with forced crossover data\r\n  try {\r\n    // Reset processor with very permissive settings\r\n    const crossoverProcessor = new SMASignalProcessor({\r\n      fastPeriod: 5,\r\n      slowPeriod: 15,\r\n      priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n      signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n      confidenceThreshold: 0.01 // Almost no threshold\r\n    });\r\n    \r\n    console.log('\\nProcessing forced crossover data:');\r\n    // Process each window\r\n    for (let i = 20; i < crossoverData.length; i++) {\r\n      const window = crossoverData.slice(0, i + 1);\r\n      const result = crossoverProcessor.process(window);\r\n      \r\n      // Calculate MAs directly for comparison\r\n      const windowPrices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(windowPrices, 5);\r\n      const slowMA = calculateSMA(windowPrices, 15);\r\n      \r\n      console.log(`\\nWindow ${i}: Fast=${fastMA[fastMA.length-1].toFixed(2)}, Slow=${slowMA[slowMA.length-1].toFixed(2)}`);\r\n      \r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence=${result.confidence.toFixed(2)}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log('No signal');\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during forced crossover test:', error);\r\n  }\r\n}",
          "hash": "63bb778aca5051b5886c1f1cbd6aa27e"
        },
        {
          "type": "function",
          "name": "debugSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-signals.ts",
          "startLine": 46,
          "endLine": 212,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 167,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR DEBUG -----');\r\n  \r\n  // Generate 100 candles with clear price movements\r\n  const candles = generateTestData(100);\r\n  console.log(`Generated ${candles.length} test candles with sine wave pattern`);\r\n  \r\n  // Extract close prices for analysis\r\n  const prices = candles.map(c => c.close);\r\n  \r\n  // Calculate MAs directly to debug\r\n  const fast1 = calculateSMA(prices, 5);\r\n  const slow1 = calculateSMA(prices, 15);\r\n  console.log(`Calculated MAs directly: Fast(5) length=${fast1.length}, Slow(15) length=${slow1.length}`);\r\n  \r\n  // Create minimal configuration with proper types\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n    signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.1 // Very low threshold\r\n  };\r\n  \r\n  // Initialize processor\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Save raw data and MAs to file for inspection\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const dataFile = path.join(outputDir, 'sma-debug-data.json');\r\n    fs.writeFileSync(dataFile, JSON.stringify({\r\n      candles: candles.slice(0, 20), // First 20 candles sample\r\n      prices: prices.slice(0, 20),\r\n      fastMA: fast1.slice(0, 20),\r\n      slowMA: slow1.slice(0, 15)\r\n    }, null, 2));\r\n    \r\n    console.log(`Saved sample data to ${dataFile}`);\r\n  } catch (error) {\r\n    console.error('Error saving debug data:', error);\r\n  }\r\n  \r\n  // Process in a sliding window to debug\r\n  console.log('\\nTesting signal processing with sliding window:');\r\n  const startIdx = 20; // Start after enough data for MA calculations\r\n  \r\n  // Direct inspection of signal generation logic\r\n  for (let i = startIdx; i < Math.min(candles.length, startIdx + 10); i++) {\r\n    // Log the prices and MAs\r\n    const window = candles.slice(0, i + 1);\r\n    const windowPrices = window.map(c => c.close);\r\n    \r\n    // Calculate MAs directly for comparison\r\n    const fastMA = calculateSMA(windowPrices, config.fastPeriod);\r\n    const slowMA = calculateSMA(windowPrices, config.slowPeriod);\r\n    \r\n    const lastPrice = windowPrices[windowPrices.length - 1];\r\n    const lastFastMA = fastMA[fastMA.length - 1];\r\n    const lastSlowMA = slowMA[slowMA.length - 1];\r\n    \r\n    console.log(`\\nWindow ${i}: Last Price=${lastPrice.toFixed(2)}`);\r\n    console.log(`Fast MA: ${lastFastMA.toFixed(2)}, Slow MA: ${lastSlowMA.toFixed(2)}`);\r\n    \r\n    // Check for crossover conditions manually\r\n    if (fastMA.length >= 2 && slowMA.length >= 2) {\r\n      const currFast = fastMA[fastMA.length - 1];\r\n      const prevFast = fastMA[fastMA.length - 2];\r\n      const currSlow = slowMA[slowMA.length - 1];\r\n      const prevSlow = slowMA[slowMA.length - 2];\r\n      \r\n      console.log(`Previous: Fast=${prevFast.toFixed(2)}, Slow=${prevSlow.toFixed(2)}`);\r\n      console.log(`Current: Fast=${currFast.toFixed(2)}, Slow=${currSlow.toFixed(2)}`);\r\n      \r\n      // Check crossover manually\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate BUY signal (bullish crossover) ***');\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate SELL signal (bearish crossover) ***');\r\n      } else {\r\n        console.log('*** MANUAL CHECK: No crossover detected ***');\r\n      }\r\n    }\r\n    \r\n    // Now use the processor and see what it returns\r\n    try {\r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`PROCESSOR RESULT: Signal=${result.signal}, Confidence=${result.confidence.toFixed(2)}, Reason=${result.reason}`);\r\n      } else {\r\n        console.log('PROCESSOR RESULT: No signal returned');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error from processor:`, error);\r\n    }\r\n  }\r\n  \r\n  console.log('\\n----- DETAILED TESTING WITH FORCED CROSSOVER DATA -----');\r\n  \r\n  // Create data with guaranteed crossover\r\n  const crossoverData: Candle[] = [];\r\n  // First add candles with fast MA below slow MA\r\n  for (let i = 0; i < 30; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 90,\r\n      high: 95,\r\n      low: 85,\r\n      close: 90 + i * 0.1, // Slowly rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then add candles where fast MA will cross above slow MA\r\n  for (let i = 0; i < 10; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 95,\r\n      high: 110,\r\n      low: 95,\r\n      close: 95 + i * 2, // Sharply rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${crossoverData.length} candles with forced crossover pattern`);\r\n  \r\n  // Test with forced crossover data\r\n  try {\r\n    // Reset processor with very permissive settings\r\n    const crossoverProcessor = new SMASignalProcessor({\r\n      fastPeriod: 5,\r\n      slowPeriod: 15,\r\n      priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n      signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n      confidenceThreshold: 0.01 // Almost no threshold\r\n    });\r\n    \r\n    console.log('\\nProcessing forced crossover data:');\r\n    // Process each window\r\n    for (let i = 20; i < crossoverData.length; i++) {\r\n      const window = crossoverData.slice(0, i + 1);\r\n      const result = crossoverProcessor.process(window);\r\n      \r\n      // Calculate MAs directly for comparison\r\n      const windowPrices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(windowPrices, 5);\r\n      const slowMA = calculateSMA(windowPrices, 15);\r\n      \r\n      console.log(`\\nWindow ${i}: Fast=${fastMA[fastMA.length-1].toFixed(2)}, Slow=${slowMA[slowMA.length-1].toFixed(2)}`);\r\n      \r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence=${result.confidence.toFixed(2)}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log('No signal');\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during forced crossover test:', error);\r\n  }\r\n}",
          "hash": "63bb778aca5051b5886c1f1cbd6aa27e"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 167
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "generateCandlesWithTrends",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts",
          "startLine": 8,
          "endLine": 49,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 42,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  \r\n  // Create a series of candles with definitive trend patterns\r\n  // First, a flat period\r\n  for (let i = 0; i < 30; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 101,\r\n      low: 99,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then a strong uptrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 100 + i * 3,\r\n      high: 101 + i * 3,\r\n      low: 99 + i * 3,\r\n      close: 100 + i * 3,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Then a strong downtrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 45) * 3600000,\r\n      open: 145 - i * 3,\r\n      high: 146 - i * 3,\r\n      low: 144 - i * 3,\r\n      close: 145 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "dd23108452806bd36d9ed2f47ac8c092"
        },
        {
          "type": "function",
          "name": "generateCandlesWithTrends",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts",
          "startLine": 8,
          "endLine": 49,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 42,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  \r\n  // Create a series of candles with definitive trend patterns\r\n  // First, a flat period\r\n  for (let i = 0; i < 30; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 101,\r\n      low: 99,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then a strong uptrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 100 + i * 3,\r\n      high: 101 + i * 3,\r\n      low: 99 + i * 3,\r\n      close: 100 + i * 3,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Then a strong downtrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 45) * 3600000,\r\n      open: 145 - i * 3,\r\n      high: 146 - i * 3,\r\n      low: 144 - i * 3,\r\n      close: 145 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "dd23108452806bd36d9ed2f47ac8c092"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 42
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts",
          "startLine": 52,
          "endLine": 92,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n  console.log(\"=== TESTING SMA SIGNAL PROCESSOR ===\");\r\n  \r\n  const candles = generateCandlesWithTrends();\r\n  console.log(`Generated ${candles.length} candles with clear trends`);\r\n  \r\n  // Create a signal processor with very permissive settings\r\n  const processor = new SMASignalProcessor({\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    confidenceThreshold: 0.01\r\n  });\r\n  \r\n  console.log(\"Processing candles with sliding window:\");\r\n  \r\n  // Test every 5th candle to reduce output\r\n  for (let i = 15; i < candles.length; i += 5) {\r\n    const window = candles.slice(0, i + 1);\r\n    try {\r\n      const lastCandle = window[window.length-1];\r\n      if (!lastCandle) {\r\n        console.log(`\\nCandle ${i}: No candle data available`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`\\nCandle ${i}: Price=${lastCandle.close}`);\r\n      \r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence: ${result.confidence}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log(\"No signal generated\");\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error at index ${i}:`, error);\r\n    }\r\n  }\r\n}",
          "hash": "8118f01c6a62e65faf23935ea317e7bd"
        },
        {
          "type": "function",
          "name": "testSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts",
          "startLine": 52,
          "endLine": 92,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n  console.log(\"=== TESTING SMA SIGNAL PROCESSOR ===\");\r\n  \r\n  const candles = generateCandlesWithTrends();\r\n  console.log(`Generated ${candles.length} candles with clear trends`);\r\n  \r\n  // Create a signal processor with very permissive settings\r\n  const processor = new SMASignalProcessor({\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    confidenceThreshold: 0.01\r\n  });\r\n  \r\n  console.log(\"Processing candles with sliding window:\");\r\n  \r\n  // Test every 5th candle to reduce output\r\n  for (let i = 15; i < candles.length; i += 5) {\r\n    const window = candles.slice(0, i + 1);\r\n    try {\r\n      const lastCandle = window[window.length-1];\r\n      if (!lastCandle) {\r\n        console.log(`\\nCandle ${i}: No candle data available`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`\\nCandle ${i}: Price=${lastCandle.close}`);\r\n      \r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence: ${result.confidence}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log(\"No signal generated\");\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error at index ${i}:`, error);\r\n    }\r\n  }\r\n}",
          "hash": "8118f01c6a62e65faf23935ea317e7bd"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 41
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testStrategy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts",
          "startLine": 95,
          "endLine": 110,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 16,
          "content": "{\r\n  console.log(\"\\n=== TESTING SMA CROSSOVER STRATEGY ===\");\r\n  \r\n  const strategy = new SMACrossoverStrategy();\r\n  console.log(\"Strategy loaded:\", strategy.name);\r\n  \r\n  // Log strategy configuration\r\n  const config = strategy.getDefaultConfig();\r\n  console.log(\"Default configuration:\", JSON.stringify(config.parameters, null, 2));\r\n  \r\n  // Print summary\r\n  console.log(\"\\nSummary of debugging analysis:\");\r\n  console.log(\"1. The SMA signal processor is configured to detect crossovers between fast and slow MAs\");\r\n  console.log(\"2. The processor requires a minimum confidence level to generate signals\");\r\n  console.log(\"3. Check the 'generateSignal' method in sma-signal-processor.ts for any issues\");\r\n}",
          "hash": "31f5a8d3ed3504a6faa1fc9f942bfc8c"
        },
        {
          "type": "function",
          "name": "testStrategy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts",
          "startLine": 95,
          "endLine": 110,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 16,
          "content": "{\r\n  console.log(\"\\n=== TESTING SMA CROSSOVER STRATEGY ===\");\r\n  \r\n  const strategy = new SMACrossoverStrategy();\r\n  console.log(\"Strategy loaded:\", strategy.name);\r\n  \r\n  // Log strategy configuration\r\n  const config = strategy.getDefaultConfig();\r\n  console.log(\"Default configuration:\", JSON.stringify(config.parameters, null, 2));\r\n  \r\n  // Print summary\r\n  console.log(\"\\nSummary of debugging analysis:\");\r\n  console.log(\"1. The SMA signal processor is configured to detect crossovers between fast and slow MAs\");\r\n  console.log(\"2. The processor requires a minimum confidence level to generate signals\");\r\n  console.log(\"3. Check the 'generateSignal' method in sma-signal-processor.ts for any issues\");\r\n}",
          "hash": "31f5a8d3ed3504a6faa1fc9f942bfc8c"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 16
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 25,
          "endLine": 34,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n  private systemMonitor: SystemMonitorService;\r\n  private testResults: any[] = [];\r\n\r\n  constructor() {\r\n    this.systemMonitor = new SystemMonitorService({\r\n      collectInterval: 1000, // 1 second for detailed monitoring\r\n      enableAlerts: true\r\n    });\r\n  }",
          "hash": "3ed8d61d68b9908da14ab859b4d43407"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 25,
          "endLine": 34,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n  private systemMonitor: SystemMonitorService;\r\n  private testResults: any[] = [];\r\n\r\n  constructor() {\r\n    this.systemMonitor = new SystemMonitorService({\r\n      collectInterval: 1000, // 1 second for detailed monitoring\r\n      enableAlerts: true\r\n    });\r\n  }",
          "hash": "3ed8d61d68b9908da14ab859b4d43407"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 10
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 83,
          "endLine": 95,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            \r\n            // Calculate SMA\r\n            const sma: number[] = [];\r\n            for (let i = period - 1; i < data.length; i++) {\r\n              const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\r\n              sma.push(sum / period);\r\n            }\r\n            \r\n            return sma.length;\r\n          }",
          "hash": "2e6b020dee8d81769208a4f99144be99"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 83,
          "endLine": 95,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            \r\n            // Calculate SMA\r\n            const sma: number[] = [];\r\n            for (let i = period - 1; i < data.length; i++) {\r\n              const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\r\n              sma.push(sum / period);\r\n            }\r\n            \r\n            return sma.length;\r\n          }",
          "hash": "2e6b020dee8d81769208a4f99144be99"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 13
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 101,
          "endLine": 113,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            const multiplier = 2 / (period + 1);\r\n            \r\n            // Calculate EMA\r\n            let ema = data[0];\r\n            for (let i = 1; i < data.length; i++) {\r\n              ema = (data[i] * multiplier) + (ema * (1 - multiplier));\r\n            }\r\n            \r\n            return ema;\r\n          }",
          "hash": "50b13f3f7a6551b37709261d4fa6fe8b"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 101,
          "endLine": 113,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            const multiplier = 2 / (period + 1);\r\n            \r\n            // Calculate EMA\r\n            let ema = data[0];\r\n            for (let i = 1; i < data.length; i++) {\r\n              ema = (data[i] * multiplier) + (ema * (1 - multiplier));\r\n            }\r\n            \r\n            return ema;\r\n          }",
          "hash": "50b13f3f7a6551b37709261d4fa6fe8b"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 13
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 119,
          "endLine": 139,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n            const prices = Array.from({ length: 100 }, () => 100 + Math.random() * 50);\r\n            const period = 14;\r\n            \r\n            // Calculate price changes\r\n            const changes = prices.slice(1).map((price, i) => price - prices[i]);\r\n            \r\n            // Separate gains and losses\r\n            const gains = changes.map(change => change > 0 ? change : 0);\r\n            const losses = changes.map(change => change < 0 ? -change : 0);\r\n            \r\n            // Calculate average gain and loss\r\n            const avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;\r\n            const avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;\r\n            \r\n            // Calculate RS and RSI\r\n            const rs = avgGain / avgLoss;\r\n            const rsi = 100 - (100 / (1 + rs));\r\n            \r\n            return rsi;\r\n          }",
          "hash": "2e09fe9db5028c7387d020934060b8c9"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 119,
          "endLine": 139,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n            const prices = Array.from({ length: 100 }, () => 100 + Math.random() * 50);\r\n            const period = 14;\r\n            \r\n            // Calculate price changes\r\n            const changes = prices.slice(1).map((price, i) => price - prices[i]);\r\n            \r\n            // Separate gains and losses\r\n            const gains = changes.map(change => change > 0 ? change : 0);\r\n            const losses = changes.map(change => change < 0 ? -change : 0);\r\n            \r\n            // Calculate average gain and loss\r\n            const avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;\r\n            const avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;\r\n            \r\n            // Calculate RS and RSI\r\n            const rs = avgGain / avgLoss;\r\n            const rsi = 100 - (100 / (1 + rs));\r\n            \r\n            return rsi;\r\n          }",
          "hash": "2e09fe9db5028c7387d020934060b8c9"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 21
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 145,
          "endLine": 155,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const size = 100000;\r\n            const data = Array.from({ length: size }, (_, i) => Math.random() * 100);\r\n            \r\n            // Perform multiple operations\r\n            const filtered = data.filter(x => x > 50);\r\n            const mapped = filtered.map(x => x * 2);\r\n            const reduced = mapped.reduce((sum, x) => sum + x, 0);\r\n            \r\n            return reduced;\r\n          }",
          "hash": "59e575cc09791930b740ea828d652de3"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 145,
          "endLine": 155,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const size = 100000;\r\n            const data = Array.from({ length: size }, (_, i) => Math.random() * 100);\r\n            \r\n            // Perform multiple operations\r\n            const filtered = data.filter(x => x > 50);\r\n            const mapped = filtered.map(x => x * 2);\r\n            const reduced = mapped.reduce((sum, x) => sum + x, 0);\r\n            \r\n            return reduced;\r\n          }",
          "hash": "59e575cc09791930b740ea828d652de3"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 11
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 173,
          "endLine": 191,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 19,
          "content": "{\r\n            const indicatorService = new IndicatorService();\r\n            const prices = Array.from({ length: 200 }, () => ({\r\n              timestamp: Date.now(),\r\n              open: 100 + Math.random() * 10,\r\n              high: 105 + Math.random() * 10,\r\n              low: 95 + Math.random() * 10,\r\n              close: 100 + Math.random() * 10,\r\n              volume: 1000 + Math.random() * 500\r\n            }));\r\n\r\n            // Calculate multiple indicators\r\n            const sma20 = indicatorService.calculateSMA(prices.map(p => p.close), 20);\r\n            const sma50 = indicatorService.calculateSMA(prices.map(p => p.close), 50);\r\n            const ema12 = indicatorService.calculateEMA(prices.map(p => p.close), 12);\r\n            const rsi = indicatorService.calculateRSI(prices.map(p => p.close), 14);\r\n\r\n            return { sma20: sma20.length, sma50: sma50.length, ema12: ema12.length, rsi: rsi.length };\r\n          }",
          "hash": "8e957b7fae3998cf3576611bde3bfab0"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 173,
          "endLine": 191,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 19,
          "content": "{\r\n            const indicatorService = new IndicatorService();\r\n            const prices = Array.from({ length: 200 }, () => ({\r\n              timestamp: Date.now(),\r\n              open: 100 + Math.random() * 10,\r\n              high: 105 + Math.random() * 10,\r\n              low: 95 + Math.random() * 10,\r\n              close: 100 + Math.random() * 10,\r\n              volume: 1000 + Math.random() * 500\r\n            }));\r\n\r\n            // Calculate multiple indicators\r\n            const sma20 = indicatorService.calculateSMA(prices.map(p => p.close), 20);\r\n            const sma50 = indicatorService.calculateSMA(prices.map(p => p.close), 50);\r\n            const ema12 = indicatorService.calculateEMA(prices.map(p => p.close), 12);\r\n            const rsi = indicatorService.calculateRSI(prices.map(p => p.close), 14);\r\n\r\n            return { sma20: sma20.length, sma50: sma50.length, ema12: ema12.length, rsi: rsi.length };\r\n          }",
          "hash": "8e957b7fae3998cf3576611bde3bfab0"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 19
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 209,
          "endLine": 225,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n            const prices = Array.from({ length: 500 }, () => Math.random() * 100);\r\n            const signals = [];\r\n            \r\n            for (let i = 20; i < prices.length; i++) {\r\n              const sma20 = prices.slice(i - 20, i).reduce((a, b) => a + b) / 20;\r\n              const sma50 = i >= 50 ? prices.slice(i - 50, i).reduce((a, b) => a + b) / 50 : 0;\r\n              \r\n              if (sma20 > sma50) {\r\n                signals.push('BUY');\r\n              } else if (sma20 < sma50) {\r\n                signals.push('SELL');\r\n              }\r\n            }\r\n            \r\n            return signals.length;\r\n          }",
          "hash": "f8f8eb08301eab92604911dbf4fc334b"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 209,
          "endLine": 225,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n            const prices = Array.from({ length: 500 }, () => Math.random() * 100);\r\n            const signals = [];\r\n            \r\n            for (let i = 20; i < prices.length; i++) {\r\n              const sma20 = prices.slice(i - 20, i).reduce((a, b) => a + b) / 20;\r\n              const sma50 = i >= 50 ? prices.slice(i - 50, i).reduce((a, b) => a + b) / 50 : 0;\r\n              \r\n              if (sma20 > sma50) {\r\n                signals.push('BUY');\r\n              } else if (sma20 < sma50) {\r\n                signals.push('SELL');\r\n              }\r\n            }\r\n            \r\n            return signals.length;\r\n          }",
          "hash": "f8f8eb08301eab92604911dbf4fc334b"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 17
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 243,
          "endLine": 253,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const initialMemory = process.memoryUsage();\r\n            const data = Array.from({ length: 100000 }, () => Math.random());\r\n            const processed = data.map(x => x * 2).filter(x => x > 1);\r\n            const finalMemory = process.memoryUsage();\r\n            \r\n            return {\r\n              processed: processed.length,\r\n              memoryDelta: finalMemory.heapUsed - initialMemory.heapUsed\r\n            };\r\n          }",
          "hash": "51d1bfe50187f34ee14912f111e312e3"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 243,
          "endLine": 253,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const initialMemory = process.memoryUsage();\r\n            const data = Array.from({ length: 100000 }, () => Math.random());\r\n            const processed = data.map(x => x * 2).filter(x => x > 1);\r\n            const finalMemory = process.memoryUsage();\r\n            \r\n            return {\r\n              processed: processed.length,\r\n              memoryDelta: finalMemory.heapUsed - initialMemory.heapUsed\r\n            };\r\n          }",
          "hash": "51d1bfe50187f34ee14912f111e312e3"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 11
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "emit",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 516,
          "endLine": 604,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 89,
          "content": "{\r\n    const state = runtime.getState();\r\n    const botId = state.botId;\r\n\r\n    runtime.on('started', () => {\r\n      // logger.info('📡 Bot started event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('stopped', () => {\r\n      // logger.info('📡 Bot stopped event', LogCategory.BOT, { botId });\r\n      this.activeBots.delete(botId);\r\n      this.broadcastBotStatusUpdate(botId, 'stopped');\r\n    });\r\n\r\n    runtime.on('paused', () => {\r\n      // logger.info('📡 Bot paused event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'paused');\r\n    });\r\n\r\n    runtime.on('resumed', () => {\r\n      // logger.info('📡 Bot resumed event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('error', (error: Error) => {\r\n      // logger.error('📡 Bot error event', LogCategory.BOT, {\r\n      //   botId,\r\n      //   error: error.message\r\n      // });\r\n      this.broadcastBotStatusUpdate(botId, 'error');\r\n    });\r\n\r\n    runtime.on('signal', (data: any) => {\r\n      // logger.info('📡 Bot signal event', LogCategory.SIGNAL, {\r\n      //   botId,\r\n      //   signal: data.signal\r\n      // });\r\n      \r\n      // Broadcast signal to WebSocket clients\r\n      webSocketService.broadcast('bot-signal', {\r\n        botId,\r\n        signal: data.signal,\r\n        timestamp: data.timestamp\r\n      });\r\n    });\r\n\r\n    runtime.on('tick', (_data: any) => {\r\n      // Broadcast performance updates periodically (every 10 ticks)\r\n      const currentState = runtime.getState();\r\n      if (currentState.performance.tickCount % 10 === 0) {\r\n        this.broadcastBotPerformanceUpdate(botId, currentState.performance);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up monitoring for bot health and performance\r\n   */\r\n  private setupMonitoring(): void {\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.performHealthCheck();\r\n    }, this.config.monitoringInterval);\r\n  }\r\n\r\n  /**\r\n   * Perform health check on all active bots\r\n   */\r\n  private performHealthCheck(): void {\r\n    const now = new Date();\r\n    \r\n    for (const [botId, runtime] of this.activeBots) {\r\n      const state = runtime.getState();\r\n      \r\n      // Check for stale bots (no tick in last 2 minutes)\r\n      if (state.lastTickAt && state.status === 'running') {\r\n        const timeSinceLastTick = now.getTime() - state.lastTickAt.getTime();\r\n        const staleThreshold = 2 * 60 * 1000; // 2 minutes\r\n        \r\n        if (timeSinceLastTick > staleThreshold) {\r\n          // logger.warn('⚠️ Bot appears stale', LogCategory.BOT, {\r\n          //   botId,\r\n          //   timeSinceLastTick,\r\n          //   lastTickAt: state.lastTickAt\r\n          // });\r\n          \r\n          // Emit warning event\r\n          this.emit('bot-stale', { botId, timeSinceLastTick });\r\n        }",
          "hash": "73e8c4a148b98110036ee6ac35b49810"
        },
        {
          "type": "function",
          "name": "on",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 517,
          "endLine": 605,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 89,
          "content": "{\r\n    const state = runtime.getState();\r\n    const botId = state.botId;\r\n\r\n    runtime.on('started', () => {\r\n      // logger.info('📡 Bot started event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('stopped', () => {\r\n      // logger.info('📡 Bot stopped event', LogCategory.BOT, { botId });\r\n      this.activeBots.delete(botId);\r\n      this.broadcastBotStatusUpdate(botId, 'stopped');\r\n    });\r\n\r\n    runtime.on('paused', () => {\r\n      // logger.info('📡 Bot paused event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'paused');\r\n    });\r\n\r\n    runtime.on('resumed', () => {\r\n      // logger.info('📡 Bot resumed event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('error', (error: Error) => {\r\n      // logger.error('📡 Bot error event', LogCategory.BOT, {\r\n      //   botId,\r\n      //   error: error.message\r\n      // });\r\n      this.broadcastBotStatusUpdate(botId, 'error');\r\n    });\r\n\r\n    runtime.on('signal', (data: any) => {\r\n      // logger.info('📡 Bot signal event', LogCategory.SIGNAL, {\r\n      //   botId,\r\n      //   signal: data.signal\r\n      // });\r\n      \r\n      // Broadcast signal to WebSocket clients\r\n      webSocketService.broadcast('bot-signal', {\r\n        botId,\r\n        signal: data.signal,\r\n        timestamp: data.timestamp\r\n      });\r\n    });\r\n\r\n    runtime.on('tick', (_data: any) => {\r\n      // Broadcast performance updates periodically (every 10 ticks)\r\n      const currentState = runtime.getState();\r\n      if (currentState.performance.tickCount % 10 === 0) {\r\n        this.broadcastBotPerformanceUpdate(botId, currentState.performance);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up monitoring for bot health and performance\r\n   */\r\n  private setupMonitoring(): void {\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.performHealthCheck();\r\n    }, this.config.monitoringInterval);\r\n  }\r\n\r\n  /**\r\n   * Perform health check on all active bots\r\n   */\r\n  private performHealthCheck(): void {\r\n    const now = new Date();\r\n    \r\n    for (const [botId, runtime] of this.activeBots) {\r\n      const state = runtime.getState();\r\n      \r\n      // Check for stale bots (no tick in last 2 minutes)\r\n      if (state.lastTickAt && state.status === 'running') {\r\n        const timeSinceLastTick = now.getTime() - state.lastTickAt.getTime();\r\n        const staleThreshold = 2 * 60 * 1000; // 2 minutes\r\n        \r\n        if (timeSinceLastTick > staleThreshold) {\r\n          // logger.warn('⚠️ Bot appears stale', LogCategory.BOT, {\r\n          //   botId,\r\n          //   timeSinceLastTick,\r\n          //   lastTickAt: state.lastTickAt\r\n          // });\r\n          \r\n          // Emit warning event\r\n          this.emit('bot-stale', { botId, timeSinceLastTick });\r\n        }",
          "hash": "73e8c4a148b98110036ee6ac35b49810"
        },
        {
          "type": "function",
          "name": "off",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 518,
          "endLine": 606,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 89,
          "content": "{\r\n    const state = runtime.getState();\r\n    const botId = state.botId;\r\n\r\n    runtime.on('started', () => {\r\n      // logger.info('📡 Bot started event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('stopped', () => {\r\n      // logger.info('📡 Bot stopped event', LogCategory.BOT, { botId });\r\n      this.activeBots.delete(botId);\r\n      this.broadcastBotStatusUpdate(botId, 'stopped');\r\n    });\r\n\r\n    runtime.on('paused', () => {\r\n      // logger.info('📡 Bot paused event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'paused');\r\n    });\r\n\r\n    runtime.on('resumed', () => {\r\n      // logger.info('📡 Bot resumed event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('error', (error: Error) => {\r\n      // logger.error('📡 Bot error event', LogCategory.BOT, {\r\n      //   botId,\r\n      //   error: error.message\r\n      // });\r\n      this.broadcastBotStatusUpdate(botId, 'error');\r\n    });\r\n\r\n    runtime.on('signal', (data: any) => {\r\n      // logger.info('📡 Bot signal event', LogCategory.SIGNAL, {\r\n      //   botId,\r\n      //   signal: data.signal\r\n      // });\r\n      \r\n      // Broadcast signal to WebSocket clients\r\n      webSocketService.broadcast('bot-signal', {\r\n        botId,\r\n        signal: data.signal,\r\n        timestamp: data.timestamp\r\n      });\r\n    });\r\n\r\n    runtime.on('tick', (_data: any) => {\r\n      // Broadcast performance updates periodically (every 10 ticks)\r\n      const currentState = runtime.getState();\r\n      if (currentState.performance.tickCount % 10 === 0) {\r\n        this.broadcastBotPerformanceUpdate(botId, currentState.performance);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up monitoring for bot health and performance\r\n   */\r\n  private setupMonitoring(): void {\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.performHealthCheck();\r\n    }, this.config.monitoringInterval);\r\n  }\r\n\r\n  /**\r\n   * Perform health check on all active bots\r\n   */\r\n  private performHealthCheck(): void {\r\n    const now = new Date();\r\n    \r\n    for (const [botId, runtime] of this.activeBots) {\r\n      const state = runtime.getState();\r\n      \r\n      // Check for stale bots (no tick in last 2 minutes)\r\n      if (state.lastTickAt && state.status === 'running') {\r\n        const timeSinceLastTick = now.getTime() - state.lastTickAt.getTime();\r\n        const staleThreshold = 2 * 60 * 1000; // 2 minutes\r\n        \r\n        if (timeSinceLastTick > staleThreshold) {\r\n          // logger.warn('⚠️ Bot appears stale', LogCategory.BOT, {\r\n          //   botId,\r\n          //   timeSinceLastTick,\r\n          //   lastTickAt: state.lastTickAt\r\n          // });\r\n          \r\n          // Emit warning event\r\n          this.emit('bot-stale', { botId, timeSinceLastTick });\r\n        }",
          "hash": "73e8c4a148b98110036ee6ac35b49810"
        }
      ],
      "description": "Found 3 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 178
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validateBotTradingCycleIntegration",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\bot-trading-cycle-validation.ts",
          "startLine": 9,
          "endLine": 265,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 257,
          "content": "{\r\n  console.log('🔍 Starting Bot Trading Cycle Integration Validation...');\r\n  \r\n  try {\r\n    // Test 1: Enhanced Trading Engine Initialization\r\n    console.log('\\n1. Testing Enhanced Trading Engine...');\r\n    \r\n    const tradingEngine = new EnhancedTradingEngine();\r\n    console.log('✅ Enhanced Trading Engine initialized successfully');\r\n    \r\n    // Test signal processing\r\n    const testSignals = [\r\n      {\r\n        id: 'test-signal-001',\r\n        symbol: 'BTC/USDT',\r\n        action: 'buy',\r\n        confidence: 0.85,\r\n        amount: 0.001,\r\n        timestamp: Date.now(),\r\n        marketData: {\r\n          volatility: 0.02,\r\n          volume: 1000000,\r\n          orderBookImbalance: 0.1\r\n        }\r\n      }\r\n    ];\r\n    \r\n    const processedSignals = await tradingEngine.processAdvancedSignals(testSignals);\r\n    console.log('✅ Signal processing successful:', {\r\n      processedCount: processedSignals.length,\r\n      enhanced: processedSignals[0]?.processed,\r\n      jabbrLabsScore: processedSignals[0]?.jabbrLabsScore\r\n    });\r\n    \r\n    // Test 2: Risk Management Integration\r\n    console.log('\\n2. Testing Risk Management Rules...');\r\n    \r\n    const testPosition = {\r\n      id: 'test-position-001',\r\n      size: 0.01,\r\n      symbol: 'BTC/USDT',\r\n      marketData: {\r\n        volatility: 0.02,\r\n        volume: 1000000\r\n      }\r\n    };\r\n    \r\n    const riskResult = await tradingEngine.applyAdvancedRiskRules(testPosition);\r\n    console.log('✅ Risk management validation:', {\r\n      approved: riskResult.approved,\r\n      reason: riskResult.reason || 'All checks passed'\r\n    });\r\n    \r\n    // Test 3: Order Routing\r\n    console.log('\\n3. Testing Order Routing...');\r\n    \r\n    const testOrder = {\r\n      id: 'test-order-001',\r\n      type: 'market',\r\n      symbol: 'BTC/USDT',\r\n      side: 'buy',\r\n      amount: 0.001\r\n    };\r\n    \r\n    const routingResult = await tradingEngine.routeCustomOrders(testOrder);\r\n    console.log('✅ Order routing successful:', {\r\n      route: routingResult.route,\r\n      hasModifications: !!routingResult.modifications\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const signalData = {\r\n      id: 'cycle-test-signal-001',\r\n      type: 'strategy',\r\n      symbol: 'ETH/USDT',\r\n      action: 'sell' as const,\r\n      confidence: 0.75,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 3000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-cycle-001', signalData);\r\n    console.log('✅ Signal execution pipeline:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Exchange Integration Validation (Simulation Mode)\r\n    console.log('\\n5. Testing Exchange Integration (Simulation)...');\r\n    \r\n    // Since we don't have valid API keys, test the exchange logic without connection\r\n    console.log('ℹ️ Running exchange integration in simulation mode');\r\n    \r\n    // Test risk validation logic\r\n    const riskConfig = {\r\n      maxPositionSize: 0.01,\r\n      maxLeverage: 10,\r\n      maxDailyLoss: 5,\r\n      maxDrawdown: 10,\r\n      maxConcurrentTrades: 3,\r\n      emergencyStop: false,\r\n      riskScore: 5,\r\n      accountBalance: 10000\r\n    };\r\n    \r\n    // Simulate order validation without exchange connection\r\n    const mockOrderRequest = {\r\n      symbol: 'ETHUSDT',\r\n      side: 'buy' as const,\r\n      type: 'market' as const,\r\n      amount: 0.005,\r\n      marketType: MarketType.FUTURES,\r\n      leverage: 5\r\n    };\r\n    \r\n    console.log('✅ Exchange integration simulation:', {\r\n      orderValid: mockOrderRequest.amount <= riskConfig.maxPositionSize,\r\n      leverageValid: (mockOrderRequest.leverage || 1) <= riskConfig.maxLeverage,\r\n      emergencyStop: riskConfig.emergencyStop\r\n    });\r\n    \r\n    // Test 6: Bot Runtime Compatibility\r\n    console.log('\\n6. Testing Bot Runtime System...');\r\n    \r\n    // Test bot configuration validation\r\n    const testBotConfig = {\r\n      id: 'test-bot-runtime-001',\r\n      name: 'Cycle Integration Test Bot',\r\n      userId: 'test-user-001',\r\n      strategy: 'target-reacher',\r\n      symbol: 'BTC/USDT',\r\n      isActive: true,\r\n      riskConfig: {\r\n        maxPositionSize: 0.01,\r\n        stopLossPercentage: 2,\r\n        takeProfitPercentage: 5\r\n      },\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n    \r\n    console.log('✅ Bot configuration validation passed:', {\r\n      botId: testBotConfig.id,\r\n      strategy: testBotConfig.strategy,\r\n      symbol: testBotConfig.symbol\r\n    });\r\n    \r\n    // Test 7: Integration Flow Validation\r\n    console.log('\\n7. Testing Complete Integration Flow...');\r\n    \r\n    // Simulate a complete trading cycle\r\n    const integrationFlowSteps = [\r\n      '📊 Market data analysis',\r\n      '🧠 Strategy signal generation', \r\n      '⚡ Signal processing',\r\n      '🛡️ Risk management validation',\r\n      '📈 Trade decision making',\r\n      '🔄 Order routing',\r\n      '✅ Execution confirmation'\r\n    ];\r\n    \r\n    for (const step of integrationFlowSteps) {\r\n      console.log(`   ${step}`);\r\n      // Simulate processing time\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n    \r\n    console.log('✅ Complete integration flow simulation successful');\r\n    \r\n    // Test 8: Error Handling and Recovery\r\n    console.log('\\n8. Testing Error Handling...');\r\n    \r\n    try {\r\n      // Test invalid signal handling\r\n      await executeSignal('invalid-bot', {\r\n        id: 'invalid-signal',\r\n        type: 'invalid',\r\n        symbol: '',\r\n        action: 'buy' as const,\r\n        confidence: -1, // Invalid confidence\r\n        timestamp: Date.now()\r\n      });\r\n    } catch (error) {\r\n      console.log('✅ Error handling working - invalid signals rejected');\r\n    }\r\n    \r\n    try {\r\n      // Test invalid position risk validation\r\n      await tradingEngine.applyAdvancedRiskRules({\r\n        size: 999999, // Massive position size\r\n        symbol: 'INVALID/PAIR'\r\n      });\r\n      console.log('✅ Risk management correctly handled edge cases');\r\n    } catch (error) {\r\n      console.log('✅ Risk validation error handling working');\r\n    }\r\n    \r\n    // Test 9: Performance and Monitoring\r\n    console.log('\\n9. Testing Performance Monitoring...');\r\n    \r\n    const performanceMetrics = {\r\n      signalProcessingTime: 50, // ms\r\n      riskValidationTime: 25,   // ms\r\n      orderRoutingTime: 15,     // ms\r\n      executionTime: 100,       // ms\r\n      totalCycleTime: 190       // ms\r\n    };\r\n    \r\n    console.log('✅ Performance metrics within acceptable range:', performanceMetrics);\r\n    \r\n    // Test 10: State Management and Persistence\r\n    console.log('\\n10. Testing State Management...');\r\n    \r\n    const botStateSnapshot = {\r\n      botId: 'test-bot-cycle-001',\r\n      status: 'running',\r\n      performance: {\r\n        tickCount: 100,\r\n        signalCount: 25,\r\n        tradeCount: 8,\r\n        errorCount: 0,\r\n        winRate: 0.75,\r\n        totalProfit: 150.50\r\n      },\r\n      lastUpdate: new Date()\r\n    };\r\n    \r\n    console.log('✅ State management operational:', {\r\n      botId: botStateSnapshot.botId,\r\n      status: botStateSnapshot.status,\r\n      winRate: botStateSnapshot.performance.winRate\r\n    });\r\n    \r\n    console.log('\\n🎉 All Bot Trading Cycle Integration Tests Passed!');\r\n    console.log('\\n📋 Validation Summary:');\r\n    console.log('   ✅ Trading Engine Integration');\r\n    console.log('   ✅ Signal Processing Pipeline');\r\n    console.log('   ✅ Risk Management System');\r\n    console.log('   ✅ Order Routing Logic');\r\n    console.log('   ✅ Exchange Connectivity');\r\n    console.log('   ✅ Bot Runtime Compatibility');\r\n    console.log('   ✅ Error Handling & Recovery');\r\n    console.log('   ✅ Performance Monitoring');\r\n    console.log('   ✅ State Management');\r\n    console.log('   ✅ Complete Integration Flow');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Bot Trading Cycle Integration Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "23391937599010ca693e49fc69f751bf"
        },
        {
          "type": "function",
          "name": "validateBotTradingCycleIntegration",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\bot-trading-cycle-validation.ts",
          "startLine": 9,
          "endLine": 265,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 257,
          "content": "{\r\n  console.log('🔍 Starting Bot Trading Cycle Integration Validation...');\r\n  \r\n  try {\r\n    // Test 1: Enhanced Trading Engine Initialization\r\n    console.log('\\n1. Testing Enhanced Trading Engine...');\r\n    \r\n    const tradingEngine = new EnhancedTradingEngine();\r\n    console.log('✅ Enhanced Trading Engine initialized successfully');\r\n    \r\n    // Test signal processing\r\n    const testSignals = [\r\n      {\r\n        id: 'test-signal-001',\r\n        symbol: 'BTC/USDT',\r\n        action: 'buy',\r\n        confidence: 0.85,\r\n        amount: 0.001,\r\n        timestamp: Date.now(),\r\n        marketData: {\r\n          volatility: 0.02,\r\n          volume: 1000000,\r\n          orderBookImbalance: 0.1\r\n        }\r\n      }\r\n    ];\r\n    \r\n    const processedSignals = await tradingEngine.processAdvancedSignals(testSignals);\r\n    console.log('✅ Signal processing successful:', {\r\n      processedCount: processedSignals.length,\r\n      enhanced: processedSignals[0]?.processed,\r\n      jabbrLabsScore: processedSignals[0]?.jabbrLabsScore\r\n    });\r\n    \r\n    // Test 2: Risk Management Integration\r\n    console.log('\\n2. Testing Risk Management Rules...');\r\n    \r\n    const testPosition = {\r\n      id: 'test-position-001',\r\n      size: 0.01,\r\n      symbol: 'BTC/USDT',\r\n      marketData: {\r\n        volatility: 0.02,\r\n        volume: 1000000\r\n      }\r\n    };\r\n    \r\n    const riskResult = await tradingEngine.applyAdvancedRiskRules(testPosition);\r\n    console.log('✅ Risk management validation:', {\r\n      approved: riskResult.approved,\r\n      reason: riskResult.reason || 'All checks passed'\r\n    });\r\n    \r\n    // Test 3: Order Routing\r\n    console.log('\\n3. Testing Order Routing...');\r\n    \r\n    const testOrder = {\r\n      id: 'test-order-001',\r\n      type: 'market',\r\n      symbol: 'BTC/USDT',\r\n      side: 'buy',\r\n      amount: 0.001\r\n    };\r\n    \r\n    const routingResult = await tradingEngine.routeCustomOrders(testOrder);\r\n    console.log('✅ Order routing successful:', {\r\n      route: routingResult.route,\r\n      hasModifications: !!routingResult.modifications\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const signalData = {\r\n      id: 'cycle-test-signal-001',\r\n      type: 'strategy',\r\n      symbol: 'ETH/USDT',\r\n      action: 'sell' as const,\r\n      confidence: 0.75,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 3000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-cycle-001', signalData);\r\n    console.log('✅ Signal execution pipeline:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Exchange Integration Validation (Simulation Mode)\r\n    console.log('\\n5. Testing Exchange Integration (Simulation)...');\r\n    \r\n    // Since we don't have valid API keys, test the exchange logic without connection\r\n    console.log('ℹ️ Running exchange integration in simulation mode');\r\n    \r\n    // Test risk validation logic\r\n    const riskConfig = {\r\n      maxPositionSize: 0.01,\r\n      maxLeverage: 10,\r\n      maxDailyLoss: 5,\r\n      maxDrawdown: 10,\r\n      maxConcurrentTrades: 3,\r\n      emergencyStop: false,\r\n      riskScore: 5,\r\n      accountBalance: 10000\r\n    };\r\n    \r\n    // Simulate order validation without exchange connection\r\n    const mockOrderRequest = {\r\n      symbol: 'ETHUSDT',\r\n      side: 'buy' as const,\r\n      type: 'market' as const,\r\n      amount: 0.005,\r\n      marketType: MarketType.FUTURES,\r\n      leverage: 5\r\n    };\r\n    \r\n    console.log('✅ Exchange integration simulation:', {\r\n      orderValid: mockOrderRequest.amount <= riskConfig.maxPositionSize,\r\n      leverageValid: (mockOrderRequest.leverage || 1) <= riskConfig.maxLeverage,\r\n      emergencyStop: riskConfig.emergencyStop\r\n    });\r\n    \r\n    // Test 6: Bot Runtime Compatibility\r\n    console.log('\\n6. Testing Bot Runtime System...');\r\n    \r\n    // Test bot configuration validation\r\n    const testBotConfig = {\r\n      id: 'test-bot-runtime-001',\r\n      name: 'Cycle Integration Test Bot',\r\n      userId: 'test-user-001',\r\n      strategy: 'target-reacher',\r\n      symbol: 'BTC/USDT',\r\n      isActive: true,\r\n      riskConfig: {\r\n        maxPositionSize: 0.01,\r\n        stopLossPercentage: 2,\r\n        takeProfitPercentage: 5\r\n      },\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n    \r\n    console.log('✅ Bot configuration validation passed:', {\r\n      botId: testBotConfig.id,\r\n      strategy: testBotConfig.strategy,\r\n      symbol: testBotConfig.symbol\r\n    });\r\n    \r\n    // Test 7: Integration Flow Validation\r\n    console.log('\\n7. Testing Complete Integration Flow...');\r\n    \r\n    // Simulate a complete trading cycle\r\n    const integrationFlowSteps = [\r\n      '📊 Market data analysis',\r\n      '🧠 Strategy signal generation', \r\n      '⚡ Signal processing',\r\n      '🛡️ Risk management validation',\r\n      '📈 Trade decision making',\r\n      '🔄 Order routing',\r\n      '✅ Execution confirmation'\r\n    ];\r\n    \r\n    for (const step of integrationFlowSteps) {\r\n      console.log(`   ${step}`);\r\n      // Simulate processing time\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n    \r\n    console.log('✅ Complete integration flow simulation successful');\r\n    \r\n    // Test 8: Error Handling and Recovery\r\n    console.log('\\n8. Testing Error Handling...');\r\n    \r\n    try {\r\n      // Test invalid signal handling\r\n      await executeSignal('invalid-bot', {\r\n        id: 'invalid-signal',\r\n        type: 'invalid',\r\n        symbol: '',\r\n        action: 'buy' as const,\r\n        confidence: -1, // Invalid confidence\r\n        timestamp: Date.now()\r\n      });\r\n    } catch (error) {\r\n      console.log('✅ Error handling working - invalid signals rejected');\r\n    }\r\n    \r\n    try {\r\n      // Test invalid position risk validation\r\n      await tradingEngine.applyAdvancedRiskRules({\r\n        size: 999999, // Massive position size\r\n        symbol: 'INVALID/PAIR'\r\n      });\r\n      console.log('✅ Risk management correctly handled edge cases');\r\n    } catch (error) {\r\n      console.log('✅ Risk validation error handling working');\r\n    }\r\n    \r\n    // Test 9: Performance and Monitoring\r\n    console.log('\\n9. Testing Performance Monitoring...');\r\n    \r\n    const performanceMetrics = {\r\n      signalProcessingTime: 50, // ms\r\n      riskValidationTime: 25,   // ms\r\n      orderRoutingTime: 15,     // ms\r\n      executionTime: 100,       // ms\r\n      totalCycleTime: 190       // ms\r\n    };\r\n    \r\n    console.log('✅ Performance metrics within acceptable range:', performanceMetrics);\r\n    \r\n    // Test 10: State Management and Persistence\r\n    console.log('\\n10. Testing State Management...');\r\n    \r\n    const botStateSnapshot = {\r\n      botId: 'test-bot-cycle-001',\r\n      status: 'running',\r\n      performance: {\r\n        tickCount: 100,\r\n        signalCount: 25,\r\n        tradeCount: 8,\r\n        errorCount: 0,\r\n        winRate: 0.75,\r\n        totalProfit: 150.50\r\n      },\r\n      lastUpdate: new Date()\r\n    };\r\n    \r\n    console.log('✅ State management operational:', {\r\n      botId: botStateSnapshot.botId,\r\n      status: botStateSnapshot.status,\r\n      winRate: botStateSnapshot.performance.winRate\r\n    });\r\n    \r\n    console.log('\\n🎉 All Bot Trading Cycle Integration Tests Passed!');\r\n    console.log('\\n📋 Validation Summary:');\r\n    console.log('   ✅ Trading Engine Integration');\r\n    console.log('   ✅ Signal Processing Pipeline');\r\n    console.log('   ✅ Risk Management System');\r\n    console.log('   ✅ Order Routing Logic');\r\n    console.log('   ✅ Exchange Connectivity');\r\n    console.log('   ✅ Bot Runtime Compatibility');\r\n    console.log('   ✅ Error Handling & Recovery');\r\n    console.log('   ✅ Performance Monitoring');\r\n    console.log('   ✅ State Management');\r\n    console.log('   ✅ Complete Integration Flow');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Bot Trading Cycle Integration Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "23391937599010ca693e49fc69f751bf"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 257
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "performDatabaseHealthCheck",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\database-health-check.ts",
          "startLine": 6,
          "endLine": 44,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 39,
          "content": "{\r\n  console.log('🔍 Starting database health check...');\r\n  \r\n  try {\r\n    // Initialize database connection\r\n    const dbManager = new DatabaseManager();\r\n    await dbManager.connect();\r\n    \r\n    console.log('✅ Database connection established');\r\n    \r\n    // Test basic query\r\n    const timeResult = await dbManager.query<{ now: Date }>('SELECT NOW() as now');\r\n    if (timeResult && timeResult.length > 0) {\r\n      console.log('✅ Query test successful:', timeResult[0]?.now);\r\n    } else {\r\n      throw new Error('Query returned no results');\r\n    }\r\n    \r\n    // Test database health and connection pool status\r\n    const healthCheck = await dbManager.healthCheck();\r\n    console.log('📊 Database health status:', {\r\n      status: healthCheck.status,\r\n      connected: healthCheck.details.connected,\r\n      poolSize: healthCheck.details.poolSize,\r\n      idleConnections: healthCheck.details.idleCount,\r\n      waitingCount: healthCheck.details.waitingCount,\r\n      responseTime: healthCheck.details.responseTime\r\n    });\r\n    \r\n    // Cleanup\r\n    await dbManager.disconnect();\r\n    console.log('✅ Database health check completed successfully');\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('❌ Database health check failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "5552c2b448adca6e8ace03f1d2533a18"
        },
        {
          "type": "function",
          "name": "performDatabaseHealthCheck",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\database-health-check.ts",
          "startLine": 6,
          "endLine": 44,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 39,
          "content": "{\r\n  console.log('🔍 Starting database health check...');\r\n  \r\n  try {\r\n    // Initialize database connection\r\n    const dbManager = new DatabaseManager();\r\n    await dbManager.connect();\r\n    \r\n    console.log('✅ Database connection established');\r\n    \r\n    // Test basic query\r\n    const timeResult = await dbManager.query<{ now: Date }>('SELECT NOW() as now');\r\n    if (timeResult && timeResult.length > 0) {\r\n      console.log('✅ Query test successful:', timeResult[0]?.now);\r\n    } else {\r\n      throw new Error('Query returned no results');\r\n    }\r\n    \r\n    // Test database health and connection pool status\r\n    const healthCheck = await dbManager.healthCheck();\r\n    console.log('📊 Database health status:', {\r\n      status: healthCheck.status,\r\n      connected: healthCheck.details.connected,\r\n      poolSize: healthCheck.details.poolSize,\r\n      idleConnections: healthCheck.details.idleCount,\r\n      waitingCount: healthCheck.details.waitingCount,\r\n      responseTime: healthCheck.details.responseTime\r\n    });\r\n    \r\n    // Cleanup\r\n    await dbManager.disconnect();\r\n    console.log('✅ Database health check completed successfully');\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('❌ Database health check failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "5552c2b448adca6e8ace03f1d2533a18"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 39
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validatePerformanceMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\performance-monitoring-validation.ts",
          "startLine": 6,
          "endLine": 353,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 348,
          "content": "{\r\n  console.log('🔍 Starting Performance Monitoring and Metrics Validation...');\r\n  \r\n  try {\r\n    // Test 1: Monitoring Service Structure Validation\r\n    console.log('\\n1. Validating Monitoring Service Structure...');\r\n    \r\n    // Check for required monitoring service files\r\n    const monitoringServices = [\r\n      'strategy-monitor.service.ts',\r\n      'database-monitor.service.ts', \r\n      'exchange-monitor.service.ts',\r\n      'application-monitor.service.ts',\r\n      'system-monitor.service.ts',\r\n      'monitoring.service.ts'\r\n    ];\r\n    \r\n    console.log('✅ Monitoring services structure validated:', {\r\n      totalServices: monitoringServices.length,\r\n      servicesAvailable: monitoringServices\r\n    });\r\n    \r\n    // Test 2: Performance Metrics Structure\r\n    console.log('\\n2. Testing Performance Metrics Structure...');\r\n    \r\n    const performanceMetrics = {\r\n      timestamp: Date.now(),\r\n      apiResponseTime: 125, // ms\r\n      orderExecutionTime: 850, // ms  \r\n      webSocketLatency: 35, // ms\r\n      memoryUsage: 256, // MB\r\n      cpuUsage: 15.5, // %\r\n      activeConnections: 45,\r\n      requestsPerSecond: 12.3,\r\n      errorRate: 0.0008, // 0.08%\r\n      throughput: 1250, // requests/hour\r\n      queueDepth: 3\r\n    };\r\n    \r\n    const metricsValid = performanceMetrics.timestamp > 0 && \r\n                        performanceMetrics.apiResponseTime > 0 &&\r\n                        performanceMetrics.cpuUsage >= 0 &&\r\n                        performanceMetrics.errorRate >= 0;\r\n    \r\n    console.log('✅ Performance metrics structure validated:', {\r\n      metricsValid,\r\n      apiResponseTime: `${performanceMetrics.apiResponseTime}ms`,\r\n      orderExecutionTime: `${performanceMetrics.orderExecutionTime}ms`,\r\n      webSocketLatency: `${performanceMetrics.webSocketLatency}ms`,\r\n      memoryUsage: `${performanceMetrics.memoryUsage}MB`,\r\n      cpuUsage: `${performanceMetrics.cpuUsage}%`,\r\n      errorRate: `${(performanceMetrics.errorRate * 100).toFixed(3)}%`\r\n    });\r\n    \r\n    // Test 3: Strategy Performance Metrics\r\n    console.log('\\n3. Testing Strategy Performance Metrics...');\r\n    \r\n    const strategyMetrics = {\r\n      botId: 'test-bot-001',\r\n      strategyName: 'aether',\r\n      strategyVersion: '1.0.0',\r\n      isRunning: true,\r\n      uptime: 3600000, // 1 hour\r\n      totalTrades: 25,\r\n      winningTrades: 18,\r\n      losingTrades: 7,\r\n      totalPnL: 245.67,\r\n      dailyPnL: 45.23,\r\n      winRate: (18 / 25) * 100, // 72%\r\n      maxDrawdown: 15.5,\r\n      currentDrawdown: 2.3,\r\n      averageTradeTime: 45000,\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    const strategyMetricsValid = strategyMetrics.totalTrades === \r\n                                (strategyMetrics.winningTrades + strategyMetrics.losingTrades) &&\r\n                                strategyMetrics.winRate > 0 &&\r\n                                strategyMetrics.totalPnL !== 0;\r\n    \r\n    console.log('✅ Strategy performance metrics validated:', {\r\n      metricsValid: strategyMetricsValid,\r\n      totalTrades: strategyMetrics.totalTrades,\r\n      winRate: `${strategyMetrics.winRate.toFixed(1)}%`,\r\n      totalPnL: `$${strategyMetrics.totalPnL}`,\r\n      uptime: `${strategyMetrics.uptime / 1000}s`\r\n    });\r\n    \r\n    // Test 4: Database Health Metrics\r\n    console.log('\\n4. Testing Database Health Metrics...');\r\n    \r\n    const dbHealthMetrics = {\r\n      status: 'healthy' as const,\r\n      connections: {\r\n        active: 8,\r\n        idle: 12,\r\n        total: 20,\r\n        maxAllowed: 100,\r\n        utilizationPercentage: 20\r\n      },\r\n      queries: {\r\n        totalExecuted: 15420,\r\n        averageTime: 23.5,\r\n        slowQueries: 3,\r\n        failedQueries: 1,\r\n        queriesPerSecond: 42.3\r\n      },\r\n      performance: {\r\n        transactionsPerSecond: 38.7,\r\n        cacheHitRatio: 0.94,\r\n        indexEfficiency: 0.89\r\n      },\r\n      uptime: 7200000, // 2 hours\r\n      lastCheck: new Date()\r\n    };\r\n    \r\n    const dbHealthValid = dbHealthMetrics.status === 'healthy' &&\r\n                         dbHealthMetrics.connections.utilizationPercentage < 80 &&\r\n                         dbHealthMetrics.performance.cacheHitRatio > 0.8;\r\n    \r\n    console.log('✅ Database health metrics validated:', {\r\n      healthValid: dbHealthValid,\r\n      status: dbHealthMetrics.status,\r\n      connectionUtilization: `${dbHealthMetrics.connections.utilizationPercentage}%`,\r\n      avgQueryTime: `${dbHealthMetrics.queries.averageTime}ms`,\r\n      cacheHitRatio: `${(dbHealthMetrics.performance.cacheHitRatio * 100).toFixed(1)}%`\r\n    });\r\n    \r\n    // Test 5: Exchange Connection Metrics\r\n    console.log('\\n5. Testing Exchange Connection Metrics...');\r\n    \r\n    const exchangeMetrics = {\r\n      exchange: 'bybit',\r\n      isConnected: true,\r\n      lastPing: Date.now(),\r\n      avgLatency: 45,\r\n      errorRate: 0.001,\r\n      totalRequests: 1250,\r\n      failedRequests: 1,\r\n      rateLimitStatus: {\r\n        remaining: 980,\r\n        limit: 1000,\r\n        resetTime: Date.now() + 60000\r\n      },\r\n      apiCalls: {\r\n        perMinute: 15,\r\n        perHour: 890,\r\n        dailyLimit: 10000\r\n      }\r\n    };\r\n    \r\n    const exchangeHealthy = exchangeMetrics.isConnected &&\r\n                           exchangeMetrics.avgLatency < 200 &&\r\n                           exchangeMetrics.errorRate < 0.01 &&\r\n                           exchangeMetrics.rateLimitStatus.remaining > 100;\r\n    \r\n    console.log('✅ Exchange connection metrics validated:', {\r\n      exchangeHealthy,\r\n      exchange: exchangeMetrics.exchange,\r\n      isConnected: exchangeMetrics.isConnected,\r\n      avgLatency: `${exchangeMetrics.avgLatency}ms`,\r\n      errorRate: `${(exchangeMetrics.errorRate * 100).toFixed(3)}%`,\r\n      rateLimitRemaining: exchangeMetrics.rateLimitStatus.remaining\r\n    });\r\n    \r\n    // Test 6: System Resource Metrics\r\n    console.log('\\n6. Testing System Resource Metrics...');\r\n    \r\n    const systemMetrics = {\r\n      cpu: {\r\n        usage: 18.5, // %\r\n        cores: 8,\r\n        loadAverage: [0.45, 0.52, 0.38]\r\n      },\r\n      memory: {\r\n        total: 16384, // MB\r\n        used: 6240, // MB\r\n        free: 10144, // MB\r\n        usage: 38.1 // %\r\n      },\r\n      disk: {\r\n        total: 512000, // MB\r\n        used: 156700, // MB\r\n        free: 355300, // MB\r\n        usage: 30.6 // %\r\n      },\r\n      network: {\r\n        bytesIn: 2340000,\r\n        bytesOut: 4560000,\r\n        packetsIn: 15420,\r\n        packetsOut: 18930\r\n      }\r\n    };\r\n    \r\n    const systemHealthy = systemMetrics.cpu.usage < 80 &&\r\n                         systemMetrics.memory.usage < 85 &&\r\n                         systemMetrics.disk.usage < 90;\r\n    \r\n    console.log('✅ System resource metrics validated:', {\r\n      systemHealthy,\r\n      cpuUsage: `${systemMetrics.cpu.usage}%`,\r\n      memoryUsage: `${systemMetrics.memory.usage}%`,\r\n      diskUsage: `${systemMetrics.disk.usage}%`,\r\n      cores: systemMetrics.cpu.cores\r\n    });\r\n    \r\n    // Test 7: Performance Thresholds and Alerting\r\n    console.log('\\n7. Testing Performance Thresholds and Alerting...');\r\n    \r\n    const performanceThresholds = {\r\n      apiResponseTime: { warning: 300, critical: 500 },\r\n      orderExecutionTime: { warning: 1500, critical: 2000 },\r\n      webSocketLatency: { warning: 100, critical: 200 },\r\n      memoryUsage: { warning: 70, critical: 85 },\r\n      cpuUsage: { warning: 70, critical: 85 },\r\n      errorRate: { warning: 0.005, critical: 0.01 },\r\n      diskUsage: { warning: 80, critical: 90 }\r\n    };\r\n    \r\n    // Check current metrics against thresholds\r\n    const alertStatus = {\r\n      apiResponseTime: performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.warning ? 'good' : \r\n                      performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.critical ? 'warning' : 'critical',\r\n      \r\n      orderExecutionTime: performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.warning ? 'good' : \r\n                         performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.critical ? 'warning' : 'critical',\r\n      \r\n      cpuUsage: systemMetrics.cpu.usage < performanceThresholds.cpuUsage.warning ? 'good' : \r\n               systemMetrics.cpu.usage < performanceThresholds.cpuUsage.critical ? 'warning' : 'critical',\r\n      \r\n      memoryUsage: systemMetrics.memory.usage < performanceThresholds.memoryUsage.warning ? 'good' : \r\n                  systemMetrics.memory.usage < performanceThresholds.memoryUsage.critical ? 'warning' : 'critical',\r\n      \r\n      errorRate: performanceMetrics.errorRate < performanceThresholds.errorRate.warning ? 'good' : \r\n                performanceMetrics.errorRate < performanceThresholds.errorRate.critical ? 'warning' : 'critical'\r\n    };\r\n    \r\n    const criticalAlerts = Object.values(alertStatus).filter(status => status === 'critical').length;\r\n    const warningAlerts = Object.values(alertStatus).filter(status => status === 'warning').length;\r\n    \r\n    console.log('✅ Performance thresholds and alerting validated:', {\r\n      criticalAlerts,\r\n      warningAlerts,\r\n      overallStatus: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'good',\r\n      alertDetails: alertStatus\r\n    });\r\n    \r\n    // Test 8: Metrics Aggregation and Reporting\r\n    console.log('\\n8. Testing Metrics Aggregation and Reporting...');\r\n    \r\n    const aggregatedMetrics = {\r\n      timeWindow: '1h',\r\n      summary: {\r\n        totalRequests: 4523,\r\n        successfulRequests: 4520,\r\n        failedRequests: 3,\r\n        avgResponseTime: 142,\r\n        p95ResponseTime: 285,\r\n        p99ResponseTime: 445,\r\n        uniqueUsers: 128,\r\n        peakConcurrency: 67\r\n      },\r\n      trends: {\r\n        responseTimeTrend: 'stable', // increasing, decreasing, stable\r\n        errorRateTrend: 'decreasing',\r\n        throughputTrend: 'increasing'\r\n      },\r\n      resourceUtilization: {\r\n        cpu: { avg: 18.5, peak: 34.2, trend: 'stable' },\r\n        memory: { avg: 312, peak: 456, trend: 'stable' },\r\n        network: { in: 2.3, out: 4.7, trend: 'increasing' }\r\n      }\r\n    };\r\n    \r\n    const aggregationValid = aggregatedMetrics.summary.totalRequests === \r\n                            (aggregatedMetrics.summary.successfulRequests + aggregatedMetrics.summary.failedRequests) &&\r\n                            aggregatedMetrics.summary.avgResponseTime > 0;\r\n    \r\n    console.log('✅ Metrics aggregation and reporting validated:', {\r\n      aggregationValid,\r\n      timeWindow: aggregatedMetrics.timeWindow,\r\n      totalRequests: aggregatedMetrics.summary.totalRequests,\r\n      successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n      avgResponseTime: `${aggregatedMetrics.summary.avgResponseTime}ms`,\r\n      p95ResponseTime: `${aggregatedMetrics.summary.p95ResponseTime}ms`\r\n    });\r\n    \r\n    // Test 9: Dashboard Data Structure\r\n    console.log('\\n9. Testing Dashboard Data Structure...');\r\n    \r\n    const dashboardData = {\r\n      realTime: {\r\n        status: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'healthy',\r\n        activeUsers: 42,\r\n        requestsPerSecond: performanceMetrics.requestsPerSecond,\r\n        errorRate: performanceMetrics.errorRate,\r\n        systemLoad: systemMetrics.cpu.usage,\r\n        uptime: systemMetrics.cpu.loadAverage[0]\r\n      },\r\n      timeSeries: {\r\n        labels: ['00:00', '00:15', '00:30', '00:45', '01:00'],\r\n        datasets: {\r\n          responseTime: [120, 135, 142, 138, 125],\r\n          throughput: [10.2, 11.8, 12.3, 11.9, 10.7],\r\n          errors: [0, 1, 0, 2, 0],\r\n          cpuUsage: [15.2, 16.8, 18.5, 17.3, 15.9],\r\n          memoryUsage: [35.4, 36.2, 38.1, 37.8, 36.9]\r\n        }\r\n      },\r\n      summary: {\r\n        uptime: '99.97%',\r\n        totalTrades: strategyMetrics.totalTrades,\r\n        successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n        avgProfit: '+2.34%'\r\n      }\r\n    };\r\n    \r\n    const dashboardValid = dashboardData.timeSeries.labels.length === \r\n                          dashboardData.timeSeries.datasets.responseTime.length &&\r\n                          dashboardData.realTime.status in ['healthy', 'warning', 'critical'];\r\n    \r\n    console.log('✅ Dashboard data structure validated:', {\r\n      dashboardValid,\r\n      realTimeStatus: dashboardData.realTime.status,\r\n      activeUsers: dashboardData.realTime.activeUsers,\r\n      dataPoints: dashboardData.timeSeries.labels.length,\r\n      uptime: dashboardData.summary.uptime\r\n    });\r\n    \r\n    console.log('\\n🎉 All Performance Monitoring and Metrics Validation Tests Passed!');\r\n    console.log('\\n📊 Validation Summary:');\r\n    console.log('   ✅ Monitoring Service Infrastructure');\r\n    console.log('   ✅ Performance Metrics Collection');\r\n    console.log('   ✅ Strategy Performance Tracking');\r\n    console.log('   ✅ Database Health Monitoring');\r\n    console.log('   ✅ Exchange Connection Monitoring');\r\n    console.log('   ✅ System Resource Monitoring');\r\n    console.log('   ✅ Performance Thresholds & Alerting');\r\n    console.log('   ✅ Metrics Aggregation & Reporting');\r\n    console.log('   ✅ Dashboard Data Preparation');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Performance Monitoring Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "cadd453a97bf48586c046b2ce64e191f"
        },
        {
          "type": "function",
          "name": "validatePerformanceMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\performance-monitoring-validation.ts",
          "startLine": 6,
          "endLine": 353,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 348,
          "content": "{\r\n  console.log('🔍 Starting Performance Monitoring and Metrics Validation...');\r\n  \r\n  try {\r\n    // Test 1: Monitoring Service Structure Validation\r\n    console.log('\\n1. Validating Monitoring Service Structure...');\r\n    \r\n    // Check for required monitoring service files\r\n    const monitoringServices = [\r\n      'strategy-monitor.service.ts',\r\n      'database-monitor.service.ts', \r\n      'exchange-monitor.service.ts',\r\n      'application-monitor.service.ts',\r\n      'system-monitor.service.ts',\r\n      'monitoring.service.ts'\r\n    ];\r\n    \r\n    console.log('✅ Monitoring services structure validated:', {\r\n      totalServices: monitoringServices.length,\r\n      servicesAvailable: monitoringServices\r\n    });\r\n    \r\n    // Test 2: Performance Metrics Structure\r\n    console.log('\\n2. Testing Performance Metrics Structure...');\r\n    \r\n    const performanceMetrics = {\r\n      timestamp: Date.now(),\r\n      apiResponseTime: 125, // ms\r\n      orderExecutionTime: 850, // ms  \r\n      webSocketLatency: 35, // ms\r\n      memoryUsage: 256, // MB\r\n      cpuUsage: 15.5, // %\r\n      activeConnections: 45,\r\n      requestsPerSecond: 12.3,\r\n      errorRate: 0.0008, // 0.08%\r\n      throughput: 1250, // requests/hour\r\n      queueDepth: 3\r\n    };\r\n    \r\n    const metricsValid = performanceMetrics.timestamp > 0 && \r\n                        performanceMetrics.apiResponseTime > 0 &&\r\n                        performanceMetrics.cpuUsage >= 0 &&\r\n                        performanceMetrics.errorRate >= 0;\r\n    \r\n    console.log('✅ Performance metrics structure validated:', {\r\n      metricsValid,\r\n      apiResponseTime: `${performanceMetrics.apiResponseTime}ms`,\r\n      orderExecutionTime: `${performanceMetrics.orderExecutionTime}ms`,\r\n      webSocketLatency: `${performanceMetrics.webSocketLatency}ms`,\r\n      memoryUsage: `${performanceMetrics.memoryUsage}MB`,\r\n      cpuUsage: `${performanceMetrics.cpuUsage}%`,\r\n      errorRate: `${(performanceMetrics.errorRate * 100).toFixed(3)}%`\r\n    });\r\n    \r\n    // Test 3: Strategy Performance Metrics\r\n    console.log('\\n3. Testing Strategy Performance Metrics...');\r\n    \r\n    const strategyMetrics = {\r\n      botId: 'test-bot-001',\r\n      strategyName: 'aether',\r\n      strategyVersion: '1.0.0',\r\n      isRunning: true,\r\n      uptime: 3600000, // 1 hour\r\n      totalTrades: 25,\r\n      winningTrades: 18,\r\n      losingTrades: 7,\r\n      totalPnL: 245.67,\r\n      dailyPnL: 45.23,\r\n      winRate: (18 / 25) * 100, // 72%\r\n      maxDrawdown: 15.5,\r\n      currentDrawdown: 2.3,\r\n      averageTradeTime: 45000,\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    const strategyMetricsValid = strategyMetrics.totalTrades === \r\n                                (strategyMetrics.winningTrades + strategyMetrics.losingTrades) &&\r\n                                strategyMetrics.winRate > 0 &&\r\n                                strategyMetrics.totalPnL !== 0;\r\n    \r\n    console.log('✅ Strategy performance metrics validated:', {\r\n      metricsValid: strategyMetricsValid,\r\n      totalTrades: strategyMetrics.totalTrades,\r\n      winRate: `${strategyMetrics.winRate.toFixed(1)}%`,\r\n      totalPnL: `$${strategyMetrics.totalPnL}`,\r\n      uptime: `${strategyMetrics.uptime / 1000}s`\r\n    });\r\n    \r\n    // Test 4: Database Health Metrics\r\n    console.log('\\n4. Testing Database Health Metrics...');\r\n    \r\n    const dbHealthMetrics = {\r\n      status: 'healthy' as const,\r\n      connections: {\r\n        active: 8,\r\n        idle: 12,\r\n        total: 20,\r\n        maxAllowed: 100,\r\n        utilizationPercentage: 20\r\n      },\r\n      queries: {\r\n        totalExecuted: 15420,\r\n        averageTime: 23.5,\r\n        slowQueries: 3,\r\n        failedQueries: 1,\r\n        queriesPerSecond: 42.3\r\n      },\r\n      performance: {\r\n        transactionsPerSecond: 38.7,\r\n        cacheHitRatio: 0.94,\r\n        indexEfficiency: 0.89\r\n      },\r\n      uptime: 7200000, // 2 hours\r\n      lastCheck: new Date()\r\n    };\r\n    \r\n    const dbHealthValid = dbHealthMetrics.status === 'healthy' &&\r\n                         dbHealthMetrics.connections.utilizationPercentage < 80 &&\r\n                         dbHealthMetrics.performance.cacheHitRatio > 0.8;\r\n    \r\n    console.log('✅ Database health metrics validated:', {\r\n      healthValid: dbHealthValid,\r\n      status: dbHealthMetrics.status,\r\n      connectionUtilization: `${dbHealthMetrics.connections.utilizationPercentage}%`,\r\n      avgQueryTime: `${dbHealthMetrics.queries.averageTime}ms`,\r\n      cacheHitRatio: `${(dbHealthMetrics.performance.cacheHitRatio * 100).toFixed(1)}%`\r\n    });\r\n    \r\n    // Test 5: Exchange Connection Metrics\r\n    console.log('\\n5. Testing Exchange Connection Metrics...');\r\n    \r\n    const exchangeMetrics = {\r\n      exchange: 'bybit',\r\n      isConnected: true,\r\n      lastPing: Date.now(),\r\n      avgLatency: 45,\r\n      errorRate: 0.001,\r\n      totalRequests: 1250,\r\n      failedRequests: 1,\r\n      rateLimitStatus: {\r\n        remaining: 980,\r\n        limit: 1000,\r\n        resetTime: Date.now() + 60000\r\n      },\r\n      apiCalls: {\r\n        perMinute: 15,\r\n        perHour: 890,\r\n        dailyLimit: 10000\r\n      }\r\n    };\r\n    \r\n    const exchangeHealthy = exchangeMetrics.isConnected &&\r\n                           exchangeMetrics.avgLatency < 200 &&\r\n                           exchangeMetrics.errorRate < 0.01 &&\r\n                           exchangeMetrics.rateLimitStatus.remaining > 100;\r\n    \r\n    console.log('✅ Exchange connection metrics validated:', {\r\n      exchangeHealthy,\r\n      exchange: exchangeMetrics.exchange,\r\n      isConnected: exchangeMetrics.isConnected,\r\n      avgLatency: `${exchangeMetrics.avgLatency}ms`,\r\n      errorRate: `${(exchangeMetrics.errorRate * 100).toFixed(3)}%`,\r\n      rateLimitRemaining: exchangeMetrics.rateLimitStatus.remaining\r\n    });\r\n    \r\n    // Test 6: System Resource Metrics\r\n    console.log('\\n6. Testing System Resource Metrics...');\r\n    \r\n    const systemMetrics = {\r\n      cpu: {\r\n        usage: 18.5, // %\r\n        cores: 8,\r\n        loadAverage: [0.45, 0.52, 0.38]\r\n      },\r\n      memory: {\r\n        total: 16384, // MB\r\n        used: 6240, // MB\r\n        free: 10144, // MB\r\n        usage: 38.1 // %\r\n      },\r\n      disk: {\r\n        total: 512000, // MB\r\n        used: 156700, // MB\r\n        free: 355300, // MB\r\n        usage: 30.6 // %\r\n      },\r\n      network: {\r\n        bytesIn: 2340000,\r\n        bytesOut: 4560000,\r\n        packetsIn: 15420,\r\n        packetsOut: 18930\r\n      }\r\n    };\r\n    \r\n    const systemHealthy = systemMetrics.cpu.usage < 80 &&\r\n                         systemMetrics.memory.usage < 85 &&\r\n                         systemMetrics.disk.usage < 90;\r\n    \r\n    console.log('✅ System resource metrics validated:', {\r\n      systemHealthy,\r\n      cpuUsage: `${systemMetrics.cpu.usage}%`,\r\n      memoryUsage: `${systemMetrics.memory.usage}%`,\r\n      diskUsage: `${systemMetrics.disk.usage}%`,\r\n      cores: systemMetrics.cpu.cores\r\n    });\r\n    \r\n    // Test 7: Performance Thresholds and Alerting\r\n    console.log('\\n7. Testing Performance Thresholds and Alerting...');\r\n    \r\n    const performanceThresholds = {\r\n      apiResponseTime: { warning: 300, critical: 500 },\r\n      orderExecutionTime: { warning: 1500, critical: 2000 },\r\n      webSocketLatency: { warning: 100, critical: 200 },\r\n      memoryUsage: { warning: 70, critical: 85 },\r\n      cpuUsage: { warning: 70, critical: 85 },\r\n      errorRate: { warning: 0.005, critical: 0.01 },\r\n      diskUsage: { warning: 80, critical: 90 }\r\n    };\r\n    \r\n    // Check current metrics against thresholds\r\n    const alertStatus = {\r\n      apiResponseTime: performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.warning ? 'good' : \r\n                      performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.critical ? 'warning' : 'critical',\r\n      \r\n      orderExecutionTime: performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.warning ? 'good' : \r\n                         performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.critical ? 'warning' : 'critical',\r\n      \r\n      cpuUsage: systemMetrics.cpu.usage < performanceThresholds.cpuUsage.warning ? 'good' : \r\n               systemMetrics.cpu.usage < performanceThresholds.cpuUsage.critical ? 'warning' : 'critical',\r\n      \r\n      memoryUsage: systemMetrics.memory.usage < performanceThresholds.memoryUsage.warning ? 'good' : \r\n                  systemMetrics.memory.usage < performanceThresholds.memoryUsage.critical ? 'warning' : 'critical',\r\n      \r\n      errorRate: performanceMetrics.errorRate < performanceThresholds.errorRate.warning ? 'good' : \r\n                performanceMetrics.errorRate < performanceThresholds.errorRate.critical ? 'warning' : 'critical'\r\n    };\r\n    \r\n    const criticalAlerts = Object.values(alertStatus).filter(status => status === 'critical').length;\r\n    const warningAlerts = Object.values(alertStatus).filter(status => status === 'warning').length;\r\n    \r\n    console.log('✅ Performance thresholds and alerting validated:', {\r\n      criticalAlerts,\r\n      warningAlerts,\r\n      overallStatus: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'good',\r\n      alertDetails: alertStatus\r\n    });\r\n    \r\n    // Test 8: Metrics Aggregation and Reporting\r\n    console.log('\\n8. Testing Metrics Aggregation and Reporting...');\r\n    \r\n    const aggregatedMetrics = {\r\n      timeWindow: '1h',\r\n      summary: {\r\n        totalRequests: 4523,\r\n        successfulRequests: 4520,\r\n        failedRequests: 3,\r\n        avgResponseTime: 142,\r\n        p95ResponseTime: 285,\r\n        p99ResponseTime: 445,\r\n        uniqueUsers: 128,\r\n        peakConcurrency: 67\r\n      },\r\n      trends: {\r\n        responseTimeTrend: 'stable', // increasing, decreasing, stable\r\n        errorRateTrend: 'decreasing',\r\n        throughputTrend: 'increasing'\r\n      },\r\n      resourceUtilization: {\r\n        cpu: { avg: 18.5, peak: 34.2, trend: 'stable' },\r\n        memory: { avg: 312, peak: 456, trend: 'stable' },\r\n        network: { in: 2.3, out: 4.7, trend: 'increasing' }\r\n      }\r\n    };\r\n    \r\n    const aggregationValid = aggregatedMetrics.summary.totalRequests === \r\n                            (aggregatedMetrics.summary.successfulRequests + aggregatedMetrics.summary.failedRequests) &&\r\n                            aggregatedMetrics.summary.avgResponseTime > 0;\r\n    \r\n    console.log('✅ Metrics aggregation and reporting validated:', {\r\n      aggregationValid,\r\n      timeWindow: aggregatedMetrics.timeWindow,\r\n      totalRequests: aggregatedMetrics.summary.totalRequests,\r\n      successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n      avgResponseTime: `${aggregatedMetrics.summary.avgResponseTime}ms`,\r\n      p95ResponseTime: `${aggregatedMetrics.summary.p95ResponseTime}ms`\r\n    });\r\n    \r\n    // Test 9: Dashboard Data Structure\r\n    console.log('\\n9. Testing Dashboard Data Structure...');\r\n    \r\n    const dashboardData = {\r\n      realTime: {\r\n        status: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'healthy',\r\n        activeUsers: 42,\r\n        requestsPerSecond: performanceMetrics.requestsPerSecond,\r\n        errorRate: performanceMetrics.errorRate,\r\n        systemLoad: systemMetrics.cpu.usage,\r\n        uptime: systemMetrics.cpu.loadAverage[0]\r\n      },\r\n      timeSeries: {\r\n        labels: ['00:00', '00:15', '00:30', '00:45', '01:00'],\r\n        datasets: {\r\n          responseTime: [120, 135, 142, 138, 125],\r\n          throughput: [10.2, 11.8, 12.3, 11.9, 10.7],\r\n          errors: [0, 1, 0, 2, 0],\r\n          cpuUsage: [15.2, 16.8, 18.5, 17.3, 15.9],\r\n          memoryUsage: [35.4, 36.2, 38.1, 37.8, 36.9]\r\n        }\r\n      },\r\n      summary: {\r\n        uptime: '99.97%',\r\n        totalTrades: strategyMetrics.totalTrades,\r\n        successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n        avgProfit: '+2.34%'\r\n      }\r\n    };\r\n    \r\n    const dashboardValid = dashboardData.timeSeries.labels.length === \r\n                          dashboardData.timeSeries.datasets.responseTime.length &&\r\n                          dashboardData.realTime.status in ['healthy', 'warning', 'critical'];\r\n    \r\n    console.log('✅ Dashboard data structure validated:', {\r\n      dashboardValid,\r\n      realTimeStatus: dashboardData.realTime.status,\r\n      activeUsers: dashboardData.realTime.activeUsers,\r\n      dataPoints: dashboardData.timeSeries.labels.length,\r\n      uptime: dashboardData.summary.uptime\r\n    });\r\n    \r\n    console.log('\\n🎉 All Performance Monitoring and Metrics Validation Tests Passed!');\r\n    console.log('\\n📊 Validation Summary:');\r\n    console.log('   ✅ Monitoring Service Infrastructure');\r\n    console.log('   ✅ Performance Metrics Collection');\r\n    console.log('   ✅ Strategy Performance Tracking');\r\n    console.log('   ✅ Database Health Monitoring');\r\n    console.log('   ✅ Exchange Connection Monitoring');\r\n    console.log('   ✅ System Resource Monitoring');\r\n    console.log('   ✅ Performance Thresholds & Alerting');\r\n    console.log('   ✅ Metrics Aggregation & Reporting');\r\n    console.log('   ✅ Dashboard Data Preparation');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Performance Monitoring Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "cadd453a97bf48586c046b2ce64e191f"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 348
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "main",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\production-readiness-validation.ts",
          "startLine": 499,
          "endLine": 505,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  const validator = new ProductionReadinessValidator();\r\n  const report = await validator.runFullValidation();\r\n  \r\n  // Exit with appropriate code\r\n  process.exit(report.overall === 'not-ready' ? 1 : 0);\r\n}",
          "hash": "1cf97ef4246c71d942a9297907426311"
        },
        {
          "type": "function",
          "name": "main",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\production-readiness-validation.ts",
          "startLine": 492,
          "endLine": 498,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  const validator = new ProductionReadinessValidator();\r\n  const report = await validator.runFullValidation();\r\n  \r\n  // Exit with appropriate code\r\n  process.exit(report.overall === 'not-ready' ? 1 : 0);\r\n}",
          "hash": "1cf97ef4246c71d942a9297907426311"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 7
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "validateSignalProcessing",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\signal-processing-validation.ts",
          "startLine": 17,
          "endLine": 167,
          "complexity": 13,
          "dependencies": [],
          "usageCount": 0,
          "size": 151,
          "content": "{\r\n  console.log('🔍 Starting JabbrLabs Signal Processing Validation...');\r\n  \r\n  try {\r\n    // Test 1: Aether Signal Generator\r\n    console.log('\\n1. Testing Aether Signal Generator...');\r\n    const aetherGenerator = new AetherSignalGenerator(DEFAULT_AETHER_PARAMETERS);\r\n    \r\n    // Sample market data (ensure sufficient data for MACD calculation)\r\n    const orderBookImbalance = 0.15;\r\n    const volatility = 0.025;\r\n    const crowdingScore = -0.3;\r\n    const priceHistory = [\r\n      100, 101, 102, 103, 102, 101, 102, 103, 104, 105,\r\n      106, 105, 104, 103, 104, 105, 106, 107, 108, 107,\r\n      106, 107, 108, 109, 110, 111, 110, 109, 108, 109,\r\n      110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\r\n      120, 119, 118, 117, 118, 119, 120, 121, 122, 123,\r\n      124, 123, 122, 121, 122, 123, 124, 125, 126, 127\r\n    ];\r\n    \r\n    const aetherSignal = aetherGenerator.calculateSignal(\r\n      orderBookImbalance,\r\n      volatility, \r\n      crowdingScore,\r\n      priceHistory\r\n    );\r\n    \r\n    console.log('✅ Aether Signal Generated:', {\r\n      value: aetherSignal.value.toFixed(4),\r\n      confidence: aetherSignal.confidence.toFixed(4),\r\n      regime: aetherSignal.regime,\r\n      timestamp: aetherSignal.timestamp\r\n    });\r\n    \r\n    // Validate signal constraints\r\n    if (!Number.isFinite(aetherSignal.value) || aetherSignal.value < -1 || aetherSignal.value > 1) {\r\n      throw new Error(`Aether signal value out of range or invalid: ${aetherSignal.value}`);\r\n    }\r\n    if (!Number.isFinite(aetherSignal.confidence) || aetherSignal.confidence < 0 || aetherSignal.confidence > 1) {\r\n      throw new Error(`Aether confidence out of range or invalid: ${aetherSignal.confidence}`);\r\n    }\r\n    \r\n    // Test 2: Technical Indicators\r\n    console.log('\\n2. Testing Technical Indicators...');\r\n    \r\n    const sma20 = calculateSMA(priceHistory, 20);\r\n    const ema20 = calculateEMA(priceHistory, 20);\r\n    // TODO: Fix MACD calculation - temporarily skipped\r\n    // const macd = calculateMACD(priceHistory);\r\n    const rsi14 = calculateRSI(priceHistory, 14);\r\n    \r\n    console.log('✅ Technical Indicators:', {\r\n      sma20Length: sma20.length,\r\n      ema20Length: ema20.length,\r\n      // macdLength: macd.macd.length,\r\n      rsi14Length: rsi14.length\r\n    });\r\n    \r\n    // Validate indicator outputs\r\n    if (sma20.length === 0 || ema20.length === 0) {\r\n      throw new Error('Moving averages not calculated');\r\n    }\r\n    // if (macd.macd.length === 0 || macd.signal.length === 0) {\r\n    //   throw new Error('MACD not calculated');\r\n    // }\r\n    if (rsi14.length === 0) {\r\n      throw new Error('RSI not calculated');\r\n    }\r\n    \r\n    // Test 3: Signal Generation\r\n    console.log('\\n3. Testing Signal Generation...');\r\n    \r\n    const maSignals = getMASignals(ema20, sma20);\r\n    // TODO: Fix MACD signals when MACD is working\r\n    // const macdSignals = getMACDSignals(macd);\r\n    const rsiSignals = getRSISignals(rsi14);\r\n    \r\n    console.log('✅ Signals Generated:', {\r\n      maSignalsLength: maSignals.length,\r\n      // macdSignalsLength: macdSignals.length,\r\n      rsiSignalsLength: rsiSignals.length\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const testSignal = {\r\n      id: 'test-signal-001',\r\n      type: 'aether',\r\n      symbol: 'BTC/USDT',\r\n      action: 'buy' as const,\r\n      confidence: aetherSignal.confidence,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 100000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-001', testSignal);\r\n    \r\n    console.log('✅ Signal Execution Result:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Data Input Validation\r\n    console.log('\\n5. Testing Data Input Validation...');\r\n    \r\n    // Test with invalid inputs\r\n    try {\r\n      aetherGenerator.calculateSignal(NaN, 0.025, 0.3, priceHistory);\r\n      throw new Error('Should have failed with NaN input');\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes('Should have failed')) {\r\n        throw error;\r\n      }\r\n      console.log('✅ Input validation working - NaN rejected');\r\n    }\r\n    \r\n    try {\r\n      calculateSMA([], 20);\r\n      console.log('✅ Empty array handling working');\r\n    } catch (error) {\r\n      console.log('✅ Empty array validation working');\r\n    }\r\n    \r\n    // Test 6: Parameter Updates\r\n    console.log('\\n6. Testing Parameter Management...');\r\n    \r\n    const originalParams = aetherGenerator.getParameters();\r\n    aetherGenerator.updateParameters({ hurstExponent: 0.8 });\r\n    const updatedParams = aetherGenerator.getParameters();\r\n    \r\n    if (updatedParams.hurstExponent !== 0.8) {\r\n      throw new Error('Parameter update failed');\r\n    }\r\n    \r\n    console.log('✅ Parameter management working');\r\n    \r\n    // Reset for consistency\r\n    aetherGenerator.updateParameters(originalParams);\r\n    \r\n    console.log('\\n🎉 All Signal Processing Validation Tests Passed!');\r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Signal Processing Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "073cf636ca04495d3baf9d6864759624"
        },
        {
          "type": "function",
          "name": "validateSignalProcessing",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\signal-processing-validation.ts",
          "startLine": 17,
          "endLine": 167,
          "complexity": 13,
          "dependencies": [],
          "usageCount": 0,
          "size": 151,
          "content": "{\r\n  console.log('🔍 Starting JabbrLabs Signal Processing Validation...');\r\n  \r\n  try {\r\n    // Test 1: Aether Signal Generator\r\n    console.log('\\n1. Testing Aether Signal Generator...');\r\n    const aetherGenerator = new AetherSignalGenerator(DEFAULT_AETHER_PARAMETERS);\r\n    \r\n    // Sample market data (ensure sufficient data for MACD calculation)\r\n    const orderBookImbalance = 0.15;\r\n    const volatility = 0.025;\r\n    const crowdingScore = -0.3;\r\n    const priceHistory = [\r\n      100, 101, 102, 103, 102, 101, 102, 103, 104, 105,\r\n      106, 105, 104, 103, 104, 105, 106, 107, 108, 107,\r\n      106, 107, 108, 109, 110, 111, 110, 109, 108, 109,\r\n      110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\r\n      120, 119, 118, 117, 118, 119, 120, 121, 122, 123,\r\n      124, 123, 122, 121, 122, 123, 124, 125, 126, 127\r\n    ];\r\n    \r\n    const aetherSignal = aetherGenerator.calculateSignal(\r\n      orderBookImbalance,\r\n      volatility, \r\n      crowdingScore,\r\n      priceHistory\r\n    );\r\n    \r\n    console.log('✅ Aether Signal Generated:', {\r\n      value: aetherSignal.value.toFixed(4),\r\n      confidence: aetherSignal.confidence.toFixed(4),\r\n      regime: aetherSignal.regime,\r\n      timestamp: aetherSignal.timestamp\r\n    });\r\n    \r\n    // Validate signal constraints\r\n    if (!Number.isFinite(aetherSignal.value) || aetherSignal.value < -1 || aetherSignal.value > 1) {\r\n      throw new Error(`Aether signal value out of range or invalid: ${aetherSignal.value}`);\r\n    }\r\n    if (!Number.isFinite(aetherSignal.confidence) || aetherSignal.confidence < 0 || aetherSignal.confidence > 1) {\r\n      throw new Error(`Aether confidence out of range or invalid: ${aetherSignal.confidence}`);\r\n    }\r\n    \r\n    // Test 2: Technical Indicators\r\n    console.log('\\n2. Testing Technical Indicators...');\r\n    \r\n    const sma20 = calculateSMA(priceHistory, 20);\r\n    const ema20 = calculateEMA(priceHistory, 20);\r\n    // TODO: Fix MACD calculation - temporarily skipped\r\n    // const macd = calculateMACD(priceHistory);\r\n    const rsi14 = calculateRSI(priceHistory, 14);\r\n    \r\n    console.log('✅ Technical Indicators:', {\r\n      sma20Length: sma20.length,\r\n      ema20Length: ema20.length,\r\n      // macdLength: macd.macd.length,\r\n      rsi14Length: rsi14.length\r\n    });\r\n    \r\n    // Validate indicator outputs\r\n    if (sma20.length === 0 || ema20.length === 0) {\r\n      throw new Error('Moving averages not calculated');\r\n    }\r\n    // if (macd.macd.length === 0 || macd.signal.length === 0) {\r\n    //   throw new Error('MACD not calculated');\r\n    // }\r\n    if (rsi14.length === 0) {\r\n      throw new Error('RSI not calculated');\r\n    }\r\n    \r\n    // Test 3: Signal Generation\r\n    console.log('\\n3. Testing Signal Generation...');\r\n    \r\n    const maSignals = getMASignals(ema20, sma20);\r\n    // TODO: Fix MACD signals when MACD is working\r\n    // const macdSignals = getMACDSignals(macd);\r\n    const rsiSignals = getRSISignals(rsi14);\r\n    \r\n    console.log('✅ Signals Generated:', {\r\n      maSignalsLength: maSignals.length,\r\n      // macdSignalsLength: macdSignals.length,\r\n      rsiSignalsLength: rsiSignals.length\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const testSignal = {\r\n      id: 'test-signal-001',\r\n      type: 'aether',\r\n      symbol: 'BTC/USDT',\r\n      action: 'buy' as const,\r\n      confidence: aetherSignal.confidence,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 100000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-001', testSignal);\r\n    \r\n    console.log('✅ Signal Execution Result:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Data Input Validation\r\n    console.log('\\n5. Testing Data Input Validation...');\r\n    \r\n    // Test with invalid inputs\r\n    try {\r\n      aetherGenerator.calculateSignal(NaN, 0.025, 0.3, priceHistory);\r\n      throw new Error('Should have failed with NaN input');\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes('Should have failed')) {\r\n        throw error;\r\n      }\r\n      console.log('✅ Input validation working - NaN rejected');\r\n    }\r\n    \r\n    try {\r\n      calculateSMA([], 20);\r\n      console.log('✅ Empty array handling working');\r\n    } catch (error) {\r\n      console.log('✅ Empty array validation working');\r\n    }\r\n    \r\n    // Test 6: Parameter Updates\r\n    console.log('\\n6. Testing Parameter Management...');\r\n    \r\n    const originalParams = aetherGenerator.getParameters();\r\n    aetherGenerator.updateParameters({ hurstExponent: 0.8 });\r\n    const updatedParams = aetherGenerator.getParameters();\r\n    \r\n    if (updatedParams.hurstExponent !== 0.8) {\r\n      throw new Error('Parameter update failed');\r\n    }\r\n    \r\n    console.log('✅ Parameter management working');\r\n    \r\n    // Reset for consistency\r\n    aetherGenerator.updateParameters(originalParams);\r\n    \r\n    console.log('\\n🎉 All Signal Processing Validation Tests Passed!');\r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Signal Processing Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "073cf636ca04495d3baf9d6864759624"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 151
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testDatabaseConnection",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts",
          "startLine": 32,
          "endLine": 100,
          "complexity": 10,
          "dependencies": [],
          "usageCount": 0,
          "size": 69,
          "content": "{\r\n  const result: DatabaseTestResult = {\r\n    connectionStatus: 'failed',\r\n    queryStatus: 'failed', \r\n    migrationStatus: 'failed',\r\n    details: {}\r\n  };\r\n\r\n  try {\r\n    logger.info('🔌 Testing database connection...');\r\n    \r\n    const startTime = Date.now();\r\n    \r\n    // Test basic connection\r\n    const testQuery = 'SELECT version() as server_version, current_timestamp as current_time';\r\n    const queryResult = await dbInstance.query<{server_version: string; current_time: string}>(testQuery);\r\n    \r\n    const connectionTime = Date.now() - startTime;\r\n    result.connectionStatus = 'success';\r\n    result.details.connectionTime = connectionTime;\r\n    \r\n    if (queryResult && queryResult.length > 0 && queryResult[0]) {\r\n      result.queryStatus = 'success';\r\n      result.details.serverVersion = queryResult[0].server_version;\r\n      logger.info(`✅ Database connection successful (${connectionTime}ms)`);\r\n      logger.info(`📊 Server version: ${queryResult[0].server_version}`);\r\n    }\r\n\r\n    // Test connection pool status\r\n    try {\r\n      const poolQuery = 'SELECT count(*) as active_connections FROM pg_stat_activity WHERE state = \\'active\\'';\r\n      const poolResult = await dbInstance.query<{active_connections: string}>(poolQuery);\r\n      \r\n      if (poolResult && poolResult.length > 0 && poolResult[0]) {\r\n        result.details.activeConnections = parseInt(poolResult[0].active_connections);\r\n        logger.info(`🔗 Active connections: ${result.details.activeConnections}`);\r\n      }\r\n    } catch (poolError) {\r\n      logger.warn('⚠️  Could not retrieve connection pool status:', poolError);\r\n    }\r\n\r\n    // Test migration status\r\n    try {\r\n      const migrationQuery = `\r\n        SELECT EXISTS (\r\n          SELECT FROM information_schema.tables \r\n          WHERE table_schema = 'public' \r\n          AND table_name = 'users'\r\n        ) as users_table_exists\r\n      `;\r\n      const migrationResult = await dbInstance.query<{users_table_exists: boolean}>(migrationQuery);\r\n      \r\n      if (migrationResult && migrationResult.length > 0 && migrationResult[0]) {\r\n        const tablesExist = migrationResult[0].users_table_exists;\r\n        result.migrationStatus = tablesExist ? 'success' : 'failed';\r\n        logger.info(`📋 Database migrations: ${tablesExist ? 'Applied' : 'Not Applied'}`);\r\n      }\r\n    } catch (migrationError) {\r\n      logger.warn('⚠️  Could not check migration status:', migrationError);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Database connection failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "1bb88a8484fec42d3efa6c902038863c"
        },
        {
          "type": "function",
          "name": "testDatabaseConnection",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts",
          "startLine": 32,
          "endLine": 100,
          "complexity": 10,
          "dependencies": [],
          "usageCount": 0,
          "size": 69,
          "content": "{\r\n  const result: DatabaseTestResult = {\r\n    connectionStatus: 'failed',\r\n    queryStatus: 'failed', \r\n    migrationStatus: 'failed',\r\n    details: {}\r\n  };\r\n\r\n  try {\r\n    logger.info('🔌 Testing database connection...');\r\n    \r\n    const startTime = Date.now();\r\n    \r\n    // Test basic connection\r\n    const testQuery = 'SELECT version() as server_version, current_timestamp as current_time';\r\n    const queryResult = await dbInstance.query<{server_version: string; current_time: string}>(testQuery);\r\n    \r\n    const connectionTime = Date.now() - startTime;\r\n    result.connectionStatus = 'success';\r\n    result.details.connectionTime = connectionTime;\r\n    \r\n    if (queryResult && queryResult.length > 0 && queryResult[0]) {\r\n      result.queryStatus = 'success';\r\n      result.details.serverVersion = queryResult[0].server_version;\r\n      logger.info(`✅ Database connection successful (${connectionTime}ms)`);\r\n      logger.info(`📊 Server version: ${queryResult[0].server_version}`);\r\n    }\r\n\r\n    // Test connection pool status\r\n    try {\r\n      const poolQuery = 'SELECT count(*) as active_connections FROM pg_stat_activity WHERE state = \\'active\\'';\r\n      const poolResult = await dbInstance.query<{active_connections: string}>(poolQuery);\r\n      \r\n      if (poolResult && poolResult.length > 0 && poolResult[0]) {\r\n        result.details.activeConnections = parseInt(poolResult[0].active_connections);\r\n        logger.info(`🔗 Active connections: ${result.details.activeConnections}`);\r\n      }\r\n    } catch (poolError) {\r\n      logger.warn('⚠️  Could not retrieve connection pool status:', poolError);\r\n    }\r\n\r\n    // Test migration status\r\n    try {\r\n      const migrationQuery = `\r\n        SELECT EXISTS (\r\n          SELECT FROM information_schema.tables \r\n          WHERE table_schema = 'public' \r\n          AND table_name = 'users'\r\n        ) as users_table_exists\r\n      `;\r\n      const migrationResult = await dbInstance.query<{users_table_exists: boolean}>(migrationQuery);\r\n      \r\n      if (migrationResult && migrationResult.length > 0 && migrationResult[0]) {\r\n        const tablesExist = migrationResult[0].users_table_exists;\r\n        result.migrationStatus = tablesExist ? 'success' : 'failed';\r\n        logger.info(`📋 Database migrations: ${tablesExist ? 'Applied' : 'Not Applied'}`);\r\n      }\r\n    } catch (migrationError) {\r\n      logger.warn('⚠️  Could not check migration status:', migrationError);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Database connection failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "1bb88a8484fec42d3efa6c902038863c"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 69
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "testMonitoringServices",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts",
          "startLine": 102,
          "endLine": 144,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n  const result: MonitoringTestResult = {\r\n    databaseMonitor: false,\r\n    metricsCollector: false,\r\n    healthCheck: false\r\n  };\r\n\r\n  try {\r\n    logger.info('📊 Testing monitoring services...');\r\n    \r\n    // Test if monitoring services can be imported\r\n    try {\r\n      const { DatabaseMonitorService } = await import('../services/database-monitor.service');\r\n      result.databaseMonitor = true;\r\n      logger.info('✅ Database monitor service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Database monitor service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { MetricsCollectorService } = await import('../services/metrics-collector.service');\r\n      result.metricsCollector = true;\r\n      logger.info('✅ Metrics collector service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Metrics collector service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { HealthCheckService } = await import('../services/health-check.service');\r\n      result.healthCheck = true;\r\n      logger.info('✅ Health check service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Health check service not available:', (error as Error).message);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Monitoring services test failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "eb0fcdc0b0cc125723cbb0f6e9a965fd"
        },
        {
          "type": "function",
          "name": "testMonitoringServices",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts",
          "startLine": 102,
          "endLine": 144,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n  const result: MonitoringTestResult = {\r\n    databaseMonitor: false,\r\n    metricsCollector: false,\r\n    healthCheck: false\r\n  };\r\n\r\n  try {\r\n    logger.info('📊 Testing monitoring services...');\r\n    \r\n    // Test if monitoring services can be imported\r\n    try {\r\n      const { DatabaseMonitorService } = await import('../services/database-monitor.service');\r\n      result.databaseMonitor = true;\r\n      logger.info('✅ Database monitor service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Database monitor service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { MetricsCollectorService } = await import('../services/metrics-collector.service');\r\n      result.metricsCollector = true;\r\n      logger.info('✅ Metrics collector service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Metrics collector service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { HealthCheckService } = await import('../services/health-check.service');\r\n      result.healthCheck = true;\r\n      logger.info('✅ Health check service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Health check service not available:', (error as Error).message);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Monitoring services test failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "eb0fcdc0b0cc125723cbb0f6e9a965fd"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 43
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "runTests",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts",
          "startLine": 146,
          "endLine": 195,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 50,
          "content": "{\r\n  logger.info('🚀 Starting Database & Monitoring Services Test...\\n');\r\n\r\n  const summary: TestSummary = {\r\n    database: await testDatabaseConnection(),\r\n    monitoring: await testMonitoringServices(),\r\n    overall: 'failed',\r\n    timestamp: new Date().toISOString()\r\n  };\r\n\r\n  // Determine overall status\r\n  const dbSuccess = summary.database.connectionStatus === 'success' && \r\n                   summary.database.queryStatus === 'success';\r\n  const monitoringSuccess = summary.monitoring.databaseMonitor || \r\n                           summary.monitoring.metricsCollector || \r\n                           summary.monitoring.healthCheck;\r\n\r\n  summary.overall = dbSuccess && monitoringSuccess ? 'success' : 'failed';\r\n\r\n  // Print summary\r\n  console.log('\\n📋 Test Summary:');\r\n  console.log('================');\r\n  console.log(`Database Connection: ${summary.database.connectionStatus}`);\r\n  console.log(`Database Queries: ${summary.database.queryStatus}`);\r\n  console.log(`Database Migrations: ${summary.database.migrationStatus}`);\r\n  console.log(`Monitoring Services: ${monitoringSuccess ? 'Available' : 'Unavailable'}`);\r\n  console.log(`Overall Status: ${summary.overall}`);\r\n  \r\n  if (summary.database.details.connectionTime) {\r\n    console.log(`Connection Time: ${summary.database.details.connectionTime}ms`);\r\n  }\r\n  \r\n  if (summary.database.details.serverVersion) {\r\n    console.log(`Database Version: ${summary.database.details.serverVersion}`);\r\n  }\r\n\r\n  // Save results to file\r\n  const fs = await import('fs/promises');\r\n  const path = await import('path');\r\n  \r\n  const resultsDir = path.join(__dirname, '../../test-results');\r\n  await fs.mkdir(resultsDir, { recursive: true });\r\n  \r\n  const resultsFile = path.join(resultsDir, `db-monitoring-test-${Date.now()}.json`);\r\n  await fs.writeFile(resultsFile, JSON.stringify(summary, null, 2));\r\n  \r\n  logger.info(`📝 Test results saved to: ${resultsFile}`);\r\n\r\n  return summary;\r\n}",
          "hash": "46794edfc4b775dc3e6ba4e2940f113e"
        },
        {
          "type": "function",
          "name": "runTests",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts",
          "startLine": 146,
          "endLine": 195,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 50,
          "content": "{\r\n  logger.info('🚀 Starting Database & Monitoring Services Test...\\n');\r\n\r\n  const summary: TestSummary = {\r\n    database: await testDatabaseConnection(),\r\n    monitoring: await testMonitoringServices(),\r\n    overall: 'failed',\r\n    timestamp: new Date().toISOString()\r\n  };\r\n\r\n  // Determine overall status\r\n  const dbSuccess = summary.database.connectionStatus === 'success' && \r\n                   summary.database.queryStatus === 'success';\r\n  const monitoringSuccess = summary.monitoring.databaseMonitor || \r\n                           summary.monitoring.metricsCollector || \r\n                           summary.monitoring.healthCheck;\r\n\r\n  summary.overall = dbSuccess && monitoringSuccess ? 'success' : 'failed';\r\n\r\n  // Print summary\r\n  console.log('\\n📋 Test Summary:');\r\n  console.log('================');\r\n  console.log(`Database Connection: ${summary.database.connectionStatus}`);\r\n  console.log(`Database Queries: ${summary.database.queryStatus}`);\r\n  console.log(`Database Migrations: ${summary.database.migrationStatus}`);\r\n  console.log(`Monitoring Services: ${monitoringSuccess ? 'Available' : 'Unavailable'}`);\r\n  console.log(`Overall Status: ${summary.overall}`);\r\n  \r\n  if (summary.database.details.connectionTime) {\r\n    console.log(`Connection Time: ${summary.database.details.connectionTime}ms`);\r\n  }\r\n  \r\n  if (summary.database.details.serverVersion) {\r\n    console.log(`Database Version: ${summary.database.details.serverVersion}`);\r\n  }\r\n\r\n  // Save results to file\r\n  const fs = await import('fs/promises');\r\n  const path = await import('path');\r\n  \r\n  const resultsDir = path.join(__dirname, '../../test-results');\r\n  await fs.mkdir(resultsDir, { recursive: true });\r\n  \r\n  const resultsFile = path.join(resultsDir, `db-monitoring-test-${Date.now()}.json`);\r\n  await fs.writeFile(resultsFile, JSON.stringify(summary, null, 2));\r\n  \r\n  logger.info(`📝 Test results saved to: ${resultsFile}`);\r\n\r\n  return summary;\r\n}",
          "hash": "46794edfc4b775dc3e6ba4e2940f113e"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 50
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "volatility",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\data-service.ts",
          "startLine": 109,
          "endLine": 116,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: currentTime,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "13933002539672e77a9fd2de9a09815d"
        },
        {
          "type": "function",
          "name": "close",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\data-service.ts",
          "startLine": 117,
          "endLine": 124,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: currentTime,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "13933002539672e77a9fd2de9a09815d"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 8
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "cacheHitRatio",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\database-monitor.service.ts",
          "startLine": 517,
          "endLine": 522,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 6,
          "content": "{\r\n        transactionsPerSecond,\r\n        lockWaitTime: lockCount * 10, // Simplified estimate\r\n        cacheHitRatio,\r\n        indexEfficiency: cacheHitRatio // Simplified - would need more complex calculation\r\n      }",
          "hash": "58b0fdbd19d3d1f74d54e0ce41d426bf"
        },
        {
          "type": "function",
          "name": "uptime",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\database-monitor.service.ts",
          "startLine": 524,
          "endLine": 529,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 6,
          "content": "{\r\n        transactionsPerSecond,\r\n        lockWaitTime: lockCount * 10, // Simplified estimate\r\n        cacheHitRatio,\r\n        indexEfficiency: cacheHitRatio // Simplified - would need more complex calculation\r\n      }",
          "hash": "58b0fdbd19d3d1f74d54e0ce41d426bf"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 6
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "noise",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 31,
          "endLine": 38,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "2567bc98f2c9e7162da67f601c80d1ad"
        },
        {
          "type": "function",
          "name": "noise",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-signals.ts",
          "startLine": 19,
          "endLine": 26,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "2567bc98f2c9e7162da67f601c80d1ad"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 8
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "getCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 93,
          "endLine": 100,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n        symbol: 'BTC/USDT',\r\n        last: candles[candles.length - 1]?.close || 0,\r\n        bid: 0,\r\n        ask: 0,\r\n        volume: 0,\r\n        timestamp: Date.now()\r\n      }",
          "hash": "933f3fab0167097e4f6f0898fb2a2eb8"
        },
        {
          "type": "function",
          "name": "getTicker",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 94,
          "endLine": 101,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n        symbol: 'BTC/USDT',\r\n        last: candles[candles.length - 1]?.close || 0,\r\n        bid: 0,\r\n        ask: 0,\r\n        volume: 0,\r\n        timestamp: Date.now()\r\n      }",
          "hash": "933f3fab0167097e4f6f0898fb2a2eb8"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 8
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "getPosition",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 122,
          "endLine": 124,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n        console.log(`[${new Date().toISOString()}] CLOSE position`);\r\n      }",
          "hash": "9b2b12f940dfb368b7749a7c22dd8f44"
        },
        {
          "type": "function",
          "name": "closePosition",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 123,
          "endLine": 125,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n        console.log(`[${new Date().toISOString()}] CLOSE position`);\r\n      }",
          "hash": "9b2b12f940dfb368b7749a7c22dd8f44"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 3
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "getUniqueStrategies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\page.tsx",
          "startLine": 231,
          "endLine": 241,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-100 p-8\">\r\n        <div className=\"max-w-6xl mx-auto\">\r\n          <div className=\"flex items-center justify-center h-64\">\r\n            <div className=\"text-lg text-gray-600\">Loading bots...</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }",
          "hash": "ed491ad84225f8ee469443e0a0ca3c8e"
        },
        {
          "type": "function",
          "name": "getUniqueExchanges",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\page.tsx",
          "startLine": 232,
          "endLine": 242,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-100 p-8\">\r\n        <div className=\"max-w-6xl mx-auto\">\r\n          <div className=\"flex items-center justify-center h-64\">\r\n            <div className=\"text-lg text-gray-600\">Loading bots...</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }",
          "hash": "ed491ad84225f8ee469443e0a0ca3c8e"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 11
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "getStatusColor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx",
          "startLine": 179,
          "endLine": 181,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n    return isRunning ? 'text-green-600 bg-green-100' : 'text-gray-600 bg-gray-100';\r\n  }",
          "hash": "a894955437926fd19f40c1fd09654779"
        },
        {
          "type": "function",
          "name": "getRunningStatusColor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 107,
          "endLine": 109,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return isRunning ? 'text-green-600 bg-green-100' : 'text-gray-600 bg-gray-100';\r\n}",
          "hash": "a894955437926fd19f40c1fd09654779"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 3
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "subscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 51,
          "endLine": 63,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "unsubscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 52,
          "endLine": 64,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "reconnect",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 53,
          "endLine": 65,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "startBot",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 56,
          "endLine": 68,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "stopBot",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 57,
          "endLine": 69,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "pauseBot",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 58,
          "endLine": 70,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        }
      ],
      "description": "Found 6 duplicate functions with identical logic",
      "severity": "high",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 65
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "sendMessage",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 22,
          "endLine": 33,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        },
        {
          "type": "function",
          "name": "subscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 23,
          "endLine": 34,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        },
        {
          "type": "function",
          "name": "unsubscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 24,
          "endLine": 35,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        },
        {
          "type": "function",
          "name": "reconnect",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 25,
          "endLine": 36,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        }
      ],
      "description": "Found 4 duplicate functions with identical logic",
      "severity": "high",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 36
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "getConnectionStatusColor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 59,
          "endLine": 63,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 5,
          "content": "{ \r\n  isConnected, \r\n  isConnecting, \r\n  connectionError \r\n}",
          "hash": "97eab06b9194f946b603d08631602afd"
        },
        {
          "type": "function",
          "name": "getConnectionStatusText",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 73,
          "endLine": 77,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 5,
          "content": "{ \r\n  isConnected, \r\n  isConnecting, \r\n  connectionError \r\n}",
          "hash": "97eab06b9194f946b603d08631602afd"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 5
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "openBrackets",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 397,
          "endLine": 406,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unmatched square brackets in line',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Check for missing opening or closing brackets'\r\n            });\r\n          }",
          "hash": "661ca5cd08569869ea3b1caa70db1217"
        },
        {
          "type": "function",
          "name": "closeBrackets",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 398,
          "endLine": 407,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unmatched square brackets in line',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Check for missing opening or closing brackets'\r\n            });\r\n          }",
          "hash": "661ca5cd08569869ea3b1caa70db1217"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 10
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "warningCount",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 230,
          "endLine": 238,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 9,
          "content": "{\r\n        passed: errorCount === 0,\r\n        message: `Linting found ${errorCount} errors and ${warningCount} warnings`,\r\n        details: [errorOutput],\r\n        suggestions: [\r\n          'Run npm run lint:fix to automatically fix some issues',\r\n          'Review and fix remaining linting errors manually'\r\n        ]\r\n      }",
          "hash": "e9053fe195c0256a8bc6f90750ea5fdf"
        },
        {
          "type": "function",
          "name": "errorCount",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 231,
          "endLine": 239,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 9,
          "content": "{\r\n        passed: errorCount === 0,\r\n        message: `Linting found ${errorCount} errors and ${warningCount} warnings`,\r\n        details: [errorOutput],\r\n        suggestions: [\r\n          'Run npm run lint:fix to automatically fix some issues',\r\n          'Review and fix remaining linting errors manually'\r\n        ]\r\n      }",
          "hash": "e9053fe195c0256a8bc6f90750ea5fdf"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 9
      },
      "implementationEffort": "medium"
    },
    {
      "type": "duplicate",
      "elements": [
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 379,
          "endLine": 400,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (!fs.existsSync(currentDir)) return;\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    }",
          "hash": "32e17252f345a668d67b1cdf9368b04e"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 301,
          "endLine": 322,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (!fs.existsSync(currentDir)) return;\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    }",
          "hash": "32e17252f345a668d67b1cdf9368b04e"
        }
      ],
      "description": "Found 2 duplicate functions with identical logic",
      "severity": "medium",
      "recommendedAction": "Extract common function to utility module and replace duplicates",
      "estimatedImpact": {
        "performance": 2,
        "maintainability": 8,
        "codeReduction": 22
      },
      "implementationEffort": "medium"
    },
    {
      "type": "complex",
      "elements": [
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 551,
          "endLine": 1153,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 552,
          "endLine": 1154,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 551,
          "endLine": 1153,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 552,
          "endLine": 1154,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "testStandaloneEngine",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-engine-standalone.ts",
          "startLine": 9,
          "endLine": 161,
          "complexity": 34,
          "dependencies": [],
          "usageCount": 0,
          "size": 153,
          "content": "{\r\n  console.log('🚀 STANDALONE TRADING ENGINE TEST');\r\n  console.log('=================================');\r\n  console.log('✨ NO DATABASE - PURE TRADING ENGINE POWER!');\r\n\r\n  // Real testnet credentials\r\n  const apiKey = {\r\n    id: 'test-key-1',\r\n    userId: 'test-user',\r\n    exchange: 'bybit' as const,\r\n    keyName: 'Test Key',\r\n    apiKey: 'DsBkIFhCCmPmfz8THD',\r\n    apiSecret: 'swDPO6E2JVswGfVOQ1oyjcj5L8rWNJdO5EL9',\r\n    sandbox: true,\r\n    permissions: ['trade', 'read'],\r\n    isActive: true,\r\n    createdAt: new Date(),\r\n    updatedAt: new Date()\r\n  };\r\n\r\n  const exchange = new BybitExchange(apiKey, true); // testnet = true\r\n\r\n  try {\r\n    // 1. Connect and test basic functionality\r\n    console.log('\\n🔌 Connecting to Bybit testnet...');\r\n    await exchange.connect();\r\n    console.log('✅ Connected successfully!');\r\n\r\n    // 2. Test market data with multiple symbols\r\n    console.log('\\n📊 Testing Market Data Across Multiple Symbols...');\r\n    \r\n    const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];\r\n    for (const symbol of symbols) {\r\n      try {\r\n        const futuresData = await exchange.getMarketData(symbol, MarketType.FUTURES);\r\n        console.log(`   ${symbol} Futures: $${futuresData.price.toFixed(2)} (24h: ${futuresData.change24h.toFixed(2)}%)`);\r\n        \r\n        // Add small delay to respect rate limits\r\n        await new Promise(resolve => setTimeout(resolve, 200));\r\n      } catch (error) {\r\n        console.log(`   ⚠️ ${symbol} failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n      }\r\n    }\r\n\r\n    // 3. Test order book depth\r\n    console.log('\\n📈 Testing Order Book Depth...');\r\n    try {\r\n      const orderBook = await exchange.getOrderBook('BTCUSDT', MarketType.FUTURES, 10);\r\n      console.log(`   Order Book Depth: ${orderBook.bids.length} bids, ${orderBook.asks.length} asks`);\r\n      console.log(`   Best Bid: $${orderBook.bids[0]?.[0].toFixed(2)} - ${orderBook.bids[0]?.[1].toFixed(4)} BTC`);\r\n      console.log(`   Best Ask: $${orderBook.asks[0]?.[0].toFixed(2)} - ${orderBook.asks[0]?.[1].toFixed(4)} BTC`);\r\n      console.log(`   Spread: $${((orderBook.asks[0]?.[0] || 0) - (orderBook.bids[0]?.[0] || 0)).toFixed(2)}`);\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Order book test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    // 4. Test trading fees for multiple symbols\r\n    console.log('\\n💰 Testing Trading Fees...');\r\n    for (const symbol of symbols.slice(0, 2)) { // Test first 2 symbols\r\n      try {\r\n        const fees = await exchange.getTradingFees(symbol, MarketType.FUTURES);\r\n        console.log(`   ${symbol} - Maker: ${(fees.maker * 100).toFixed(4)}%, Taker: ${(fees.taker * 100).toFixed(4)}%`);\r\n        await new Promise(resolve => setTimeout(resolve, 200));\r\n      } catch (error) {\r\n        console.log(`   ⚠️ ${symbol} fees failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n      }\r\n    }\r\n\r\n    // 5. Test account balance (should show 0 for testnet)\r\n    console.log('\\n💳 Testing Account Balance...');\r\n    try {\r\n      const futuresBalance = await exchange.getBalance(MarketType.FUTURES);\r\n      console.log(`   Futures Balance: ${futuresBalance.length} currencies`);\r\n      futuresBalance.forEach(balance => {\r\n        if (balance.total > 0) {\r\n          console.log(`     ${balance.currency}: ${balance.total} (Available: ${balance.available})`);\r\n        }\r\n      });\r\n      \r\n      if (futuresBalance.length === 0) {\r\n        console.log('   ⚠️ No funds in testnet account (expected for new testnet accounts)');\r\n      }\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Balance test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    // 6. Test position management (safe operations)\r\n    console.log('\\n⚡ Testing Position Management...');\r\n    try {\r\n      const positions = await exchange.getPositions();\r\n      console.log(`   Current Positions: ${positions.length}`);\r\n      \r\n      if (positions.length > 0) {\r\n        positions.forEach(pos => {\r\n          console.log(`     ${pos.symbol}: ${pos.side} ${pos.size} @ $${pos.entryPrice} (${pos.leverage}x)`);\r\n          console.log(`       PnL: ${pos.unrealizedPnl} (Mark: $${pos.markPrice})`);\r\n        });\r\n      } else {\r\n        console.log('   ✅ No open positions (clean account)');\r\n      }\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Position test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    // 7. Test recent trades data\r\n    console.log('\\n📊 Testing Recent Trades...');\r\n    try {\r\n      const trades = await exchange.getRecentTrades('BTCUSDT', MarketType.FUTURES, 5);\r\n      console.log(`   Recent Trades: ${trades.length} trades retrieved`);\r\n      trades.slice(0, 3).forEach((trade, index) => {\r\n        console.log(`     ${index + 1}. ${trade.side} ${trade.amount.toFixed(4)} @ $${trade.price.toFixed(2)}`);\r\n      });\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Recent trades test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    // 8. Test candlestick data\r\n    console.log('\\n📈 Testing Candlestick Data...');\r\n    try {\r\n      const klines = await exchange.getKlines('BTCUSDT', '1h', MarketType.FUTURES, undefined, undefined, 5);\r\n      console.log(`   Candlestick Data: ${klines.length} candles retrieved`);\r\n      const latest = klines[klines.length - 1];\r\n      if (latest) {\r\n        console.log(`   Latest Candle: O:${latest.open.toFixed(2)} H:${latest.high.toFixed(2)} L:${latest.low.toFixed(2)} C:${latest.close.toFixed(2)}`);\r\n        console.log(`   Volume: ${latest.volume.toFixed(4)} BTC`);\r\n      }\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Candlestick test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    // 9. Test exchange capabilities\r\n    console.log('\\n🏆 Exchange Capabilities Summary:');\r\n    const capabilities = exchange.getCapabilities();\r\n    console.log(`   ✅ Spot Trading: ${capabilities.spot ? 'Supported' : 'Not Supported'} (Max: ${capabilities.maxLeverage.spot}x)`);\r\n    console.log(`   ✅ Futures Trading: ${capabilities.futures ? 'Supported' : 'Not Supported'} (Max: ${capabilities.maxLeverage.futures}x)`);\r\n    console.log(`   ✅ Options Trading: ${capabilities.options ? 'Supported' : 'Not Supported'}`);\r\n    console.log(`   ✅ Margin Trading: ${capabilities.margin ? 'Supported' : 'Not Supported'}`);\r\n    console.log(`   ✅ Rate Limit: ${capabilities.rateLimits.requests} requests per ${capabilities.rateLimits.window/1000}s`);\r\n    console.log(`   ✅ Order Types: ${capabilities.supportedOrderTypes.join(', ')}`);\r\n    console.log(`   ✅ Timeframes: ${capabilities.supportedTimeframes.length} supported`);\r\n\r\n    console.log('\\n🎉 STANDALONE ENGINE TEST COMPLETED!');\r\n    console.log('💪 Your trading engine is FULLY OPERATIONAL without any dependencies!');\r\n    console.log('🚀 Ready for integration with bots, strategies, and real trading!');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Standalone test failed:', error);\r\n  } finally {\r\n    // Disconnect\r\n    await exchange.disconnect();\r\n    console.log('\\n🔌 Disconnected from exchange');\r\n  }\r\n}",
          "hash": "0db9cebbcdb6802a285b619207cefaf7"
        },
        {
          "type": "function",
          "name": "findAndFixIssues",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-processor.ts",
          "startLine": 14,
          "endLine": 205,
          "complexity": 31,
          "dependencies": [],
          "usageCount": 0,
          "size": 192,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR ISSUE FINDER -----');\r\n  \r\n  // Create test data with predictable pattern\r\n  const candles: Candle[] = [];\r\n  \r\n  // Start with a flat pattern\r\n  for (let i = 0; i < 20; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 102,\r\n      low: 98,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Add a clear uptrend - this should cause a bullish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 20) * 3600000,\r\n      open: 100 + i * 2,\r\n      high: 102 + i * 2,\r\n      low: 98 + i * 2,\r\n      close: 100 + i * 2.5,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Add a clear downtrend - this should cause a bearish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 125 - i * 2,\r\n      high: 127 - i * 2,\r\n      low: 123 - i * 2,\r\n      close: 125 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${candles.length} test candles with clear trend patterns`);\r\n  \r\n  // Configuration with very low thresholds to ensure we get signals\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.01, // Almost no threshold\r\n    minChangePercent: 0.01 // Almost no minimum change\r\n  };\r\n  \r\n  // Manually check when crossovers should happen\r\n  console.log('\\nAnalyzing data for expected crossover points:');\r\n  \r\n  for (let i = 20; i < candles.length; i++) {\r\n    // Calculate SMA values ourselves\r\n    const prices = candles.slice(0, i + 1).map(c => c.close);\r\n    const fastMA = calculateSMA(prices, config.fastPeriod);\r\n    const slowMA = calculateSMA(prices, config.slowPeriod);\r\n    \r\n    if (fastMA.length < 2 || slowMA.length < 2) {continue;}\r\n    \r\n    // Get current and previous values\r\n    const currFast = fastMA[fastMA.length - 1]; \r\n    const prevFast = fastMA[fastMA.length - 2];\r\n    const currSlow = slowMA[slowMA.length - 1];\r\n    const prevSlow = slowMA[slowMA.length - 2];\r\n    \r\n    // Check for crossovers manually\r\n    if (currFast && prevFast && currSlow && prevSlow) {\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log(`Candle ${i}: BULLISH CROSSOVER DETECTED - Should generate BUY signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log(`Candle ${i}: BEARISH CROSSOVER DETECTED - Should generate SELL signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Now test using the SMA processor\r\n  console.log('\\nTesting SMA processor with the same data:');\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Create a log of raw data for analysis\r\n  const logData: {\r\n    configuration: typeof config;\r\n    candleData: Array<{\r\n      index: number;\r\n      price: number;\r\n      fastMA: number;\r\n      slowMA: number;\r\n      difference: number;\r\n    }>;\r\n    signals: Array<{\r\n      index: number;\r\n      type: string;\r\n      confidence: number;\r\n      reason: string;\r\n    }>;\r\n  } = {\r\n    configuration: config,\r\n    candleData: [],\r\n    signals: []\r\n  };\r\n  \r\n  // Process each window\r\n  for (let i = 15; i < candles.length; i++) {\r\n    const window = candles.slice(0, i + 1);\r\n    \r\n    try {\r\n      const result = processor.process(window);\r\n      \r\n      // Calculate MAs directly for reference\r\n      const prices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(prices, config.fastPeriod);\r\n      const slowMA = calculateSMA(prices, config.slowPeriod);\r\n      \r\n      const lastFastMA = fastMA.length > 0 ? fastMA[fastMA.length - 1] : null;\r\n      const lastSlowMA = slowMA.length > 0 ? slowMA[slowMA.length - 1] : null;\r\n      \r\n      console.log(`\\nCandle ${i}: Fast MA = ${lastFastMA?.toFixed(2) || 'N/A'}, Slow MA = ${lastSlowMA?.toFixed(2) || 'N/A'}`);\r\n      \r\n      // Save data for analysis\r\n      if (lastFastMA !== null && lastSlowMA !== null && window.length > 0) {\r\n        const lastCandle = window[window.length - 1];\r\n        if (lastCandle) {\r\n          logData.candleData.push({\r\n            index: i,\r\n            price: lastCandle.close,\r\n            fastMA: lastFastMA,\r\n            slowMA: lastSlowMA,\r\n            difference: lastFastMA - lastSlowMA\r\n          });\r\n        }\r\n      }\r\n      \r\n      if (result) {\r\n        const signalType = result.signal > 0 ? 'BUY' : result.signal < 0 ? 'SELL' : 'NONE';\r\n        console.log(`*** SIGNAL: ${signalType} - Confidence: ${result.confidence.toFixed(2)} ***`);\r\n        console.log(`Reason: ${result.reason}`);\r\n        \r\n        logData.signals.push({\r\n          index: i,\r\n          type: signalType,\r\n          confidence: result.confidence,\r\n          reason: result.reason\r\n        });\r\n      } else {\r\n        console.log('No signal generated');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error processing window at index ${i}:`, error);\r\n    }\r\n  }\r\n  \r\n  // Save data for analysis\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const filename = path.join(outputDir, 'sma-debug-analysis.json');\r\n    fs.writeFileSync(filename, JSON.stringify(logData, null, 2));\r\n    console.log(`\\nDetailed analysis data saved to ${filename}`);\r\n  } catch (error) {\r\n    console.error('Error saving analysis data:', error);\r\n  }\r\n  \r\n  // Check the SMASignalProcessor implementation for issues\r\n  console.log('\\nChecking SMASignalProcessor implementation:');\r\n  console.log('1. Configuration used:', config);\r\n  console.log('2. Signals generated:', logData.signals.length);\r\n  \r\n  if (logData.signals.length === 0) {\r\n    console.log('\\nPOTENTIAL ISSUES IDENTIFIED:');\r\n    console.log(`- Confidence threshold may be too high (current: ${  config.confidenceThreshold  })`);\r\n    console.log('- Signal generation logic may have bugs');\r\n    console.log('- Crossover detection might not be working as expected');\r\n    console.log('\\nRECOMMENDATIONS:');\r\n    console.log('- Review the generateSignal method in SMASignalProcessor');\r\n    console.log('- Ensure crossover detection is correctly implemented');\r\n    console.log('- Lower the confidence threshold or modify confidence calculation');\r\n  }\r\n}",
          "hash": "f0efd78eda81f5ae2400a7a300506675"
        },
        {
          "type": "function",
          "name": "findAndFixIssues",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-processor.ts",
          "startLine": 14,
          "endLine": 205,
          "complexity": 31,
          "dependencies": [],
          "usageCount": 0,
          "size": 192,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR ISSUE FINDER -----');\r\n  \r\n  // Create test data with predictable pattern\r\n  const candles: Candle[] = [];\r\n  \r\n  // Start with a flat pattern\r\n  for (let i = 0; i < 20; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 102,\r\n      low: 98,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Add a clear uptrend - this should cause a bullish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 20) * 3600000,\r\n      open: 100 + i * 2,\r\n      high: 102 + i * 2,\r\n      low: 98 + i * 2,\r\n      close: 100 + i * 2.5,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Add a clear downtrend - this should cause a bearish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 125 - i * 2,\r\n      high: 127 - i * 2,\r\n      low: 123 - i * 2,\r\n      close: 125 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${candles.length} test candles with clear trend patterns`);\r\n  \r\n  // Configuration with very low thresholds to ensure we get signals\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.01, // Almost no threshold\r\n    minChangePercent: 0.01 // Almost no minimum change\r\n  };\r\n  \r\n  // Manually check when crossovers should happen\r\n  console.log('\\nAnalyzing data for expected crossover points:');\r\n  \r\n  for (let i = 20; i < candles.length; i++) {\r\n    // Calculate SMA values ourselves\r\n    const prices = candles.slice(0, i + 1).map(c => c.close);\r\n    const fastMA = calculateSMA(prices, config.fastPeriod);\r\n    const slowMA = calculateSMA(prices, config.slowPeriod);\r\n    \r\n    if (fastMA.length < 2 || slowMA.length < 2) {continue;}\r\n    \r\n    // Get current and previous values\r\n    const currFast = fastMA[fastMA.length - 1]; \r\n    const prevFast = fastMA[fastMA.length - 2];\r\n    const currSlow = slowMA[slowMA.length - 1];\r\n    const prevSlow = slowMA[slowMA.length - 2];\r\n    \r\n    // Check for crossovers manually\r\n    if (currFast && prevFast && currSlow && prevSlow) {\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log(`Candle ${i}: BULLISH CROSSOVER DETECTED - Should generate BUY signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log(`Candle ${i}: BEARISH CROSSOVER DETECTED - Should generate SELL signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Now test using the SMA processor\r\n  console.log('\\nTesting SMA processor with the same data:');\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Create a log of raw data for analysis\r\n  const logData: {\r\n    configuration: typeof config;\r\n    candleData: Array<{\r\n      index: number;\r\n      price: number;\r\n      fastMA: number;\r\n      slowMA: number;\r\n      difference: number;\r\n    }>;\r\n    signals: Array<{\r\n      index: number;\r\n      type: string;\r\n      confidence: number;\r\n      reason: string;\r\n    }>;\r\n  } = {\r\n    configuration: config,\r\n    candleData: [],\r\n    signals: []\r\n  };\r\n  \r\n  // Process each window\r\n  for (let i = 15; i < candles.length; i++) {\r\n    const window = candles.slice(0, i + 1);\r\n    \r\n    try {\r\n      const result = processor.process(window);\r\n      \r\n      // Calculate MAs directly for reference\r\n      const prices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(prices, config.fastPeriod);\r\n      const slowMA = calculateSMA(prices, config.slowPeriod);\r\n      \r\n      const lastFastMA = fastMA.length > 0 ? fastMA[fastMA.length - 1] : null;\r\n      const lastSlowMA = slowMA.length > 0 ? slowMA[slowMA.length - 1] : null;\r\n      \r\n      console.log(`\\nCandle ${i}: Fast MA = ${lastFastMA?.toFixed(2) || 'N/A'}, Slow MA = ${lastSlowMA?.toFixed(2) || 'N/A'}`);\r\n      \r\n      // Save data for analysis\r\n      if (lastFastMA !== null && lastSlowMA !== null && window.length > 0) {\r\n        const lastCandle = window[window.length - 1];\r\n        if (lastCandle) {\r\n          logData.candleData.push({\r\n            index: i,\r\n            price: lastCandle.close,\r\n            fastMA: lastFastMA,\r\n            slowMA: lastSlowMA,\r\n            difference: lastFastMA - lastSlowMA\r\n          });\r\n        }\r\n      }\r\n      \r\n      if (result) {\r\n        const signalType = result.signal > 0 ? 'BUY' : result.signal < 0 ? 'SELL' : 'NONE';\r\n        console.log(`*** SIGNAL: ${signalType} - Confidence: ${result.confidence.toFixed(2)} ***`);\r\n        console.log(`Reason: ${result.reason}`);\r\n        \r\n        logData.signals.push({\r\n          index: i,\r\n          type: signalType,\r\n          confidence: result.confidence,\r\n          reason: result.reason\r\n        });\r\n      } else {\r\n        console.log('No signal generated');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error processing window at index ${i}:`, error);\r\n    }\r\n  }\r\n  \r\n  // Save data for analysis\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const filename = path.join(outputDir, 'sma-debug-analysis.json');\r\n    fs.writeFileSync(filename, JSON.stringify(logData, null, 2));\r\n    console.log(`\\nDetailed analysis data saved to ${filename}`);\r\n  } catch (error) {\r\n    console.error('Error saving analysis data:', error);\r\n  }\r\n  \r\n  // Check the SMASignalProcessor implementation for issues\r\n  console.log('\\nChecking SMASignalProcessor implementation:');\r\n  console.log('1. Configuration used:', config);\r\n  console.log('2. Signals generated:', logData.signals.length);\r\n  \r\n  if (logData.signals.length === 0) {\r\n    console.log('\\nPOTENTIAL ISSUES IDENTIFIED:');\r\n    console.log(`- Confidence threshold may be too high (current: ${  config.confidenceThreshold  })`);\r\n    console.log('- Signal generation logic may have bugs');\r\n    console.log('- Crossover detection might not be working as expected');\r\n    console.log('\\nRECOMMENDATIONS:');\r\n    console.log('- Review the generateSignal method in SMASignalProcessor');\r\n    console.log('- Ensure crossover detection is correctly implemented');\r\n    console.log('- Lower the confidence threshold or modify confidence calculation');\r\n  }\r\n}",
          "hash": "f0efd78eda81f5ae2400a7a300506675"
        },
        {
          "type": "function",
          "name": "useWebSocket",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 27,
          "endLine": 242,
          "complexity": 30,
          "dependencies": [],
          "usageCount": 0,
          "size": 216,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  } = options;\r\n\r\n  const [socket, setSocket] = useState<WebSocket | null>(null);\r\n  const [isConnected, setIsConnected] = useState<boolean>(false);\r\n  const [isConnecting, setIsConnecting] = useState<boolean>(false);\r\n  const [connectionError, setConnectionError] = useState<string | null>(null);\r\n  const [sessionId, setSessionId] = useState<string | null>(null);\r\n\r\n  const reconnectAttempts = useRef(0);\r\n  const heartbeatTimer = useRef<NodeJS.Timeout | null>(null);\r\n  const reconnectTimer = useRef<NodeJS.Timeout | null>(null);\r\n  const isManualClose = useRef(false);\r\n\r\n  const clearTimers = useCallback(() => {\r\n    if (heartbeatTimer.current) {\r\n      clearInterval(heartbeatTimer.current);\r\n      heartbeatTimer.current = null;\r\n    }\r\n    if (reconnectTimer.current) {\r\n      clearTimeout(reconnectTimer.current);\r\n      reconnectTimer.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const startHeartbeat = useCallback(() => {\r\n    clearTimers();\r\n    heartbeatTimer.current = setInterval(() => {\r\n      if (socket && socket.readyState === WebSocket.OPEN) {\r\n        const pingMessage: WebSocketMessage = {\r\n          type: 'ping',\r\n          channel: CONSTANTS.WS_CHANNELS.SYSTEM_HEALTH,\r\n          data: { timestamp: new Date().toISOString() }\r\n        };\r\n        socket.send(JSON.stringify(pingMessage));\r\n      }\r\n    }, heartbeatInterval);\r\n  }, [socket, heartbeatInterval, clearTimers]);\r\n\r\n  const connect = useCallback(() => {\r\n    if (isConnecting || (socket && socket.readyState === WebSocket.CONNECTING)) {\r\n      return;\r\n    }\r\n\r\n    setIsConnecting(true);\r\n    setConnectionError(null);\r\n    isManualClose.current = false;\r\n\r\n    try {\r\n      const wsUrl = token ? `${url}?token=${encodeURIComponent(token)}` : url;\r\n      const ws = new WebSocket(wsUrl);\r\n      \r\n      setSocket(ws);\r\n\r\n      ws.onopen = () => {\r\n        console.log('✅ WebSocket connected');\r\n        setIsConnected(true);\r\n        setIsConnecting(false);\r\n        setConnectionError(null);\r\n        reconnectAttempts.current = 0;\r\n        startHeartbeat();\r\n        onOpen?.();\r\n      };\r\n\r\n      ws.onmessage = (event) => {\r\n        try {\r\n          const message: WebSocketResponse = JSON.parse(event.data);\r\n          \r\n          // Handle system messages\r\n          if (message.type === 'connection' && message.channel === CONSTANTS.WS_CHANNELS.SYSTEM_HEALTH) {\r\n            if (message.data?.sessionId) {\r\n              setSessionId(message.data.sessionId);\r\n            }\r\n          } else if (message.type === 'pong') {\r\n            // Handle pong response - connection is alive\r\n            console.log('📡 Received pong from server');\r\n          } else if (message.type === 'error') {\r\n            console.error('❌ WebSocket error message:', message.data);\r\n            setConnectionError(message.data?.error || 'Unknown error');\r\n          } else {\r\n            // Pass other messages to the handler\r\n            onMessage?.(message);\r\n          }\r\n        } catch (error) {\r\n          console.error('❌ Error parsing WebSocket message:', error);\r\n        }\r\n      };\r\n\r\n      ws.onerror = (event) => {\r\n        console.error('❌ WebSocket error:', event);\r\n        setConnectionError('Connection error occurred');\r\n        setIsConnecting(false);\r\n        onError?.(event);\r\n      };\r\n\r\n      ws.onclose = (event) => {\r\n        console.log('🔌 WebSocket disconnected:', event.code, event.reason);\r\n        setIsConnected(false);\r\n        setIsConnecting(false);\r\n        setSocket(null);\r\n        clearTimers();\r\n        \r\n        onClose?.(event);\r\n\r\n        // Auto-reconnect unless it was a manual close\r\n        if (!isManualClose.current && reconnectAttempts.current < maxReconnectAttempts) {\r\n          const delay = Math.min(reconnectInterval * Math.pow(2, reconnectAttempts.current), 30000);\r\n          console.log(`🔄 Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts.current + 1}/${maxReconnectAttempts})`);\r\n          \r\n          reconnectTimer.current = setTimeout(() => {\r\n            reconnectAttempts.current++;\r\n            connect();\r\n          }, delay);\r\n        } else if (reconnectAttempts.current >= maxReconnectAttempts) {\r\n          console.warn('❌ Max reconnect attempts reached');\r\n          setConnectionError('Failed to reconnect after multiple attempts');\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to create WebSocket connection:', error);\r\n      setConnectionError('Failed to create connection');\r\n      setIsConnecting(false);\r\n    }\r\n  }, [url, token, onOpen, onMessage, onError, onClose, reconnectInterval, maxReconnectAttempts, startHeartbeat, clearTimers, isConnecting, socket]);\r\n\r\n  const sendMessage = useCallback((message: WebSocketMessage) => {\r\n    if (socket && socket.readyState === WebSocket.OPEN) {\r\n      try {\r\n        const messageWithTimestamp = {\r\n          ...message,\r\n          timestamp: new Date()\r\n        };\r\n        socket.send(JSON.stringify(messageWithTimestamp));\r\n      } catch (error) {\r\n        console.error('❌ Failed to send WebSocket message:', error);\r\n      }\r\n    } else {\r\n      console.warn('⚠️ WebSocket not connected. Message not sent:', message);\r\n    }\r\n  }, [socket]);\r\n\r\n  const subscribe = useCallback((channel: string, symbol?: string) => {\r\n    const subscribeMessage: WebSocketMessage = {\r\n      type: 'subscribe',\r\n      channel,\r\n      data: symbol ? { symbol } : {}\r\n    };\r\n    sendMessage(subscribeMessage);\r\n  }, [sendMessage]);\r\n\r\n  const unsubscribe = useCallback((channel: string, symbol?: string) => {\r\n    const unsubscribeMessage: WebSocketMessage = {\r\n      type: 'unsubscribe',\r\n      channel,\r\n      data: symbol ? { symbol } : {}\r\n    };\r\n    sendMessage(unsubscribeMessage);\r\n  }, [sendMessage]);\r\n\r\n  const reconnect = useCallback(() => {\r\n    if (socket) {\r\n      isManualClose.current = true;\r\n      socket.close();\r\n    }\r\n    reconnectAttempts.current = 0;\r\n    connect();\r\n  }, [socket, connect]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    isManualClose.current = true;\r\n    clearTimers();\r\n    if (socket) {\r\n      socket.close();\r\n    }\r\n  }, [socket, clearTimers]);\r\n\r\n  // Initialize connection\r\n  useEffect(() => {\r\n    connect();\r\n    \r\n    // Cleanup on unmount\r\n    return () => {\r\n      disconnect();\r\n    };\r\n  }, [connect, disconnect]);\r\n\r\n  // Cleanup timers on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      clearTimers();\r\n    };\r\n  }, [clearTimers]);\r\n\r\n  return {\r\n    socket,\r\n    isConnected,\r\n    isConnecting,\r\n    connectionError,\r\n    sessionId,\r\n    sendMessage,\r\n    subscribe,\r\n    unsubscribe,\r\n    reconnect\r\n  };\r\n}",
          "hash": "763f17351e547f14608a7a828b5181a6"
        },
        {
          "type": "function",
          "name": "change",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\metrics-collector.ts",
          "startLine": 385,
          "endLine": 424,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n    const progress = snapshot.projectMetrics.overallProgress;\r\n    const velocity = snapshot.projectMetrics.velocityPerWeek;\r\n    const blockedTasks = snapshot.projectMetrics.blockedTasks;\r\n    const testCoverage = snapshot.testMetrics?.testCoverage || 0;\r\n    \r\n    let score = 0;\r\n    \r\n    // Progress score (40% weight)\r\n    if (progress > 80) score += 40;\r\n    else if (progress > 60) score += 30;\r\n    else if (progress > 40) score += 20;\r\n    else score += 10;\r\n    \r\n    // Velocity score (30% weight)\r\n    if (velocity > 5) score += 30;\r\n    else if (velocity > 3) score += 20;\r\n    else if (velocity > 1) score += 10;\r\n    \r\n    // Quality score (20% weight)\r\n    if (testCoverage > 80) score += 20;\r\n    else if (testCoverage > 60) score += 15;\r\n    else if (testCoverage > 40) score += 10;\r\n    \r\n    // Risk score (10% weight) - negative impact\r\n    if (blockedTasks === 0) score += 10;\r\n    else if (blockedTasks < 3) score += 5;\r\n    \r\n    if (score >= 90) return 'excellent';\r\n    if (score >= 75) return 'good';\r\n    if (score >= 60) return 'warning';\r\n    return 'critical';\r\n  }\r\n\r\n  private generateExecutiveRecommendations(latest: MetricsSnapshot, trends: any): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (latest.projectMetrics.blockedTasks > 0) {\r\n      recommendations.push(`Immediate attention needed: ${latest.projectMetrics.blockedTasks} blocked tasks`);\r\n    }",
          "hash": "200161f2cce8f2a9cacc6d209fccf769"
        },
        {
          "type": "function",
          "name": "change",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\metrics-collector.ts",
          "startLine": 385,
          "endLine": 424,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n    const progress = snapshot.projectMetrics.overallProgress;\r\n    const velocity = snapshot.projectMetrics.velocityPerWeek;\r\n    const blockedTasks = snapshot.projectMetrics.blockedTasks;\r\n    const testCoverage = snapshot.testMetrics?.testCoverage || 0;\r\n    \r\n    let score = 0;\r\n    \r\n    // Progress score (40% weight)\r\n    if (progress > 80) score += 40;\r\n    else if (progress > 60) score += 30;\r\n    else if (progress > 40) score += 20;\r\n    else score += 10;\r\n    \r\n    // Velocity score (30% weight)\r\n    if (velocity > 5) score += 30;\r\n    else if (velocity > 3) score += 20;\r\n    else if (velocity > 1) score += 10;\r\n    \r\n    // Quality score (20% weight)\r\n    if (testCoverage > 80) score += 20;\r\n    else if (testCoverage > 60) score += 15;\r\n    else if (testCoverage > 40) score += 10;\r\n    \r\n    // Risk score (10% weight) - negative impact\r\n    if (blockedTasks === 0) score += 10;\r\n    else if (blockedTasks < 3) score += 5;\r\n    \r\n    if (score >= 90) return 'excellent';\r\n    if (score >= 75) return 'good';\r\n    if (score >= 60) return 'warning';\r\n    return 'critical';\r\n  }\r\n\r\n  private generateExecutiveRecommendations(latest: MetricsSnapshot, trends: any): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (latest.projectMetrics.blockedTasks > 0) {\r\n      recommendations.push(`Immediate attention needed: ${latest.projectMetrics.blockedTasks} blocked tasks`);\r\n    }",
          "hash": "200161f2cce8f2a9cacc6d209fccf769"
        },
        {
          "type": "function",
          "name": "debugSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-signals.ts",
          "startLine": 46,
          "endLine": 212,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 167,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR DEBUG -----');\r\n  \r\n  // Generate 100 candles with clear price movements\r\n  const candles = generateTestData(100);\r\n  console.log(`Generated ${candles.length} test candles with sine wave pattern`);\r\n  \r\n  // Extract close prices for analysis\r\n  const prices = candles.map(c => c.close);\r\n  \r\n  // Calculate MAs directly to debug\r\n  const fast1 = calculateSMA(prices, 5);\r\n  const slow1 = calculateSMA(prices, 15);\r\n  console.log(`Calculated MAs directly: Fast(5) length=${fast1.length}, Slow(15) length=${slow1.length}`);\r\n  \r\n  // Create minimal configuration with proper types\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n    signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.1 // Very low threshold\r\n  };\r\n  \r\n  // Initialize processor\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Save raw data and MAs to file for inspection\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const dataFile = path.join(outputDir, 'sma-debug-data.json');\r\n    fs.writeFileSync(dataFile, JSON.stringify({\r\n      candles: candles.slice(0, 20), // First 20 candles sample\r\n      prices: prices.slice(0, 20),\r\n      fastMA: fast1.slice(0, 20),\r\n      slowMA: slow1.slice(0, 15)\r\n    }, null, 2));\r\n    \r\n    console.log(`Saved sample data to ${dataFile}`);\r\n  } catch (error) {\r\n    console.error('Error saving debug data:', error);\r\n  }\r\n  \r\n  // Process in a sliding window to debug\r\n  console.log('\\nTesting signal processing with sliding window:');\r\n  const startIdx = 20; // Start after enough data for MA calculations\r\n  \r\n  // Direct inspection of signal generation logic\r\n  for (let i = startIdx; i < Math.min(candles.length, startIdx + 10); i++) {\r\n    // Log the prices and MAs\r\n    const window = candles.slice(0, i + 1);\r\n    const windowPrices = window.map(c => c.close);\r\n    \r\n    // Calculate MAs directly for comparison\r\n    const fastMA = calculateSMA(windowPrices, config.fastPeriod);\r\n    const slowMA = calculateSMA(windowPrices, config.slowPeriod);\r\n    \r\n    const lastPrice = windowPrices[windowPrices.length - 1];\r\n    const lastFastMA = fastMA[fastMA.length - 1];\r\n    const lastSlowMA = slowMA[slowMA.length - 1];\r\n    \r\n    console.log(`\\nWindow ${i}: Last Price=${lastPrice.toFixed(2)}`);\r\n    console.log(`Fast MA: ${lastFastMA.toFixed(2)}, Slow MA: ${lastSlowMA.toFixed(2)}`);\r\n    \r\n    // Check for crossover conditions manually\r\n    if (fastMA.length >= 2 && slowMA.length >= 2) {\r\n      const currFast = fastMA[fastMA.length - 1];\r\n      const prevFast = fastMA[fastMA.length - 2];\r\n      const currSlow = slowMA[slowMA.length - 1];\r\n      const prevSlow = slowMA[slowMA.length - 2];\r\n      \r\n      console.log(`Previous: Fast=${prevFast.toFixed(2)}, Slow=${prevSlow.toFixed(2)}`);\r\n      console.log(`Current: Fast=${currFast.toFixed(2)}, Slow=${currSlow.toFixed(2)}`);\r\n      \r\n      // Check crossover manually\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate BUY signal (bullish crossover) ***');\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate SELL signal (bearish crossover) ***');\r\n      } else {\r\n        console.log('*** MANUAL CHECK: No crossover detected ***');\r\n      }\r\n    }\r\n    \r\n    // Now use the processor and see what it returns\r\n    try {\r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`PROCESSOR RESULT: Signal=${result.signal}, Confidence=${result.confidence.toFixed(2)}, Reason=${result.reason}`);\r\n      } else {\r\n        console.log('PROCESSOR RESULT: No signal returned');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error from processor:`, error);\r\n    }\r\n  }\r\n  \r\n  console.log('\\n----- DETAILED TESTING WITH FORCED CROSSOVER DATA -----');\r\n  \r\n  // Create data with guaranteed crossover\r\n  const crossoverData: Candle[] = [];\r\n  // First add candles with fast MA below slow MA\r\n  for (let i = 0; i < 30; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 90,\r\n      high: 95,\r\n      low: 85,\r\n      close: 90 + i * 0.1, // Slowly rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then add candles where fast MA will cross above slow MA\r\n  for (let i = 0; i < 10; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 95,\r\n      high: 110,\r\n      low: 95,\r\n      close: 95 + i * 2, // Sharply rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${crossoverData.length} candles with forced crossover pattern`);\r\n  \r\n  // Test with forced crossover data\r\n  try {\r\n    // Reset processor with very permissive settings\r\n    const crossoverProcessor = new SMASignalProcessor({\r\n      fastPeriod: 5,\r\n      slowPeriod: 15,\r\n      priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n      signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n      confidenceThreshold: 0.01 // Almost no threshold\r\n    });\r\n    \r\n    console.log('\\nProcessing forced crossover data:');\r\n    // Process each window\r\n    for (let i = 20; i < crossoverData.length; i++) {\r\n      const window = crossoverData.slice(0, i + 1);\r\n      const result = crossoverProcessor.process(window);\r\n      \r\n      // Calculate MAs directly for comparison\r\n      const windowPrices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(windowPrices, 5);\r\n      const slowMA = calculateSMA(windowPrices, 15);\r\n      \r\n      console.log(`\\nWindow ${i}: Fast=${fastMA[fastMA.length-1].toFixed(2)}, Slow=${slowMA[slowMA.length-1].toFixed(2)}`);\r\n      \r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence=${result.confidence.toFixed(2)}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log('No signal');\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during forced crossover test:', error);\r\n  }\r\n}",
          "hash": "63bb778aca5051b5886c1f1cbd6aa27e"
        },
        {
          "type": "function",
          "name": "testFuturesBeast",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-futures-beast.ts",
          "startLine": 3,
          "endLine": 195,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 193,
          "content": "{\r\n  console.log('🔥 SPARTAN BEAST MODE: FULL FUTURES TRADING ENGINE TEST');\r\n  console.log('======================================================');\r\n\r\n  // Mainnet credentials (safe for small test)\r\n  const apiKey = {\r\n    id: 'mainnet-key-1',\r\n    userId: 'mainnet-user',\r\n    exchange: 'bybit' as const,\r\n    keyName: 'Mainnet Key',\r\n    apiKey: '3TZG3zGNOZBa5Fnuck',\r\n    apiSecret: 'k2loWLXJhswTajZvGhwdW98soSGL87BjDIWI',\r\n    sandbox: false,\r\n    permissions: ['trade', 'read'],\r\n    isActive: true,\r\n    createdAt: new Date(),\r\n    updatedAt: new Date()\r\n  };\r\n\r\n  const exchange = new BybitExchange(apiKey, false);\r\n\r\n  try {\r\n    // Connect\r\n    console.log('\\n🔌 Connecting to Bybit MAINNET...');\r\n    await exchange.connect();\r\n    console.log('✅ Connected successfully!');\r\n\r\n    // Set leverage and margin mode\r\n    console.log('\\n⚡ Setting leverage and margin mode...');\r\n    await exchange.setLeverage('BTCUSDT', 10);\r\n    await exchange.setMarginMode('BTCUSDT', 'isolated');\r\n    console.log('✅ Leverage set to 10x, margin mode set to isolated');\r\n\r\n    // Place a market order (open position)\r\n    console.log('\\n📝 Placing market order (BUY 0.001 BTCUSDT)...');\r\n    let marketOrder;\r\n    try {\r\n      marketOrder = await exchange.placeOrder({\r\n        symbol: 'BTCUSDT',\r\n        side: 'buy',\r\n        type: 'market',\r\n        amount: 0.001,\r\n        marketType: MarketType.FUTURES\r\n      });\r\n      console.log('✅ Market order placed:', marketOrder);\r\n    } catch (error) {\r\n      console.error('❌ Market order failed:', error);\r\n    }\r\n\r\n    // Place a limit order (pending)\r\n    console.log('\\n📝 Placing limit order (SELL 0.001 BTCUSDT 2% above market)...');\r\n    let limitOrder;\r\n    try {\r\n      const marketData = await exchange.getMarketData('BTCUSDT', MarketType.FUTURES);\r\n      const limitPrice = marketData.price * 1.02;\r\n      limitOrder = await exchange.placeOrder({\r\n        symbol: 'BTCUSDT',\r\n        side: 'sell',\r\n        type: 'limit',\r\n        amount: 0.001,\r\n        price: limitPrice,\r\n        marketType: MarketType.FUTURES\r\n      });\r\n      console.log('✅ Limit order placed:', limitOrder);\r\n    } catch (error) {\r\n      console.error('❌ Limit order failed:', error);\r\n    }\r\n\r\n    // Place a stop order (pending)\r\n    console.log('\\n📝 Placing stop order (SELL 0.001 BTCUSDT 2% below market)...');\r\n    let stopOrder;\r\n    try {\r\n      const marketData = await exchange.getMarketData('BTCUSDT', MarketType.FUTURES);\r\n      const stopPrice = marketData.price * 0.98;\r\n      stopOrder = await exchange.placeOrder({\r\n        symbol: 'BTCUSDT',\r\n        side: 'sell',\r\n        type: 'stop',\r\n        amount: 0.001,\r\n        stopPrice,\r\n        marketType: MarketType.FUTURES\r\n      });\r\n      console.log('✅ Stop order placed:', stopOrder);\r\n    } catch (error) {\r\n      console.error('❌ Stop order failed:', error);\r\n    }\r\n\r\n    // Check open positions\r\n    console.log('\\n📊 Checking open positions...');\r\n    try {\r\n      const positions = await exchange.getPositions();\r\n      if (positions.length > 0) {\r\n        positions.forEach(pos => {\r\n          console.log(`   ${pos.symbol}: ${pos.side} ${pos.size} @ $${pos.entryPrice} (${pos.leverage}x)`);\r\n          console.log(`     PnL: ${pos.unrealizedPnl} (Mark: $${pos.markPrice})`);\r\n        });\r\n      } else {\r\n        console.log('   No open positions');\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Failed to get positions:', error);\r\n    }\r\n\r\n    // Cancel all open orders\r\n    console.log('\\n🚫 Cancelling all open orders...');\r\n    try {\r\n      await exchange.cancelAllOrders('BTCUSDT', MarketType.FUTURES);\r\n      console.log('✅ All open orders cancelled');\r\n    } catch (error) {\r\n      console.error('❌ Failed to cancel all orders:', error);\r\n    }\r\n\r\n    // Final positions and balance\r\n    console.log('\\n📊 Final positions and balance:');\r\n    try {\r\n      const positions = await exchange.getPositions();\r\n      const balance = await exchange.getBalance(MarketType.FUTURES);\r\n      console.log('   Positions:', positions);\r\n      console.log('   Balance:', balance);\r\n    } catch (error) {\r\n      console.error('❌ Final check failed:', error);\r\n    }\r\n\r\n    // 4. Switch position mode to hedge\r\n    console.log('\\n🔄 Switching position mode to hedge...');\r\n    try {\r\n      await exchange.setPositionMode('hedge');\r\n      console.log('✅ Position mode switched to hedge');\r\n    } catch (error) {\r\n      console.error('❌ Failed to switch position mode:', error);\r\n    }\r\n\r\n    // 5. Add stop-loss and take-profit (manual simulation)\r\n    console.log('\\n🛡️ Adding stop-loss and take-profit (manual simulation)...');\r\n    try {\r\n      const positionsNow = await exchange.getPositions();\r\n      const pos = positionsNow[0];\r\n      if (pos) {\r\n        const stopLoss = pos.entryPrice * 0.98;\r\n        const takeProfit = pos.entryPrice * 1.05;\r\n        console.log(`   Would set stop-loss at $${stopLoss.toFixed(2)} and take-profit at $${takeProfit.toFixed(2)}`);\r\n      } else {\r\n        console.log('   No open positions to set stop-loss/take-profit');\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Failed to add stop-loss/take-profit:', error);\r\n    }\r\n\r\n    // 6. Close the position (market order)\r\n    console.log('\\n🚪 Closing open position (market order)...');\r\n    try {\r\n      const positionsNow = await exchange.getPositions();\r\n      const pos = positionsNow[0];\r\n      if (pos && pos.size > 0) {\r\n        const closeOrder = await exchange.placeOrder({\r\n          symbol: pos.symbol,\r\n          side: pos.side === 'buy' ? 'sell' : 'buy',\r\n          type: 'market',\r\n          amount: pos.size,\r\n          marketType: MarketType.FUTURES,\r\n          reduceOnly: true\r\n        });\r\n        console.log('✅ Close order placed:', closeOrder);\r\n      } else if (pos) {\r\n        console.log('   No position to close');\r\n      } else {\r\n        console.log('   No open positions to close');\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Failed to close position:', error);\r\n    }\r\n\r\n    // Start position monitor for TP/SL automation\r\n    console.log('\\n🛡️ Starting PositionMonitorService for TP/SL automation...');\r\n    const monitor = new PositionMonitorService(exchange, {\r\n      symbol: 'BTCUSDT',\r\n      side: 'buy',\r\n      stopLossPercent: 0.02, // 2% SL\r\n      takeProfitPercent: 0.05 // 5% TP\r\n    });\r\n    monitor.start();\r\n    // Let it run for 30 seconds\r\n    await new Promise(resolve => setTimeout(resolve, 30000));\r\n    monitor.stop();\r\n    console.log('🛡️ PositionMonitorService stopped');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Beast mode test failed:', error);\r\n  } finally {\r\n    await exchange.disconnect();\r\n    console.log('\\n🔌 Disconnected from exchange');\r\n  }\r\n}",
          "hash": "a63eed4a4d0330be466ea47fb87f63cc"
        },
        {
          "type": "function",
          "name": "debugSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-signals.ts",
          "startLine": 46,
          "endLine": 212,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 167,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR DEBUG -----');\r\n  \r\n  // Generate 100 candles with clear price movements\r\n  const candles = generateTestData(100);\r\n  console.log(`Generated ${candles.length} test candles with sine wave pattern`);\r\n  \r\n  // Extract close prices for analysis\r\n  const prices = candles.map(c => c.close);\r\n  \r\n  // Calculate MAs directly to debug\r\n  const fast1 = calculateSMA(prices, 5);\r\n  const slow1 = calculateSMA(prices, 15);\r\n  console.log(`Calculated MAs directly: Fast(5) length=${fast1.length}, Slow(15) length=${slow1.length}`);\r\n  \r\n  // Create minimal configuration with proper types\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n    signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.1 // Very low threshold\r\n  };\r\n  \r\n  // Initialize processor\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Save raw data and MAs to file for inspection\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const dataFile = path.join(outputDir, 'sma-debug-data.json');\r\n    fs.writeFileSync(dataFile, JSON.stringify({\r\n      candles: candles.slice(0, 20), // First 20 candles sample\r\n      prices: prices.slice(0, 20),\r\n      fastMA: fast1.slice(0, 20),\r\n      slowMA: slow1.slice(0, 15)\r\n    }, null, 2));\r\n    \r\n    console.log(`Saved sample data to ${dataFile}`);\r\n  } catch (error) {\r\n    console.error('Error saving debug data:', error);\r\n  }\r\n  \r\n  // Process in a sliding window to debug\r\n  console.log('\\nTesting signal processing with sliding window:');\r\n  const startIdx = 20; // Start after enough data for MA calculations\r\n  \r\n  // Direct inspection of signal generation logic\r\n  for (let i = startIdx; i < Math.min(candles.length, startIdx + 10); i++) {\r\n    // Log the prices and MAs\r\n    const window = candles.slice(0, i + 1);\r\n    const windowPrices = window.map(c => c.close);\r\n    \r\n    // Calculate MAs directly for comparison\r\n    const fastMA = calculateSMA(windowPrices, config.fastPeriod);\r\n    const slowMA = calculateSMA(windowPrices, config.slowPeriod);\r\n    \r\n    const lastPrice = windowPrices[windowPrices.length - 1];\r\n    const lastFastMA = fastMA[fastMA.length - 1];\r\n    const lastSlowMA = slowMA[slowMA.length - 1];\r\n    \r\n    console.log(`\\nWindow ${i}: Last Price=${lastPrice.toFixed(2)}`);\r\n    console.log(`Fast MA: ${lastFastMA.toFixed(2)}, Slow MA: ${lastSlowMA.toFixed(2)}`);\r\n    \r\n    // Check for crossover conditions manually\r\n    if (fastMA.length >= 2 && slowMA.length >= 2) {\r\n      const currFast = fastMA[fastMA.length - 1];\r\n      const prevFast = fastMA[fastMA.length - 2];\r\n      const currSlow = slowMA[slowMA.length - 1];\r\n      const prevSlow = slowMA[slowMA.length - 2];\r\n      \r\n      console.log(`Previous: Fast=${prevFast.toFixed(2)}, Slow=${prevSlow.toFixed(2)}`);\r\n      console.log(`Current: Fast=${currFast.toFixed(2)}, Slow=${currSlow.toFixed(2)}`);\r\n      \r\n      // Check crossover manually\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate BUY signal (bullish crossover) ***');\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate SELL signal (bearish crossover) ***');\r\n      } else {\r\n        console.log('*** MANUAL CHECK: No crossover detected ***');\r\n      }\r\n    }\r\n    \r\n    // Now use the processor and see what it returns\r\n    try {\r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`PROCESSOR RESULT: Signal=${result.signal}, Confidence=${result.confidence.toFixed(2)}, Reason=${result.reason}`);\r\n      } else {\r\n        console.log('PROCESSOR RESULT: No signal returned');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error from processor:`, error);\r\n    }\r\n  }\r\n  \r\n  console.log('\\n----- DETAILED TESTING WITH FORCED CROSSOVER DATA -----');\r\n  \r\n  // Create data with guaranteed crossover\r\n  const crossoverData: Candle[] = [];\r\n  // First add candles with fast MA below slow MA\r\n  for (let i = 0; i < 30; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 90,\r\n      high: 95,\r\n      low: 85,\r\n      close: 90 + i * 0.1, // Slowly rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then add candles where fast MA will cross above slow MA\r\n  for (let i = 0; i < 10; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 95,\r\n      high: 110,\r\n      low: 95,\r\n      close: 95 + i * 2, // Sharply rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${crossoverData.length} candles with forced crossover pattern`);\r\n  \r\n  // Test with forced crossover data\r\n  try {\r\n    // Reset processor with very permissive settings\r\n    const crossoverProcessor = new SMASignalProcessor({\r\n      fastPeriod: 5,\r\n      slowPeriod: 15,\r\n      priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n      signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n      confidenceThreshold: 0.01 // Almost no threshold\r\n    });\r\n    \r\n    console.log('\\nProcessing forced crossover data:');\r\n    // Process each window\r\n    for (let i = 20; i < crossoverData.length; i++) {\r\n      const window = crossoverData.slice(0, i + 1);\r\n      const result = crossoverProcessor.process(window);\r\n      \r\n      // Calculate MAs directly for comparison\r\n      const windowPrices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(windowPrices, 5);\r\n      const slowMA = calculateSMA(windowPrices, 15);\r\n      \r\n      console.log(`\\nWindow ${i}: Fast=${fastMA[fastMA.length-1].toFixed(2)}, Slow=${slowMA[slowMA.length-1].toFixed(2)}`);\r\n      \r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence=${result.confidence.toFixed(2)}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log('No signal');\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during forced crossover test:', error);\r\n  }\r\n}",
          "hash": "63bb778aca5051b5886c1f1cbd6aa27e"
        },
        {
          "type": "function",
          "name": "testMainnetSmall",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-mainnet-small.ts",
          "startLine": 9,
          "endLine": 162,
          "complexity": 22,
          "dependencies": [],
          "usageCount": 0,
          "size": 154,
          "content": "{\r\n  console.log('🚀 MAINNET SMALL AMOUNT TEST');\r\n  console.log('============================');\r\n  console.log('⚠️ REAL MONEY - SMALL AMOUNTS ONLY!');\r\n\r\n  // Real mainnet credentials (your provided keys)\r\n  const apiKey = {\r\n    id: 'mainnet-key-1',\r\n    userId: 'mainnet-user',\r\n    exchange: 'bybit' as const,\r\n    keyName: 'Mainnet Key',\r\n    apiKey: '3TZG3zGNOZBa5Fnuck',\r\n    apiSecret: 'k2loWLXJhswTajZvGhwdW98soSGL87BjDIWI',\r\n    sandbox: false, // MAINNET = false\r\n    permissions: ['trade', 'read'],\r\n    isActive: true,\r\n    createdAt: new Date(),\r\n    updatedAt: new Date()\r\n  };\r\n\r\n  const exchange = new BybitExchange(apiKey, false); // mainnet = false\r\n\r\n  try {\r\n    // Connect\r\n    console.log('\\n🔌 Connecting to Bybit MAINNET...');\r\n    await exchange.connect();\r\n    console.log('✅ Connected successfully!');\r\n\r\n    // Get current market price\r\n    console.log('\\n📊 Getting current market data...');\r\n    const marketData = await exchange.getMarketData('BTCUSDT', MarketType.FUTURES);\r\n    console.log(`   Current BTC Price: $${marketData.price.toFixed(2)}`);\r\n\r\n    // Check account balance\r\n    console.log('\\n💰 Checking Account Balance...');\r\n    try {\r\n      const futuresBalance = await exchange.getBalance(MarketType.FUTURES);\r\n      console.log('   Futures Balance:');\r\n      futuresBalance.forEach(balance => {\r\n        if (balance.total > 0) {\r\n          console.log(`     ${balance.currency}: ${balance.total} (Available: ${balance.available})`);\r\n        }\r\n      });\r\n\r\n      const spotBalance = await exchange.getBalance(MarketType.SPOT);\r\n      console.log('   Spot Balance:');\r\n      spotBalance.forEach(balance => {\r\n        if (balance.total > 0) {\r\n          console.log(`     ${balance.currency}: ${balance.total} (Available: ${balance.available})`);\r\n        }\r\n      });\r\n\r\n      // Check if we have any USDT for trading\r\n      const usdtBalance = futuresBalance.find(b => b.currency === 'USDT');\r\n      if (usdtBalance && usdtBalance.available > 1) {\r\n        console.log(`\\n💵 Found ${usdtBalance.available} USDT available for trading!`);\r\n        \r\n        // Calculate a VERY small order (minimum possible)\r\n        const minOrderSize = 0.001; // 0.001 BTC = ~$95 at current prices\r\n        const limitPrice = marketData.price * 0.98; // 2% below market for safety\r\n        \r\n        console.log('\\n📝 READY TO PLACE SMALL TEST ORDER:');\r\n        console.log(`   Symbol: BTCUSDT`);\r\n        console.log(`   Side: BUY`);\r\n        console.log(`   Type: LIMIT`);\r\n        console.log(`   Amount: ${minOrderSize} BTC (~$${(minOrderSize * marketData.price).toFixed(2)})`);\r\n        console.log(`   Price: $${limitPrice.toFixed(2)} (2% below market)`);\r\n        console.log(`   Market: FUTURES`);\r\n        \r\n        console.log('\\n🚫 ORDER PLACEMENT COMMENTED OUT FOR SAFETY');\r\n        console.log('   To execute real trade, uncomment the code below:');\r\n        console.log('   // const order = await exchange.placeOrder({');\r\n        console.log('   //   symbol: \"BTCUSDT\",');\r\n        console.log('   //   side: \"buy\",');\r\n        console.log('   //   type: \"limit\",');\r\n        console.log(`   //   amount: ${minOrderSize},`);\r\n        console.log(`   //   price: ${limitPrice.toFixed(2)},`);\r\n        console.log('   //   marketType: MarketType.FUTURES');\r\n        console.log('   // });');\r\n        \r\n        // UNCOMMENT BELOW TO EXECUTE REAL TRADE (VERY SMALL AMOUNT)\r\n        \r\n        try {\r\n          console.log('\\n🔥 EXECUTING REAL TRADE ON MAINNET!!! 🔥');\r\n          const order = await exchange.placeOrder({\r\n            symbol: 'BTCUSDT',\r\n            side: 'buy',\r\n            type: 'limit',\r\n            amount: minOrderSize,\r\n            price: limitPrice,\r\n            marketType: MarketType.FUTURES\r\n          });\r\n\r\n          console.log('\\n🎉 REAL ORDER PLACED ON MAINNET!');\r\n          console.log(`   Order ID: ${order.orderId}`);\r\n          console.log(`   Status: ${order.status}`);\r\n          console.log(`   Amount: ${order.amount} BTC`);\r\n          console.log(`   Price: $${order.price?.toFixed(2)}`);\r\n          \r\n          // Wait and check status\r\n          setTimeout(async () => {\r\n            try {\r\n              const orderStatus = await exchange.getOrder(order.orderId, 'BTCUSDT', MarketType.FUTURES);\r\n              console.log(`\\n📊 Order Status: ${orderStatus.status}`);\r\n              \r\n              // Cancel if still open after 10 seconds (safety measure)\r\n              if (orderStatus.status === 'open') {\r\n                console.log('\\n⏰ Cancelling order after 10 seconds for safety...');\r\n                await exchange.cancelOrder(order.orderId, 'BTCUSDT', MarketType.FUTURES);\r\n                console.log('✅ Order cancelled successfully');\r\n              }\r\n            } catch (statusError) {\r\n              console.error('❌ Order status check failed:', statusError);\r\n            }\r\n          }, 10000); // 10 seconds\r\n\r\n        } catch (orderError) {\r\n          console.error('❌ Order placement failed:', orderError);\r\n        }\r\n        \r\n      } else {\r\n        console.log('\\n⚠️ No USDT available for trading');\r\n        console.log('   To test trading, deposit some USDT to your Bybit account');\r\n      }\r\n\r\n    } catch (balanceError) {\r\n      console.log(`   ⚠️ Balance check failed: ${balanceError instanceof Error ? balanceError.message : 'Unknown error'}`);\r\n    }\r\n\r\n    // Test current positions\r\n    console.log('\\n⚡ Current Positions:');\r\n    try {\r\n      const positions = await exchange.getPositions();\r\n      console.log(`   Open Positions: ${positions.length}`);\r\n      positions.forEach(pos => {\r\n        console.log(`     ${pos.symbol}: ${pos.side} ${pos.size} @ $${pos.entryPrice} (${pos.leverage}x)`);\r\n        console.log(`       PnL: ${pos.unrealizedPnl} (Mark: $${pos.markPrice})`);\r\n      });\r\n    } catch (posError) {\r\n      console.log(`   ⚠️ Position check failed: ${posError instanceof Error ? posError.message : 'Unknown error'}`);\r\n    }\r\n\r\n    console.log('\\n🎉 MAINNET TEST COMPLETED!');\r\n    console.log('💪 Your trading engine is connected to REAL BYBIT!');\r\n    console.log('🔥 Ready for live trading when you add funds!');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Mainnet test failed:', error);\r\n  } finally {\r\n    // Disconnect\r\n    await exchange.disconnect();\r\n    console.log('\\n🔌 Disconnected from exchange');\r\n  }\r\n}",
          "hash": "b46f670838aac51e662d584e637e8fcb"
        },
        {
          "type": "function",
          "name": "verifyOrder",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\verify-order.ts",
          "startLine": 8,
          "endLine": 136,
          "complexity": 19,
          "dependencies": [],
          "usageCount": 0,
          "size": 129,
          "content": "{\r\n  console.log('🔍 VERIFYING RECENT ORDER');\r\n  console.log('========================');\r\n\r\n  // Real mainnet credentials\r\n  const apiKey = {\r\n    id: 'mainnet-key-1',\r\n    userId: 'mainnet-user',\r\n    exchange: 'bybit' as const,\r\n    keyName: 'Mainnet Key',\r\n    apiKey: '3TZG3zGNOZBa5Fnuck',\r\n    apiSecret: 'k2loWLXJhswTajZvGhwdW98soSGL87BjDIWI',\r\n    sandbox: false,\r\n    permissions: ['trade', 'read'],\r\n    isActive: true,\r\n    createdAt: new Date(),\r\n    updatedAt: new Date()\r\n  };\r\n\r\n  const exchange = new BybitExchange(apiKey, false);\r\n\r\n  try {\r\n    // Connect\r\n    console.log('\\n🔌 Connecting to Bybit MAINNET...');\r\n    await exchange.connect();\r\n    console.log('✅ Connected successfully!');\r\n\r\n    // Get recent orders (last 50)\r\n    console.log('\\n📋 Getting Recent Orders...');\r\n    try {\r\n      const recentOrders = await exchange.getOrderHistory('BTCUSDT', MarketType.FUTURES);\r\n      console.log(`   Found ${recentOrders.length} recent orders`);\r\n      \r\n      // Show the most recent orders\r\n      console.log('\\n🎯 RECENT ORDERS (PROOF):');\r\n      recentOrders.slice(0, 5).forEach((order, index) => {\r\n        console.log(`   ${index + 1}. Order ID: ${order.orderId}`);\r\n        console.log(`      Symbol: ${order.symbol}`);\r\n        console.log(`      Side: ${order.side.toUpperCase()}`);\r\n        console.log(`      Type: ${order.type.toUpperCase()}`);\r\n        console.log(`      Amount: ${order.amount} BTC`);\r\n        console.log(`      Price: $${order.price?.toFixed(2) || 'Market'}`);\r\n        console.log(`      Status: ${order.status.toUpperCase()}`);\r\n        console.log(`      Created: ${order.timestamp ? new Date(order.timestamp).toLocaleString() : 'Unknown'}`);\r\n        console.log(`      Filled: ${order.filled || 0} BTC`);\r\n        console.log(`      Remaining: ${order.remaining || 0} BTC`);\r\n        console.log('      ---');\r\n      });\r\n\r\n      // Check for our specific order ID\r\n      const ourOrderId = 'aafa1480-42ea-4563-b017-59f2cc558521';\r\n      const ourOrder = recentOrders.find(order => order.orderId === ourOrderId);\r\n      \r\n      if (ourOrder) {\r\n        console.log('\\n🎉 FOUND OUR ORDER!!! PROOF OF EXECUTION:');\r\n        console.log(`   ✅ Order ID: ${ourOrder.orderId}`);\r\n        console.log(`   ✅ Status: ${ourOrder.status.toUpperCase()}`);\r\n        console.log(`   ✅ Amount: ${ourOrder.amount} BTC`);\r\n        console.log(`   ✅ Price: $${ourOrder.price?.toFixed(2)}`);\r\n        console.log(`   ✅ Filled: ${ourOrder.filled || 0} BTC`);\r\n        console.log(`   ✅ Created: ${ourOrder.timestamp ? new Date(ourOrder.timestamp).toLocaleString() : 'Unknown'}`);\r\n      } else {\r\n        console.log('\\n⚠️ Our specific order not found in recent history');\r\n        console.log('   This could mean:');\r\n        console.log('   - Order was cancelled automatically');\r\n        console.log('   - Order is too old to appear in recent history');\r\n        console.log('   - Order was executed and removed from active list');\r\n      }\r\n\r\n    } catch (historyError) {\r\n      console.error('❌ Failed to get order history:', historyError);\r\n    }\r\n\r\n    // Check current open orders\r\n    console.log('\\n⚡ Current Open Orders:');\r\n    try {\r\n      const openOrders = await exchange.getOpenOrders('BTCUSDT', MarketType.FUTURES);\r\n      console.log(`   Open Orders: ${openOrders.length}`);\r\n      \r\n      if (openOrders.length > 0) {\r\n        openOrders.forEach((order, index) => {\r\n          console.log(`   ${index + 1}. ${order.orderId} - ${order.side.toUpperCase()} ${order.amount} BTC @ $${order.price?.toFixed(2)}`);\r\n        });\r\n      } else {\r\n        console.log('   No open orders found');\r\n      }\r\n    } catch (openError) {\r\n      console.error('❌ Failed to get open orders:', openError);\r\n    }\r\n\r\n    // Check current balance\r\n    console.log('\\n💰 Current Balance:');\r\n    try {\r\n      const balance = await exchange.getBalance(MarketType.FUTURES);\r\n      const usdtBalance = balance.find(b => b.currency === 'USDT');\r\n      if (usdtBalance) {\r\n        console.log(`   USDT: ${usdtBalance.total} (Available: ${usdtBalance.available})`);\r\n      }\r\n    } catch (balanceError) {\r\n      console.error('❌ Failed to get balance:', balanceError);\r\n    }\r\n\r\n    // Check current positions\r\n    console.log('\\n📊 Current Positions:');\r\n    try {\r\n      const positions = await exchange.getPositions();\r\n      console.log(`   Open Positions: ${positions.length}`);\r\n      \r\n      if (positions.length > 0) {\r\n        positions.forEach(pos => {\r\n          console.log(`   ${pos.symbol}: ${pos.side} ${pos.size} @ $${pos.entryPrice} (${pos.leverage}x)`);\r\n          console.log(`     PnL: ${pos.unrealizedPnl} (Mark: $${pos.markPrice})`);\r\n        });\r\n      } else {\r\n        console.log('   No open positions');\r\n      }\r\n    } catch (posError) {\r\n      console.error('❌ Failed to get positions:', posError);\r\n    }\r\n\r\n    console.log('\\n🎉 VERIFICATION COMPLETED!');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Verification failed:', error);\r\n  } finally {\r\n    await exchange.disconnect();\r\n    console.log('\\n🔌 Disconnected from exchange');\r\n  }\r\n}",
          "hash": "89b31ebd7fc71286006a0f2b48905dc3"
        },
        {
          "type": "function",
          "name": "runBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\sma-backtest.ts",
          "startLine": 26,
          "endLine": 180,
          "complexity": 18,
          "dependencies": [],
          "usageCount": 0,
          "size": 155,
          "content": "{\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}",
          "hash": "c0a8e331992cbf831ea3ca2272bbb9ba"
        },
        {
          "type": "function",
          "name": "runBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\sma-backtest.ts",
          "startLine": 26,
          "endLine": 180,
          "complexity": 18,
          "dependencies": [],
          "usageCount": 0,
          "size": 155,
          "content": "{\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}",
          "hash": "c0a8e331992cbf831ea3ca2272bbb9ba"
        },
        {
          "type": "function",
          "name": "runFixedBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\fixed-sma-backtest.ts",
          "startLine": 107,
          "endLine": 205,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 99,
          "content": "{\r\n  console.log('\\n----- RUNNING FIXED SMA CROSSOVER BACKTEST -----');\r\n  \r\n  // Generate sample price data with clear trends for testing\r\n  const candles = generateSampleData();\r\n  console.log(`Generated ${candles.length} sample candles`);\r\n  \r\n  // Create the fixed signal processor\r\n  const processor = new FixedSMASignalProcessor();\r\n  \r\n  // Trading state\r\n  let position: 'long' | 'short' | null = null;\r\n  let entryPrice = 0;\r\n  let totalProfit = 0;\r\n  let trades = 0;\r\n  \r\n  // Process candles with sliding window\r\n  const windowSize = 30; // Enough data for calculations\r\n  \r\n  console.log('\\nProcessing price data...');\r\n  for (let i = windowSize; i < candles.length; i++) {\r\n    // Get current window\r\n    const window = candles.slice(i - windowSize, i + 1);\r\n    \r\n    // Safety check\r\n    if (window.length === 0) {\r\n      continue;\r\n    }\r\n    \r\n    const lastCandle = window[window.length - 1];\r\n    if (!lastCandle) {\r\n      continue;\r\n    }\r\n    \r\n    const currentPrice = lastCandle.close;\r\n    console.log(`\\nWindow ${i}: Price ${currentPrice.toFixed(2)}`);\r\n    \r\n    // Process signal\r\n    const result = processor.process(window);\r\n    \r\n    // Track position and calculate P&L\r\n    if (result) {\r\n      if (result.signal > 0.7) { // Strong buy signal\r\n        if (position === 'short') {\r\n          // Close short position\r\n          const profit = entryPrice - currentPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close SHORT position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open long position\r\n          position = 'long';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open LONG position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      } else if (result.signal < -0.7) { // Strong sell signal\r\n        if (position === 'long') {\r\n          // Close long position\r\n          const profit = currentPrice - entryPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close LONG position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open short position\r\n          position = 'short';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open SHORT position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close any open position\r\n  if (position && candles.length > 0) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      const lastPrice = lastCandle.close;\r\n      const profit = position === 'long' ? \r\n        (lastPrice - entryPrice) : (entryPrice - lastPrice);\r\n      totalProfit += profit;\r\n      console.log(`Close final ${position} position at ${lastPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n    }\r\n  }\r\n  \r\n  // Print results\r\n  console.log('\\n----- BACKTEST RESULTS -----');\r\n  console.log(`Total trades: ${trades}`);\r\n  console.log(`Total profit: ${totalProfit.toFixed(2)}`);\r\n  console.log(`Final position: ${position || 'none'}`);\r\n  console.log('---------------------------\\n');\r\n}",
          "hash": "77322cfc9714c8c1f2dcf994c66daa1e"
        },
        {
          "type": "function",
          "name": "validatePerformanceMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\performance-monitoring-validation.ts",
          "startLine": 6,
          "endLine": 353,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 348,
          "content": "{\r\n  console.log('🔍 Starting Performance Monitoring and Metrics Validation...');\r\n  \r\n  try {\r\n    // Test 1: Monitoring Service Structure Validation\r\n    console.log('\\n1. Validating Monitoring Service Structure...');\r\n    \r\n    // Check for required monitoring service files\r\n    const monitoringServices = [\r\n      'strategy-monitor.service.ts',\r\n      'database-monitor.service.ts', \r\n      'exchange-monitor.service.ts',\r\n      'application-monitor.service.ts',\r\n      'system-monitor.service.ts',\r\n      'monitoring.service.ts'\r\n    ];\r\n    \r\n    console.log('✅ Monitoring services structure validated:', {\r\n      totalServices: monitoringServices.length,\r\n      servicesAvailable: monitoringServices\r\n    });\r\n    \r\n    // Test 2: Performance Metrics Structure\r\n    console.log('\\n2. Testing Performance Metrics Structure...');\r\n    \r\n    const performanceMetrics = {\r\n      timestamp: Date.now(),\r\n      apiResponseTime: 125, // ms\r\n      orderExecutionTime: 850, // ms  \r\n      webSocketLatency: 35, // ms\r\n      memoryUsage: 256, // MB\r\n      cpuUsage: 15.5, // %\r\n      activeConnections: 45,\r\n      requestsPerSecond: 12.3,\r\n      errorRate: 0.0008, // 0.08%\r\n      throughput: 1250, // requests/hour\r\n      queueDepth: 3\r\n    };\r\n    \r\n    const metricsValid = performanceMetrics.timestamp > 0 && \r\n                        performanceMetrics.apiResponseTime > 0 &&\r\n                        performanceMetrics.cpuUsage >= 0 &&\r\n                        performanceMetrics.errorRate >= 0;\r\n    \r\n    console.log('✅ Performance metrics structure validated:', {\r\n      metricsValid,\r\n      apiResponseTime: `${performanceMetrics.apiResponseTime}ms`,\r\n      orderExecutionTime: `${performanceMetrics.orderExecutionTime}ms`,\r\n      webSocketLatency: `${performanceMetrics.webSocketLatency}ms`,\r\n      memoryUsage: `${performanceMetrics.memoryUsage}MB`,\r\n      cpuUsage: `${performanceMetrics.cpuUsage}%`,\r\n      errorRate: `${(performanceMetrics.errorRate * 100).toFixed(3)}%`\r\n    });\r\n    \r\n    // Test 3: Strategy Performance Metrics\r\n    console.log('\\n3. Testing Strategy Performance Metrics...');\r\n    \r\n    const strategyMetrics = {\r\n      botId: 'test-bot-001',\r\n      strategyName: 'aether',\r\n      strategyVersion: '1.0.0',\r\n      isRunning: true,\r\n      uptime: 3600000, // 1 hour\r\n      totalTrades: 25,\r\n      winningTrades: 18,\r\n      losingTrades: 7,\r\n      totalPnL: 245.67,\r\n      dailyPnL: 45.23,\r\n      winRate: (18 / 25) * 100, // 72%\r\n      maxDrawdown: 15.5,\r\n      currentDrawdown: 2.3,\r\n      averageTradeTime: 45000,\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    const strategyMetricsValid = strategyMetrics.totalTrades === \r\n                                (strategyMetrics.winningTrades + strategyMetrics.losingTrades) &&\r\n                                strategyMetrics.winRate > 0 &&\r\n                                strategyMetrics.totalPnL !== 0;\r\n    \r\n    console.log('✅ Strategy performance metrics validated:', {\r\n      metricsValid: strategyMetricsValid,\r\n      totalTrades: strategyMetrics.totalTrades,\r\n      winRate: `${strategyMetrics.winRate.toFixed(1)}%`,\r\n      totalPnL: `$${strategyMetrics.totalPnL}`,\r\n      uptime: `${strategyMetrics.uptime / 1000}s`\r\n    });\r\n    \r\n    // Test 4: Database Health Metrics\r\n    console.log('\\n4. Testing Database Health Metrics...');\r\n    \r\n    const dbHealthMetrics = {\r\n      status: 'healthy' as const,\r\n      connections: {\r\n        active: 8,\r\n        idle: 12,\r\n        total: 20,\r\n        maxAllowed: 100,\r\n        utilizationPercentage: 20\r\n      },\r\n      queries: {\r\n        totalExecuted: 15420,\r\n        averageTime: 23.5,\r\n        slowQueries: 3,\r\n        failedQueries: 1,\r\n        queriesPerSecond: 42.3\r\n      },\r\n      performance: {\r\n        transactionsPerSecond: 38.7,\r\n        cacheHitRatio: 0.94,\r\n        indexEfficiency: 0.89\r\n      },\r\n      uptime: 7200000, // 2 hours\r\n      lastCheck: new Date()\r\n    };\r\n    \r\n    const dbHealthValid = dbHealthMetrics.status === 'healthy' &&\r\n                         dbHealthMetrics.connections.utilizationPercentage < 80 &&\r\n                         dbHealthMetrics.performance.cacheHitRatio > 0.8;\r\n    \r\n    console.log('✅ Database health metrics validated:', {\r\n      healthValid: dbHealthValid,\r\n      status: dbHealthMetrics.status,\r\n      connectionUtilization: `${dbHealthMetrics.connections.utilizationPercentage}%`,\r\n      avgQueryTime: `${dbHealthMetrics.queries.averageTime}ms`,\r\n      cacheHitRatio: `${(dbHealthMetrics.performance.cacheHitRatio * 100).toFixed(1)}%`\r\n    });\r\n    \r\n    // Test 5: Exchange Connection Metrics\r\n    console.log('\\n5. Testing Exchange Connection Metrics...');\r\n    \r\n    const exchangeMetrics = {\r\n      exchange: 'bybit',\r\n      isConnected: true,\r\n      lastPing: Date.now(),\r\n      avgLatency: 45,\r\n      errorRate: 0.001,\r\n      totalRequests: 1250,\r\n      failedRequests: 1,\r\n      rateLimitStatus: {\r\n        remaining: 980,\r\n        limit: 1000,\r\n        resetTime: Date.now() + 60000\r\n      },\r\n      apiCalls: {\r\n        perMinute: 15,\r\n        perHour: 890,\r\n        dailyLimit: 10000\r\n      }\r\n    };\r\n    \r\n    const exchangeHealthy = exchangeMetrics.isConnected &&\r\n                           exchangeMetrics.avgLatency < 200 &&\r\n                           exchangeMetrics.errorRate < 0.01 &&\r\n                           exchangeMetrics.rateLimitStatus.remaining > 100;\r\n    \r\n    console.log('✅ Exchange connection metrics validated:', {\r\n      exchangeHealthy,\r\n      exchange: exchangeMetrics.exchange,\r\n      isConnected: exchangeMetrics.isConnected,\r\n      avgLatency: `${exchangeMetrics.avgLatency}ms`,\r\n      errorRate: `${(exchangeMetrics.errorRate * 100).toFixed(3)}%`,\r\n      rateLimitRemaining: exchangeMetrics.rateLimitStatus.remaining\r\n    });\r\n    \r\n    // Test 6: System Resource Metrics\r\n    console.log('\\n6. Testing System Resource Metrics...');\r\n    \r\n    const systemMetrics = {\r\n      cpu: {\r\n        usage: 18.5, // %\r\n        cores: 8,\r\n        loadAverage: [0.45, 0.52, 0.38]\r\n      },\r\n      memory: {\r\n        total: 16384, // MB\r\n        used: 6240, // MB\r\n        free: 10144, // MB\r\n        usage: 38.1 // %\r\n      },\r\n      disk: {\r\n        total: 512000, // MB\r\n        used: 156700, // MB\r\n        free: 355300, // MB\r\n        usage: 30.6 // %\r\n      },\r\n      network: {\r\n        bytesIn: 2340000,\r\n        bytesOut: 4560000,\r\n        packetsIn: 15420,\r\n        packetsOut: 18930\r\n      }\r\n    };\r\n    \r\n    const systemHealthy = systemMetrics.cpu.usage < 80 &&\r\n                         systemMetrics.memory.usage < 85 &&\r\n                         systemMetrics.disk.usage < 90;\r\n    \r\n    console.log('✅ System resource metrics validated:', {\r\n      systemHealthy,\r\n      cpuUsage: `${systemMetrics.cpu.usage}%`,\r\n      memoryUsage: `${systemMetrics.memory.usage}%`,\r\n      diskUsage: `${systemMetrics.disk.usage}%`,\r\n      cores: systemMetrics.cpu.cores\r\n    });\r\n    \r\n    // Test 7: Performance Thresholds and Alerting\r\n    console.log('\\n7. Testing Performance Thresholds and Alerting...');\r\n    \r\n    const performanceThresholds = {\r\n      apiResponseTime: { warning: 300, critical: 500 },\r\n      orderExecutionTime: { warning: 1500, critical: 2000 },\r\n      webSocketLatency: { warning: 100, critical: 200 },\r\n      memoryUsage: { warning: 70, critical: 85 },\r\n      cpuUsage: { warning: 70, critical: 85 },\r\n      errorRate: { warning: 0.005, critical: 0.01 },\r\n      diskUsage: { warning: 80, critical: 90 }\r\n    };\r\n    \r\n    // Check current metrics against thresholds\r\n    const alertStatus = {\r\n      apiResponseTime: performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.warning ? 'good' : \r\n                      performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.critical ? 'warning' : 'critical',\r\n      \r\n      orderExecutionTime: performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.warning ? 'good' : \r\n                         performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.critical ? 'warning' : 'critical',\r\n      \r\n      cpuUsage: systemMetrics.cpu.usage < performanceThresholds.cpuUsage.warning ? 'good' : \r\n               systemMetrics.cpu.usage < performanceThresholds.cpuUsage.critical ? 'warning' : 'critical',\r\n      \r\n      memoryUsage: systemMetrics.memory.usage < performanceThresholds.memoryUsage.warning ? 'good' : \r\n                  systemMetrics.memory.usage < performanceThresholds.memoryUsage.critical ? 'warning' : 'critical',\r\n      \r\n      errorRate: performanceMetrics.errorRate < performanceThresholds.errorRate.warning ? 'good' : \r\n                performanceMetrics.errorRate < performanceThresholds.errorRate.critical ? 'warning' : 'critical'\r\n    };\r\n    \r\n    const criticalAlerts = Object.values(alertStatus).filter(status => status === 'critical').length;\r\n    const warningAlerts = Object.values(alertStatus).filter(status => status === 'warning').length;\r\n    \r\n    console.log('✅ Performance thresholds and alerting validated:', {\r\n      criticalAlerts,\r\n      warningAlerts,\r\n      overallStatus: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'good',\r\n      alertDetails: alertStatus\r\n    });\r\n    \r\n    // Test 8: Metrics Aggregation and Reporting\r\n    console.log('\\n8. Testing Metrics Aggregation and Reporting...');\r\n    \r\n    const aggregatedMetrics = {\r\n      timeWindow: '1h',\r\n      summary: {\r\n        totalRequests: 4523,\r\n        successfulRequests: 4520,\r\n        failedRequests: 3,\r\n        avgResponseTime: 142,\r\n        p95ResponseTime: 285,\r\n        p99ResponseTime: 445,\r\n        uniqueUsers: 128,\r\n        peakConcurrency: 67\r\n      },\r\n      trends: {\r\n        responseTimeTrend: 'stable', // increasing, decreasing, stable\r\n        errorRateTrend: 'decreasing',\r\n        throughputTrend: 'increasing'\r\n      },\r\n      resourceUtilization: {\r\n        cpu: { avg: 18.5, peak: 34.2, trend: 'stable' },\r\n        memory: { avg: 312, peak: 456, trend: 'stable' },\r\n        network: { in: 2.3, out: 4.7, trend: 'increasing' }\r\n      }\r\n    };\r\n    \r\n    const aggregationValid = aggregatedMetrics.summary.totalRequests === \r\n                            (aggregatedMetrics.summary.successfulRequests + aggregatedMetrics.summary.failedRequests) &&\r\n                            aggregatedMetrics.summary.avgResponseTime > 0;\r\n    \r\n    console.log('✅ Metrics aggregation and reporting validated:', {\r\n      aggregationValid,\r\n      timeWindow: aggregatedMetrics.timeWindow,\r\n      totalRequests: aggregatedMetrics.summary.totalRequests,\r\n      successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n      avgResponseTime: `${aggregatedMetrics.summary.avgResponseTime}ms`,\r\n      p95ResponseTime: `${aggregatedMetrics.summary.p95ResponseTime}ms`\r\n    });\r\n    \r\n    // Test 9: Dashboard Data Structure\r\n    console.log('\\n9. Testing Dashboard Data Structure...');\r\n    \r\n    const dashboardData = {\r\n      realTime: {\r\n        status: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'healthy',\r\n        activeUsers: 42,\r\n        requestsPerSecond: performanceMetrics.requestsPerSecond,\r\n        errorRate: performanceMetrics.errorRate,\r\n        systemLoad: systemMetrics.cpu.usage,\r\n        uptime: systemMetrics.cpu.loadAverage[0]\r\n      },\r\n      timeSeries: {\r\n        labels: ['00:00', '00:15', '00:30', '00:45', '01:00'],\r\n        datasets: {\r\n          responseTime: [120, 135, 142, 138, 125],\r\n          throughput: [10.2, 11.8, 12.3, 11.9, 10.7],\r\n          errors: [0, 1, 0, 2, 0],\r\n          cpuUsage: [15.2, 16.8, 18.5, 17.3, 15.9],\r\n          memoryUsage: [35.4, 36.2, 38.1, 37.8, 36.9]\r\n        }\r\n      },\r\n      summary: {\r\n        uptime: '99.97%',\r\n        totalTrades: strategyMetrics.totalTrades,\r\n        successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n        avgProfit: '+2.34%'\r\n      }\r\n    };\r\n    \r\n    const dashboardValid = dashboardData.timeSeries.labels.length === \r\n                          dashboardData.timeSeries.datasets.responseTime.length &&\r\n                          dashboardData.realTime.status in ['healthy', 'warning', 'critical'];\r\n    \r\n    console.log('✅ Dashboard data structure validated:', {\r\n      dashboardValid,\r\n      realTimeStatus: dashboardData.realTime.status,\r\n      activeUsers: dashboardData.realTime.activeUsers,\r\n      dataPoints: dashboardData.timeSeries.labels.length,\r\n      uptime: dashboardData.summary.uptime\r\n    });\r\n    \r\n    console.log('\\n🎉 All Performance Monitoring and Metrics Validation Tests Passed!');\r\n    console.log('\\n📊 Validation Summary:');\r\n    console.log('   ✅ Monitoring Service Infrastructure');\r\n    console.log('   ✅ Performance Metrics Collection');\r\n    console.log('   ✅ Strategy Performance Tracking');\r\n    console.log('   ✅ Database Health Monitoring');\r\n    console.log('   ✅ Exchange Connection Monitoring');\r\n    console.log('   ✅ System Resource Monitoring');\r\n    console.log('   ✅ Performance Thresholds & Alerting');\r\n    console.log('   ✅ Metrics Aggregation & Reporting');\r\n    console.log('   ✅ Dashboard Data Preparation');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Performance Monitoring Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "cadd453a97bf48586c046b2ce64e191f"
        },
        {
          "type": "function",
          "name": "runFixedBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\fixed-sma-backtest.ts",
          "startLine": 107,
          "endLine": 205,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 99,
          "content": "{\r\n  console.log('\\n----- RUNNING FIXED SMA CROSSOVER BACKTEST -----');\r\n  \r\n  // Generate sample price data with clear trends for testing\r\n  const candles = generateSampleData();\r\n  console.log(`Generated ${candles.length} sample candles`);\r\n  \r\n  // Create the fixed signal processor\r\n  const processor = new FixedSMASignalProcessor();\r\n  \r\n  // Trading state\r\n  let position: 'long' | 'short' | null = null;\r\n  let entryPrice = 0;\r\n  let totalProfit = 0;\r\n  let trades = 0;\r\n  \r\n  // Process candles with sliding window\r\n  const windowSize = 30; // Enough data for calculations\r\n  \r\n  console.log('\\nProcessing price data...');\r\n  for (let i = windowSize; i < candles.length; i++) {\r\n    // Get current window\r\n    const window = candles.slice(i - windowSize, i + 1);\r\n    \r\n    // Safety check\r\n    if (window.length === 0) {\r\n      continue;\r\n    }\r\n    \r\n    const lastCandle = window[window.length - 1];\r\n    if (!lastCandle) {\r\n      continue;\r\n    }\r\n    \r\n    const currentPrice = lastCandle.close;\r\n    console.log(`\\nWindow ${i}: Price ${currentPrice.toFixed(2)}`);\r\n    \r\n    // Process signal\r\n    const result = processor.process(window);\r\n    \r\n    // Track position and calculate P&L\r\n    if (result) {\r\n      if (result.signal > 0.7) { // Strong buy signal\r\n        if (position === 'short') {\r\n          // Close short position\r\n          const profit = entryPrice - currentPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close SHORT position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open long position\r\n          position = 'long';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open LONG position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      } else if (result.signal < -0.7) { // Strong sell signal\r\n        if (position === 'long') {\r\n          // Close long position\r\n          const profit = currentPrice - entryPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close LONG position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open short position\r\n          position = 'short';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open SHORT position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close any open position\r\n  if (position && candles.length > 0) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      const lastPrice = lastCandle.close;\r\n      const profit = position === 'long' ? \r\n        (lastPrice - entryPrice) : (entryPrice - lastPrice);\r\n      totalProfit += profit;\r\n      console.log(`Close final ${position} position at ${lastPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n    }\r\n  }\r\n  \r\n  // Print results\r\n  console.log('\\n----- BACKTEST RESULTS -----');\r\n  console.log(`Total trades: ${trades}`);\r\n  console.log(`Total profit: ${totalProfit.toFixed(2)}`);\r\n  console.log(`Final position: ${position || 'none'}`);\r\n  console.log('---------------------------\\n');\r\n}",
          "hash": "77322cfc9714c8c1f2dcf994c66daa1e"
        },
        {
          "type": "function",
          "name": "validatePerformanceMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\performance-monitoring-validation.ts",
          "startLine": 6,
          "endLine": 353,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 348,
          "content": "{\r\n  console.log('🔍 Starting Performance Monitoring and Metrics Validation...');\r\n  \r\n  try {\r\n    // Test 1: Monitoring Service Structure Validation\r\n    console.log('\\n1. Validating Monitoring Service Structure...');\r\n    \r\n    // Check for required monitoring service files\r\n    const monitoringServices = [\r\n      'strategy-monitor.service.ts',\r\n      'database-monitor.service.ts', \r\n      'exchange-monitor.service.ts',\r\n      'application-monitor.service.ts',\r\n      'system-monitor.service.ts',\r\n      'monitoring.service.ts'\r\n    ];\r\n    \r\n    console.log('✅ Monitoring services structure validated:', {\r\n      totalServices: monitoringServices.length,\r\n      servicesAvailable: monitoringServices\r\n    });\r\n    \r\n    // Test 2: Performance Metrics Structure\r\n    console.log('\\n2. Testing Performance Metrics Structure...');\r\n    \r\n    const performanceMetrics = {\r\n      timestamp: Date.now(),\r\n      apiResponseTime: 125, // ms\r\n      orderExecutionTime: 850, // ms  \r\n      webSocketLatency: 35, // ms\r\n      memoryUsage: 256, // MB\r\n      cpuUsage: 15.5, // %\r\n      activeConnections: 45,\r\n      requestsPerSecond: 12.3,\r\n      errorRate: 0.0008, // 0.08%\r\n      throughput: 1250, // requests/hour\r\n      queueDepth: 3\r\n    };\r\n    \r\n    const metricsValid = performanceMetrics.timestamp > 0 && \r\n                        performanceMetrics.apiResponseTime > 0 &&\r\n                        performanceMetrics.cpuUsage >= 0 &&\r\n                        performanceMetrics.errorRate >= 0;\r\n    \r\n    console.log('✅ Performance metrics structure validated:', {\r\n      metricsValid,\r\n      apiResponseTime: `${performanceMetrics.apiResponseTime}ms`,\r\n      orderExecutionTime: `${performanceMetrics.orderExecutionTime}ms`,\r\n      webSocketLatency: `${performanceMetrics.webSocketLatency}ms`,\r\n      memoryUsage: `${performanceMetrics.memoryUsage}MB`,\r\n      cpuUsage: `${performanceMetrics.cpuUsage}%`,\r\n      errorRate: `${(performanceMetrics.errorRate * 100).toFixed(3)}%`\r\n    });\r\n    \r\n    // Test 3: Strategy Performance Metrics\r\n    console.log('\\n3. Testing Strategy Performance Metrics...');\r\n    \r\n    const strategyMetrics = {\r\n      botId: 'test-bot-001',\r\n      strategyName: 'aether',\r\n      strategyVersion: '1.0.0',\r\n      isRunning: true,\r\n      uptime: 3600000, // 1 hour\r\n      totalTrades: 25,\r\n      winningTrades: 18,\r\n      losingTrades: 7,\r\n      totalPnL: 245.67,\r\n      dailyPnL: 45.23,\r\n      winRate: (18 / 25) * 100, // 72%\r\n      maxDrawdown: 15.5,\r\n      currentDrawdown: 2.3,\r\n      averageTradeTime: 45000,\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    const strategyMetricsValid = strategyMetrics.totalTrades === \r\n                                (strategyMetrics.winningTrades + strategyMetrics.losingTrades) &&\r\n                                strategyMetrics.winRate > 0 &&\r\n                                strategyMetrics.totalPnL !== 0;\r\n    \r\n    console.log('✅ Strategy performance metrics validated:', {\r\n      metricsValid: strategyMetricsValid,\r\n      totalTrades: strategyMetrics.totalTrades,\r\n      winRate: `${strategyMetrics.winRate.toFixed(1)}%`,\r\n      totalPnL: `$${strategyMetrics.totalPnL}`,\r\n      uptime: `${strategyMetrics.uptime / 1000}s`\r\n    });\r\n    \r\n    // Test 4: Database Health Metrics\r\n    console.log('\\n4. Testing Database Health Metrics...');\r\n    \r\n    const dbHealthMetrics = {\r\n      status: 'healthy' as const,\r\n      connections: {\r\n        active: 8,\r\n        idle: 12,\r\n        total: 20,\r\n        maxAllowed: 100,\r\n        utilizationPercentage: 20\r\n      },\r\n      queries: {\r\n        totalExecuted: 15420,\r\n        averageTime: 23.5,\r\n        slowQueries: 3,\r\n        failedQueries: 1,\r\n        queriesPerSecond: 42.3\r\n      },\r\n      performance: {\r\n        transactionsPerSecond: 38.7,\r\n        cacheHitRatio: 0.94,\r\n        indexEfficiency: 0.89\r\n      },\r\n      uptime: 7200000, // 2 hours\r\n      lastCheck: new Date()\r\n    };\r\n    \r\n    const dbHealthValid = dbHealthMetrics.status === 'healthy' &&\r\n                         dbHealthMetrics.connections.utilizationPercentage < 80 &&\r\n                         dbHealthMetrics.performance.cacheHitRatio > 0.8;\r\n    \r\n    console.log('✅ Database health metrics validated:', {\r\n      healthValid: dbHealthValid,\r\n      status: dbHealthMetrics.status,\r\n      connectionUtilization: `${dbHealthMetrics.connections.utilizationPercentage}%`,\r\n      avgQueryTime: `${dbHealthMetrics.queries.averageTime}ms`,\r\n      cacheHitRatio: `${(dbHealthMetrics.performance.cacheHitRatio * 100).toFixed(1)}%`\r\n    });\r\n    \r\n    // Test 5: Exchange Connection Metrics\r\n    console.log('\\n5. Testing Exchange Connection Metrics...');\r\n    \r\n    const exchangeMetrics = {\r\n      exchange: 'bybit',\r\n      isConnected: true,\r\n      lastPing: Date.now(),\r\n      avgLatency: 45,\r\n      errorRate: 0.001,\r\n      totalRequests: 1250,\r\n      failedRequests: 1,\r\n      rateLimitStatus: {\r\n        remaining: 980,\r\n        limit: 1000,\r\n        resetTime: Date.now() + 60000\r\n      },\r\n      apiCalls: {\r\n        perMinute: 15,\r\n        perHour: 890,\r\n        dailyLimit: 10000\r\n      }\r\n    };\r\n    \r\n    const exchangeHealthy = exchangeMetrics.isConnected &&\r\n                           exchangeMetrics.avgLatency < 200 &&\r\n                           exchangeMetrics.errorRate < 0.01 &&\r\n                           exchangeMetrics.rateLimitStatus.remaining > 100;\r\n    \r\n    console.log('✅ Exchange connection metrics validated:', {\r\n      exchangeHealthy,\r\n      exchange: exchangeMetrics.exchange,\r\n      isConnected: exchangeMetrics.isConnected,\r\n      avgLatency: `${exchangeMetrics.avgLatency}ms`,\r\n      errorRate: `${(exchangeMetrics.errorRate * 100).toFixed(3)}%`,\r\n      rateLimitRemaining: exchangeMetrics.rateLimitStatus.remaining\r\n    });\r\n    \r\n    // Test 6: System Resource Metrics\r\n    console.log('\\n6. Testing System Resource Metrics...');\r\n    \r\n    const systemMetrics = {\r\n      cpu: {\r\n        usage: 18.5, // %\r\n        cores: 8,\r\n        loadAverage: [0.45, 0.52, 0.38]\r\n      },\r\n      memory: {\r\n        total: 16384, // MB\r\n        used: 6240, // MB\r\n        free: 10144, // MB\r\n        usage: 38.1 // %\r\n      },\r\n      disk: {\r\n        total: 512000, // MB\r\n        used: 156700, // MB\r\n        free: 355300, // MB\r\n        usage: 30.6 // %\r\n      },\r\n      network: {\r\n        bytesIn: 2340000,\r\n        bytesOut: 4560000,\r\n        packetsIn: 15420,\r\n        packetsOut: 18930\r\n      }\r\n    };\r\n    \r\n    const systemHealthy = systemMetrics.cpu.usage < 80 &&\r\n                         systemMetrics.memory.usage < 85 &&\r\n                         systemMetrics.disk.usage < 90;\r\n    \r\n    console.log('✅ System resource metrics validated:', {\r\n      systemHealthy,\r\n      cpuUsage: `${systemMetrics.cpu.usage}%`,\r\n      memoryUsage: `${systemMetrics.memory.usage}%`,\r\n      diskUsage: `${systemMetrics.disk.usage}%`,\r\n      cores: systemMetrics.cpu.cores\r\n    });\r\n    \r\n    // Test 7: Performance Thresholds and Alerting\r\n    console.log('\\n7. Testing Performance Thresholds and Alerting...');\r\n    \r\n    const performanceThresholds = {\r\n      apiResponseTime: { warning: 300, critical: 500 },\r\n      orderExecutionTime: { warning: 1500, critical: 2000 },\r\n      webSocketLatency: { warning: 100, critical: 200 },\r\n      memoryUsage: { warning: 70, critical: 85 },\r\n      cpuUsage: { warning: 70, critical: 85 },\r\n      errorRate: { warning: 0.005, critical: 0.01 },\r\n      diskUsage: { warning: 80, critical: 90 }\r\n    };\r\n    \r\n    // Check current metrics against thresholds\r\n    const alertStatus = {\r\n      apiResponseTime: performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.warning ? 'good' : \r\n                      performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.critical ? 'warning' : 'critical',\r\n      \r\n      orderExecutionTime: performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.warning ? 'good' : \r\n                         performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.critical ? 'warning' : 'critical',\r\n      \r\n      cpuUsage: systemMetrics.cpu.usage < performanceThresholds.cpuUsage.warning ? 'good' : \r\n               systemMetrics.cpu.usage < performanceThresholds.cpuUsage.critical ? 'warning' : 'critical',\r\n      \r\n      memoryUsage: systemMetrics.memory.usage < performanceThresholds.memoryUsage.warning ? 'good' : \r\n                  systemMetrics.memory.usage < performanceThresholds.memoryUsage.critical ? 'warning' : 'critical',\r\n      \r\n      errorRate: performanceMetrics.errorRate < performanceThresholds.errorRate.warning ? 'good' : \r\n                performanceMetrics.errorRate < performanceThresholds.errorRate.critical ? 'warning' : 'critical'\r\n    };\r\n    \r\n    const criticalAlerts = Object.values(alertStatus).filter(status => status === 'critical').length;\r\n    const warningAlerts = Object.values(alertStatus).filter(status => status === 'warning').length;\r\n    \r\n    console.log('✅ Performance thresholds and alerting validated:', {\r\n      criticalAlerts,\r\n      warningAlerts,\r\n      overallStatus: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'good',\r\n      alertDetails: alertStatus\r\n    });\r\n    \r\n    // Test 8: Metrics Aggregation and Reporting\r\n    console.log('\\n8. Testing Metrics Aggregation and Reporting...');\r\n    \r\n    const aggregatedMetrics = {\r\n      timeWindow: '1h',\r\n      summary: {\r\n        totalRequests: 4523,\r\n        successfulRequests: 4520,\r\n        failedRequests: 3,\r\n        avgResponseTime: 142,\r\n        p95ResponseTime: 285,\r\n        p99ResponseTime: 445,\r\n        uniqueUsers: 128,\r\n        peakConcurrency: 67\r\n      },\r\n      trends: {\r\n        responseTimeTrend: 'stable', // increasing, decreasing, stable\r\n        errorRateTrend: 'decreasing',\r\n        throughputTrend: 'increasing'\r\n      },\r\n      resourceUtilization: {\r\n        cpu: { avg: 18.5, peak: 34.2, trend: 'stable' },\r\n        memory: { avg: 312, peak: 456, trend: 'stable' },\r\n        network: { in: 2.3, out: 4.7, trend: 'increasing' }\r\n      }\r\n    };\r\n    \r\n    const aggregationValid = aggregatedMetrics.summary.totalRequests === \r\n                            (aggregatedMetrics.summary.successfulRequests + aggregatedMetrics.summary.failedRequests) &&\r\n                            aggregatedMetrics.summary.avgResponseTime > 0;\r\n    \r\n    console.log('✅ Metrics aggregation and reporting validated:', {\r\n      aggregationValid,\r\n      timeWindow: aggregatedMetrics.timeWindow,\r\n      totalRequests: aggregatedMetrics.summary.totalRequests,\r\n      successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n      avgResponseTime: `${aggregatedMetrics.summary.avgResponseTime}ms`,\r\n      p95ResponseTime: `${aggregatedMetrics.summary.p95ResponseTime}ms`\r\n    });\r\n    \r\n    // Test 9: Dashboard Data Structure\r\n    console.log('\\n9. Testing Dashboard Data Structure...');\r\n    \r\n    const dashboardData = {\r\n      realTime: {\r\n        status: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'healthy',\r\n        activeUsers: 42,\r\n        requestsPerSecond: performanceMetrics.requestsPerSecond,\r\n        errorRate: performanceMetrics.errorRate,\r\n        systemLoad: systemMetrics.cpu.usage,\r\n        uptime: systemMetrics.cpu.loadAverage[0]\r\n      },\r\n      timeSeries: {\r\n        labels: ['00:00', '00:15', '00:30', '00:45', '01:00'],\r\n        datasets: {\r\n          responseTime: [120, 135, 142, 138, 125],\r\n          throughput: [10.2, 11.8, 12.3, 11.9, 10.7],\r\n          errors: [0, 1, 0, 2, 0],\r\n          cpuUsage: [15.2, 16.8, 18.5, 17.3, 15.9],\r\n          memoryUsage: [35.4, 36.2, 38.1, 37.8, 36.9]\r\n        }\r\n      },\r\n      summary: {\r\n        uptime: '99.97%',\r\n        totalTrades: strategyMetrics.totalTrades,\r\n        successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n        avgProfit: '+2.34%'\r\n      }\r\n    };\r\n    \r\n    const dashboardValid = dashboardData.timeSeries.labels.length === \r\n                          dashboardData.timeSeries.datasets.responseTime.length &&\r\n                          dashboardData.realTime.status in ['healthy', 'warning', 'critical'];\r\n    \r\n    console.log('✅ Dashboard data structure validated:', {\r\n      dashboardValid,\r\n      realTimeStatus: dashboardData.realTime.status,\r\n      activeUsers: dashboardData.realTime.activeUsers,\r\n      dataPoints: dashboardData.timeSeries.labels.length,\r\n      uptime: dashboardData.summary.uptime\r\n    });\r\n    \r\n    console.log('\\n🎉 All Performance Monitoring and Metrics Validation Tests Passed!');\r\n    console.log('\\n📊 Validation Summary:');\r\n    console.log('   ✅ Monitoring Service Infrastructure');\r\n    console.log('   ✅ Performance Metrics Collection');\r\n    console.log('   ✅ Strategy Performance Tracking');\r\n    console.log('   ✅ Database Health Monitoring');\r\n    console.log('   ✅ Exchange Connection Monitoring');\r\n    console.log('   ✅ System Resource Monitoring');\r\n    console.log('   ✅ Performance Thresholds & Alerting');\r\n    console.log('   ✅ Metrics Aggregation & Reporting');\r\n    console.log('   ✅ Dashboard Data Preparation');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Performance Monitoring Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "cadd453a97bf48586c046b2ce64e191f"
        },
        {
          "type": "function",
          "name": "downloadHistoricalData",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\data-service.ts",
          "startLine": 22,
          "endLine": 80,
          "complexity": 16,
          "dependencies": [],
          "usageCount": 0,
          "size": 59,
          "content": "{\r\n  // Validate and sanitize inputs\r\n  if (!symbol || typeof symbol !== 'string') {\r\n    throw new Error('Invalid symbol provided');\r\n  }\r\n  if (!timeframe || typeof timeframe !== 'string') {\r\n    throw new Error('Invalid timeframe provided');\r\n  }\r\n  \r\n  // Normalize symbol for file naming (remove dangerous characters)\r\n  const normalizedSymbol = symbol.replace(/[^a-zA-Z0-9_-]/g, '_');\r\n  const normalizedTimeframe = timeframe.replace(/[^a-zA-Z0-9_-]/g, '_');\r\n  const cacheFileName = `${normalizedSymbol}_${normalizedTimeframe}_${startTime}_${endTime}.json`;\r\n  \r\n  // Validate that cache directory is within allowed bounds\r\n  const resolvedCacheDir = path.resolve(cacheDir);\r\n  const resolvedBasePath = path.resolve(DEFAULT_DATA_DIR);\r\n  if (!resolvedCacheDir.startsWith(resolvedBasePath)) {\r\n    throw new Error('Invalid cache directory path');\r\n  }\r\n  \r\n  const cachePath = path.join(resolvedCacheDir, path.basename(cacheFileName));\r\n  \r\n  // Try to load from cache first\r\n  try {\r\n    await fs.mkdir(cacheDir, { recursive: true });\r\n    \r\n    try {\r\n      const cacheFile = await fs.readFile(cachePath, 'utf8');\r\n      const cachedData = JSON.parse(cacheFile);\r\n      logger.info(`Loaded ${cachedData.length} candles from cache for ${symbol} ${timeframe}`);\r\n      return cachedData;\r\n    } catch (err) {\r\n      // Cache file doesn't exist, continue to download\r\n      logger.debug(`No cache found for ${symbol} ${timeframe}, downloading...`);\r\n    }\r\n  } catch (err) {\r\n    logger.warn(`Could not create cache directory: ${err instanceof Error ? err.message : String(err)}`);\r\n  }\r\n  \r\n  try {\r\n    // For this example, we'll generate mock data\r\n    // In production, you would fetch from an exchange API\r\n    const candles = generateMockCandles(symbol, timeframe, startTime, endTime);\r\n    \r\n    // Save to cache\r\n    try {\r\n      await fs.writeFile(cachePath, JSON.stringify(candles));\r\n      logger.debug(`Saved ${candles.length} candles to cache for ${symbol} ${timeframe}`);\r\n    } catch (err) {\r\n      logger.warn(`Could not save to cache: ${err instanceof Error ? err.message : String(err)}`);\r\n    }\r\n    \r\n    return candles;\r\n  } catch (error) {\r\n    logger.error(`Failed to download historical data: ${error instanceof Error ? error.message : String(error)}`);\r\n    throw new Error(`Failed to download historical data for ${symbol} ${timeframe}`);\r\n  }\r\n}",
          "hash": "50643f25ac9165b3f32f769fa0b7462c"
        },
        {
          "type": "function",
          "name": "main",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 908,
          "endLine": 988,
          "complexity": 16,
          "dependencies": [],
          "usageCount": 0,
          "size": 81,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    // Parse command line arguments\r\n    const args = process.argv.slice(2);\r\n    const helpFlag = args.includes('--help') || args.includes('-h');\r\n    \r\n    if (helpFlag) {\r\n      printUsage();\r\n      return;\r\n    }\r\n\r\n    const options: Partial<DocValidationOptions> = {};\r\n    \r\n    // Parse options\r\n    if (args.includes('--check-external-links')) {\r\n      options.checkExternalLinks = true;\r\n    }\r\n    \r\n    if (args.includes('--strict')) {\r\n      options.strictMode = true;\r\n    }\r\n    \r\n    if (args.includes('--skip-code-refs')) {\r\n      options.validateCodeReferences = false;\r\n    }\r\n    \r\n    // Get target directory\r\n    let targetDir = process.cwd();\r\n    for (let i = args.length - 1; i >= 0; i--) {\r\n      if (!args[i].startsWith('-') && fs.existsSync(args[i])) {\r\n        targetDir = path.resolve(args[i]);\r\n        break;\r\n      }\r\n    }\r\n    \r\n    console.log('📚 Comprehensive Documentation Validator');\r\n    console.log(`⚙️ Configuration:`);\r\n    console.log(`   Check External Links: ${options.checkExternalLinks ?? DEFAULT_OPTIONS.checkExternalLinks}`);\r\n    console.log(`   Validate Code References: ${options.validateCodeReferences ?? DEFAULT_OPTIONS.validateCodeReferences}`);\r\n    console.log(`   Strict Mode: ${options.strictMode ?? DEFAULT_OPTIONS.strictMode}`);\r\n    \r\n    // Run validation\r\n    const validator = new ComprehensiveDocumentationValidator(options);\r\n    const report = await validator.validate(targetDir);\r\n    \r\n    // Generate report\r\n    DocumentationReporter.generateReport(report);\r\n    \r\n    // Save detailed report\r\n    const reportsDir = path.join(process.cwd(), 'reports', 'quality');\r\n    if (!fs.existsSync(reportsDir)) {\r\n      fs.mkdirSync(reportsDir, { recursive: true });\r\n    }\r\n    \r\n    const timestamp = new Date().toISOString().split('T')[0];\r\n    const reportPath = path.join(reportsDir, `documentation-validation-${timestamp}.json`);\r\n    DocumentationReporter.saveReportToFile(report, reportPath);\r\n    \r\n    const endTime = Date.now();\r\n    const duration = ((endTime - startTime) / 1000).toFixed(2);\r\n    console.log(`\\n⏱️ Validation completed in ${duration} seconds`);\r\n    \r\n    // Exit with appropriate code\r\n    const hasErrors = report.summary.errors > 0;\r\n    const hasWarnings = report.summary.warnings > 0;\r\n    \r\n    if (hasErrors) {\r\n      process.exit(1);\r\n    } else if (hasWarnings && options.strictMode) {\r\n      process.exit(1);\r\n    } else {\r\n      process.exit(0);\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Error during documentation validation:', error);\r\n    process.exit(1);\r\n  }\r\n}",
          "hash": "8b95ebebf71d0721b66a132fdc0d7be4"
        },
        {
          "type": "function",
          "name": "handleStrategyUpdate",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx",
          "startLine": 67,
          "endLine": 124,
          "complexity": 15,
          "dependencies": [],
          "usageCount": 0,
          "size": 58,
          "content": "{\r\n    const { type, botId: updateBotId, data, timestamp } = update;\r\n\r\n    // Filter by specific bot if specified\r\n    if (botId && updateBotId !== botId) {return;}\r\n\r\n    switch (type) {\r\n      case 'performance':\r\n        if (data.metrics) {\r\n          setStrategies(prev => ({\r\n            ...prev,\r\n            [updateBotId]: data.metrics\r\n          }));\r\n        }\r\n        break;\r\n\r\n      case 'signal':\r\n        if (data.signal) {\r\n          setRecentSignals(prev => {\r\n            // Keep last 20 signals\r\n            return [data.signal, ...prev].slice(0, 20);\r\n          });\r\n        }\r\n        break;\r\n\r\n      case 'trade':\r\n        // Update strategy metrics if trade data includes metrics\r\n        if (data.metrics) {\r\n          setStrategies(prev => ({\r\n            ...prev,\r\n            [updateBotId]: data.metrics\r\n          }));\r\n        }\r\n        break;\r\n\r\n      case 'state_change':\r\n        if (data.metrics) {\r\n          setStrategies(prev => ({\r\n            ...prev,\r\n            [updateBotId]: data.metrics\r\n          }));\r\n        }\r\n        break;\r\n\r\n      case 'risk_alert':\r\n        if (data.alerts) {\r\n          setRiskAlerts(prev => {\r\n            const newAlert = {\r\n              botId: updateBotId,\r\n              alerts: data.alerts,\r\n              timestamp: new Date(timestamp)\r\n            };\r\n            return [newAlert, ...prev].slice(0, 10); // Keep last 10 alerts\r\n          });\r\n        }\r\n        break;\r\n    }\r\n  }",
          "hash": "08074bd53a0cb53d7cafe60583f773d3"
        },
        {
          "type": "function",
          "name": "processAndTrade",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 75,
          "endLine": 178,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 104,
          "content": "{\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}",
          "hash": "dfba8b52503986219f2d6be3a07b5c4b"
        },
        {
          "type": "function",
          "name": "testCorrectBybitFormat",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\test-bybit-formats.ts",
          "startLine": 6,
          "endLine": 108,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 103,
          "content": "{\r\n  console.log('🔍 Testing with CORRECT Bybit V5 WebSocket API format...\\n');\r\n\r\n  const client = new BybitWebSocketClient(true); // Use testnet\r\n  let dataReceived = 0;\r\n  let connectionOpened = false;\r\n\r\n  // Set up detailed event listeners\r\n  client.on('connected', () => {\r\n    console.log('✅ Connected to Bybit testnet WebSocket');\r\n    connectionOpened = true;\r\n    \r\n    // Test different subscription formats based on Bybit V5 API\r\n    console.log('\\n📺 Testing various subscription formats...');\r\n    \r\n    // Format 1: tickers.BTCUSDT (our current format)\r\n    console.log('1. Testing: tickers.BTCUSDT');\r\n    client.subscribe('tickers', 'BTCUSDT');\r\n    \r\n    setTimeout(() => {\r\n      // Format 2: publicTrade.BTCUSDT\r\n      console.log('2. Testing: publicTrade.BTCUSDT');\r\n      client.subscribe('publicTrade', 'BTCUSDT');\r\n    }, 2000);\r\n    \r\n    setTimeout(() => {\r\n      // Format 3: orderbook.1.BTCUSDT (depth 1)\r\n      console.log('3. Testing: orderbook.1.BTCUSDT');\r\n      client.subscribe('orderbook.1', 'BTCUSDT');\r\n    }, 4000);\r\n    \r\n    setTimeout(() => {\r\n      // Format 4: kline.1.BTCUSDT (1-minute kline)\r\n      console.log('4. Testing: kline.1.BTCUSDT');\r\n      client.subscribe('kline.1', 'BTCUSDT');\r\n    }, 6000);\r\n  });\r\n\r\n  client.on('error', (error) => {\r\n    console.error('❌ WebSocket error:', error.message);\r\n  });\r\n\r\n  client.on('data', (data) => {\r\n    dataReceived++;\r\n    console.log(`\\n📊 [${dataReceived}] REAL DATA RECEIVED!`);\r\n    console.log('Topic:', data.topic);\r\n    console.log('Type:', data.type);\r\n    console.log('Timestamp:', new Date().toISOString());\r\n    \r\n    if (data.data) {\r\n      console.log('Data sample:', JSON.stringify(data.data, null, 2).slice(0, 300) + '...');\r\n    }\r\n  });\r\n\r\n  // Listen for specific events\r\n  client.on('ticker', (tickerData) => {\r\n    console.log(`\\n🎯 TICKER DATA for ${tickerData.symbol}:`, tickerData.data);\r\n  });\r\n\r\n  client.on('trade', (tradeData) => {\r\n    console.log(`\\n💰 TRADE DATA for ${tradeData.symbol}:`, tradeData);\r\n  });\r\n\r\n  client.on('orderbook', (orderbookData) => {\r\n    console.log(`\\n📚 ORDERBOOK DATA for ${orderbookData.symbol}:`, {\r\n      bids: orderbookData.bids.slice(0, 3),\r\n      asks: orderbookData.asks.slice(0, 3)\r\n    });\r\n  });\r\n\r\n  client.on('disconnected', () => {\r\n    console.log('🔌 Disconnected from Bybit WebSocket');\r\n  });\r\n\r\n  try {\r\n    // Connect\r\n    console.log('📡 Connecting to Bybit testnet...');\r\n    await client.connect();\r\n    \r\n    // Wait for data for 20 seconds\r\n    console.log('⏳ Waiting for market data (20 seconds)...\\n');\r\n    await new Promise(resolve => setTimeout(resolve, 20000));\r\n    \r\n    // Report results\r\n    console.log('\\n' + '='.repeat(50));\r\n    console.log('📈 FINAL TEST RESULTS:');\r\n    console.log(`- Connection opened: ${connectionOpened ? '✅ YES' : '❌ NO'}`);\r\n    console.log(`- Total data messages: ${dataReceived}`);\r\n    \r\n    if (dataReceived > 0) {\r\n      console.log('🎉 SUCCESS: Real market data is flowing!');\r\n    } else {\r\n      console.log('🔍 NO DATA: Check subscription format or market activity');\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('💥 Test failed:', error instanceof Error ? error.message : error);\r\n  } finally {\r\n    // Cleanup\r\n    client.disconnect();\r\n    setTimeout(() => process.exit(0), 2000);\r\n  }\r\n}",
          "hash": "1a74ab743cc1116e7fe22568a3298baf"
        },
        {
          "type": "function",
          "name": "runTest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts",
          "startLine": 68,
          "endLine": 203,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 136,
          "content": "{\r\n  console.log('Starting SMA Crossover Strategy Test');\r\n  console.log(`Settings: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 100,\r\n    volatility: 0.01,\r\n    trendStrength: 0.008,\r\n    trendChangeProbability: 0.1\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-test-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Report saved to sma-test-report.json');\r\n}",
          "hash": "4764ff35836dfe3aed8ed450668b95a8"
        },
        {
          "type": "function",
          "name": "testFuturesPositionModify",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-futures-position-modify.ts",
          "startLine": 2,
          "endLine": 138,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 137,
          "content": "{\r\n  console.log('🔥 SPARTAN BEAST MODE: FULL FUTURES PARAMETER TEST');\r\n  console.log('==================================================');\r\n\r\n  // Mainnet credentials (safe for small test)\r\n  const apiKey = {\r\n    id: 'mainnet-key-1',\r\n    userId: 'mainnet-user',\r\n    exchange: 'bybit' as const,\r\n    keyName: 'Mainnet Key',\r\n    apiKey: '3TZG3zGNOZBa5Fnuck',\r\n    apiSecret: 'k2loWLXJhswTajZvGhwdW98soSGL87BjDIWI',\r\n    sandbox: false,\r\n    permissions: ['trade', 'read'],\r\n    isActive: true,\r\n    createdAt: new Date(),\r\n    updatedAt: new Date()\r\n  };\r\n\r\n  const exchange = new BybitExchange(apiKey, false);\r\n\r\n  try {\r\n    // Connect\r\n    console.log('\\n🔌 Connecting to Bybit MAINNET...');\r\n    await exchange.connect();\r\n    console.log('✅ Connected successfully!');\r\n\r\n    // Set leverage and margin mode\r\n    console.log('\\n⚡ Setting leverage and margin mode...');\r\n    try {\r\n      await exchange.setLeverage('BTCUSDT', 10);\r\n      await exchange.setMarginMode('BTCUSDT', 'isolated');\r\n      await exchange.setPositionMode('hedge');\r\n      console.log('✅ Leverage set to 10x, margin mode set to isolated, position mode set to hedge');\r\n    } catch (error) {\r\n      console.error('❌ Failed to set leverage/margin/position mode:', error);\r\n    }\r\n\r\n    // Place a limit order with all advanced parameters\r\n    console.log('\\n📝 Placing advanced limit order (BUY 0.001 BTCUSDT, reduceOnly, GTC, clientOrderId, TIF)...');\r\n    let limitOrder;\r\n    try {\r\n      const marketData = await exchange.getMarketData('BTCUSDT', MarketType.FUTURES);\r\n      const limitPrice = marketData.price * 0.99;\r\n      limitOrder = await exchange.placeOrder({\r\n        symbol: 'BTCUSDT',\r\n        side: 'buy',\r\n        type: 'limit',\r\n        amount: 0.001,\r\n        price: limitPrice,\r\n        marketType: MarketType.FUTURES,\r\n        reduceOnly: true,\r\n        timeInForce: 'GTC',\r\n        clientOrderId: `spartan-${Date.now()}`\r\n      });\r\n      console.log('✅ Advanced limit order placed:', limitOrder);\r\n    } catch (error) {\r\n      console.error('❌ Advanced limit order failed:', error);\r\n    }\r\n\r\n    // Place a stop-limit order with stopPrice and triggerDirection\r\n    console.log('\\n📝 Placing stop-limit order (SELL 0.001 BTCUSDT, stopPrice, triggerDirection)...');\r\n    let stopLimitOrder;\r\n    try {\r\n      const marketData = await exchange.getMarketData('BTCUSDT', MarketType.FUTURES);\r\n      const stopPrice = marketData.price * 0.98;\r\n      const limitPrice = stopPrice * 0.99;\r\n      stopLimitOrder = await exchange.placeOrder({\r\n        symbol: 'BTCUSDT',\r\n        side: 'sell',\r\n        type: 'stop-limit',\r\n        amount: 0.001,\r\n        price: limitPrice,\r\n        stopPrice,\r\n        marketType: MarketType.FUTURES,\r\n        // Bybit/CCXT: add triggerDirection param in params\r\n        // params: { triggerDirection: 'below' }\r\n      });\r\n      console.log('✅ Stop-limit order placed:', stopLimitOrder);\r\n    } catch (error) {\r\n      console.error('❌ Stop-limit order failed:', error);\r\n    }\r\n\r\n    // Place a trailing stop order (if supported)\r\n    console.log('\\n📝 Placing trailing stop order (SELL 0.001 BTCUSDT, trailing)...');\r\n    try {\r\n      // Bybit/CCXT: trailing stop is not always supported, but we simulate the params\r\n      // params: { trailingPercent: 0.5 }\r\n      // This is a placeholder for exchanges that support it\r\n      console.log('   Trailing stop order simulation (not all exchanges support trailing)');\r\n    } catch (error) {\r\n      console.error('❌ Trailing stop order failed:', error);\r\n    }\r\n\r\n    // Check open positions\r\n    console.log('\\n📊 Checking open positions...');\r\n    try {\r\n      const positionsNow = await exchange.getPositions();\r\n      if (positionsNow.length > 0) {\r\n        positionsNow.forEach(pos => {\r\n          console.log(`   ${pos.symbol}: ${pos.side} ${pos.size} @ $${pos.entryPrice} (${pos.leverage}x)`);\r\n          console.log(`     PnL: ${pos.unrealizedPnl} (Mark: $${pos.markPrice})`);\r\n        });\r\n      } else {\r\n        console.log('   No open positions');\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Failed to get positions:', error);\r\n    }\r\n\r\n    // Cancel all open orders\r\n    console.log('\\n🚫 Cancelling all open orders...');\r\n    try {\r\n      await exchange.cancelAllOrders('BTCUSDT', MarketType.FUTURES);\r\n      console.log('✅ All open orders cancelled');\r\n    } catch (error) {\r\n      console.error('❌ Failed to cancel all orders:', error);\r\n    }\r\n\r\n    // Final positions and balance\r\n    console.log('\\n📊 Final positions and balance:');\r\n    try {\r\n      const positionsNow = await exchange.getPositions();\r\n      const balance = await exchange.getBalance(MarketType.FUTURES);\r\n      console.log('   Positions:', positionsNow);\r\n      console.log('   Balance:', balance);\r\n    } catch (error) {\r\n      console.error('❌ Final check failed:', error);\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Position modification test failed:', error);\r\n  } finally {\r\n    await exchange.disconnect();\r\n    console.log('\\n🔌 Disconnected from exchange');\r\n  }\r\n}",
          "hash": "a5d35bfd2123fe33efc781ddb334b413"
        },
        {
          "type": "function",
          "name": "main",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\duplicate-method-detector.ts",
          "startLine": 659,
          "endLine": 740,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 82,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    // Parse command line arguments\r\n    const args = process.argv.slice(2);\r\n    const helpFlag = args.includes('--help') || args.includes('-h');\r\n    \r\n    if (helpFlag) {\r\n      printUsage();\r\n      return;\r\n    }\r\n\r\n    const options: Partial<DetectionOptions> = {};\r\n    \r\n    // Parse options\r\n    const thresholdIndex = args.indexOf('--threshold');\r\n    if (thresholdIndex !== -1 && args[thresholdIndex + 1]) {\r\n      options.similarityThreshold = parseFloat(args[thresholdIndex + 1]);\r\n    }\r\n    \r\n    const minLengthIndex = args.indexOf('--min-length');\r\n    if (minLengthIndex !== -1 && args[minLengthIndex + 1]) {\r\n      options.minMethodLength = parseInt(args[minLengthIndex + 1]);\r\n    }\r\n    \r\n    const includePrivateFlag = args.includes('--include-private');\r\n    if (includePrivateFlag) {\r\n      options.includePrivateMethods = true;\r\n    }\r\n    \r\n    const includeGettersSettersFlag = args.includes('--include-getters-setters');\r\n    if (includeGettersSettersFlag) {\r\n      options.includeGettersSetters = true;\r\n    }\r\n\r\n    // Get target directory (last non-option argument)\r\n    let targetDir = process.cwd();\r\n    for (let i = args.length - 1; i >= 0; i--) {\r\n      if (!args[i].startsWith('-') && !args[i].match(/^\\d+(\\.\\d+)?$/)) {\r\n        targetDir = path.resolve(args[i]);\r\n        break;\r\n      }\r\n    }\r\n    \r\n    console.log('🚀 Duplicate Method Detector');\r\n    console.log(`⚙️ Configuration:`);\r\n    console.log(`   Similarity Threshold: ${options.similarityThreshold || DEFAULT_OPTIONS.similarityThreshold}`);\r\n    console.log(`   Minimum Method Length: ${options.minMethodLength || DEFAULT_OPTIONS.minMethodLength} lines`);\r\n    console.log(`   Include Private Methods: ${options.includePrivateMethods ?? DEFAULT_OPTIONS.includePrivateMethods}`);\r\n    console.log(`   Include Getters/Setters: ${options.includeGettersSetters ?? DEFAULT_OPTIONS.includeGettersSetters}`);\r\n    \r\n    // Run detection\r\n    const detector = new DuplicateMethodDetector(options);\r\n    const result = await detector.detectDuplicates(targetDir);\r\n    \r\n    // Generate report\r\n    DuplicateMethodReporter.generateReport(result);\r\n    \r\n    // Save detailed report\r\n    const reportsDir = path.join(process.cwd(), 'reports', 'quality');\r\n    if (!fs.existsSync(reportsDir)) {\r\n      fs.mkdirSync(reportsDir, { recursive: true });\r\n    }\r\n    \r\n    const timestamp = new Date().toISOString().split('T')[0];\r\n    const reportPath = path.join(reportsDir, `duplicate-methods-${timestamp}.json`);\r\n    DuplicateMethodReporter.saveReportToFile(result, reportPath);\r\n    \r\n    const endTime = Date.now();\r\n    const duration = ((endTime - startTime) / 1000).toFixed(2);\r\n    console.log(`\\n⏱️ Analysis completed in ${duration} seconds`);\r\n    \r\n    // Exit with appropriate code\r\n    const hasDuplicates = result.exactDuplicates > 0 || result.similarDuplicates > 0;\r\n    process.exit(hasDuplicates ? 1 : 0);\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Error during duplicate method detection:', error);\r\n    process.exit(1);\r\n  }\r\n}",
          "hash": "69ce9f1903bffcd053a04ad6088c2b84"
        },
        {
          "type": "function",
          "name": "processAndTrade",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 75,
          "endLine": 178,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 104,
          "content": "{\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}",
          "hash": "dfba8b52503986219f2d6be3a07b5c4b"
        },
        {
          "type": "function",
          "name": "validateSignalProcessing",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\signal-processing-validation.ts",
          "startLine": 17,
          "endLine": 167,
          "complexity": 13,
          "dependencies": [],
          "usageCount": 0,
          "size": 151,
          "content": "{\r\n  console.log('🔍 Starting JabbrLabs Signal Processing Validation...');\r\n  \r\n  try {\r\n    // Test 1: Aether Signal Generator\r\n    console.log('\\n1. Testing Aether Signal Generator...');\r\n    const aetherGenerator = new AetherSignalGenerator(DEFAULT_AETHER_PARAMETERS);\r\n    \r\n    // Sample market data (ensure sufficient data for MACD calculation)\r\n    const orderBookImbalance = 0.15;\r\n    const volatility = 0.025;\r\n    const crowdingScore = -0.3;\r\n    const priceHistory = [\r\n      100, 101, 102, 103, 102, 101, 102, 103, 104, 105,\r\n      106, 105, 104, 103, 104, 105, 106, 107, 108, 107,\r\n      106, 107, 108, 109, 110, 111, 110, 109, 108, 109,\r\n      110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\r\n      120, 119, 118, 117, 118, 119, 120, 121, 122, 123,\r\n      124, 123, 122, 121, 122, 123, 124, 125, 126, 127\r\n    ];\r\n    \r\n    const aetherSignal = aetherGenerator.calculateSignal(\r\n      orderBookImbalance,\r\n      volatility, \r\n      crowdingScore,\r\n      priceHistory\r\n    );\r\n    \r\n    console.log('✅ Aether Signal Generated:', {\r\n      value: aetherSignal.value.toFixed(4),\r\n      confidence: aetherSignal.confidence.toFixed(4),\r\n      regime: aetherSignal.regime,\r\n      timestamp: aetherSignal.timestamp\r\n    });\r\n    \r\n    // Validate signal constraints\r\n    if (!Number.isFinite(aetherSignal.value) || aetherSignal.value < -1 || aetherSignal.value > 1) {\r\n      throw new Error(`Aether signal value out of range or invalid: ${aetherSignal.value}`);\r\n    }\r\n    if (!Number.isFinite(aetherSignal.confidence) || aetherSignal.confidence < 0 || aetherSignal.confidence > 1) {\r\n      throw new Error(`Aether confidence out of range or invalid: ${aetherSignal.confidence}`);\r\n    }\r\n    \r\n    // Test 2: Technical Indicators\r\n    console.log('\\n2. Testing Technical Indicators...');\r\n    \r\n    const sma20 = calculateSMA(priceHistory, 20);\r\n    const ema20 = calculateEMA(priceHistory, 20);\r\n    // TODO: Fix MACD calculation - temporarily skipped\r\n    // const macd = calculateMACD(priceHistory);\r\n    const rsi14 = calculateRSI(priceHistory, 14);\r\n    \r\n    console.log('✅ Technical Indicators:', {\r\n      sma20Length: sma20.length,\r\n      ema20Length: ema20.length,\r\n      // macdLength: macd.macd.length,\r\n      rsi14Length: rsi14.length\r\n    });\r\n    \r\n    // Validate indicator outputs\r\n    if (sma20.length === 0 || ema20.length === 0) {\r\n      throw new Error('Moving averages not calculated');\r\n    }\r\n    // if (macd.macd.length === 0 || macd.signal.length === 0) {\r\n    //   throw new Error('MACD not calculated');\r\n    // }\r\n    if (rsi14.length === 0) {\r\n      throw new Error('RSI not calculated');\r\n    }\r\n    \r\n    // Test 3: Signal Generation\r\n    console.log('\\n3. Testing Signal Generation...');\r\n    \r\n    const maSignals = getMASignals(ema20, sma20);\r\n    // TODO: Fix MACD signals when MACD is working\r\n    // const macdSignals = getMACDSignals(macd);\r\n    const rsiSignals = getRSISignals(rsi14);\r\n    \r\n    console.log('✅ Signals Generated:', {\r\n      maSignalsLength: maSignals.length,\r\n      // macdSignalsLength: macdSignals.length,\r\n      rsiSignalsLength: rsiSignals.length\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const testSignal = {\r\n      id: 'test-signal-001',\r\n      type: 'aether',\r\n      symbol: 'BTC/USDT',\r\n      action: 'buy' as const,\r\n      confidence: aetherSignal.confidence,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 100000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-001', testSignal);\r\n    \r\n    console.log('✅ Signal Execution Result:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Data Input Validation\r\n    console.log('\\n5. Testing Data Input Validation...');\r\n    \r\n    // Test with invalid inputs\r\n    try {\r\n      aetherGenerator.calculateSignal(NaN, 0.025, 0.3, priceHistory);\r\n      throw new Error('Should have failed with NaN input');\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes('Should have failed')) {\r\n        throw error;\r\n      }\r\n      console.log('✅ Input validation working - NaN rejected');\r\n    }\r\n    \r\n    try {\r\n      calculateSMA([], 20);\r\n      console.log('✅ Empty array handling working');\r\n    } catch (error) {\r\n      console.log('✅ Empty array validation working');\r\n    }\r\n    \r\n    // Test 6: Parameter Updates\r\n    console.log('\\n6. Testing Parameter Management...');\r\n    \r\n    const originalParams = aetherGenerator.getParameters();\r\n    aetherGenerator.updateParameters({ hurstExponent: 0.8 });\r\n    const updatedParams = aetherGenerator.getParameters();\r\n    \r\n    if (updatedParams.hurstExponent !== 0.8) {\r\n      throw new Error('Parameter update failed');\r\n    }\r\n    \r\n    console.log('✅ Parameter management working');\r\n    \r\n    // Reset for consistency\r\n    aetherGenerator.updateParameters(originalParams);\r\n    \r\n    console.log('\\n🎉 All Signal Processing Validation Tests Passed!');\r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Signal Processing Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "073cf636ca04495d3baf9d6864759624"
        },
        {
          "type": "function",
          "name": "testMarketData",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-market-data.ts",
          "startLine": 8,
          "endLine": 101,
          "complexity": 13,
          "dependencies": [],
          "usageCount": 0,
          "size": 94,
          "content": "{\r\n  console.log('🚀 TESTING JABBR MARKET DATA ENGINE');\r\n  console.log('===================================');\r\n\r\n  // Create exchange with dummy credentials for public data\r\n  const apiKey = {\r\n    id: 'test-key-1',\r\n    userId: 'test-user',\r\n    exchange: 'bybit' as const,\r\n    keyName: 'Test Key',\r\n    apiKey: 'dummy',\r\n    apiSecret: 'dummy',\r\n    sandbox: true,\r\n    permissions: ['read'],\r\n    isActive: true,\r\n    createdAt: new Date(),\r\n    updatedAt: new Date()\r\n  };\r\n\r\n  const exchange = new BybitExchange(apiKey, true); // testnet = true\r\n\r\n  try {\r\n    console.log('\\n📋 Exchange Capabilities:');\r\n    const capabilities = exchange.getCapabilities();\r\n    console.log(`   Spot: ${capabilities.spot ? '✅' : '❌'}`);\r\n    console.log(`   Futures: ${capabilities.futures ? '✅' : '❌'}`);\r\n    console.log(`   Max Leverage - Spot: ${capabilities.maxLeverage.spot}x, Futures: ${capabilities.maxLeverage.futures}x`);\r\n    console.log(`   Rate Limit: ${capabilities.rateLimits.requests} requests/${capabilities.rateLimits.window/1000}s`);\r\n\r\n    console.log('\\n📊 Testing Public Market Data...');\r\n    \r\n    try {\r\n      // Test public market data (no auth required)\r\n      const futuresData = await exchange.getMarketData('BTCUSDT', MarketType.FUTURES);\r\n      console.log(`   ✅ BTCUSDT Futures: $${futuresData.price.toFixed(2)} (24h: ${futuresData.change24h.toFixed(2)}%)`);\r\n      \r\n      const spotData = await exchange.getMarketData('BTCUSDT', MarketType.SPOT);\r\n      console.log(`   ✅ BTCUSDT Spot: $${spotData.price.toFixed(2)} (24h: ${spotData.change24h.toFixed(2)}%)`);\r\n\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Market data test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    try {\r\n      // Test order book (public data)\r\n      console.log('\\n📈 Testing Order Book...');\r\n      const orderBook = await exchange.getOrderBook('BTCUSDT', MarketType.FUTURES, 5);\r\n      console.log('   Top 5 Bids:');\r\n      orderBook.bids.slice(0, 5).forEach(([price, amount]) => {\r\n        console.log(`     $${price.toFixed(2)} - ${amount.toFixed(4)} BTC`);\r\n      });\r\n      console.log('   Top 5 Asks:');\r\n      orderBook.asks.slice(0, 5).forEach(([price, amount]) => {\r\n        console.log(`     $${price.toFixed(2)} - ${amount.toFixed(4)} BTC`);\r\n      });\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Order book test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    try {\r\n      // Test recent trades (public data)\r\n      console.log('\\n📊 Testing Recent Trades...');\r\n      const trades = await exchange.getRecentTrades('BTCUSDT', MarketType.FUTURES, 5);\r\n      console.log('   Latest 5 trades:');\r\n      trades.slice(0, 5).forEach(trade => {\r\n        console.log(`     ${trade.side} ${trade.amount.toFixed(4)} @ $${trade.price.toFixed(2)}`);\r\n      });\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Recent trades test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    try {\r\n      // Test klines/candlesticks (public data)\r\n      console.log('\\n📈 Testing Candlestick Data...');\r\n      const klines = await exchange.getKlines('BTCUSDT', '1h', MarketType.FUTURES, undefined, undefined, 5);\r\n      console.log('   Latest 5 hourly candles:');\r\n      klines.slice(-5).forEach(candle => {\r\n        console.log(`     ${candle.timestamp.toISOString()}: O:${candle.open.toFixed(2)} H:${candle.high.toFixed(2)} L:${candle.low.toFixed(2)} C:${candle.close.toFixed(2)}`);\r\n      });\r\n    } catch (error) {\r\n      console.log(`   ⚠️ Candlestick test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n\r\n    console.log('\\n🎉 MARKET DATA TESTS COMPLETED!');\r\n    console.log('💪 Your trading engine\\'s market data functionality is OPERATIONAL!');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Test failed:', error);\r\n  } finally {\r\n    // Disconnect\r\n    await exchange.disconnect();\r\n    console.log('\\n🔌 Disconnected from exchange');\r\n  }\r\n}",
          "hash": "016ab4f2955e7b7fea28f78a4fe700c3"
        },
        {
          "type": "function",
          "name": "validateSignalProcessing",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\signal-processing-validation.ts",
          "startLine": 17,
          "endLine": 167,
          "complexity": 13,
          "dependencies": [],
          "usageCount": 0,
          "size": 151,
          "content": "{\r\n  console.log('🔍 Starting JabbrLabs Signal Processing Validation...');\r\n  \r\n  try {\r\n    // Test 1: Aether Signal Generator\r\n    console.log('\\n1. Testing Aether Signal Generator...');\r\n    const aetherGenerator = new AetherSignalGenerator(DEFAULT_AETHER_PARAMETERS);\r\n    \r\n    // Sample market data (ensure sufficient data for MACD calculation)\r\n    const orderBookImbalance = 0.15;\r\n    const volatility = 0.025;\r\n    const crowdingScore = -0.3;\r\n    const priceHistory = [\r\n      100, 101, 102, 103, 102, 101, 102, 103, 104, 105,\r\n      106, 105, 104, 103, 104, 105, 106, 107, 108, 107,\r\n      106, 107, 108, 109, 110, 111, 110, 109, 108, 109,\r\n      110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\r\n      120, 119, 118, 117, 118, 119, 120, 121, 122, 123,\r\n      124, 123, 122, 121, 122, 123, 124, 125, 126, 127\r\n    ];\r\n    \r\n    const aetherSignal = aetherGenerator.calculateSignal(\r\n      orderBookImbalance,\r\n      volatility, \r\n      crowdingScore,\r\n      priceHistory\r\n    );\r\n    \r\n    console.log('✅ Aether Signal Generated:', {\r\n      value: aetherSignal.value.toFixed(4),\r\n      confidence: aetherSignal.confidence.toFixed(4),\r\n      regime: aetherSignal.regime,\r\n      timestamp: aetherSignal.timestamp\r\n    });\r\n    \r\n    // Validate signal constraints\r\n    if (!Number.isFinite(aetherSignal.value) || aetherSignal.value < -1 || aetherSignal.value > 1) {\r\n      throw new Error(`Aether signal value out of range or invalid: ${aetherSignal.value}`);\r\n    }\r\n    if (!Number.isFinite(aetherSignal.confidence) || aetherSignal.confidence < 0 || aetherSignal.confidence > 1) {\r\n      throw new Error(`Aether confidence out of range or invalid: ${aetherSignal.confidence}`);\r\n    }\r\n    \r\n    // Test 2: Technical Indicators\r\n    console.log('\\n2. Testing Technical Indicators...');\r\n    \r\n    const sma20 = calculateSMA(priceHistory, 20);\r\n    const ema20 = calculateEMA(priceHistory, 20);\r\n    // TODO: Fix MACD calculation - temporarily skipped\r\n    // const macd = calculateMACD(priceHistory);\r\n    const rsi14 = calculateRSI(priceHistory, 14);\r\n    \r\n    console.log('✅ Technical Indicators:', {\r\n      sma20Length: sma20.length,\r\n      ema20Length: ema20.length,\r\n      // macdLength: macd.macd.length,\r\n      rsi14Length: rsi14.length\r\n    });\r\n    \r\n    // Validate indicator outputs\r\n    if (sma20.length === 0 || ema20.length === 0) {\r\n      throw new Error('Moving averages not calculated');\r\n    }\r\n    // if (macd.macd.length === 0 || macd.signal.length === 0) {\r\n    //   throw new Error('MACD not calculated');\r\n    // }\r\n    if (rsi14.length === 0) {\r\n      throw new Error('RSI not calculated');\r\n    }\r\n    \r\n    // Test 3: Signal Generation\r\n    console.log('\\n3. Testing Signal Generation...');\r\n    \r\n    const maSignals = getMASignals(ema20, sma20);\r\n    // TODO: Fix MACD signals when MACD is working\r\n    // const macdSignals = getMACDSignals(macd);\r\n    const rsiSignals = getRSISignals(rsi14);\r\n    \r\n    console.log('✅ Signals Generated:', {\r\n      maSignalsLength: maSignals.length,\r\n      // macdSignalsLength: macdSignals.length,\r\n      rsiSignalsLength: rsiSignals.length\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const testSignal = {\r\n      id: 'test-signal-001',\r\n      type: 'aether',\r\n      symbol: 'BTC/USDT',\r\n      action: 'buy' as const,\r\n      confidence: aetherSignal.confidence,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 100000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-001', testSignal);\r\n    \r\n    console.log('✅ Signal Execution Result:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Data Input Validation\r\n    console.log('\\n5. Testing Data Input Validation...');\r\n    \r\n    // Test with invalid inputs\r\n    try {\r\n      aetherGenerator.calculateSignal(NaN, 0.025, 0.3, priceHistory);\r\n      throw new Error('Should have failed with NaN input');\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes('Should have failed')) {\r\n        throw error;\r\n      }\r\n      console.log('✅ Input validation working - NaN rejected');\r\n    }\r\n    \r\n    try {\r\n      calculateSMA([], 20);\r\n      console.log('✅ Empty array handling working');\r\n    } catch (error) {\r\n      console.log('✅ Empty array validation working');\r\n    }\r\n    \r\n    // Test 6: Parameter Updates\r\n    console.log('\\n6. Testing Parameter Management...');\r\n    \r\n    const originalParams = aetherGenerator.getParameters();\r\n    aetherGenerator.updateParameters({ hurstExponent: 0.8 });\r\n    const updatedParams = aetherGenerator.getParameters();\r\n    \r\n    if (updatedParams.hurstExponent !== 0.8) {\r\n      throw new Error('Parameter update failed');\r\n    }\r\n    \r\n    console.log('✅ Parameter management working');\r\n    \r\n    // Reset for consistency\r\n    aetherGenerator.updateParameters(originalParams);\r\n    \r\n    console.log('\\n🎉 All Signal Processing Validation Tests Passed!');\r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Signal Processing Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "073cf636ca04495d3baf9d6864759624"
        },
        {
          "type": "function",
          "name": "getLogs",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\logs.routes.ts",
          "startLine": 10,
          "endLine": 193,
          "complexity": 12,
          "dependencies": [],
          "usageCount": 0,
          "size": 184,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    const {\r\n      page = '1',\r\n      limit = '50',\r\n      levels,\r\n      categories,\r\n      search,\r\n      startDate,\r\n      endDate,\r\n      userId,\r\n      botId,\r\n      tradeId\r\n    } = req.query;\r\n\r\n    const pageNum = parseInt(page as string, 10);\r\n    const limitNum = parseInt(limit as string, 10);\r\n    const offset = (pageNum - 1) * limitNum;\r\n\r\n    // Build dynamic query\r\n    let whereConditions: string[] = [];\r\n    let queryParams: any[] = [];\r\n    let paramIndex = 1;\r\n\r\n    // Level filter\r\n    if (levels) {\r\n      const levelArray = (levels as string).split(',');\r\n      whereConditions.push(`level = ANY($${paramIndex})`);\r\n      queryParams.push(levelArray);\r\n      paramIndex++;\r\n    }\r\n\r\n    // Category filter\r\n    if (categories) {\r\n      const categoryArray = (categories as string).split(',');\r\n      whereConditions.push(`category = ANY($${paramIndex})`);\r\n      queryParams.push(categoryArray);\r\n      paramIndex++;\r\n    }\r\n\r\n    // Search filter\r\n    if (search) {\r\n      whereConditions.push(`(message ILIKE $${paramIndex} OR category ILIKE $${paramIndex + 1})`);\r\n      queryParams.push(`%${search}%`, `%${search}%`);\r\n      paramIndex += 2;\r\n    }\r\n\r\n    // Date range filter\r\n    if (startDate) {\r\n      whereConditions.push(`timestamp >= $${paramIndex}`);\r\n      queryParams.push(new Date(startDate as string));\r\n      paramIndex++;\r\n    }\r\n\r\n    if (endDate) {\r\n      whereConditions.push(`timestamp <= $${paramIndex}`);\r\n      queryParams.push(new Date(endDate as string));\r\n      paramIndex++;\r\n    }\r\n\r\n    // User filter\r\n    if (userId) {\r\n      whereConditions.push(`user_id = $${paramIndex}`);\r\n      queryParams.push(userId);\r\n      paramIndex++;\r\n    }\r\n\r\n    // Bot filter\r\n    if (botId) {\r\n      whereConditions.push(`bot_id = $${paramIndex}`);\r\n      queryParams.push(botId);\r\n      paramIndex++;\r\n    }\r\n\r\n    // Trade filter\r\n    if (tradeId) {\r\n      whereConditions.push(`trade_id = $${paramIndex}`);\r\n      queryParams.push(tradeId);\r\n      paramIndex++;\r\n    }\r\n\r\n    const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';\r\n\r\n    // Get total count\r\n    const countQuery = `\r\n      SELECT COUNT(*) as total \r\n      FROM logs \r\n      ${whereClause}\r\n    `;\r\n\r\n    const countResult = await database.query(countQuery, queryParams);\r\n    const total = parseInt((countResult as any).rows[0].total, 10);\r\n\r\n    // Get logs with pagination\r\n    const logsQuery = `\r\n      SELECT \r\n        id,\r\n        level,\r\n        message,\r\n        category,\r\n        user_id as \"userId\",\r\n        bot_id as \"botId\", \r\n        trade_id as \"tradeId\",\r\n        metadata,\r\n        timestamp\r\n      FROM logs \r\n      ${whereClause}\r\n      ORDER BY timestamp DESC\r\n      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}\r\n    `;\r\n\r\n    queryParams.push(limitNum, offset);\r\n\r\n    const logsResult = await database.query(logsQuery, queryParams);\r\n    \r\n    const logs: LogEntry[] = (logsResult as any).rows.map((row: any) => ({\r\n      id: row.id,\r\n      level: row.level,\r\n      message: row.message,\r\n      category: row.category,\r\n      userId: row.userId,\r\n      botId: row.botId,\r\n      tradeId: row.tradeId,\r\n      metadata: row.metadata,\r\n      timestamp: new Date(row.timestamp)\r\n    }));\r\n\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        logs,\r\n        total,\r\n        page: pageNum,\r\n        limit: limitNum,\r\n        totalPages: Math.ceil(total / limitNum)\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/logs'\r\n      }\r\n    });\r\n\r\n    logger.info('Logs retrieved successfully', {\r\n      total,\r\n      page: pageNum,\r\n      limit: limitNum,\r\n      filters: {\r\n        levels,\r\n        categories,\r\n        search,\r\n        startDate,\r\n        endDate,\r\n        userId,\r\n        botId,\r\n        tradeId\r\n      },\r\n      responseTime\r\n    });\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n    logger.error('Failed to retrieve logs', error);\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: {\r\n        message: 'Failed to retrieve logs',\r\n        details: errorMessage\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/logs'\r\n      }\r\n    });\r\n  }\r\n}",
          "hash": "4eac0bd2b3fb995501dbcd250bfd452a"
        },
        {
          "type": "function",
          "name": "runSmaBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\docs\\examples\\sma-backtest-example.ts",
          "startLine": 13,
          "endLine": 159,
          "complexity": 11,
          "dependencies": [],
          "usageCount": 0,
          "size": 147,
          "content": "{\r\n  logger.info('Starting SMA Strategy Backtesting');\r\n  \r\n  try {\r\n    // First, load or download historical data\r\n    const startDate = new Date('2023-01-01').getTime();\r\n    const endDate = new Date('2023-12-31').getTime();\r\n    const symbol = 'BTC/USDT';\r\n    const timeframe = '1h';\r\n    \r\n    logger.info(`Downloading historical data for ${symbol} (${timeframe}) from ${new Date(startDate).toISOString()} to ${new Date(endDate).toISOString()}`);\r\n    \r\n    const candles = await downloadHistoricalData(symbol, timeframe, startDate, endDate);\r\n    \r\n    if (!candles || candles.length === 0) {\r\n      throw new Error('Failed to download historical data or no data available for the specified period');\r\n    }\r\n    \r\n    logger.info(`Downloaded ${candles.length} candles`);\r\n    \r\n    // Configure the strategy parameters\r\n    const strategyConfig = {\r\n      type: 'sma-crossover',\r\n      parameters: {\r\n        symbol: 'BTC/USDT',\r\n        fastPeriod: 20,\r\n        slowPeriod: 50,\r\n        signalThreshold: 0\r\n      },\r\n      riskManagement: {\r\n        stopLossPercentage: 0.05, // 5% stop loss\r\n        takeProfitPercentage: 0.15 // 15% take profit\r\n      },\r\n      execution: {\r\n        timeframe: '1h',\r\n        minimumConfidence: 0.6\r\n      }\r\n    };\r\n    \r\n    // Ensure the strategy is available\r\n    const availableStrategies = await strategyFactory.getAvailablePlugins();\r\n    const isSmaAvailable = availableStrategies.some(s => s.name.toLowerCase().includes('sma'));\r\n    \r\n    if (!isSmaAvailable) {\r\n      logger.warn('SMA Crossover strategy not found in available plugins');\r\n    }\r\n    \r\n    // Option 1: Quick backtest\r\n    logger.info('Running quick backtest...');\r\n    const quickResults = await quickBacktest(\r\n      'sma-crossover',\r\n      strategyConfig,\r\n      candles,\r\n      {\r\n        initialCapital: 10000,\r\n        fees: 0.001,\r\n        slippage: 0.001\r\n      }\r\n    );\r\n    \r\n    logger.info('Quick backtest results:', {\r\n      totalTrades: quickResults.totalTrades,\r\n      winRate: `${(quickResults.winRate * 100).toFixed(2)  }%`,\r\n      totalPnl: quickResults.totalPnl.toFixed(2),\r\n      maxDrawdown: `${(quickResults.maxDrawdown * 100).toFixed(2)  }%`\r\n    });\r\n    \r\n    // Option 2: Full control with StrategyBacktester\r\n    logger.info('Running detailed backtest with multiple configurations...');\r\n    \r\n    // Test multiple parameter combinations\r\n    const fastPeriods = [10, 20, 30];\r\n    const slowPeriods = [40, 50, 60];\r\n    \r\n    const results = [];\r\n    \r\n    for (const fastPeriod of fastPeriods) {\r\n      for (const slowPeriod of slowPeriods) {\r\n        // Skip invalid combinations\r\n        if (fastPeriod >= slowPeriod) {continue;}\r\n        \r\n        const config = {\r\n          ...strategyConfig,\r\n          parameters: {\r\n            ...strategyConfig.parameters,\r\n            fastPeriod,\r\n            slowPeriod\r\n          }\r\n        };\r\n        \r\n        const backtester = new StrategyBacktester(candles, {\r\n          initialCapital: 10000,\r\n          fees: 0.001,\r\n          slippage: 0.001,\r\n          enableLogs: false // Disable detailed logs for parameter scanning\r\n        });\r\n        \r\n        await backtester.loadStrategy('sma-crossover', config);\r\n        const result = await backtester.runBacktest();\r\n        \r\n        results.push({\r\n          fastPeriod,\r\n          slowPeriod,\r\n          totalPnl: result.totalPnl,\r\n          winRate: result.winRate,\r\n          profitFactor: result.profitFactor,\r\n          maxDrawdown: result.maxDrawdown\r\n        });\r\n        \r\n        logger.info(`Tested SMA(${fastPeriod},${slowPeriod}): PnL=${result.totalPnl.toFixed(2)}, Win=${(result.winRate * 100).toFixed(2)}%`);\r\n      }\r\n    }\r\n    \r\n    // Find best parameters\r\n    results.sort((a, b) => b.totalPnl - a.totalPnl);\r\n    const bestResult = results[0] || {\r\n      fastPeriod: 0,\r\n      slowPeriod: 0,\r\n      totalPnl: 0,\r\n      winRate: 0,\r\n      profitFactor: 0,\r\n      maxDrawdown: 0\r\n    };\r\n    \r\n    logger.info('Best parameters found:', {\r\n      fastPeriod: bestResult.fastPeriod,\r\n      slowPeriod: bestResult.slowPeriod,\r\n      totalPnl: bestResult.totalPnl.toFixed(2),\r\n      winRate: `${(bestResult.winRate * 100).toFixed(2)  }%`,\r\n      profitFactor: bestResult.profitFactor.toFixed(2),\r\n      maxDrawdown: `${(bestResult.maxDrawdown * 100).toFixed(2)  }%`\r\n    });\r\n    \r\n    return {\r\n      quickResults,\r\n      parameterResults: results,\r\n      bestParameters: {\r\n        fastPeriod: bestResult.fastPeriod,\r\n        slowPeriod: bestResult.slowPeriod\r\n      }\r\n    };\r\n    \r\n  } catch (error) {\r\n    logger.error(`Backtest failed: ${error instanceof Error ? error.message : String(error)}`);\r\n    throw error;\r\n  }\r\n}",
          "hash": "e54921bfc0ea6f94fd7638ba4a26aca9"
        },
        {
          "type": "function",
          "name": "getAlerts",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts",
          "startLine": 19,
          "endLine": 90,
          "complexity": 11,
          "dependencies": [],
          "usageCount": 0,
          "size": 72,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    if (!alertManager) {\r\n      res.status(503).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert manager not initialized',\r\n          code: 'SERVICE_UNAVAILABLE'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const {\r\n      type,\r\n      level,\r\n      category,\r\n      acknowledged,\r\n      resolved,\r\n      escalated,\r\n      since\r\n    } = req.query;\r\n\r\n    // Build filter criteria\r\n    const criteria: any = {};\r\n    \r\n    if (type) criteria.type = type as string;\r\n    if (level) criteria.level = level as string;\r\n    if (category) criteria.category = category as string;\r\n    if (acknowledged !== undefined) criteria.acknowledged = acknowledged === 'true';\r\n    if (resolved !== undefined) criteria.resolved = resolved === 'true';\r\n    if (escalated !== undefined) criteria.escalated = escalated === 'true';\r\n    if (since) criteria.since = new Date(since as string);\r\n\r\n    const alerts = alertManager.getAlerts(criteria);\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        alerts,\r\n        total: alerts.length\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/alerts'\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n    logger.error('Failed to retrieve alerts', { error: errorMessage });\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: {\r\n        message: 'Failed to retrieve alerts',\r\n        details: errorMessage\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/alerts'\r\n      }\r\n    });\r\n  }\r\n}",
          "hash": "cdc38bd2c29a63881f7e077614aff5bf"
        },
        {
          "type": "function",
          "name": "testConfig",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-signals.ts",
          "startLine": 95,
          "endLine": 141,
          "complexity": 11,
          "dependencies": [],
          "usageCount": 0,
          "size": 47,
          "content": "{\r\n  console.log(`\\n--- Testing ${name} ---`);\r\n  \r\n  try {\r\n    const processor = new SMASignalProcessor(config);\r\n    \r\n    // Process all candles and count signals\r\n    let buys = 0;\r\n    let sells = 0;\r\n    let nosignal = 0;\r\n    \r\n    // Use sliding window to process candles like in real trading\r\n    const windowSize = Math.max(config.slowPeriod * 3, 30); // Enough history for calculations\r\n    \r\n    for (let i = windowSize; i < candles.length; i++) {\r\n      // Get window of candles\r\n      const window = candles.slice(i - windowSize, i);\r\n      \r\n      try {\r\n        const result = processor.process(window);\r\n        \r\n        if (result) {\r\n          if (result.signal > 0) {\r\n            buys++;\r\n            console.log(`[${i}] BUY signal: ${result.reason} (confidence: ${result.confidence.toFixed(2)})`);\r\n          } else if (result.signal < 0) {\r\n            sells++;\r\n            console.log(`[${i}] SELL signal: ${result.reason} (confidence: ${result.confidence.toFixed(2)})`);\r\n          }\r\n        } else {\r\n          nosignal++;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error processing window at index ${i}:`, error);\r\n      }\r\n    }\r\n    \r\n    console.log(`Results for ${name}:`);\r\n    console.log(`- Buy signals: ${buys}`);\r\n    console.log(`- Sell signals: ${sells}`);\r\n    console.log(`- No signals: ${nosignal}`);\r\n    console.log(`- Total processed: ${candles.length - windowSize}`);\r\n    console.log(`- Signal rate: ${((buys + sells) / (candles.length - windowSize) * 100).toFixed(2)}%`);\r\n  } catch (error) {\r\n    console.error(`Failed to test ${name}:`, error);\r\n  }\r\n}",
          "hash": "c3f1dbdb8227017b5340481f2bea8d39"
        },
        {
          "type": "function",
          "name": "validate",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 379,
          "endLine": 437,
          "complexity": 11,
          "dependencies": [],
          "usageCount": 0,
          "size": 59,
          "content": "{\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        lines.forEach((line, index) => {\r\n          // Check for malformed headers\r\n          if (line.match(/^#{7,}/)) {\r\n            results.push({\r\n              type: 'error',\r\n              rule: 'markdown-syntax',\r\n              message: 'Invalid header level (max 6 levels allowed)',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Use header levels 1-6 (# to ######)'\r\n            });\r\n          }\r\n          \r\n          // Check for unmatched brackets\r\n          const openBrackets = (line.match(/\\[/g) || []).length;\r\n          const closeBrackets = (line.match(/\\]/g) || []).length;\r\n          \r\n          if (openBrackets !== closeBrackets) {\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unmatched square brackets in line',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Check for missing opening or closing brackets'\r\n            });\r\n          }\r\n          \r\n          // Check for unmatched parentheses in links\r\n          if (line.includes('](') && line.match(/\\]\\([^)]*$/)) {\r\n            results.push({\r\n              type: 'error',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unclosed link parenthesis',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Add closing parenthesis to complete the link'\r\n            });\r\n          }\r\n          \r\n          // Check for common markdown formatting issues\r\n          if (line.match(/\\*\\*[^*]*\\*(?!\\*)/)) {\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Potentially malformed bold text (unmatched asterisks)',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Ensure bold text uses ** on both sides'\r\n            });\r\n          }\r\n        });\r\n        \r\n        return results;\r\n      }",
          "hash": "b8f0136119359fc7a4f57d6148919b76"
        }
      ],
      "description": "Found 38 highly complex functions that are difficult to maintain",
      "severity": "high",
      "recommendedAction": "Break down complex functions into smaller, focused functions",
      "estimatedImpact": {
        "performance": 3,
        "maintainability": 9,
        "codeReduction": 0
      },
      "implementationEffort": "high"
    }
  ],
  "consolidationOpportunities": [
    {
      "type": "method-centralization",
      "targetFiles": [
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\cli.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\cli.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\metrics-collector.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\metrics-collector.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\unified-analyzer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\understanding\\unified-analyzer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\fixed-sma-backtest.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\fixed-sma-backtest.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\sma-backtest.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\sma-backtest.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-processor.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-processor.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-signals.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-signals.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\config\\config-manager.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\bollinger-bands.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\moving-averages.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\bot-trading-cycle-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\bot-trading-cycle-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\database-health-check.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\database-health-check.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\performance-monitoring-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\performance-monitoring-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\production-readiness-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\production-readiness-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\signal-processing-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\signal-processing-validation.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\data-service.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\database-monitor.service.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\fixtures\\candles.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-signals.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\page.tsx",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\TradingActivityMonitor.tsx",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\AlertSystem.tsx",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\PositionPnLVisualization.tsx",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\index.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\test-utils\\data-generators.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\duplicate-method-detector.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\duplication-analyzer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\manual-duplication-reviewer.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
        "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts"
      ],
      "suggestedLocation": "src/utils/common.ts",
      "suggestedName": "centralizedUtilities",
      "affectedElements": [
        {
          "type": "function",
          "name": "runMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\cli.ts",
          "startLine": 194,
          "endLine": 215,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      try {\r\n        const timestamp = new Date().toLocaleString();\r\n        console.log(`\\n🔄 Running monitoring cycle at ${timestamp}`);\r\n        \r\n        if (options.metrics) {\r\n          const collector = new MetricsCollector(projectRoot);\r\n          await collector.collectMetrics();\r\n          console.log('  ✅ Metrics collected');\r\n        }\r\n        \r\n        if (options.dashboard) {\r\n          await DashboardCLI.run(projectRoot, { notify: options.notifications });\r\n          console.log('  ✅ Dashboard updated');\r\n        }\r\n        \r\n        console.log(`  ⏰ Next update in ${options.interval} minutes`);\r\n        \r\n      } catch (error) {\r\n        console.error('  ❌ Error during monitoring cycle:', error);\r\n      }\r\n    }",
          "hash": "6c9f63bcb2d38c6225c70c3e8ecff174"
        },
        {
          "type": "function",
          "name": "runMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\cli.ts",
          "startLine": 193,
          "endLine": 214,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      try {\r\n        const timestamp = new Date().toLocaleString();\r\n        console.log(`\\n🔄 Running monitoring cycle at ${timestamp}`);\r\n        \r\n        if (options.metrics) {\r\n          const collector = new MetricsCollector(projectRoot);\r\n          await collector.collectMetrics();\r\n          console.log('  ✅ Metrics collected');\r\n        }\r\n        \r\n        if (options.dashboard) {\r\n          await DashboardCLI.run(projectRoot, { notify: options.notifications });\r\n          console.log('  ✅ Dashboard updated');\r\n        }\r\n        \r\n        console.log(`  ⏰ Next update in ${options.interval} minutes`);\r\n        \r\n      } catch (error) {\r\n        console.error('  ❌ Error during monitoring cycle:', error);\r\n      }\r\n    }",
          "hash": "6c9f63bcb2d38c6225c70c3e8ecff174"
        },
        {
          "type": "function",
          "name": "dfs",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 257,
          "endLine": 278,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (recursionStack.has(nodeId)) {\r\n        // Found a cycle\r\n        const cycleStart = path.indexOf(nodeId);\r\n        if (cycleStart !== -1) {\r\n          cycles.push(path.slice(cycleStart));\r\n        }\r\n        return;\r\n      }\r\n      \r\n      if (visited.has(nodeId)) return;\r\n      \r\n      visited.add(nodeId);\r\n      recursionStack.add(nodeId);\r\n      \r\n      const outgoingEdges = dependencyEdges.filter(e => e.source === nodeId);\r\n      for (const edge of outgoingEdges) {\r\n        dfs(edge.target, [...path, nodeId]);\r\n      }\r\n      \r\n      recursionStack.delete(nodeId);\r\n    }",
          "hash": "1695291ea10204c1b9eabc6e3710651f"
        },
        {
          "type": "function",
          "name": "dfs",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 257,
          "endLine": 278,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (recursionStack.has(nodeId)) {\r\n        // Found a cycle\r\n        const cycleStart = path.indexOf(nodeId);\r\n        if (cycleStart !== -1) {\r\n          cycles.push(path.slice(cycleStart));\r\n        }\r\n        return;\r\n      }\r\n      \r\n      if (visited.has(nodeId)) return;\r\n      \r\n      visited.add(nodeId);\r\n      recursionStack.add(nodeId);\r\n      \r\n      const outgoingEdges = dependencyEdges.filter(e => e.source === nodeId);\r\n      for (const edge of outgoingEdges) {\r\n        dfs(edge.target, [...path, nodeId]);\r\n      }\r\n      \r\n      recursionStack.delete(nodeId);\r\n    }",
          "hash": "1695291ea10204c1b9eabc6e3710651f"
        },
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 551,
          "endLine": 1153,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 552,
          "endLine": 1154,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 551,
          "endLine": 1153,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 552,
          "endLine": 1154,
          "complexity": 44,
          "dependencies": [],
          "usageCount": 0,
          "size": 603,
          "content": "{\r\n        const pos1 = layout.get(edge.source)!;\r\n        const pos2 = layout.get(edge.target)!;\r\n        \r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\r\n        \r\n        const force = distance * 0.01;\r\n        const fx = (dx / distance) * force;\r\n        const fy = (dy / distance) * force;\r\n        \r\n        forces.get(edge.source)!.fx += fx;\r\n        forces.get(edge.source)!.fy += fy;\r\n        forces.get(edge.target)!.fx -= fx;\r\n        forces.get(edge.target)!.fy -= fy;\r\n      });\r\n      \r\n      // Apply forces\r\n      graph.nodes.forEach(node => {\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}\" y=\"${midY}\" text-anchor=\"middle\" \r\n                font-family=\"Arial, sans-serif\" font-size=\"10\" \r\n                fill=\"#6c757d\" opacity=\"0.8\">\r\n            ${edge.label}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return edgeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw all nodes\r\n   */\r\n  private drawNodes(nodes: TaskNode[], layout: Map<string, { x: number; y: number }>): string {\r\n    const nodeElements = [];\r\n    \r\n    for (const node of nodes) {\r\n      const pos = layout.get(node.id);\r\n      if (!pos) continue;\r\n      \r\n      const fillColor = this.getNodeColor(node);\r\n      const strokeColor = this.getNodeStrokeColor(node);\r\n      const radius = this.getNodeRadius(node);\r\n      \r\n      // Node circle\r\n      nodeElements.push(`\r\n        <circle cx=\"${pos.x}\" cy=\"${pos.y}\" r=\"${radius}\"\r\n                fill=\"${fillColor}\" stroke=\"${strokeColor}\" stroke-width=\"2\"\r\n                opacity=\"0.9\">\r\n          <title>${node.title} (${node.id})\\nStatus: ${node.status}\\nPriority: ${node.priority}</title>\r\n        </circle>\r\n      `);\r\n      \r\n      // Progress indicator (if enabled)\r\n      if (this.config.showProgress && node.status !== 'pending') {\r\n        const progressAngle = this.getProgressAngle(node);\r\n        nodeElements.push(`\r\n          <path d=\"M ${pos.x} ${pos.y - radius} A ${radius} ${radius} 0 ${progressAngle > 180 ? 1 : 0} 1 ${pos.x + radius * Math.sin(progressAngle * Math.PI / 180)} ${pos.y - radius * Math.cos(progressAngle * Math.PI / 180)}\"\r\n                stroke=\"#28a745\" stroke-width=\"3\" fill=\"none\" opacity=\"0.8\" />\r\n        `);\r\n      }\r\n      \r\n      // Node label\r\n      if (this.config.showLabels) {\r\n        const labelText = node.title.length > 15 ? node.title.substring(0, 12) + '...' : node.title;\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + radius + 15}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"11\" fill=\"#495057\">\r\n            ${labelText}\r\n          </text>\r\n        `);\r\n        \r\n        // Node ID\r\n        nodeElements.push(`\r\n          <text x=\"${pos.x}\" y=\"${pos.y + 3}\" text-anchor=\"middle\"\r\n                font-family=\"Arial, sans-serif\" font-size=\"9\" font-weight=\"bold\" fill=\"#ffffff\">\r\n            ${node.id}\r\n          </text>\r\n        `);\r\n      }\r\n    }\r\n    \r\n    return nodeElements.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get node color based on color scheme\r\n   */\r\n  private getNodeColor(node: TaskNode): string {\r\n    switch (this.config.colorScheme) {\r\n      case 'status':\r\n        return this.getStatusColor(node.status);\r\n      case 'priority':\r\n        return this.getPriorityColor(node.priority);\r\n      case 'complexity':\r\n        return this.getComplexityColor(node.complexity || 5);\r\n      default:\r\n        return this.getStatusColor(node.status);\r\n    }\r\n  }\r\n\r\n  private getStatusColor(status: string): string {\r\n    const colors = {\r\n      'pending': '#6c757d',\r\n      'in-progress': '#007bff',\r\n      'done': '#28a745',\r\n      'blocked': '#dc3545',\r\n      'deferred': '#ffc107',\r\n      'cancelled': '#343a40'\r\n    };\r\n    return colors[status as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getPriorityColor(priority: string): string {\r\n    const colors = {\r\n      'low': '#28a745',\r\n      'medium': '#ffc107',\r\n      'high': '#fd7e14',\r\n      'critical': '#dc3545'\r\n    };\r\n    return colors[priority as keyof typeof colors] || '#6c757d';\r\n  }\r\n\r\n  private getComplexityColor(complexity: number): string {\r\n    if (complexity <= 3) return '#28a745';\r\n    if (complexity <= 6) return '#ffc107';\r\n    if (complexity <= 8) return '#fd7e14';\r\n    return '#dc3545';\r\n  }\r\n\r\n  private getNodeStrokeColor(node: TaskNode): string {\r\n    if (node.isSubtask) return '#6f42c1';\r\n    if (node.priority === 'critical') return '#dc3545';\r\n    return '#495057';\r\n  }\r\n\r\n  private getNodeRadius(node: TaskNode): number {\r\n    if (node.isSubtask) return 15;\r\n    if (node.priority === 'critical') return 25;\r\n    if (node.priority === 'high') return 22;\r\n    return 20;\r\n  }\r\n\r\n  private getEdgeColor(edge: DependencyEdge): string {\r\n    const colors = {\r\n      'dependency': '#6c757d',\r\n      'blocks': '#dc3545',\r\n      'subtask': '#6f42c1'\r\n    };\r\n    return colors[edge.type] || '#6c757d';\r\n  }\r\n\r\n  private getEdgeWidth(edge: DependencyEdge): number {\r\n    if (edge.type === 'blocks') return 3;\r\n    if (edge.weight && edge.weight > 3) return 2.5;\r\n    return 2;\r\n  }\r\n\r\n  private getProgressAngle(node: TaskNode): number {\r\n    if (node.status === 'done') return 360;\r\n    if (node.status === 'in-progress') return 180;\r\n    if (node.status === 'blocked') return 90;\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Draw legend\r\n   */\r\n  private drawLegend(width: number, height: number): string {\r\n    const legend = [];\r\n    const startX = width - 200;\r\n    const startY = 80;\r\n    \r\n    legend.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"180\" height=\"120\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    legend.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Legend</text>`);\r\n    \r\n    // Status colors\r\n    const statuses = [\r\n      { status: 'pending', color: '#6c757d', label: 'Pending' },\r\n      { status: 'in-progress', color: '#007bff', label: 'In Progress' },\r\n      { status: 'done', color: '#28a745', label: 'Done' },\r\n      { status: 'blocked', color: '#dc3545', label: 'Blocked' }\r\n    ];\r\n    \r\n    statuses.forEach((item, index) => {\r\n      const y = startY + 20 + (index * 20);\r\n      legend.push(`<circle cx=\"${startX + 10}\" cy=\"${y}\" r=\"6\" fill=\"${item.color}\"/>`);\r\n      legend.push(`<text x=\"${startX + 25}\" y=\"${y + 4}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${item.label}</text>`);\r\n    });\r\n    \r\n    return legend.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Draw statistics panel\r\n   */\r\n  private drawStatistics(graph: DependencyGraph, width: number): string {\r\n    const stats = [];\r\n    const startX = 20;\r\n    const startY = 80;\r\n    \r\n    stats.push(`<rect x=\"${startX - 10}\" y=\"${startY - 10}\" width=\"200\" height=\"100\" fill=\"white\" stroke=\"#dee2e6\" stroke-width=\"1\" opacity=\"0.9\" rx=\"5\"/>`);\r\n    stats.push(`<text x=\"${startX}\" y=\"${startY + 5}\" font-family=\"Arial, sans-serif\" font-size=\"12\" font-weight=\"bold\" fill=\"#495057\">Statistics</text>`);\r\n    \r\n    const statsData = [\r\n      `Total Tasks: ${graph.metadata.totalTasks}`,\r\n      `Dependencies: ${graph.metadata.totalDependencies}`,\r\n      `Complexity: ${graph.metadata.complexity}`,\r\n      `Orphan Tasks: ${graph.metadata.orphanTasks.length}`,\r\n      `Cycles: ${graph.metadata.cycles.length}`\r\n    ];\r\n    \r\n    statsData.forEach((stat, index) => {\r\n      const y = startY + 20 + (index * 15);\r\n      stats.push(`<text x=\"${startX}\" y=\"${y}\" font-family=\"Arial, sans-serif\" font-size=\"10\" fill=\"#495057\">${stat}</text>`);\r\n    });\r\n    \r\n    return stats.join('\\n');\r\n  }\r\n}\r\n\r\nexport class DependencyVisualizer {\r\n  private projectRoot: string;\r\n  private graphBuilder: DependencyGraphBuilder;\r\n\r\n  constructor(projectRoot: string) {\r\n    this.projectRoot = projectRoot;\r\n    this.graphBuilder = new DependencyGraphBuilder(projectRoot);\r\n  }\r\n\r\n  /**\r\n   * Generate and save dependency visualization\r\n   */\r\n  public generateVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.svg');\r\n    writeFileSync(outputPath, svg);\r\n    \r\n    console.log(`Dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Generate interactive HTML visualization\r\n   */\r\n  public generateInteractiveVisualization(config: Partial<VisualizationConfig> = {}): string {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    const html = this.createInteractiveHTML(graph, config);\r\n    \r\n    // Save to file\r\n    const outputPath = join(this.projectRoot, '.taskmaster', 'reports', 'dependency-graph.html');\r\n    writeFileSync(outputPath, html);\r\n    \r\n    console.log(`Interactive dependency visualization saved to: ${outputPath}`);\r\n    return outputPath;\r\n  }\r\n\r\n  /**\r\n   * Get dependency graph data\r\n   */\r\n  public getGraph(): DependencyGraph {\r\n    return this.graphBuilder.buildGraph();\r\n  }\r\n\r\n  /**\r\n   * Analyze dependency graph for issues\r\n   */\r\n  public analyzeDependencies(): any {\r\n    const graph = this.graphBuilder.buildGraph();\r\n    \r\n    return {\r\n      summary: {\r\n        totalTasks: graph.metadata.totalTasks,\r\n        totalDependencies: graph.metadata.totalDependencies,\r\n        complexity: graph.metadata.complexity\r\n      },\r\n      issues: {\r\n        cycles: graph.metadata.cycles.length > 0 ? {\r\n          count: graph.metadata.cycles.length,\r\n          cycles: graph.metadata.cycles,\r\n          recommendation: 'Remove circular dependencies to prevent deadlocks'\r\n        } : null,\r\n        orphanTasks: graph.metadata.orphanTasks.length > 0 ? {\r\n          count: graph.metadata.orphanTasks.length,\r\n          tasks: graph.metadata.orphanTasks,\r\n          recommendation: 'Review orphan tasks for proper integration into workflow'\r\n        } : null,\r\n        highComplexity: graph.metadata.complexity > 7 ? {\r\n          complexity: graph.metadata.complexity,\r\n          recommendation: 'Consider simplifying task dependencies to reduce complexity'\r\n        } : null\r\n      },\r\n      insights: {\r\n        criticalPath: graph.metadata.criticalPath,\r\n        recommendations: this.generateRecommendations(graph)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create interactive HTML visualization\r\n   */\r\n  private createInteractiveHTML(graph: DependencyGraph, config: Partial<VisualizationConfig>): string {\r\n    const svgGenerator = new SVGVisualizationGenerator(config);\r\n    const svg = svgGenerator.generateSVG(graph, 1400, 900);\r\n    \r\n    return `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Task Dependency Visualization - JBR Trading Platform</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }\r\n        .container { max-width: 1600px; margin: 0 auto; }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }\r\n        .controls { background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .control-group { display: inline-block; margin-right: 2rem; }\r\n        .control-group label { display: block; font-weight: bold; margin-bottom: 0.5rem; }\r\n        .control-group select, .control-group input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }\r\n        .visualization { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }\r\n        .stats-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }\r\n        .stat-item { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 6px; }\r\n        .stat-value { font-size: 2rem; font-weight: bold; color: #667eea; }\r\n        .stat-label { color: #6c757d; font-size: 0.9rem; }\r\n        .analysis-panel { background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\r\n        .issue { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #dc3545; background: #f8d7da; border-radius: 4px; }\r\n        .recommendation { padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #28a745; background: #d4edda; border-radius: 4px; }\r\n        svg { width: 100%; height: auto; display: block; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Task Dependency Visualization</h1>\r\n            <p>Interactive view of project task dependencies and relationships</p>\r\n        </div>\r\n\r\n        <div class=\"controls\">\r\n            <div class=\"control-group\">\r\n                <label>Layout:</label>\r\n                <select id=\"layoutSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"hierarchical\">Hierarchical</option>\r\n                    <option value=\"force\">Force-Directed</option>\r\n                    <option value=\"circular\">Circular</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Color Scheme:</label>\r\n                <select id=\"colorSelect\" onchange=\"updateVisualization()\">\r\n                    <option value=\"status\">By Status</option>\r\n                    <option value=\"priority\">By Priority</option>\r\n                    <option value=\"complexity\">By Complexity</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"control-group\">\r\n                <label>Show:</label>\r\n                <input type=\"checkbox\" id=\"showLabels\" onchange=\"updateVisualization()\" checked> Labels\r\n                <input type=\"checkbox\" id=\"showSubtasks\" onchange=\"updateVisualization()\" checked> Subtasks\r\n                <input type=\"checkbox\" id=\"showProgress\" onchange=\"updateVisualization()\" checked> Progress\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"visualization\">\r\n            ${svg}\r\n        </div>\r\n\r\n        <div class=\"stats-panel\">\r\n            <h3>Project Statistics</h3>\r\n            <div class=\"stats-grid\">\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalTasks}</div>\r\n                    <div class=\"stat-label\">Total Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.totalDependencies}</div>\r\n                    <div class=\"stat-label\">Dependencies</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.complexity}</div>\r\n                    <div class=\"stat-label\">Complexity Score</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.orphanTasks.length}</div>\r\n                    <div class=\"stat-label\">Orphan Tasks</div>\r\n                </div>\r\n                <div class=\"stat-item\">\r\n                    <div class=\"stat-value\">${graph.metadata.cycles.length}</div>\r\n                    <div class=\"stat-label\">Circular Dependencies</div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"analysis-panel\">\r\n            <h3>Dependency Analysis</h3>\r\n            ${graph.metadata.cycles.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Circular Dependencies Detected:</strong> ${graph.metadata.cycles.length} cycles found.\r\n                    These can cause deadlocks and should be resolved.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.orphanTasks.length > 0 ? `\r\n                <div class=\"issue\">\r\n                    <strong>Orphan Tasks:</strong> ${graph.metadata.orphanTasks.length} tasks have no dependencies or dependents.\r\n                    Consider integrating them into the main workflow.\r\n                </div>\r\n            ` : ''}\r\n            ${graph.metadata.criticalPath.length > 0 ? `\r\n                <div class=\"recommendation\">\r\n                    <strong>Critical Path:</strong> Focus on tasks ${graph.metadata.criticalPath.join(' → ')} \r\n                    as they are on the critical path for project completion.\r\n                </div>\r\n            ` : ''}\r\n        </div>\r\n    </div>\r\n\r\n    <script>\r\n        function updateVisualization() {\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }\r\n\r\n        // Add zoom and pan functionality\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n            const svg = document.querySelector('svg');\r\n            let isPanning = false;\r\n            let startPoint = { x: 0, y: 0 };\r\n            let endPoint = { x: 0, y: 0 };\r\n            let scale = 1;\r\n\r\n            svg.addEventListener('wheel', function(e) {\r\n                e.preventDefault();\r\n                const delta = e.deltaY > 0 ? 0.9 : 1.1;\r\n                scale *= delta;\r\n                scale = Math.max(0.1, Math.min(3, scale));\r\n                svg.style.transform = \\`scale(\\${scale})\\`;\r\n            });\r\n\r\n            svg.addEventListener('mousedown', function(e) {\r\n                isPanning = true;\r\n                startPoint = { x: e.clientX, y: e.clientY };\r\n                svg.style.cursor = 'grabbing';\r\n            });\r\n\r\n            document.addEventListener('mousemove', function(e) {\r\n                if (isPanning) {\r\n                    const dx = e.clientX - startPoint.x;\r\n                    const dy = e.clientY - startPoint.y;\r\n                    svg.style.transform = \\`scale(\\${scale}",
          "hash": "28cdbccfa975c1fffb82b76da3397cf9"
        },
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 571,
          "endLine": 709,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 572,
          "endLine": 710,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        },
        {
          "type": "function",
          "name": "fx",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 571,
          "endLine": 709,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        },
        {
          "type": "function",
          "name": "fy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 572,
          "endLine": 710,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 139,
          "content": "{\r\n        const pos = layout.get(node.id)!;\r\n        const force = forces.get(node.id)!;\r\n        \r\n        pos.x += force.fx * 0.1;\r\n        pos.y += force.fy * 0.1;\r\n        \r\n        // Keep within bounds\r\n        pos.x = Math.max(50, Math.min(width - 50, pos.x));\r\n        pos.y = Math.max(50, Math.min(height - 50, pos.y));\r\n      });\r\n    }\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Circular layout\r\n   */\r\n  private calculateCircularLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    const layout = new Map<string, { x: number; y: number }>();\r\n    const centerX = width / 2;\r\n    const centerY = height / 2;\r\n    const radius = Math.min(width, height) * 0.4;\r\n    \r\n    graph.nodes.forEach((node, index) => {\r\n      const angle = (2 * Math.PI * index) / graph.nodes.length;\r\n      layout.set(node.id, {\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      });\r\n    });\r\n    \r\n    return layout;\r\n  }\r\n\r\n  /**\r\n   * Tree layout (simplified)\r\n   */\r\n  private calculateTreeLayout(graph: DependencyGraph, width: number, height: number): Map<string, { x: number; y: number }> {\r\n    // For now, use hierarchical layout as tree layout\r\n    return this.calculateHierarchicalLayout(graph, width, height);\r\n  }\r\n\r\n  /**\r\n   * Create SVG document with nodes and edges\r\n   */\r\n  private createSVGDocument(graph: DependencyGraph, layout: Map<string, { x: number; y: number }>, width: number, height: number): string {\r\n    const svg = [];\r\n    \r\n    // SVG header\r\n    svg.push(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`);\r\n    svg.push('<defs>');\r\n    svg.push(this.createArrowMarkers());\r\n    svg.push(this.createGradients());\r\n    svg.push('</defs>');\r\n    \r\n    // Background\r\n    svg.push(`<rect width=\"${width}\" height=\"${height}\" fill=\"#f8f9fa\" stroke=\"#e9ecef\" stroke-width=\"1\"/>`);\r\n    \r\n    // Title\r\n    svg.push(`<text x=\"${width/2}\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial, sans-serif\" font-size=\"20\" font-weight=\"bold\" fill=\"#495057\">Task Dependency Visualization</text>`);\r\n    \r\n    // Draw edges first (so they appear behind nodes)\r\n    svg.push(this.drawEdges(graph.edges, layout));\r\n    \r\n    // Draw nodes\r\n    svg.push(this.drawNodes(graph.nodes, layout));\r\n    \r\n    // Draw legend\r\n    svg.push(this.drawLegend(width, height));\r\n    \r\n    // Statistics\r\n    svg.push(this.drawStatistics(graph, width));\r\n    \r\n    svg.push('</svg>');\r\n    \r\n    return svg.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Create arrow markers for edges\r\n   */\r\n  private createArrowMarkers(): string {\r\n    return `\r\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#6c757d\" />\r\n      </marker>\r\n      <marker id=\"arrowhead-critical\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n        <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#dc3545\" />\r\n      </marker>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Create gradients for visual effects\r\n   */\r\n  private createGradients(): string {\r\n    return `\r\n      <linearGradient id=\"nodeGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n        <stop offset=\"0%\" stop-color=\"#ffffff\" stop-opacity=\"1\" />\r\n        <stop offset=\"100%\" stop-color=\"#f8f9fa\" stop-opacity=\"1\" />\r\n      </linearGradient>\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * Draw all edges\r\n   */\r\n  private drawEdges(edges: DependencyEdge[], layout: Map<string, { x: number; y: number }>): string {\r\n    const edgeElements = [];\r\n    \r\n    for (const edge of edges) {\r\n      const sourcePos = layout.get(edge.source);\r\n      const targetPos = layout.get(edge.target);\r\n      \r\n      if (!sourcePos || !targetPos) continue;\r\n      \r\n      const isCritical = this.config.highlightCriticalPath; // Simplified for now\r\n      const strokeColor = this.getEdgeColor(edge);\r\n      const strokeWidth = this.getEdgeWidth(edge);\r\n      const marker = isCritical ? 'url(#arrowhead-critical)' : 'url(#arrowhead)';\r\n      \r\n      edgeElements.push(`\r\n        <line x1=\"${sourcePos.x}\" y1=\"${sourcePos.y}\" \r\n              x2=\"${targetPos.x}\" y2=\"${targetPos.y}\"\r\n              stroke=\"${strokeColor}\" stroke-width=\"${strokeWidth}\"\r\n              marker-end=\"${marker}\" opacity=\"0.7\">\r\n          <title>${edge.label || edge.type}: ${edge.source} → ${edge.target}</title>\r\n        </line>\r\n      `);\r\n      \r\n      // Add edge label if needed\r\n      if (this.config.showLabels && edge.label) {\r\n        const midX = (sourcePos.x + targetPos.x) / 2;\r\n        const midY = (sourcePos.y + targetPos.y) / 2;\r\n        \r\n        edgeElements.push(`\r\n          <text x=\"${midX}",
          "hash": "995e830140850d40e9557af9a31cdb53"
        },
        {
          "type": "function",
          "name": "angle",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 607,
          "endLine": 610,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      }",
          "hash": "c116f698852128781f2ea3156292fbbe"
        },
        {
          "type": "function",
          "name": "angle",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 607,
          "endLine": 610,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n        x: centerX + radius * Math.cos(angle),\r\n        y: centerY + radius * Math.sin(angle)\r\n      }",
          "hash": "c116f698852128781f2ea3156292fbbe"
        },
        {
          "type": "function",
          "name": "updateVisualization",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts",
          "startLine": 1124,
          "endLine": 1136,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }",
          "hash": "fb14ec7033c31b215819e64ba0424ee6"
        },
        {
          "type": "function",
          "name": "updateVisualization",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts",
          "startLine": 1124,
          "endLine": 1136,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            // This would typically make an AJAX call to regenerate the visualization\r\n            // For now, we'll just show that the controls are interactive\r\n            console.log('Visualization update requested');\r\n            \r\n            const layout = document.getElementById('layoutSelect').value;\r\n            const colorScheme = document.getElementById('colorSelect').value;\r\n            const showLabels = document.getElementById('showLabels').checked;\r\n            const showSubtasks = document.getElementById('showSubtasks').checked;\r\n            const showProgress = document.getElementById('showProgress').checked;\r\n            \r\n            console.log('Config:', { layout, colorScheme, showLabels, showSubtasks, showProgress });\r\n        }",
          "hash": "fb14ec7033c31b215819e64ba0424ee6"
        },
        {
          "type": "function",
          "name": "countTestFiles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\metrics-collector.ts",
          "startLine": 190,
          "endLine": 204,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 15,
          "content": "{\r\n        if (!existsSync(dir)) return;\r\n        const files = readdirSync(dir);\r\n        files.forEach(file => {\r\n          const filePath = join(dir, file);\r\n          const stat = statSync(filePath);\r\n          if (stat.isDirectory()) {\r\n            countTestFiles(filePath);\r\n          } else if (file.endsWith('.test.ts') || file.endsWith('.test.js') || file.endsWith('.spec.ts')) {\r\n            testFiles++;\r\n            // Estimate tests per file (could be parsed more accurately)\r\n            totalTests += 3; // Average tests per file\r\n          }\r\n        });\r\n      }",
          "hash": "75fcac5c9767d118639f5b67092df99a"
        },
        {
          "type": "function",
          "name": "countTestFiles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\metrics-collector.ts",
          "startLine": 190,
          "endLine": 204,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 15,
          "content": "{\r\n        if (!existsSync(dir)) return;\r\n        const files = readdirSync(dir);\r\n        files.forEach(file => {\r\n          const filePath = join(dir, file);\r\n          const stat = statSync(filePath);\r\n          if (stat.isDirectory()) {\r\n            countTestFiles(filePath);\r\n          } else if (file.endsWith('.test.ts') || file.endsWith('.test.js') || file.endsWith('.spec.ts')) {\r\n            testFiles++;\r\n            // Estimate tests per file (could be parsed more accurately)\r\n            totalTests += 3; // Average tests per file\r\n          }\r\n        });\r\n      }",
          "hash": "75fcac5c9767d118639f5b67092df99a"
        },
        {
          "type": "function",
          "name": "change",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\metrics-collector.ts",
          "startLine": 385,
          "endLine": 424,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n    const progress = snapshot.projectMetrics.overallProgress;\r\n    const velocity = snapshot.projectMetrics.velocityPerWeek;\r\n    const blockedTasks = snapshot.projectMetrics.blockedTasks;\r\n    const testCoverage = snapshot.testMetrics?.testCoverage || 0;\r\n    \r\n    let score = 0;\r\n    \r\n    // Progress score (40% weight)\r\n    if (progress > 80) score += 40;\r\n    else if (progress > 60) score += 30;\r\n    else if (progress > 40) score += 20;\r\n    else score += 10;\r\n    \r\n    // Velocity score (30% weight)\r\n    if (velocity > 5) score += 30;\r\n    else if (velocity > 3) score += 20;\r\n    else if (velocity > 1) score += 10;\r\n    \r\n    // Quality score (20% weight)\r\n    if (testCoverage > 80) score += 20;\r\n    else if (testCoverage > 60) score += 15;\r\n    else if (testCoverage > 40) score += 10;\r\n    \r\n    // Risk score (10% weight) - negative impact\r\n    if (blockedTasks === 0) score += 10;\r\n    else if (blockedTasks < 3) score += 5;\r\n    \r\n    if (score >= 90) return 'excellent';\r\n    if (score >= 75) return 'good';\r\n    if (score >= 60) return 'warning';\r\n    return 'critical';\r\n  }\r\n\r\n  private generateExecutiveRecommendations(latest: MetricsSnapshot, trends: any): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (latest.projectMetrics.blockedTasks > 0) {\r\n      recommendations.push(`Immediate attention needed: ${latest.projectMetrics.blockedTasks} blocked tasks`);\r\n    }",
          "hash": "200161f2cce8f2a9cacc6d209fccf769"
        },
        {
          "type": "function",
          "name": "change",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\metrics-collector.ts",
          "startLine": 385,
          "endLine": 424,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n    const progress = snapshot.projectMetrics.overallProgress;\r\n    const velocity = snapshot.projectMetrics.velocityPerWeek;\r\n    const blockedTasks = snapshot.projectMetrics.blockedTasks;\r\n    const testCoverage = snapshot.testMetrics?.testCoverage || 0;\r\n    \r\n    let score = 0;\r\n    \r\n    // Progress score (40% weight)\r\n    if (progress > 80) score += 40;\r\n    else if (progress > 60) score += 30;\r\n    else if (progress > 40) score += 20;\r\n    else score += 10;\r\n    \r\n    // Velocity score (30% weight)\r\n    if (velocity > 5) score += 30;\r\n    else if (velocity > 3) score += 20;\r\n    else if (velocity > 1) score += 10;\r\n    \r\n    // Quality score (20% weight)\r\n    if (testCoverage > 80) score += 20;\r\n    else if (testCoverage > 60) score += 15;\r\n    else if (testCoverage > 40) score += 10;\r\n    \r\n    // Risk score (10% weight) - negative impact\r\n    if (blockedTasks === 0) score += 10;\r\n    else if (blockedTasks < 3) score += 5;\r\n    \r\n    if (score >= 90) return 'excellent';\r\n    if (score >= 75) return 'good';\r\n    if (score >= 60) return 'warning';\r\n    return 'critical';\r\n  }\r\n\r\n  private generateExecutiveRecommendations(latest: MetricsSnapshot, trends: any): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (latest.projectMetrics.blockedTasks > 0) {\r\n      recommendations.push(`Immediate attention needed: ${latest.projectMetrics.blockedTasks} blocked tasks`);\r\n    }",
          "hash": "200161f2cce8f2a9cacc6d209fccf769"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 13,
          "endLine": 30,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 18,
          "content": "{\r\n  isValid: boolean;\r\n  message: string;\r\n  suggestions?: string[];\r\n  autoFix?: () => void;\r\n}\r\n\r\nexport interface ValidationContext {\r\n  projectRoot: string;\r\n  tasksData: any;\r\n  validationConfig: ValidationConfig;\r\n}\r\n\r\nexport interface ValidationConfig {\r\n  rules: {\r\n    enabled: string[];\r\n    disabled: string[];\r\n  }",
          "hash": "5a43ad8019d7cffcff68664a6915871d"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 13,
          "endLine": 30,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 18,
          "content": "{\r\n  isValid: boolean;\r\n  message: string;\r\n  suggestions?: string[];\r\n  autoFix?: () => void;\r\n}\r\n\r\nexport interface ValidationContext {\r\n  projectRoot: string;\r\n  tasksData: any;\r\n  validationConfig: ValidationConfig;\r\n}\r\n\r\nexport interface ValidationConfig {\r\n  rules: {\r\n    enabled: string[];\r\n    disabled: string[];\r\n  }",
          "hash": "5a43ad8019d7cffcff68664a6915871d"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 299,
          "endLine": 326,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 28,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          if (!task.dependencies || task.dependencies.length === 0) {\r\n            return { isValid: true, message: 'No dependencies to check' };\r\n          }\r\n\r\n          const incompleteDeps = task.dependencies.filter((depId: string) => {\r\n            const depTask = this.findTask(allTasks, depId);\r\n            return !depTask || depTask.status !== 'done';\r\n          });\r\n\r\n          if (incompleteDeps.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is marked as done but has incomplete dependencies: ${incompleteDeps.join(', ')}`,\r\n              suggestions: [\r\n                'Complete dependency tasks first',\r\n                'Remove invalid dependencies',\r\n                'Change task status to in-progress or pending'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'All dependencies completed' };\r\n        }",
          "hash": "4529699d0651e3b1b53b7b504eabf1de"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 299,
          "endLine": 326,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 28,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          if (!task.dependencies || task.dependencies.length === 0) {\r\n            return { isValid: true, message: 'No dependencies to check' };\r\n          }\r\n\r\n          const incompleteDeps = task.dependencies.filter((depId: string) => {\r\n            const depTask = this.findTask(allTasks, depId);\r\n            return !depTask || depTask.status !== 'done';\r\n          });\r\n\r\n          if (incompleteDeps.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is marked as done but has incomplete dependencies: ${incompleteDeps.join(', ')}`,\r\n              suggestions: [\r\n                'Complete dependency tasks first',\r\n                'Remove invalid dependencies',\r\n                'Change task status to in-progress or pending'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'All dependencies completed' };\r\n        }",
          "hash": "4529699d0651e3b1b53b7b504eabf1de"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 334,
          "endLine": 376,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n          // Check if task has subtasks\r\n          if (task.subtasks && task.subtasks.length > 0) {\r\n            const completedSubtasks = task.subtasks.filter((st: any) => st.status === 'done').length;\r\n            const totalSubtasks = task.subtasks.length;\r\n            const completionRate = completedSubtasks / totalSubtasks;\r\n\r\n            // Parent task status should reflect subtask completion\r\n            if (completionRate === 1 && task.status !== 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but is not marked as done`,\r\n                suggestions: ['Mark task as done', 'Review subtask completion'],\r\n                autoFix: () => {\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n\r\n            if (completionRate === 0 && task.status === 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} is marked as done but has no completed subtasks`,\r\n                suggestions: ['Review task status', 'Complete subtasks first']\r\n              };\r\n            }\r\n\r\n            if (completionRate > 0 && completionRate < 1 && task.status === 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has partially completed subtasks but is still marked as pending`,\r\n                suggestions: ['Update status to in-progress'],\r\n                autoFix: () => {\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Status is consistent' };\r\n        }",
          "hash": "67878020f48c265ae3f3f74bf969f307"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 334,
          "endLine": 376,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n          // Check if task has subtasks\r\n          if (task.subtasks && task.subtasks.length > 0) {\r\n            const completedSubtasks = task.subtasks.filter((st: any) => st.status === 'done').length;\r\n            const totalSubtasks = task.subtasks.length;\r\n            const completionRate = completedSubtasks / totalSubtasks;\r\n\r\n            // Parent task status should reflect subtask completion\r\n            if (completionRate === 1 && task.status !== 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but is not marked as done`,\r\n                suggestions: ['Mark task as done', 'Review subtask completion'],\r\n                autoFix: () => {\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n\r\n            if (completionRate === 0 && task.status === 'done') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} is marked as done but has no completed subtasks`,\r\n                suggestions: ['Review task status', 'Complete subtasks first']\r\n              };\r\n            }\r\n\r\n            if (completionRate > 0 && completionRate < 1 && task.status === 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has partially completed subtasks but is still marked as pending`,\r\n                suggestions: ['Update status to in-progress'],\r\n                autoFix: () => {\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Status is consistent' };\r\n        }",
          "hash": "67878020f48c265ae3f3f74bf969f307"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 347,
          "endLine": 350,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "9d7f15edb0d7502791ea3fa475e20d37"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 367,
          "endLine": 370,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "a47801b94ec245173e29cf80b9bb0726"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 483,
          "endLine": 486,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "0126a3ca9f90b171688b85ac86a0a187"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 498,
          "endLine": 501,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "808483eedb9d77ce53742fc56c3ded54"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 347,
          "endLine": 350,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'done';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "9d7f15edb0d7502791ea3fa475e20d37"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 367,
          "endLine": 370,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'in-progress';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "a47801b94ec245173e29cf80b9bb0726"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 483,
          "endLine": 486,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "0126a3ca9f90b171688b85ac86a0a187"
        },
        {
          "type": "function",
          "name": "autoFix",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 498,
          "endLine": 501,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 4,
          "content": "{\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }",
          "hash": "808483eedb9d77ce53742fc56c3ded54"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 384,
          "endLine": 420,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 37,
          "content": "{\r\n          if (task.status !== 'blocked') {\r\n            return { isValid: true, message: 'Task is not blocked' };\r\n          }\r\n\r\n          // Check if blocked task has blocking reasons\r\n          if (!task.blockers || task.blockers.length === 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has no specified blockers`,\r\n              suggestions: [\r\n                'Add blocker details to task',\r\n                'Change status if not actually blocked',\r\n                'Create issues for blockers'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if any tasks depend on this blocked task and are marked as done\r\n          const dependentTasks = allTasks.filter((t: any) => \r\n            t.dependencies && t.dependencies.includes(task.id.toString()) && t.status === 'done'\r\n          );\r\n\r\n          if (dependentTasks.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has dependent tasks marked as done: ${dependentTasks.map((t: any) => t.id).join(', ')}`,\r\n              suggestions: [\r\n                'Resolve blocking issues',\r\n                'Review dependent task statuses',\r\n                'Update task dependencies'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Blocking validation passed' };\r\n        }",
          "hash": "35a18eefd4a192eeba6c37abe943a0b9"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 384,
          "endLine": 420,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 37,
          "content": "{\r\n          if (task.status !== 'blocked') {\r\n            return { isValid: true, message: 'Task is not blocked' };\r\n          }\r\n\r\n          // Check if blocked task has blocking reasons\r\n          if (!task.blockers || task.blockers.length === 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has no specified blockers`,\r\n              suggestions: [\r\n                'Add blocker details to task',\r\n                'Change status if not actually blocked',\r\n                'Create issues for blockers'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if any tasks depend on this blocked task and are marked as done\r\n          const dependentTasks = allTasks.filter((t: any) => \r\n            t.dependencies && t.dependencies.includes(task.id.toString()) && t.status === 'done'\r\n          );\r\n\r\n          if (dependentTasks.length > 0) {\r\n            return {\r\n              isValid: false,\r\n              message: `Blocked task ${task.id} has dependent tasks marked as done: ${dependentTasks.map((t: any) => t.id).join(', ')}`,\r\n              suggestions: [\r\n                'Resolve blocking issues',\r\n                'Review dependent task statuses',\r\n                'Update task dependencies'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Blocking validation passed' };\r\n        }",
          "hash": "35a18eefd4a192eeba6c37abe943a0b9"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 428,
          "endLine": 460,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 33,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          // Check if task has required fields when marked as done\r\n          if (!task.details || task.details.trim().length < 10) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} lacks sufficient details`,\r\n              suggestions: [\r\n                'Add comprehensive task details',\r\n                'Document completion steps',\r\n                'Include verification information'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if test strategy is defined for completed tasks\r\n          if (!task.testStrategy) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} has no test strategy defined`,\r\n              suggestions: [\r\n                'Define test strategy',\r\n                'Add verification steps',\r\n                'Document quality assurance process'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Completion requirements met' };\r\n        }",
          "hash": "3eff6d069de472b8f89cbaa5d7f811ea"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 428,
          "endLine": 460,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 33,
          "content": "{\r\n          if (task.status !== 'done') {\r\n            return { isValid: true, message: 'Task not marked as done' };\r\n          }\r\n\r\n          // Check if task has required fields when marked as done\r\n          if (!task.details || task.details.trim().length < 10) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} lacks sufficient details`,\r\n              suggestions: [\r\n                'Add comprehensive task details',\r\n                'Document completion steps',\r\n                'Include verification information'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if test strategy is defined for completed tasks\r\n          if (!task.testStrategy) {\r\n            return {\r\n              isValid: false,\r\n              message: `Completed task ${task.id} has no test strategy defined`,\r\n              suggestions: [\r\n                'Define test strategy',\r\n                'Add verification steps',\r\n                'Document quality assurance process'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Completion requirements met' };\r\n        }",
          "hash": "3eff6d069de472b8f89cbaa5d7f811ea"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 468,
          "endLine": 507,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n          if (!task.subtasks || task.subtasks.length === 0) {\r\n            return { isValid: true, message: 'No subtasks to synchronize' };\r\n          }\r\n\r\n          const subtaskStatuses = task.subtasks.map((st: any) => st.status);\r\n          const uniqueStatuses = [...new Set(subtaskStatuses)];\r\n\r\n          // If all subtasks are done, parent should be done or in review\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'done') {\r\n            if (task.status !== 'done' && task.status !== 'review') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to done or review'],\r\n                autoFix: () => {\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          // If no subtasks are started, parent should be pending\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'pending') {\r\n            if (task.status !== 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks pending but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to pending'],\r\n                autoFix: () => {\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Parent-child status synchronized' };\r\n        }",
          "hash": "578795d15c5a365480987215ccf9c9be"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 468,
          "endLine": 507,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 40,
          "content": "{\r\n          if (!task.subtasks || task.subtasks.length === 0) {\r\n            return { isValid: true, message: 'No subtasks to synchronize' };\r\n          }\r\n\r\n          const subtaskStatuses = task.subtasks.map((st: any) => st.status);\r\n          const uniqueStatuses = [...new Set(subtaskStatuses)];\r\n\r\n          // If all subtasks are done, parent should be done or in review\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'done') {\r\n            if (task.status !== 'done' && task.status !== 'review') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks completed but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to done or review'],\r\n                autoFix: () => {\r\n                  task.status = 'review';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          // If no subtasks are started, parent should be pending\r\n          if (uniqueStatuses.length === 1 && uniqueStatuses[0] === 'pending') {\r\n            if (task.status !== 'pending') {\r\n              return {\r\n                isValid: false,\r\n                message: `Task ${task.id} has all subtasks pending but parent status is ${task.status}`,\r\n                suggestions: ['Update parent status to pending'],\r\n                autoFix: () => {\r\n                  task.status = 'pending';\r\n                  this.saveTasksData(context.tasksData);\r\n                }\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Parent-child status synchronized' };\r\n        }",
          "hash": "578795d15c5a365480987215ccf9c9be"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 515,
          "endLine": 550,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 36,
          "content": "{\r\n          if (!task.endDate) {\r\n            return { isValid: true, message: 'No deadline set' };\r\n          }\r\n\r\n          const deadline = new Date(task.endDate);\r\n          const now = new Date();\r\n\r\n          if (deadline < now && task.status !== 'done' && task.status !== 'cancelled') {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is overdue (deadline: ${deadline.toLocaleDateString()})`,\r\n              suggestions: [\r\n                'Update deadline if still relevant',\r\n                'Complete task urgently',\r\n                'Mark as cancelled if no longer needed',\r\n                'Escalate to project manager'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if deadline is unrealistic (in the past for pending tasks)\r\n          if (deadline < now && task.status === 'pending') {\r\n            return {\r\n              isValid: false,\r\n              message: `Pending task ${task.id} has deadline in the past`,\r\n              suggestions: [\r\n                'Update deadline to realistic date',\r\n                'Start task immediately',\r\n                'Review task priority'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Deadline validation passed' };\r\n        }",
          "hash": "e1ffc74d024d33bc2e311ac2393db1b2"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 515,
          "endLine": 550,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 36,
          "content": "{\r\n          if (!task.endDate) {\r\n            return { isValid: true, message: 'No deadline set' };\r\n          }\r\n\r\n          const deadline = new Date(task.endDate);\r\n          const now = new Date();\r\n\r\n          if (deadline < now && task.status !== 'done' && task.status !== 'cancelled') {\r\n            return {\r\n              isValid: false,\r\n              message: `Task ${task.id} is overdue (deadline: ${deadline.toLocaleDateString()})`,\r\n              suggestions: [\r\n                'Update deadline if still relevant',\r\n                'Complete task urgently',\r\n                'Mark as cancelled if no longer needed',\r\n                'Escalate to project manager'\r\n              ]\r\n            };\r\n          }\r\n\r\n          // Check if deadline is unrealistic (in the past for pending tasks)\r\n          if (deadline < now && task.status === 'pending') {\r\n            return {\r\n              isValid: false,\r\n              message: `Pending task ${task.id} has deadline in the past`,\r\n              suggestions: [\r\n                'Update deadline to realistic date',\r\n                'Start task immediately',\r\n                'Review task priority'\r\n              ]\r\n            };\r\n          }\r\n\r\n          return { isValid: true, message: 'Deadline validation passed' };\r\n        }",
          "hash": "e1ffc74d024d33bc2e311ac2393db1b2"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 558,
          "endLine": 598,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n          // High priority tasks shouldn't be pending for too long\r\n          if (task.priority === 'high' && task.status === 'pending') {\r\n            const lastUpdated = task.lastUpdated ? new Date(task.lastUpdated) : new Date();\r\n            const daysSinceUpdate = (Date.now() - lastUpdated.getTime()) / (1000 * 60 * 60 * 24);\r\n\r\n            if (daysSinceUpdate > 3) {\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          // Critical priority tasks should have clear dependencies\r\n          if (task.priority === 'critical') {\r\n            const dependentTasks = allTasks.filter((t: any) => \r\n              t.dependencies && t.dependencies.includes(task.id.toString())\r\n            );\r\n\r\n            if (dependentTasks.length === 0) {\r\n              return {\r\n                isValid: false,\r\n                message: `Critical priority task ${task.id} has no dependent tasks`,\r\n                suggestions: [\r\n                  'Review priority classification',\r\n                  'Identify dependent tasks',\r\n                  'Document critical path importance'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Priority consistency validated' };\r\n        }",
          "hash": "380fb52b2895355fdb40e5376f97d636"
        },
        {
          "type": "function",
          "name": "validator",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 558,
          "endLine": 598,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n          // High priority tasks shouldn't be pending for too long\r\n          if (task.priority === 'high' && task.status === 'pending') {\r\n            const lastUpdated = task.lastUpdated ? new Date(task.lastUpdated) : new Date();\r\n            const daysSinceUpdate = (Date.now() - lastUpdated.getTime()) / (1000 * 60 * 60 * 24);\r\n\r\n            if (daysSinceUpdate > 3) {\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          // Critical priority tasks should have clear dependencies\r\n          if (task.priority === 'critical') {\r\n            const dependentTasks = allTasks.filter((t: any) => \r\n              t.dependencies && t.dependencies.includes(task.id.toString())\r\n            );\r\n\r\n            if (dependentTasks.length === 0) {\r\n              return {\r\n                isValid: false,\r\n                message: `Critical priority task ${task.id} has no dependent tasks`,\r\n                suggestions: [\r\n                  'Review priority classification',\r\n                  'Identify dependent tasks',\r\n                  'Document critical path importance'\r\n                ]\r\n              };\r\n            }\r\n          }\r\n\r\n          return { isValid: true, message: 'Priority consistency validated' };\r\n        }",
          "hash": "380fb52b2895355fdb40e5376f97d636"
        },
        {
          "type": "function",
          "name": "daysSinceUpdate",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\status-validator.ts",
          "startLine": 562,
          "endLine": 573,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }",
          "hash": "7e88d083356ef01e016b03c52d7ee238"
        },
        {
          "type": "function",
          "name": "daysSinceUpdate",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\status-validator.ts",
          "startLine": 562,
          "endLine": 573,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n              return {\r\n                isValid: false,\r\n                message: `High priority task ${task.id} has been pending for ${Math.floor(daysSinceUpdate)} days`,\r\n                suggestions: [\r\n                  'Start high priority task immediately',\r\n                  'Reassign if resources unavailable',\r\n                  'Review priority classification',\r\n                  'Break down into smaller tasks'\r\n                ]\r\n              };\r\n            }",
          "hash": "7e88d083356ef01e016b03c52d7ee238"
        },
        {
          "type": "function",
          "name": "scan",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\unified-analyzer.ts",
          "startLine": 762,
          "endLine": 778,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n      try {\r\n        const items = await this.readdir(dir);\r\n        for (const item of items) {\r\n          if (this.config.ignoredPaths.some((ignored: string) => item.includes(ignored))) continue;\r\n          const fullPath = path.join(dir, item);\r\n          const stats = await this.stat(fullPath);\r\n          if (stats.isDirectory()) {\r\n            await scan(fullPath);\r\n          } else if (stats.size < this.config.maxFileSize) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Ignore permission errors\r\n      }\r\n    }",
          "hash": "d63e59e47f9fde17e8f7c67ef53dc587"
        },
        {
          "type": "function",
          "name": "scan",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\understanding\\unified-analyzer.ts",
          "startLine": 762,
          "endLine": 778,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n      try {\r\n        const items = await this.readdir(dir);\r\n        for (const item of items) {\r\n          if (this.config.ignoredPaths.some((ignored: string) => item.includes(ignored))) continue;\r\n          const fullPath = path.join(dir, item);\r\n          const stats = await this.stat(fullPath);\r\n          if (stats.isDirectory()) {\r\n            await scan(fullPath);\r\n          } else if (stats.size < this.config.maxFileSize) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Ignore permission errors\r\n      }\r\n    }",
          "hash": "d63e59e47f9fde17e8f7c67ef53dc587"
        },
        {
          "type": "function",
          "name": "createUnifiedAnalyzer",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\unified-analyzer.ts",
          "startLine": 1048,
          "endLine": 1050,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return new UnifiedProjectAnalyzer(projectRoot, config);\r\n}",
          "hash": "4805b9997d165ca97d8cb628f7d0bfb5"
        },
        {
          "type": "function",
          "name": "createUnifiedAnalyzer",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\understanding\\unified-analyzer.ts",
          "startLine": 1048,
          "endLine": 1050,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return new UnifiedProjectAnalyzer(projectRoot, config);\r\n}",
          "hash": "4805b9997d165ca97d8cb628f7d0bfb5"
        },
        {
          "type": "function",
          "name": "runFixedBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\fixed-sma-backtest.ts",
          "startLine": 107,
          "endLine": 205,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 99,
          "content": "{\r\n  console.log('\\n----- RUNNING FIXED SMA CROSSOVER BACKTEST -----');\r\n  \r\n  // Generate sample price data with clear trends for testing\r\n  const candles = generateSampleData();\r\n  console.log(`Generated ${candles.length} sample candles`);\r\n  \r\n  // Create the fixed signal processor\r\n  const processor = new FixedSMASignalProcessor();\r\n  \r\n  // Trading state\r\n  let position: 'long' | 'short' | null = null;\r\n  let entryPrice = 0;\r\n  let totalProfit = 0;\r\n  let trades = 0;\r\n  \r\n  // Process candles with sliding window\r\n  const windowSize = 30; // Enough data for calculations\r\n  \r\n  console.log('\\nProcessing price data...');\r\n  for (let i = windowSize; i < candles.length; i++) {\r\n    // Get current window\r\n    const window = candles.slice(i - windowSize, i + 1);\r\n    \r\n    // Safety check\r\n    if (window.length === 0) {\r\n      continue;\r\n    }\r\n    \r\n    const lastCandle = window[window.length - 1];\r\n    if (!lastCandle) {\r\n      continue;\r\n    }\r\n    \r\n    const currentPrice = lastCandle.close;\r\n    console.log(`\\nWindow ${i}: Price ${currentPrice.toFixed(2)}`);\r\n    \r\n    // Process signal\r\n    const result = processor.process(window);\r\n    \r\n    // Track position and calculate P&L\r\n    if (result) {\r\n      if (result.signal > 0.7) { // Strong buy signal\r\n        if (position === 'short') {\r\n          // Close short position\r\n          const profit = entryPrice - currentPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close SHORT position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open long position\r\n          position = 'long';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open LONG position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      } else if (result.signal < -0.7) { // Strong sell signal\r\n        if (position === 'long') {\r\n          // Close long position\r\n          const profit = currentPrice - entryPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close LONG position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open short position\r\n          position = 'short';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open SHORT position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close any open position\r\n  if (position && candles.length > 0) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      const lastPrice = lastCandle.close;\r\n      const profit = position === 'long' ? \r\n        (lastPrice - entryPrice) : (entryPrice - lastPrice);\r\n      totalProfit += profit;\r\n      console.log(`Close final ${position} position at ${lastPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n    }\r\n  }\r\n  \r\n  // Print results\r\n  console.log('\\n----- BACKTEST RESULTS -----');\r\n  console.log(`Total trades: ${trades}`);\r\n  console.log(`Total profit: ${totalProfit.toFixed(2)}`);\r\n  console.log(`Final position: ${position || 'none'}`);\r\n  console.log('---------------------------\\n');\r\n}",
          "hash": "77322cfc9714c8c1f2dcf994c66daa1e"
        },
        {
          "type": "function",
          "name": "runFixedBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\fixed-sma-backtest.ts",
          "startLine": 107,
          "endLine": 205,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 99,
          "content": "{\r\n  console.log('\\n----- RUNNING FIXED SMA CROSSOVER BACKTEST -----');\r\n  \r\n  // Generate sample price data with clear trends for testing\r\n  const candles = generateSampleData();\r\n  console.log(`Generated ${candles.length} sample candles`);\r\n  \r\n  // Create the fixed signal processor\r\n  const processor = new FixedSMASignalProcessor();\r\n  \r\n  // Trading state\r\n  let position: 'long' | 'short' | null = null;\r\n  let entryPrice = 0;\r\n  let totalProfit = 0;\r\n  let trades = 0;\r\n  \r\n  // Process candles with sliding window\r\n  const windowSize = 30; // Enough data for calculations\r\n  \r\n  console.log('\\nProcessing price data...');\r\n  for (let i = windowSize; i < candles.length; i++) {\r\n    // Get current window\r\n    const window = candles.slice(i - windowSize, i + 1);\r\n    \r\n    // Safety check\r\n    if (window.length === 0) {\r\n      continue;\r\n    }\r\n    \r\n    const lastCandle = window[window.length - 1];\r\n    if (!lastCandle) {\r\n      continue;\r\n    }\r\n    \r\n    const currentPrice = lastCandle.close;\r\n    console.log(`\\nWindow ${i}: Price ${currentPrice.toFixed(2)}`);\r\n    \r\n    // Process signal\r\n    const result = processor.process(window);\r\n    \r\n    // Track position and calculate P&L\r\n    if (result) {\r\n      if (result.signal > 0.7) { // Strong buy signal\r\n        if (position === 'short') {\r\n          // Close short position\r\n          const profit = entryPrice - currentPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close SHORT position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open long position\r\n          position = 'long';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open LONG position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      } else if (result.signal < -0.7) { // Strong sell signal\r\n        if (position === 'long') {\r\n          // Close long position\r\n          const profit = currentPrice - entryPrice;\r\n          totalProfit += profit;\r\n          console.log(`Close LONG position at ${currentPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n          position = null;\r\n          trades++;\r\n        }\r\n        \r\n        if (!position) {\r\n          // Open short position\r\n          position = 'short';\r\n          entryPrice = currentPrice;\r\n          console.log(`Open SHORT position at ${currentPrice.toFixed(2)}`);\r\n          trades++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close any open position\r\n  if (position && candles.length > 0) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      const lastPrice = lastCandle.close;\r\n      const profit = position === 'long' ? \r\n        (lastPrice - entryPrice) : (entryPrice - lastPrice);\r\n      totalProfit += profit;\r\n      console.log(`Close final ${position} position at ${lastPrice.toFixed(2)}, profit: ${profit.toFixed(2)}`);\r\n    }\r\n  }\r\n  \r\n  // Print results\r\n  console.log('\\n----- BACKTEST RESULTS -----');\r\n  console.log(`Total trades: ${trades}`);\r\n  console.log(`Total profit: ${totalProfit.toFixed(2)}`);\r\n  console.log(`Final position: ${position || 'none'}`);\r\n  console.log('---------------------------\\n');\r\n}",
          "hash": "77322cfc9714c8c1f2dcf994c66daa1e"
        },
        {
          "type": "function",
          "name": "runBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\sma-backtest.ts",
          "startLine": 26,
          "endLine": 180,
          "complexity": 18,
          "dependencies": [],
          "usageCount": 0,
          "size": 155,
          "content": "{\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}",
          "hash": "c0a8e331992cbf831ea3ca2272bbb9ba"
        },
        {
          "type": "function",
          "name": "runTest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts",
          "startLine": 68,
          "endLine": 203,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 136,
          "content": "{\r\n  console.log('Starting SMA Crossover Strategy Test');\r\n  console.log(`Settings: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 100,\r\n    volatility: 0.01,\r\n    trendStrength: 0.008,\r\n    trendChangeProbability: 0.1\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-test-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Report saved to sma-test-report.json');\r\n}",
          "hash": "4764ff35836dfe3aed8ed450668b95a8"
        },
        {
          "type": "function",
          "name": "runBacktest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\sma-backtest.ts",
          "startLine": 26,
          "endLine": 180,
          "complexity": 18,
          "dependencies": [],
          "usageCount": 0,
          "size": 155,
          "content": "{\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}",
          "hash": "c0a8e331992cbf831ea3ca2272bbb9ba"
        },
        {
          "type": "function",
          "name": "generateSyntheticCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 28,
          "endLine": 34,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}",
          "hash": "5e5bed3186bbcd8fea06df21126954fd"
        },
        {
          "type": "function",
          "name": "generateSyntheticCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts",
          "startLine": 21,
          "endLine": 27,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}",
          "hash": "5e5bed3186bbcd8fea06df21126954fd"
        },
        {
          "type": "function",
          "name": "generateSyntheticCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 28,
          "endLine": 34,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}",
          "hash": "5e5bed3186bbcd8fea06df21126954fd"
        },
        {
          "type": "function",
          "name": "randomMovement",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 47,
          "endLine": 54,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "9b8fc06ce20784f6e7c9e94170a33760"
        },
        {
          "type": "function",
          "name": "randomMovement",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts",
          "startLine": 40,
          "endLine": 47,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "9b8fc06ce20784f6e7c9e94170a33760"
        },
        {
          "type": "function",
          "name": "randomMovement",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 47,
          "endLine": 54,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "9b8fc06ce20784f6e7c9e94170a33760"
        },
        {
          "type": "function",
          "name": "processAndTrade",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 75,
          "endLine": 178,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 104,
          "content": "{\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}",
          "hash": "dfba8b52503986219f2d6be3a07b5c4b"
        },
        {
          "type": "function",
          "name": "processAndTrade",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 75,
          "endLine": 178,
          "complexity": 14,
          "dependencies": [],
          "usageCount": 0,
          "size": 104,
          "content": "{\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}",
          "hash": "dfba8b52503986219f2d6be3a07b5c4b"
        },
        {
          "type": "function",
          "name": "runComparisonTest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts",
          "startLine": 181,
          "endLine": 248,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 68,
          "content": "{\r\n  console.log('Starting SMA Signal Processor Comparison Test');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 200,\r\n    volatility: 0.01,\r\n    trendStrength: 0.005,\r\n    trendChangeProbability: 0.05\r\n  });\r\n  \r\n  // Create processors\r\n  const originalProcessor = new SMASignalProcessor(config);\r\n  const improvedProcessor = new ImprovedSMASignalProcessor(config);\r\n  \r\n  // Process with both implementations\r\n  console.log('\\nRunning Original SMA Signal Processor...');\r\n  const originalResults = processAndTrade(originalProcessor, candles);\r\n  \r\n  console.log('\\nRunning Improved SMA Signal Processor...');\r\n  const improvedResults = processAndTrade(improvedProcessor, candles);\r\n  \r\n  // Log comparison results\r\n  console.log('\\n===== COMPARISON RESULTS =====');\r\n  console.log(`Original: ${originalResults.signals.length} signals, ${originalResults.trades.length} trades, P&L: ${originalResults.pnl.toFixed(2)}`);\r\n  console.log(`Improved: ${improvedResults.signals.length} signals, ${improvedResults.trades.length} trades, P&L: ${improvedResults.pnl.toFixed(2)}`);\r\n  \r\n  // Generate comparison report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      original: {\r\n        signalCount: originalResults.signals.length,\r\n        tradeCount: originalResults.trades.length,\r\n        pnl: originalResults.pnl\r\n      },\r\n      improved: {\r\n        signalCount: improvedResults.signals.length,\r\n        tradeCount: improvedResults.trades.length,\r\n        pnl: improvedResults.pnl\r\n      },\r\n      comparison: {\r\n        signalDifference: improvedResults.signals.length - originalResults.signals.length,\r\n        pnlDifference: improvedResults.pnl - originalResults.pnl\r\n      }\r\n    },\r\n    details: {\r\n      original: {\r\n        signals: originalResults.signals,\r\n        trades: originalResults.trades\r\n      },\r\n      improved: {\r\n        signals: improvedResults.signals,\r\n        trades: improvedResults.trades\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-comparison-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Comparison report saved to sma-comparison-report.json');\r\n}",
          "hash": "70bc8fa33e2d6ad9d570a686acc49340"
        },
        {
          "type": "function",
          "name": "runComparisonTest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts",
          "startLine": 181,
          "endLine": 248,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 68,
          "content": "{\r\n  console.log('Starting SMA Signal Processor Comparison Test');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 200,\r\n    volatility: 0.01,\r\n    trendStrength: 0.005,\r\n    trendChangeProbability: 0.05\r\n  });\r\n  \r\n  // Create processors\r\n  const originalProcessor = new SMASignalProcessor(config);\r\n  const improvedProcessor = new ImprovedSMASignalProcessor(config);\r\n  \r\n  // Process with both implementations\r\n  console.log('\\nRunning Original SMA Signal Processor...');\r\n  const originalResults = processAndTrade(originalProcessor, candles);\r\n  \r\n  console.log('\\nRunning Improved SMA Signal Processor...');\r\n  const improvedResults = processAndTrade(improvedProcessor, candles);\r\n  \r\n  // Log comparison results\r\n  console.log('\\n===== COMPARISON RESULTS =====');\r\n  console.log(`Original: ${originalResults.signals.length} signals, ${originalResults.trades.length} trades, P&L: ${originalResults.pnl.toFixed(2)}`);\r\n  console.log(`Improved: ${improvedResults.signals.length} signals, ${improvedResults.trades.length} trades, P&L: ${improvedResults.pnl.toFixed(2)}`);\r\n  \r\n  // Generate comparison report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      original: {\r\n        signalCount: originalResults.signals.length,\r\n        tradeCount: originalResults.trades.length,\r\n        pnl: originalResults.pnl\r\n      },\r\n      improved: {\r\n        signalCount: improvedResults.signals.length,\r\n        tradeCount: improvedResults.trades.length,\r\n        pnl: improvedResults.pnl\r\n      },\r\n      comparison: {\r\n        signalDifference: improvedResults.signals.length - originalResults.signals.length,\r\n        pnlDifference: improvedResults.pnl - originalResults.pnl\r\n      }\r\n    },\r\n    details: {\r\n      original: {\r\n        signals: originalResults.signals,\r\n        trades: originalResults.trades\r\n      },\r\n      improved: {\r\n        signals: improvedResults.signals,\r\n        trades: improvedResults.trades\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-comparison-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Comparison report saved to sma-comparison-report.json');\r\n}",
          "hash": "70bc8fa33e2d6ad9d570a686acc49340"
        },
        {
          "type": "function",
          "name": "findAndFixIssues",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-processor.ts",
          "startLine": 14,
          "endLine": 205,
          "complexity": 31,
          "dependencies": [],
          "usageCount": 0,
          "size": 192,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR ISSUE FINDER -----');\r\n  \r\n  // Create test data with predictable pattern\r\n  const candles: Candle[] = [];\r\n  \r\n  // Start with a flat pattern\r\n  for (let i = 0; i < 20; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 102,\r\n      low: 98,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Add a clear uptrend - this should cause a bullish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 20) * 3600000,\r\n      open: 100 + i * 2,\r\n      high: 102 + i * 2,\r\n      low: 98 + i * 2,\r\n      close: 100 + i * 2.5,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Add a clear downtrend - this should cause a bearish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 125 - i * 2,\r\n      high: 127 - i * 2,\r\n      low: 123 - i * 2,\r\n      close: 125 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${candles.length} test candles with clear trend patterns`);\r\n  \r\n  // Configuration with very low thresholds to ensure we get signals\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.01, // Almost no threshold\r\n    minChangePercent: 0.01 // Almost no minimum change\r\n  };\r\n  \r\n  // Manually check when crossovers should happen\r\n  console.log('\\nAnalyzing data for expected crossover points:');\r\n  \r\n  for (let i = 20; i < candles.length; i++) {\r\n    // Calculate SMA values ourselves\r\n    const prices = candles.slice(0, i + 1).map(c => c.close);\r\n    const fastMA = calculateSMA(prices, config.fastPeriod);\r\n    const slowMA = calculateSMA(prices, config.slowPeriod);\r\n    \r\n    if (fastMA.length < 2 || slowMA.length < 2) {continue;}\r\n    \r\n    // Get current and previous values\r\n    const currFast = fastMA[fastMA.length - 1]; \r\n    const prevFast = fastMA[fastMA.length - 2];\r\n    const currSlow = slowMA[slowMA.length - 1];\r\n    const prevSlow = slowMA[slowMA.length - 2];\r\n    \r\n    // Check for crossovers manually\r\n    if (currFast && prevFast && currSlow && prevSlow) {\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log(`Candle ${i}: BULLISH CROSSOVER DETECTED - Should generate BUY signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log(`Candle ${i}: BEARISH CROSSOVER DETECTED - Should generate SELL signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Now test using the SMA processor\r\n  console.log('\\nTesting SMA processor with the same data:');\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Create a log of raw data for analysis\r\n  const logData: {\r\n    configuration: typeof config;\r\n    candleData: Array<{\r\n      index: number;\r\n      price: number;\r\n      fastMA: number;\r\n      slowMA: number;\r\n      difference: number;\r\n    }>;\r\n    signals: Array<{\r\n      index: number;\r\n      type: string;\r\n      confidence: number;\r\n      reason: string;\r\n    }>;\r\n  } = {\r\n    configuration: config,\r\n    candleData: [],\r\n    signals: []\r\n  };\r\n  \r\n  // Process each window\r\n  for (let i = 15; i < candles.length; i++) {\r\n    const window = candles.slice(0, i + 1);\r\n    \r\n    try {\r\n      const result = processor.process(window);\r\n      \r\n      // Calculate MAs directly for reference\r\n      const prices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(prices, config.fastPeriod);\r\n      const slowMA = calculateSMA(prices, config.slowPeriod);\r\n      \r\n      const lastFastMA = fastMA.length > 0 ? fastMA[fastMA.length - 1] : null;\r\n      const lastSlowMA = slowMA.length > 0 ? slowMA[slowMA.length - 1] : null;\r\n      \r\n      console.log(`\\nCandle ${i}: Fast MA = ${lastFastMA?.toFixed(2) || 'N/A'}, Slow MA = ${lastSlowMA?.toFixed(2) || 'N/A'}`);\r\n      \r\n      // Save data for analysis\r\n      if (lastFastMA !== null && lastSlowMA !== null && window.length > 0) {\r\n        const lastCandle = window[window.length - 1];\r\n        if (lastCandle) {\r\n          logData.candleData.push({\r\n            index: i,\r\n            price: lastCandle.close,\r\n            fastMA: lastFastMA,\r\n            slowMA: lastSlowMA,\r\n            difference: lastFastMA - lastSlowMA\r\n          });\r\n        }\r\n      }\r\n      \r\n      if (result) {\r\n        const signalType = result.signal > 0 ? 'BUY' : result.signal < 0 ? 'SELL' : 'NONE';\r\n        console.log(`*** SIGNAL: ${signalType} - Confidence: ${result.confidence.toFixed(2)} ***`);\r\n        console.log(`Reason: ${result.reason}`);\r\n        \r\n        logData.signals.push({\r\n          index: i,\r\n          type: signalType,\r\n          confidence: result.confidence,\r\n          reason: result.reason\r\n        });\r\n      } else {\r\n        console.log('No signal generated');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error processing window at index ${i}:`, error);\r\n    }\r\n  }\r\n  \r\n  // Save data for analysis\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const filename = path.join(outputDir, 'sma-debug-analysis.json');\r\n    fs.writeFileSync(filename, JSON.stringify(logData, null, 2));\r\n    console.log(`\\nDetailed analysis data saved to ${filename}`);\r\n  } catch (error) {\r\n    console.error('Error saving analysis data:', error);\r\n  }\r\n  \r\n  // Check the SMASignalProcessor implementation for issues\r\n  console.log('\\nChecking SMASignalProcessor implementation:');\r\n  console.log('1. Configuration used:', config);\r\n  console.log('2. Signals generated:', logData.signals.length);\r\n  \r\n  if (logData.signals.length === 0) {\r\n    console.log('\\nPOTENTIAL ISSUES IDENTIFIED:');\r\n    console.log(`- Confidence threshold may be too high (current: ${  config.confidenceThreshold  })`);\r\n    console.log('- Signal generation logic may have bugs');\r\n    console.log('- Crossover detection might not be working as expected');\r\n    console.log('\\nRECOMMENDATIONS:');\r\n    console.log('- Review the generateSignal method in SMASignalProcessor');\r\n    console.log('- Ensure crossover detection is correctly implemented');\r\n    console.log('- Lower the confidence threshold or modify confidence calculation');\r\n  }\r\n}",
          "hash": "f0efd78eda81f5ae2400a7a300506675"
        },
        {
          "type": "function",
          "name": "findAndFixIssues",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-processor.ts",
          "startLine": 14,
          "endLine": 205,
          "complexity": 31,
          "dependencies": [],
          "usageCount": 0,
          "size": 192,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR ISSUE FINDER -----');\r\n  \r\n  // Create test data with predictable pattern\r\n  const candles: Candle[] = [];\r\n  \r\n  // Start with a flat pattern\r\n  for (let i = 0; i < 20; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 102,\r\n      low: 98,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Add a clear uptrend - this should cause a bullish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 20) * 3600000,\r\n      open: 100 + i * 2,\r\n      high: 102 + i * 2,\r\n      low: 98 + i * 2,\r\n      close: 100 + i * 2.5,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Add a clear downtrend - this should cause a bearish crossover\r\n  for (let i = 0; i < 10; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 125 - i * 2,\r\n      high: 127 - i * 2,\r\n      low: 123 - i * 2,\r\n      close: 125 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${candles.length} test candles with clear trend patterns`);\r\n  \r\n  // Configuration with very low thresholds to ensure we get signals\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.01, // Almost no threshold\r\n    minChangePercent: 0.01 // Almost no minimum change\r\n  };\r\n  \r\n  // Manually check when crossovers should happen\r\n  console.log('\\nAnalyzing data for expected crossover points:');\r\n  \r\n  for (let i = 20; i < candles.length; i++) {\r\n    // Calculate SMA values ourselves\r\n    const prices = candles.slice(0, i + 1).map(c => c.close);\r\n    const fastMA = calculateSMA(prices, config.fastPeriod);\r\n    const slowMA = calculateSMA(prices, config.slowPeriod);\r\n    \r\n    if (fastMA.length < 2 || slowMA.length < 2) {continue;}\r\n    \r\n    // Get current and previous values\r\n    const currFast = fastMA[fastMA.length - 1]; \r\n    const prevFast = fastMA[fastMA.length - 2];\r\n    const currSlow = slowMA[slowMA.length - 1];\r\n    const prevSlow = slowMA[slowMA.length - 2];\r\n    \r\n    // Check for crossovers manually\r\n    if (currFast && prevFast && currSlow && prevSlow) {\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log(`Candle ${i}: BULLISH CROSSOVER DETECTED - Should generate BUY signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log(`Candle ${i}: BEARISH CROSSOVER DETECTED - Should generate SELL signal`);\r\n        console.log(`  Fast: ${prevFast.toFixed(2)} -> ${currFast.toFixed(2)}`);\r\n        console.log(`  Slow: ${prevSlow.toFixed(2)} -> ${currSlow.toFixed(2)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Now test using the SMA processor\r\n  console.log('\\nTesting SMA processor with the same data:');\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Create a log of raw data for analysis\r\n  const logData: {\r\n    configuration: typeof config;\r\n    candleData: Array<{\r\n      index: number;\r\n      price: number;\r\n      fastMA: number;\r\n      slowMA: number;\r\n      difference: number;\r\n    }>;\r\n    signals: Array<{\r\n      index: number;\r\n      type: string;\r\n      confidence: number;\r\n      reason: string;\r\n    }>;\r\n  } = {\r\n    configuration: config,\r\n    candleData: [],\r\n    signals: []\r\n  };\r\n  \r\n  // Process each window\r\n  for (let i = 15; i < candles.length; i++) {\r\n    const window = candles.slice(0, i + 1);\r\n    \r\n    try {\r\n      const result = processor.process(window);\r\n      \r\n      // Calculate MAs directly for reference\r\n      const prices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(prices, config.fastPeriod);\r\n      const slowMA = calculateSMA(prices, config.slowPeriod);\r\n      \r\n      const lastFastMA = fastMA.length > 0 ? fastMA[fastMA.length - 1] : null;\r\n      const lastSlowMA = slowMA.length > 0 ? slowMA[slowMA.length - 1] : null;\r\n      \r\n      console.log(`\\nCandle ${i}: Fast MA = ${lastFastMA?.toFixed(2) || 'N/A'}, Slow MA = ${lastSlowMA?.toFixed(2) || 'N/A'}`);\r\n      \r\n      // Save data for analysis\r\n      if (lastFastMA !== null && lastSlowMA !== null && window.length > 0) {\r\n        const lastCandle = window[window.length - 1];\r\n        if (lastCandle) {\r\n          logData.candleData.push({\r\n            index: i,\r\n            price: lastCandle.close,\r\n            fastMA: lastFastMA,\r\n            slowMA: lastSlowMA,\r\n            difference: lastFastMA - lastSlowMA\r\n          });\r\n        }\r\n      }\r\n      \r\n      if (result) {\r\n        const signalType = result.signal > 0 ? 'BUY' : result.signal < 0 ? 'SELL' : 'NONE';\r\n        console.log(`*** SIGNAL: ${signalType} - Confidence: ${result.confidence.toFixed(2)} ***`);\r\n        console.log(`Reason: ${result.reason}`);\r\n        \r\n        logData.signals.push({\r\n          index: i,\r\n          type: signalType,\r\n          confidence: result.confidence,\r\n          reason: result.reason\r\n        });\r\n      } else {\r\n        console.log('No signal generated');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error processing window at index ${i}:`, error);\r\n    }\r\n  }\r\n  \r\n  // Save data for analysis\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const filename = path.join(outputDir, 'sma-debug-analysis.json');\r\n    fs.writeFileSync(filename, JSON.stringify(logData, null, 2));\r\n    console.log(`\\nDetailed analysis data saved to ${filename}`);\r\n  } catch (error) {\r\n    console.error('Error saving analysis data:', error);\r\n  }\r\n  \r\n  // Check the SMASignalProcessor implementation for issues\r\n  console.log('\\nChecking SMASignalProcessor implementation:');\r\n  console.log('1. Configuration used:', config);\r\n  console.log('2. Signals generated:', logData.signals.length);\r\n  \r\n  if (logData.signals.length === 0) {\r\n    console.log('\\nPOTENTIAL ISSUES IDENTIFIED:');\r\n    console.log(`- Confidence threshold may be too high (current: ${  config.confidenceThreshold  })`);\r\n    console.log('- Signal generation logic may have bugs');\r\n    console.log('- Crossover detection might not be working as expected');\r\n    console.log('\\nRECOMMENDATIONS:');\r\n    console.log('- Review the generateSignal method in SMASignalProcessor');\r\n    console.log('- Ensure crossover detection is correctly implemented');\r\n    console.log('- Lower the confidence threshold or modify confidence calculation');\r\n  }\r\n}",
          "hash": "f0efd78eda81f5ae2400a7a300506675"
        },
        {
          "type": "function",
          "name": "generateTestData",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-signals.ts",
          "startLine": 14,
          "endLine": 43,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 30,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  let price = 100;\r\n  const startTime = Date.now();\r\n  \r\n  // Use a simpler sine wave for clarity\r\n  for (let i = 0; i < length; i++) {\r\n    // Create obvious up and down trends (high amplitude)\r\n    const trend = Math.sin(i / 20) * 20; // 20% price swings\r\n    price = 100 + trend;\r\n    \r\n    const timestamp = startTime + i * 60 * 60 * 1000; // hourly data\r\n    const open = price * 0.99;\r\n    const close = price;\r\n    const high = price * 1.01;\r\n    const low = price * 0.98;\r\n    const volume = 1000;\r\n    \r\n    candles.push({\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "045654b871c890d2168388fda1d6b071"
        },
        {
          "type": "function",
          "name": "generateTestData",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-signals.ts",
          "startLine": 14,
          "endLine": 43,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 30,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  let price = 100;\r\n  const startTime = Date.now();\r\n  \r\n  // Use a simpler sine wave for clarity\r\n  for (let i = 0; i < length; i++) {\r\n    // Create obvious up and down trends (high amplitude)\r\n    const trend = Math.sin(i / 20) * 20; // 20% price swings\r\n    price = 100 + trend;\r\n    \r\n    const timestamp = startTime + i * 60 * 60 * 1000; // hourly data\r\n    const open = price * 0.99;\r\n    const close = price;\r\n    const high = price * 1.01;\r\n    const low = price * 0.98;\r\n    const volume = 1000;\r\n    \r\n    candles.push({\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "045654b871c890d2168388fda1d6b071"
        },
        {
          "type": "function",
          "name": "debugSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-signals.ts",
          "startLine": 46,
          "endLine": 212,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 167,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR DEBUG -----');\r\n  \r\n  // Generate 100 candles with clear price movements\r\n  const candles = generateTestData(100);\r\n  console.log(`Generated ${candles.length} test candles with sine wave pattern`);\r\n  \r\n  // Extract close prices for analysis\r\n  const prices = candles.map(c => c.close);\r\n  \r\n  // Calculate MAs directly to debug\r\n  const fast1 = calculateSMA(prices, 5);\r\n  const slow1 = calculateSMA(prices, 15);\r\n  console.log(`Calculated MAs directly: Fast(5) length=${fast1.length}, Slow(15) length=${slow1.length}`);\r\n  \r\n  // Create minimal configuration with proper types\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n    signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.1 // Very low threshold\r\n  };\r\n  \r\n  // Initialize processor\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Save raw data and MAs to file for inspection\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const dataFile = path.join(outputDir, 'sma-debug-data.json');\r\n    fs.writeFileSync(dataFile, JSON.stringify({\r\n      candles: candles.slice(0, 20), // First 20 candles sample\r\n      prices: prices.slice(0, 20),\r\n      fastMA: fast1.slice(0, 20),\r\n      slowMA: slow1.slice(0, 15)\r\n    }, null, 2));\r\n    \r\n    console.log(`Saved sample data to ${dataFile}`);\r\n  } catch (error) {\r\n    console.error('Error saving debug data:', error);\r\n  }\r\n  \r\n  // Process in a sliding window to debug\r\n  console.log('\\nTesting signal processing with sliding window:');\r\n  const startIdx = 20; // Start after enough data for MA calculations\r\n  \r\n  // Direct inspection of signal generation logic\r\n  for (let i = startIdx; i < Math.min(candles.length, startIdx + 10); i++) {\r\n    // Log the prices and MAs\r\n    const window = candles.slice(0, i + 1);\r\n    const windowPrices = window.map(c => c.close);\r\n    \r\n    // Calculate MAs directly for comparison\r\n    const fastMA = calculateSMA(windowPrices, config.fastPeriod);\r\n    const slowMA = calculateSMA(windowPrices, config.slowPeriod);\r\n    \r\n    const lastPrice = windowPrices[windowPrices.length - 1];\r\n    const lastFastMA = fastMA[fastMA.length - 1];\r\n    const lastSlowMA = slowMA[slowMA.length - 1];\r\n    \r\n    console.log(`\\nWindow ${i}: Last Price=${lastPrice.toFixed(2)}`);\r\n    console.log(`Fast MA: ${lastFastMA.toFixed(2)}, Slow MA: ${lastSlowMA.toFixed(2)}`);\r\n    \r\n    // Check for crossover conditions manually\r\n    if (fastMA.length >= 2 && slowMA.length >= 2) {\r\n      const currFast = fastMA[fastMA.length - 1];\r\n      const prevFast = fastMA[fastMA.length - 2];\r\n      const currSlow = slowMA[slowMA.length - 1];\r\n      const prevSlow = slowMA[slowMA.length - 2];\r\n      \r\n      console.log(`Previous: Fast=${prevFast.toFixed(2)}, Slow=${prevSlow.toFixed(2)}`);\r\n      console.log(`Current: Fast=${currFast.toFixed(2)}, Slow=${currSlow.toFixed(2)}`);\r\n      \r\n      // Check crossover manually\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate BUY signal (bullish crossover) ***');\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate SELL signal (bearish crossover) ***');\r\n      } else {\r\n        console.log('*** MANUAL CHECK: No crossover detected ***');\r\n      }\r\n    }\r\n    \r\n    // Now use the processor and see what it returns\r\n    try {\r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`PROCESSOR RESULT: Signal=${result.signal}, Confidence=${result.confidence.toFixed(2)}, Reason=${result.reason}`);\r\n      } else {\r\n        console.log('PROCESSOR RESULT: No signal returned');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error from processor:`, error);\r\n    }\r\n  }\r\n  \r\n  console.log('\\n----- DETAILED TESTING WITH FORCED CROSSOVER DATA -----');\r\n  \r\n  // Create data with guaranteed crossover\r\n  const crossoverData: Candle[] = [];\r\n  // First add candles with fast MA below slow MA\r\n  for (let i = 0; i < 30; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 90,\r\n      high: 95,\r\n      low: 85,\r\n      close: 90 + i * 0.1, // Slowly rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then add candles where fast MA will cross above slow MA\r\n  for (let i = 0; i < 10; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 95,\r\n      high: 110,\r\n      low: 95,\r\n      close: 95 + i * 2, // Sharply rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${crossoverData.length} candles with forced crossover pattern`);\r\n  \r\n  // Test with forced crossover data\r\n  try {\r\n    // Reset processor with very permissive settings\r\n    const crossoverProcessor = new SMASignalProcessor({\r\n      fastPeriod: 5,\r\n      slowPeriod: 15,\r\n      priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n      signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n      confidenceThreshold: 0.01 // Almost no threshold\r\n    });\r\n    \r\n    console.log('\\nProcessing forced crossover data:');\r\n    // Process each window\r\n    for (let i = 20; i < crossoverData.length; i++) {\r\n      const window = crossoverData.slice(0, i + 1);\r\n      const result = crossoverProcessor.process(window);\r\n      \r\n      // Calculate MAs directly for comparison\r\n      const windowPrices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(windowPrices, 5);\r\n      const slowMA = calculateSMA(windowPrices, 15);\r\n      \r\n      console.log(`\\nWindow ${i}: Fast=${fastMA[fastMA.length-1].toFixed(2)}, Slow=${slowMA[slowMA.length-1].toFixed(2)}`);\r\n      \r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence=${result.confidence.toFixed(2)}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log('No signal');\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during forced crossover test:', error);\r\n  }\r\n}",
          "hash": "63bb778aca5051b5886c1f1cbd6aa27e"
        },
        {
          "type": "function",
          "name": "debugSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-signals.ts",
          "startLine": 46,
          "endLine": 212,
          "complexity": 25,
          "dependencies": [],
          "usageCount": 0,
          "size": 167,
          "content": "{\r\n  console.log('\\n----- SMA SIGNAL PROCESSOR DEBUG -----');\r\n  \r\n  // Generate 100 candles with clear price movements\r\n  const candles = generateTestData(100);\r\n  console.log(`Generated ${candles.length} test candles with sine wave pattern`);\r\n  \r\n  // Extract close prices for analysis\r\n  const prices = candles.map(c => c.close);\r\n  \r\n  // Calculate MAs directly to debug\r\n  const fast1 = calculateSMA(prices, 5);\r\n  const slow1 = calculateSMA(prices, 15);\r\n  console.log(`Calculated MAs directly: Fast(5) length=${fast1.length}, Slow(15) length=${slow1.length}`);\r\n  \r\n  // Create minimal configuration with proper types\r\n  const config = {\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n    signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n    useEMA: false,\r\n    confidenceThreshold: 0.1 // Very low threshold\r\n  };\r\n  \r\n  // Initialize processor\r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  // Save raw data and MAs to file for inspection\r\n  const outputDir = path.join(__dirname, 'debug-output');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const dataFile = path.join(outputDir, 'sma-debug-data.json');\r\n    fs.writeFileSync(dataFile, JSON.stringify({\r\n      candles: candles.slice(0, 20), // First 20 candles sample\r\n      prices: prices.slice(0, 20),\r\n      fastMA: fast1.slice(0, 20),\r\n      slowMA: slow1.slice(0, 15)\r\n    }, null, 2));\r\n    \r\n    console.log(`Saved sample data to ${dataFile}`);\r\n  } catch (error) {\r\n    console.error('Error saving debug data:', error);\r\n  }\r\n  \r\n  // Process in a sliding window to debug\r\n  console.log('\\nTesting signal processing with sliding window:');\r\n  const startIdx = 20; // Start after enough data for MA calculations\r\n  \r\n  // Direct inspection of signal generation logic\r\n  for (let i = startIdx; i < Math.min(candles.length, startIdx + 10); i++) {\r\n    // Log the prices and MAs\r\n    const window = candles.slice(0, i + 1);\r\n    const windowPrices = window.map(c => c.close);\r\n    \r\n    // Calculate MAs directly for comparison\r\n    const fastMA = calculateSMA(windowPrices, config.fastPeriod);\r\n    const slowMA = calculateSMA(windowPrices, config.slowPeriod);\r\n    \r\n    const lastPrice = windowPrices[windowPrices.length - 1];\r\n    const lastFastMA = fastMA[fastMA.length - 1];\r\n    const lastSlowMA = slowMA[slowMA.length - 1];\r\n    \r\n    console.log(`\\nWindow ${i}: Last Price=${lastPrice.toFixed(2)}`);\r\n    console.log(`Fast MA: ${lastFastMA.toFixed(2)}, Slow MA: ${lastSlowMA.toFixed(2)}`);\r\n    \r\n    // Check for crossover conditions manually\r\n    if (fastMA.length >= 2 && slowMA.length >= 2) {\r\n      const currFast = fastMA[fastMA.length - 1];\r\n      const prevFast = fastMA[fastMA.length - 2];\r\n      const currSlow = slowMA[slowMA.length - 1];\r\n      const prevSlow = slowMA[slowMA.length - 2];\r\n      \r\n      console.log(`Previous: Fast=${prevFast.toFixed(2)}, Slow=${prevSlow.toFixed(2)}`);\r\n      console.log(`Current: Fast=${currFast.toFixed(2)}, Slow=${currSlow.toFixed(2)}`);\r\n      \r\n      // Check crossover manually\r\n      if (currFast > currSlow && prevFast <= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate BUY signal (bullish crossover) ***');\r\n      } else if (currFast < currSlow && prevFast >= prevSlow) {\r\n        console.log('*** MANUAL CHECK: Should generate SELL signal (bearish crossover) ***');\r\n      } else {\r\n        console.log('*** MANUAL CHECK: No crossover detected ***');\r\n      }\r\n    }\r\n    \r\n    // Now use the processor and see what it returns\r\n    try {\r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`PROCESSOR RESULT: Signal=${result.signal}, Confidence=${result.confidence.toFixed(2)}, Reason=${result.reason}`);\r\n      } else {\r\n        console.log('PROCESSOR RESULT: No signal returned');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error from processor:`, error);\r\n    }\r\n  }\r\n  \r\n  console.log('\\n----- DETAILED TESTING WITH FORCED CROSSOVER DATA -----');\r\n  \r\n  // Create data with guaranteed crossover\r\n  const crossoverData: Candle[] = [];\r\n  // First add candles with fast MA below slow MA\r\n  for (let i = 0; i < 30; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 90,\r\n      high: 95,\r\n      low: 85,\r\n      close: 90 + i * 0.1, // Slowly rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then add candles where fast MA will cross above slow MA\r\n  for (let i = 0; i < 10; i++) {\r\n    crossoverData.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 95,\r\n      high: 110,\r\n      low: 95,\r\n      close: 95 + i * 2, // Sharply rising\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  console.log(`Created ${crossoverData.length} candles with forced crossover pattern`);\r\n  \r\n  // Test with forced crossover data\r\n  try {\r\n    // Reset processor with very permissive settings\r\n    const crossoverProcessor = new SMASignalProcessor({\r\n      fastPeriod: 5,\r\n      slowPeriod: 15,\r\n      priceSource: 'close' as 'close' | 'open' | 'high' | 'low',\r\n      signalMode: 'crossover' as 'crossover' | 'trend' | 'combined',\r\n      confidenceThreshold: 0.01 // Almost no threshold\r\n    });\r\n    \r\n    console.log('\\nProcessing forced crossover data:');\r\n    // Process each window\r\n    for (let i = 20; i < crossoverData.length; i++) {\r\n      const window = crossoverData.slice(0, i + 1);\r\n      const result = crossoverProcessor.process(window);\r\n      \r\n      // Calculate MAs directly for comparison\r\n      const windowPrices = window.map(c => c.close);\r\n      const fastMA = calculateSMA(windowPrices, 5);\r\n      const slowMA = calculateSMA(windowPrices, 15);\r\n      \r\n      console.log(`\\nWindow ${i}: Fast=${fastMA[fastMA.length-1].toFixed(2)}, Slow=${slowMA[slowMA.length-1].toFixed(2)}`);\r\n      \r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence=${result.confidence.toFixed(2)}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log('No signal');\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during forced crossover test:', error);\r\n  }\r\n}",
          "hash": "63bb778aca5051b5886c1f1cbd6aa27e"
        },
        {
          "type": "function",
          "name": "generateCandlesWithTrends",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts",
          "startLine": 8,
          "endLine": 49,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 42,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  \r\n  // Create a series of candles with definitive trend patterns\r\n  // First, a flat period\r\n  for (let i = 0; i < 30; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 101,\r\n      low: 99,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then a strong uptrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 100 + i * 3,\r\n      high: 101 + i * 3,\r\n      low: 99 + i * 3,\r\n      close: 100 + i * 3,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Then a strong downtrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 45) * 3600000,\r\n      open: 145 - i * 3,\r\n      high: 146 - i * 3,\r\n      low: 144 - i * 3,\r\n      close: 145 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "dd23108452806bd36d9ed2f47ac8c092"
        },
        {
          "type": "function",
          "name": "generateCandlesWithTrends",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts",
          "startLine": 8,
          "endLine": 49,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 42,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  \r\n  // Create a series of candles with definitive trend patterns\r\n  // First, a flat period\r\n  for (let i = 0; i < 30; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + i * 3600000,\r\n      open: 100,\r\n      high: 101,\r\n      low: 99,\r\n      close: 100,\r\n      volume: 1000\r\n    });\r\n  }\r\n  \r\n  // Then a strong uptrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 30) * 3600000,\r\n      open: 100 + i * 3,\r\n      high: 101 + i * 3,\r\n      low: 99 + i * 3,\r\n      close: 100 + i * 3,\r\n      volume: 2000\r\n    });\r\n  }\r\n  \r\n  // Then a strong downtrend\r\n  for (let i = 0; i < 15; i++) {\r\n    candles.push({\r\n      timestamp: Date.now() + (i + 45) * 3600000,\r\n      open: 145 - i * 3,\r\n      high: 146 - i * 3,\r\n      low: 144 - i * 3,\r\n      close: 145 - i * 3,\r\n      volume: 3000\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "dd23108452806bd36d9ed2f47ac8c092"
        },
        {
          "type": "function",
          "name": "testSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts",
          "startLine": 52,
          "endLine": 92,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n  console.log(\"=== TESTING SMA SIGNAL PROCESSOR ===\");\r\n  \r\n  const candles = generateCandlesWithTrends();\r\n  console.log(`Generated ${candles.length} candles with clear trends`);\r\n  \r\n  // Create a signal processor with very permissive settings\r\n  const processor = new SMASignalProcessor({\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    confidenceThreshold: 0.01\r\n  });\r\n  \r\n  console.log(\"Processing candles with sliding window:\");\r\n  \r\n  // Test every 5th candle to reduce output\r\n  for (let i = 15; i < candles.length; i += 5) {\r\n    const window = candles.slice(0, i + 1);\r\n    try {\r\n      const lastCandle = window[window.length-1];\r\n      if (!lastCandle) {\r\n        console.log(`\\nCandle ${i}: No candle data available`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`\\nCandle ${i}: Price=${lastCandle.close}`);\r\n      \r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence: ${result.confidence}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log(\"No signal generated\");\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error at index ${i}:`, error);\r\n    }\r\n  }\r\n}",
          "hash": "8118f01c6a62e65faf23935ea317e7bd"
        },
        {
          "type": "function",
          "name": "testSignalProcessor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts",
          "startLine": 52,
          "endLine": 92,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 41,
          "content": "{\r\n  console.log(\"=== TESTING SMA SIGNAL PROCESSOR ===\");\r\n  \r\n  const candles = generateCandlesWithTrends();\r\n  console.log(`Generated ${candles.length} candles with clear trends`);\r\n  \r\n  // Create a signal processor with very permissive settings\r\n  const processor = new SMASignalProcessor({\r\n    fastPeriod: 5,\r\n    slowPeriod: 15,\r\n    priceSource: 'close' as 'close',\r\n    signalMode: 'crossover' as 'crossover',\r\n    confidenceThreshold: 0.01\r\n  });\r\n  \r\n  console.log(\"Processing candles with sliding window:\");\r\n  \r\n  // Test every 5th candle to reduce output\r\n  for (let i = 15; i < candles.length; i += 5) {\r\n    const window = candles.slice(0, i + 1);\r\n    try {\r\n      const lastCandle = window[window.length-1];\r\n      if (!lastCandle) {\r\n        console.log(`\\nCandle ${i}: No candle data available`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`\\nCandle ${i}: Price=${lastCandle.close}`);\r\n      \r\n      const result = processor.process(window);\r\n      if (result) {\r\n        console.log(`SIGNAL: ${result.signal > 0 ? 'BUY' : 'SELL'}, Confidence: ${result.confidence}`);\r\n        console.log(`Reason: ${result.reason}`);\r\n      } else {\r\n        console.log(\"No signal generated\");\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error at index ${i}:`, error);\r\n    }\r\n  }\r\n}",
          "hash": "8118f01c6a62e65faf23935ea317e7bd"
        },
        {
          "type": "function",
          "name": "testStrategy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts",
          "startLine": 95,
          "endLine": 110,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 16,
          "content": "{\r\n  console.log(\"\\n=== TESTING SMA CROSSOVER STRATEGY ===\");\r\n  \r\n  const strategy = new SMACrossoverStrategy();\r\n  console.log(\"Strategy loaded:\", strategy.name);\r\n  \r\n  // Log strategy configuration\r\n  const config = strategy.getDefaultConfig();\r\n  console.log(\"Default configuration:\", JSON.stringify(config.parameters, null, 2));\r\n  \r\n  // Print summary\r\n  console.log(\"\\nSummary of debugging analysis:\");\r\n  console.log(\"1. The SMA signal processor is configured to detect crossovers between fast and slow MAs\");\r\n  console.log(\"2. The processor requires a minimum confidence level to generate signals\");\r\n  console.log(\"3. Check the 'generateSignal' method in sma-signal-processor.ts for any issues\");\r\n}",
          "hash": "31f5a8d3ed3504a6faa1fc9f942bfc8c"
        },
        {
          "type": "function",
          "name": "testStrategy",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts",
          "startLine": 95,
          "endLine": 110,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 16,
          "content": "{\r\n  console.log(\"\\n=== TESTING SMA CROSSOVER STRATEGY ===\");\r\n  \r\n  const strategy = new SMACrossoverStrategy();\r\n  console.log(\"Strategy loaded:\", strategy.name);\r\n  \r\n  // Log strategy configuration\r\n  const config = strategy.getDefaultConfig();\r\n  console.log(\"Default configuration:\", JSON.stringify(config.parameters, null, 2));\r\n  \r\n  // Print summary\r\n  console.log(\"\\nSummary of debugging analysis:\");\r\n  console.log(\"1. The SMA signal processor is configured to detect crossovers between fast and slow MAs\");\r\n  console.log(\"2. The processor requires a minimum confidence level to generate signals\");\r\n  console.log(\"3. Check the 'generateSignal' method in sma-signal-processor.ts for any issues\");\r\n}",
          "hash": "31f5a8d3ed3504a6faa1fc9f942bfc8c"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 25,
          "endLine": 34,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n  private systemMonitor: SystemMonitorService;\r\n  private testResults: any[] = [];\r\n\r\n  constructor() {\r\n    this.systemMonitor = new SystemMonitorService({\r\n      collectInterval: 1000, // 1 second for detailed monitoring\r\n      enableAlerts: true\r\n    });\r\n  }",
          "hash": "3ed8d61d68b9908da14ab859b4d43407"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 25,
          "endLine": 34,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n  private systemMonitor: SystemMonitorService;\r\n  private testResults: any[] = [];\r\n\r\n  constructor() {\r\n    this.systemMonitor = new SystemMonitorService({\r\n      collectInterval: 1000, // 1 second for detailed monitoring\r\n      enableAlerts: true\r\n    });\r\n  }",
          "hash": "3ed8d61d68b9908da14ab859b4d43407"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 83,
          "endLine": 95,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            \r\n            // Calculate SMA\r\n            const sma: number[] = [];\r\n            for (let i = period - 1; i < data.length; i++) {\r\n              const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\r\n              sma.push(sum / period);\r\n            }\r\n            \r\n            return sma.length;\r\n          }",
          "hash": "2e6b020dee8d81769208a4f99144be99"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 83,
          "endLine": 95,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            \r\n            // Calculate SMA\r\n            const sma: number[] = [];\r\n            for (let i = period - 1; i < data.length; i++) {\r\n              const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\r\n              sma.push(sum / period);\r\n            }\r\n            \r\n            return sma.length;\r\n          }",
          "hash": "2e6b020dee8d81769208a4f99144be99"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 101,
          "endLine": 113,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            const multiplier = 2 / (period + 1);\r\n            \r\n            // Calculate EMA\r\n            let ema = data[0];\r\n            for (let i = 1; i < data.length; i++) {\r\n              ema = (data[i] * multiplier) + (ema * (1 - multiplier));\r\n            }\r\n            \r\n            return ema;\r\n          }",
          "hash": "50b13f3f7a6551b37709261d4fa6fe8b"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 101,
          "endLine": 113,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            const multiplier = 2 / (period + 1);\r\n            \r\n            // Calculate EMA\r\n            let ema = data[0];\r\n            for (let i = 1; i < data.length; i++) {\r\n              ema = (data[i] * multiplier) + (ema * (1 - multiplier));\r\n            }\r\n            \r\n            return ema;\r\n          }",
          "hash": "50b13f3f7a6551b37709261d4fa6fe8b"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 119,
          "endLine": 139,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n            const prices = Array.from({ length: 100 }, () => 100 + Math.random() * 50);\r\n            const period = 14;\r\n            \r\n            // Calculate price changes\r\n            const changes = prices.slice(1).map((price, i) => price - prices[i]);\r\n            \r\n            // Separate gains and losses\r\n            const gains = changes.map(change => change > 0 ? change : 0);\r\n            const losses = changes.map(change => change < 0 ? -change : 0);\r\n            \r\n            // Calculate average gain and loss\r\n            const avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;\r\n            const avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;\r\n            \r\n            // Calculate RS and RSI\r\n            const rs = avgGain / avgLoss;\r\n            const rsi = 100 - (100 / (1 + rs));\r\n            \r\n            return rsi;\r\n          }",
          "hash": "2e09fe9db5028c7387d020934060b8c9"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 119,
          "endLine": 139,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n            const prices = Array.from({ length: 100 }, () => 100 + Math.random() * 50);\r\n            const period = 14;\r\n            \r\n            // Calculate price changes\r\n            const changes = prices.slice(1).map((price, i) => price - prices[i]);\r\n            \r\n            // Separate gains and losses\r\n            const gains = changes.map(change => change > 0 ? change : 0);\r\n            const losses = changes.map(change => change < 0 ? -change : 0);\r\n            \r\n            // Calculate average gain and loss\r\n            const avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;\r\n            const avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;\r\n            \r\n            // Calculate RS and RSI\r\n            const rs = avgGain / avgLoss;\r\n            const rsi = 100 - (100 / (1 + rs));\r\n            \r\n            return rsi;\r\n          }",
          "hash": "2e09fe9db5028c7387d020934060b8c9"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 145,
          "endLine": 155,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const size = 100000;\r\n            const data = Array.from({ length: size }, (_, i) => Math.random() * 100);\r\n            \r\n            // Perform multiple operations\r\n            const filtered = data.filter(x => x > 50);\r\n            const mapped = filtered.map(x => x * 2);\r\n            const reduced = mapped.reduce((sum, x) => sum + x, 0);\r\n            \r\n            return reduced;\r\n          }",
          "hash": "59e575cc09791930b740ea828d652de3"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 145,
          "endLine": 155,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const size = 100000;\r\n            const data = Array.from({ length: size }, (_, i) => Math.random() * 100);\r\n            \r\n            // Perform multiple operations\r\n            const filtered = data.filter(x => x > 50);\r\n            const mapped = filtered.map(x => x * 2);\r\n            const reduced = mapped.reduce((sum, x) => sum + x, 0);\r\n            \r\n            return reduced;\r\n          }",
          "hash": "59e575cc09791930b740ea828d652de3"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 173,
          "endLine": 191,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 19,
          "content": "{\r\n            const indicatorService = new IndicatorService();\r\n            const prices = Array.from({ length: 200 }, () => ({\r\n              timestamp: Date.now(),\r\n              open: 100 + Math.random() * 10,\r\n              high: 105 + Math.random() * 10,\r\n              low: 95 + Math.random() * 10,\r\n              close: 100 + Math.random() * 10,\r\n              volume: 1000 + Math.random() * 500\r\n            }));\r\n\r\n            // Calculate multiple indicators\r\n            const sma20 = indicatorService.calculateSMA(prices.map(p => p.close), 20);\r\n            const sma50 = indicatorService.calculateSMA(prices.map(p => p.close), 50);\r\n            const ema12 = indicatorService.calculateEMA(prices.map(p => p.close), 12);\r\n            const rsi = indicatorService.calculateRSI(prices.map(p => p.close), 14);\r\n\r\n            return { sma20: sma20.length, sma50: sma50.length, ema12: ema12.length, rsi: rsi.length };\r\n          }",
          "hash": "8e957b7fae3998cf3576611bde3bfab0"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 173,
          "endLine": 191,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 19,
          "content": "{\r\n            const indicatorService = new IndicatorService();\r\n            const prices = Array.from({ length: 200 }, () => ({\r\n              timestamp: Date.now(),\r\n              open: 100 + Math.random() * 10,\r\n              high: 105 + Math.random() * 10,\r\n              low: 95 + Math.random() * 10,\r\n              close: 100 + Math.random() * 10,\r\n              volume: 1000 + Math.random() * 500\r\n            }));\r\n\r\n            // Calculate multiple indicators\r\n            const sma20 = indicatorService.calculateSMA(prices.map(p => p.close), 20);\r\n            const sma50 = indicatorService.calculateSMA(prices.map(p => p.close), 50);\r\n            const ema12 = indicatorService.calculateEMA(prices.map(p => p.close), 12);\r\n            const rsi = indicatorService.calculateRSI(prices.map(p => p.close), 14);\r\n\r\n            return { sma20: sma20.length, sma50: sma50.length, ema12: ema12.length, rsi: rsi.length };\r\n          }",
          "hash": "8e957b7fae3998cf3576611bde3bfab0"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 209,
          "endLine": 225,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n            const prices = Array.from({ length: 500 }, () => Math.random() * 100);\r\n            const signals = [];\r\n            \r\n            for (let i = 20; i < prices.length; i++) {\r\n              const sma20 = prices.slice(i - 20, i).reduce((a, b) => a + b) / 20;\r\n              const sma50 = i >= 50 ? prices.slice(i - 50, i).reduce((a, b) => a + b) / 50 : 0;\r\n              \r\n              if (sma20 > sma50) {\r\n                signals.push('BUY');\r\n              } else if (sma20 < sma50) {\r\n                signals.push('SELL');\r\n              }\r\n            }\r\n            \r\n            return signals.length;\r\n          }",
          "hash": "f8f8eb08301eab92604911dbf4fc334b"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 209,
          "endLine": 225,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 17,
          "content": "{\r\n            const prices = Array.from({ length: 500 }, () => Math.random() * 100);\r\n            const signals = [];\r\n            \r\n            for (let i = 20; i < prices.length; i++) {\r\n              const sma20 = prices.slice(i - 20, i).reduce((a, b) => a + b) / 20;\r\n              const sma50 = i >= 50 ? prices.slice(i - 50, i).reduce((a, b) => a + b) / 50 : 0;\r\n              \r\n              if (sma20 > sma50) {\r\n                signals.push('BUY');\r\n              } else if (sma20 < sma50) {\r\n                signals.push('SELL');\r\n              }\r\n            }\r\n            \r\n            return signals.length;\r\n          }",
          "hash": "f8f8eb08301eab92604911dbf4fc334b"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts",
          "startLine": 243,
          "endLine": 253,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const initialMemory = process.memoryUsage();\r\n            const data = Array.from({ length: 100000 }, () => Math.random());\r\n            const processed = data.map(x => x * 2).filter(x => x > 1);\r\n            const finalMemory = process.memoryUsage();\r\n            \r\n            return {\r\n              processed: processed.length,\r\n              memoryDelta: finalMemory.heapUsed - initialMemory.heapUsed\r\n            };\r\n          }",
          "hash": "51d1bfe50187f34ee14912f111e312e3"
        },
        {
          "type": "function",
          "name": "testFunction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts",
          "startLine": 243,
          "endLine": 253,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n            const initialMemory = process.memoryUsage();\r\n            const data = Array.from({ length: 100000 }, () => Math.random());\r\n            const processed = data.map(x => x * 2).filter(x => x > 1);\r\n            const finalMemory = process.memoryUsage();\r\n            \r\n            return {\r\n              processed: processed.length,\r\n              memoryDelta: finalMemory.heapUsed - initialMemory.heapUsed\r\n            };\r\n          }",
          "hash": "51d1bfe50187f34ee14912f111e312e3"
        },
        {
          "type": "function",
          "name": "info",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 497,
          "endLine": 499,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n          // logger.info(message, LogCategory.STRATEGY, data);\r\n        }",
          "hash": "2b2865f9d353981be36250581f512c52"
        },
        {
          "type": "function",
          "name": "warn",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 500,
          "endLine": 502,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n          // logger.warn(message, LogCategory.STRATEGY, data);\r\n        }",
          "hash": "cc1b2898ef9be65964f63e65bba9a7c3"
        },
        {
          "type": "function",
          "name": "error",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 503,
          "endLine": 505,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n          // logger.error(message, LogCategory.STRATEGY, data);\r\n        }",
          "hash": "13516622887f71241498ec3ce861009f"
        },
        {
          "type": "function",
          "name": "debug",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 506,
          "endLine": 508,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n          // logger.debug(message, LogCategory.STRATEGY, data);\r\n        }",
          "hash": "5629a0a90705d7dd85f6db26878a1575"
        },
        {
          "type": "function",
          "name": "emit",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 516,
          "endLine": 604,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 89,
          "content": "{\r\n    const state = runtime.getState();\r\n    const botId = state.botId;\r\n\r\n    runtime.on('started', () => {\r\n      // logger.info('📡 Bot started event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('stopped', () => {\r\n      // logger.info('📡 Bot stopped event', LogCategory.BOT, { botId });\r\n      this.activeBots.delete(botId);\r\n      this.broadcastBotStatusUpdate(botId, 'stopped');\r\n    });\r\n\r\n    runtime.on('paused', () => {\r\n      // logger.info('📡 Bot paused event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'paused');\r\n    });\r\n\r\n    runtime.on('resumed', () => {\r\n      // logger.info('📡 Bot resumed event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('error', (error: Error) => {\r\n      // logger.error('📡 Bot error event', LogCategory.BOT, {\r\n      //   botId,\r\n      //   error: error.message\r\n      // });\r\n      this.broadcastBotStatusUpdate(botId, 'error');\r\n    });\r\n\r\n    runtime.on('signal', (data: any) => {\r\n      // logger.info('📡 Bot signal event', LogCategory.SIGNAL, {\r\n      //   botId,\r\n      //   signal: data.signal\r\n      // });\r\n      \r\n      // Broadcast signal to WebSocket clients\r\n      webSocketService.broadcast('bot-signal', {\r\n        botId,\r\n        signal: data.signal,\r\n        timestamp: data.timestamp\r\n      });\r\n    });\r\n\r\n    runtime.on('tick', (_data: any) => {\r\n      // Broadcast performance updates periodically (every 10 ticks)\r\n      const currentState = runtime.getState();\r\n      if (currentState.performance.tickCount % 10 === 0) {\r\n        this.broadcastBotPerformanceUpdate(botId, currentState.performance);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up monitoring for bot health and performance\r\n   */\r\n  private setupMonitoring(): void {\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.performHealthCheck();\r\n    }, this.config.monitoringInterval);\r\n  }\r\n\r\n  /**\r\n   * Perform health check on all active bots\r\n   */\r\n  private performHealthCheck(): void {\r\n    const now = new Date();\r\n    \r\n    for (const [botId, runtime] of this.activeBots) {\r\n      const state = runtime.getState();\r\n      \r\n      // Check for stale bots (no tick in last 2 minutes)\r\n      if (state.lastTickAt && state.status === 'running') {\r\n        const timeSinceLastTick = now.getTime() - state.lastTickAt.getTime();\r\n        const staleThreshold = 2 * 60 * 1000; // 2 minutes\r\n        \r\n        if (timeSinceLastTick > staleThreshold) {\r\n          // logger.warn('⚠️ Bot appears stale', LogCategory.BOT, {\r\n          //   botId,\r\n          //   timeSinceLastTick,\r\n          //   lastTickAt: state.lastTickAt\r\n          // });\r\n          \r\n          // Emit warning event\r\n          this.emit('bot-stale', { botId, timeSinceLastTick });\r\n        }",
          "hash": "73e8c4a148b98110036ee6ac35b49810"
        },
        {
          "type": "function",
          "name": "on",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 517,
          "endLine": 605,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 89,
          "content": "{\r\n    const state = runtime.getState();\r\n    const botId = state.botId;\r\n\r\n    runtime.on('started', () => {\r\n      // logger.info('📡 Bot started event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('stopped', () => {\r\n      // logger.info('📡 Bot stopped event', LogCategory.BOT, { botId });\r\n      this.activeBots.delete(botId);\r\n      this.broadcastBotStatusUpdate(botId, 'stopped');\r\n    });\r\n\r\n    runtime.on('paused', () => {\r\n      // logger.info('📡 Bot paused event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'paused');\r\n    });\r\n\r\n    runtime.on('resumed', () => {\r\n      // logger.info('📡 Bot resumed event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('error', (error: Error) => {\r\n      // logger.error('📡 Bot error event', LogCategory.BOT, {\r\n      //   botId,\r\n      //   error: error.message\r\n      // });\r\n      this.broadcastBotStatusUpdate(botId, 'error');\r\n    });\r\n\r\n    runtime.on('signal', (data: any) => {\r\n      // logger.info('📡 Bot signal event', LogCategory.SIGNAL, {\r\n      //   botId,\r\n      //   signal: data.signal\r\n      // });\r\n      \r\n      // Broadcast signal to WebSocket clients\r\n      webSocketService.broadcast('bot-signal', {\r\n        botId,\r\n        signal: data.signal,\r\n        timestamp: data.timestamp\r\n      });\r\n    });\r\n\r\n    runtime.on('tick', (_data: any) => {\r\n      // Broadcast performance updates periodically (every 10 ticks)\r\n      const currentState = runtime.getState();\r\n      if (currentState.performance.tickCount % 10 === 0) {\r\n        this.broadcastBotPerformanceUpdate(botId, currentState.performance);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up monitoring for bot health and performance\r\n   */\r\n  private setupMonitoring(): void {\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.performHealthCheck();\r\n    }, this.config.monitoringInterval);\r\n  }\r\n\r\n  /**\r\n   * Perform health check on all active bots\r\n   */\r\n  private performHealthCheck(): void {\r\n    const now = new Date();\r\n    \r\n    for (const [botId, runtime] of this.activeBots) {\r\n      const state = runtime.getState();\r\n      \r\n      // Check for stale bots (no tick in last 2 minutes)\r\n      if (state.lastTickAt && state.status === 'running') {\r\n        const timeSinceLastTick = now.getTime() - state.lastTickAt.getTime();\r\n        const staleThreshold = 2 * 60 * 1000; // 2 minutes\r\n        \r\n        if (timeSinceLastTick > staleThreshold) {\r\n          // logger.warn('⚠️ Bot appears stale', LogCategory.BOT, {\r\n          //   botId,\r\n          //   timeSinceLastTick,\r\n          //   lastTickAt: state.lastTickAt\r\n          // });\r\n          \r\n          // Emit warning event\r\n          this.emit('bot-stale', { botId, timeSinceLastTick });\r\n        }",
          "hash": "73e8c4a148b98110036ee6ac35b49810"
        },
        {
          "type": "function",
          "name": "off",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts",
          "startLine": 518,
          "endLine": 606,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 89,
          "content": "{\r\n    const state = runtime.getState();\r\n    const botId = state.botId;\r\n\r\n    runtime.on('started', () => {\r\n      // logger.info('📡 Bot started event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('stopped', () => {\r\n      // logger.info('📡 Bot stopped event', LogCategory.BOT, { botId });\r\n      this.activeBots.delete(botId);\r\n      this.broadcastBotStatusUpdate(botId, 'stopped');\r\n    });\r\n\r\n    runtime.on('paused', () => {\r\n      // logger.info('📡 Bot paused event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'paused');\r\n    });\r\n\r\n    runtime.on('resumed', () => {\r\n      // logger.info('📡 Bot resumed event', LogCategory.BOT, { botId });\r\n      this.broadcastBotStatusUpdate(botId, 'running');\r\n    });\r\n\r\n    runtime.on('error', (error: Error) => {\r\n      // logger.error('📡 Bot error event', LogCategory.BOT, {\r\n      //   botId,\r\n      //   error: error.message\r\n      // });\r\n      this.broadcastBotStatusUpdate(botId, 'error');\r\n    });\r\n\r\n    runtime.on('signal', (data: any) => {\r\n      // logger.info('📡 Bot signal event', LogCategory.SIGNAL, {\r\n      //   botId,\r\n      //   signal: data.signal\r\n      // });\r\n      \r\n      // Broadcast signal to WebSocket clients\r\n      webSocketService.broadcast('bot-signal', {\r\n        botId,\r\n        signal: data.signal,\r\n        timestamp: data.timestamp\r\n      });\r\n    });\r\n\r\n    runtime.on('tick', (_data: any) => {\r\n      // Broadcast performance updates periodically (every 10 ticks)\r\n      const currentState = runtime.getState();\r\n      if (currentState.performance.tickCount % 10 === 0) {\r\n        this.broadcastBotPerformanceUpdate(botId, currentState.performance);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up monitoring for bot health and performance\r\n   */\r\n  private setupMonitoring(): void {\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.performHealthCheck();\r\n    }, this.config.monitoringInterval);\r\n  }\r\n\r\n  /**\r\n   * Perform health check on all active bots\r\n   */\r\n  private performHealthCheck(): void {\r\n    const now = new Date();\r\n    \r\n    for (const [botId, runtime] of this.activeBots) {\r\n      const state = runtime.getState();\r\n      \r\n      // Check for stale bots (no tick in last 2 minutes)\r\n      if (state.lastTickAt && state.status === 'running') {\r\n        const timeSinceLastTick = now.getTime() - state.lastTickAt.getTime();\r\n        const staleThreshold = 2 * 60 * 1000; // 2 minutes\r\n        \r\n        if (timeSinceLastTick > staleThreshold) {\r\n          // logger.warn('⚠️ Bot appears stale', LogCategory.BOT, {\r\n          //   botId,\r\n          //   timeSinceLastTick,\r\n          //   lastTickAt: state.lastTickAt\r\n          // });\r\n          \r\n          // Emit warning event\r\n          this.emit('bot-stale', { botId, timeSinceLastTick });\r\n        }",
          "hash": "73e8c4a148b98110036ee6ac35b49810"
        },
        {
          "type": "function",
          "name": "isProduction",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\config\\config-manager.ts",
          "startLine": 425,
          "endLine": 427,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return configManager.getEnvironment() === 'production';\r\n}",
          "hash": "e9a90c4271a8ab8dc54f65760f69a7e1"
        },
        {
          "type": "function",
          "name": "isDevelopment",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\config\\config-manager.ts",
          "startLine": 429,
          "endLine": 431,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return configManager.getEnvironment() === 'development';\r\n}",
          "hash": "0dbd4e5e78c43623986b8c60a277e258"
        },
        {
          "type": "function",
          "name": "isTest",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\config\\config-manager.ts",
          "startLine": 433,
          "endLine": 435,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return configManager.getEnvironment() === 'test';\r\n}",
          "hash": "e8760b85fe4eba59e8ef05c0ccb9b74e"
        },
        {
          "type": "function",
          "name": "percentB",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\bollinger-bands.ts",
          "startLine": 63,
          "endLine": 83,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n  const { upper, lower } = bollingerBands\r\n  const signals: number[] = []\r\n\r\n  // Align prices with Bollinger Bands (which start after 'period' elements)\r\n  const alignedPrices = prices.slice(prices.length - upper.length)\r\n\r\n  for (let i = 1; i < alignedPrices.length; i++) {\r\n    const price = alignedPrices.at(i);\r\n    const pricePrev = alignedPrices.at(i - 1);\r\n    const l = lower.at(i);\r\n    const lPrev = lower.at(i - 1);\r\n    const u = upper.at(i);\r\n    const uPrev = upper.at(i - 1);\r\n    if (\r\n      price !== undefined && l !== undefined && pricePrev !== undefined && lPrev !== undefined &&\r\n      price < l && pricePrev >= lPrev\r\n    ) {\r\n      // Price crosses below lower band - potential buy signal\r\n      signals.push(1);\r\n    }",
          "hash": "197eaeb9ea1f434e4cea7c763058ef28"
        },
        {
          "type": "function",
          "name": "getBollingerBandsSignals",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\bollinger-bands.ts",
          "startLine": 77,
          "endLine": 110,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 34,
          "content": "{\r\n  const { upper, lower } = bollingerBands\r\n  const signals: number[] = []\r\n\r\n  // Align prices with Bollinger Bands (which start after 'period' elements)\r\n  const alignedPrices = prices.slice(prices.length - upper.length)\r\n\r\n  for (let i = 1; i < alignedPrices.length; i++) {\r\n    const price = alignedPrices.at(i);\r\n    const pricePrev = alignedPrices.at(i - 1);\r\n    const l = lower.at(i);\r\n    const lPrev = lower.at(i - 1);\r\n    const u = upper.at(i);\r\n    const uPrev = upper.at(i - 1);\r\n    if (\r\n      price !== undefined && l !== undefined && pricePrev !== undefined && lPrev !== undefined &&\r\n      price < l && pricePrev >= lPrev\r\n    ) {\r\n      // Price crosses below lower band - potential buy signal\r\n      signals.push(1);\r\n    } else if (\r\n      price !== undefined && u !== undefined && pricePrev !== undefined && uPrev !== undefined &&\r\n      price > u && pricePrev <= uPrev\r\n    ) {\r\n      // Price crosses above upper band - potential sell signal\r\n      signals.push(-1);\r\n    } else {\r\n      // No signal\r\n      signals.push(0);\r\n    }\r\n  }\r\n\r\n  return signals\r\n}",
          "hash": "4a04a6d957f039216cefe1e12255e3aa"
        },
        {
          "type": "function",
          "name": "ema",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\moving-averages.ts",
          "startLine": 56,
          "endLine": 70,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 15,
          "content": "{\r\n  if (fastMA.length !== slowMA.length) {\r\n    throw new Error(\"Moving average arrays must be of the same length\")\r\n  }\r\n\r\n  const signals: number[] = []\r\n\r\n  for (let i = 1; i < fastMA.length; i++) {\r\n    const f = fastMA.at(i);\r\n    const fPrev = fastMA.at(i - 1);\r\n    const s = slowMA.at(i);\r\n    const sPrev = slowMA.at(i - 1);\r\n    if (f === undefined || fPrev === undefined || s === undefined || sPrev === undefined) {\r\n      throw new Error(`Missing moving average value at index ${i} for crossover signal calculation`);\r\n    }",
          "hash": "d6f7de301ecb6b95215fb0ad50f9d2e3"
        },
        {
          "type": "function",
          "name": "getMASignals",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\moving-averages.ts",
          "startLine": 70,
          "endLine": 98,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 29,
          "content": "{\r\n  if (fastMA.length !== slowMA.length) {\r\n    throw new Error(\"Moving average arrays must be of the same length\")\r\n  }\r\n\r\n  const signals: number[] = []\r\n\r\n  for (let i = 1; i < fastMA.length; i++) {\r\n    const f = fastMA.at(i);\r\n    const fPrev = fastMA.at(i - 1);\r\n    const s = slowMA.at(i);\r\n    const sPrev = slowMA.at(i - 1);\r\n    if (f === undefined || fPrev === undefined || s === undefined || sPrev === undefined) {\r\n      throw new Error(`Missing moving average value at index ${i} for crossover signal calculation`);\r\n    }\r\n    if (f > s && fPrev <= sPrev) {\r\n      // Bullish crossover (fast MA crosses above slow MA)\r\n      signals.push(1);\r\n    } else if (f < s && fPrev >= sPrev) {\r\n      // Bearish crossover (fast MA crosses below slow MA)\r\n      signals.push(-1);\r\n    } else {\r\n      // No crossover\r\n      signals.push(0);\r\n    }\r\n  }\r\n\r\n  return signals\r\n}",
          "hash": "dbbf3871502db2e76d4f334e1a128084"
        },
        {
          "type": "function",
          "name": "getActiveAlerts",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts",
          "startLine": 95,
          "endLine": 145,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 51,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    if (!alertManager) {\r\n      res.status(503).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert manager not initialized',\r\n          code: 'SERVICE_UNAVAILABLE'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const alerts = alertManager.getActiveAlerts();\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        alerts,\r\n        total: alerts.length\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/alerts/active'\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n    logger.error('Failed to retrieve active alerts', { error: errorMessage });\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: {\r\n        message: 'Failed to retrieve active alerts',\r\n        details: errorMessage\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/alerts/active'\r\n      }\r\n    });\r\n  }\r\n}",
          "hash": "bd1348ef00e78b8e06e5411cea4bc42d"
        },
        {
          "type": "function",
          "name": "getAlertStats",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts",
          "startLine": 150,
          "endLine": 201,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 52,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    if (!alertManager) {\r\n      res.status(503).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert manager not initialized',\r\n          code: 'SERVICE_UNAVAILABLE'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const stats = alertManager.getAlertStats();\r\n    const summary = alertManager.getAlertSummary();\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        stats,\r\n        summary\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/alerts/stats'\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n    logger.error('Failed to retrieve alert statistics', { error: errorMessage });\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: {\r\n        message: 'Failed to retrieve alert statistics',\r\n        details: errorMessage\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: '/api/alerts/stats'\r\n      }\r\n    });\r\n  }\r\n}",
          "hash": "b93f41dd72c653e8842da46fdd42a32d"
        },
        {
          "type": "function",
          "name": "acknowledgeAlert",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts",
          "startLine": 206,
          "endLine": 278,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 73,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    if (!alertManager) {\r\n      res.status(503).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert manager not initialized',\r\n          code: 'SERVICE_UNAVAILABLE'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const { alertId } = req.params;\r\n    const { acknowledgedBy = 'system' } = req.body;\r\n\r\n    if (!alertId) {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert ID is required',\r\n          code: 'MISSING_ALERT_ID'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const updatedAlert = alertManager.acknowledgeAlert(alertId, acknowledgedBy);\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        alert: updatedAlert\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: `/api/alerts/${alertId}/acknowledge`\r\n      }\r\n    });\r\n\r\n    logger.info('Alert acknowledged', {\r\n      alertId,\r\n      acknowledgedBy,\r\n      title: updatedAlert.title\r\n    });\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n    logger.error('Failed to acknowledge alert', { \r\n      alertId: req.params.alertId,\r\n      error: errorMessage \r\n    });\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: {\r\n        message: 'Failed to acknowledge alert',\r\n        details: errorMessage\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: `/api/alerts/${req.params.alertId}/acknowledge`\r\n      }\r\n    });\r\n  }\r\n}",
          "hash": "a27ebd584d8b205b8c957491c5b690eb"
        },
        {
          "type": "function",
          "name": "resolveAlert",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts",
          "startLine": 283,
          "endLine": 355,
          "complexity": 6,
          "dependencies": [],
          "usageCount": 0,
          "size": 73,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    if (!alertManager) {\r\n      res.status(503).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert manager not initialized',\r\n          code: 'SERVICE_UNAVAILABLE'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const { alertId } = req.params;\r\n\r\n    if (!alertId) {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert ID is required',\r\n          code: 'MISSING_ALERT_ID'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const updatedAlert = alertManager.resolveAlert(alertId);\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        alert: updatedAlert\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: `/api/alerts/${alertId}/resolve`\r\n      }\r\n    });\r\n\r\n    logger.info('Alert resolved', {\r\n      alertId,\r\n      title: updatedAlert.title,\r\n      duration: updatedAlert.resolvedAt ? \r\n        updatedAlert.resolvedAt.getTime() - updatedAlert.timestamp.getTime() : 0\r\n    });\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n    logger.error('Failed to resolve alert', { \r\n      alertId: req.params.alertId,\r\n      error: errorMessage \r\n    });\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: {\r\n        message: 'Failed to resolve alert',\r\n        details: errorMessage\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: `/api/alerts/${req.params.alertId}/resolve`\r\n      }\r\n    });\r\n  }\r\n}",
          "hash": "36209c5d186a98d952355f0063b2505a"
        },
        {
          "type": "function",
          "name": "escalateAlert",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts",
          "startLine": 360,
          "endLine": 430,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 71,
          "content": "{\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    if (!alertManager) {\r\n      res.status(503).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert manager not initialized',\r\n          code: 'SERVICE_UNAVAILABLE'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const { alertId } = req.params;\r\n\r\n    if (!alertId) {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: {\r\n          message: 'Alert ID is required',\r\n          code: 'MISSING_ALERT_ID'\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    const updatedAlert = alertManager.escalateAlert(alertId);\r\n    const responseTime = Date.now() - startTime;\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        alert: updatedAlert\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: `/api/alerts/${alertId}/escalate`\r\n      }\r\n    });\r\n\r\n    logger.warn('Alert escalated', {\r\n      alertId,\r\n      title: updatedAlert.title\r\n    });\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - startTime;\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n    logger.error('Failed to escalate alert', { \r\n      alertId: req.params.alertId,\r\n      error: errorMessage \r\n    });\r\n\r\n    res.status(500).json({\r\n      success: false,\r\n      error: {\r\n        message: 'Failed to escalate alert',\r\n        details: errorMessage\r\n      },\r\n      meta: {\r\n        responseTime,\r\n        timestamp: new Date().toISOString(),\r\n        endpoint: `/api/alerts/${req.params.alertId}/escalate`\r\n      }\r\n    });\r\n  }\r\n}",
          "hash": "86b1175320ff9f17fe0fba89046c19fb"
        },
        {
          "type": "function",
          "name": "validateBotTradingCycleIntegration",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\bot-trading-cycle-validation.ts",
          "startLine": 9,
          "endLine": 265,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 257,
          "content": "{\r\n  console.log('🔍 Starting Bot Trading Cycle Integration Validation...');\r\n  \r\n  try {\r\n    // Test 1: Enhanced Trading Engine Initialization\r\n    console.log('\\n1. Testing Enhanced Trading Engine...');\r\n    \r\n    const tradingEngine = new EnhancedTradingEngine();\r\n    console.log('✅ Enhanced Trading Engine initialized successfully');\r\n    \r\n    // Test signal processing\r\n    const testSignals = [\r\n      {\r\n        id: 'test-signal-001',\r\n        symbol: 'BTC/USDT',\r\n        action: 'buy',\r\n        confidence: 0.85,\r\n        amount: 0.001,\r\n        timestamp: Date.now(),\r\n        marketData: {\r\n          volatility: 0.02,\r\n          volume: 1000000,\r\n          orderBookImbalance: 0.1\r\n        }\r\n      }\r\n    ];\r\n    \r\n    const processedSignals = await tradingEngine.processAdvancedSignals(testSignals);\r\n    console.log('✅ Signal processing successful:', {\r\n      processedCount: processedSignals.length,\r\n      enhanced: processedSignals[0]?.processed,\r\n      jabbrLabsScore: processedSignals[0]?.jabbrLabsScore\r\n    });\r\n    \r\n    // Test 2: Risk Management Integration\r\n    console.log('\\n2. Testing Risk Management Rules...');\r\n    \r\n    const testPosition = {\r\n      id: 'test-position-001',\r\n      size: 0.01,\r\n      symbol: 'BTC/USDT',\r\n      marketData: {\r\n        volatility: 0.02,\r\n        volume: 1000000\r\n      }\r\n    };\r\n    \r\n    const riskResult = await tradingEngine.applyAdvancedRiskRules(testPosition);\r\n    console.log('✅ Risk management validation:', {\r\n      approved: riskResult.approved,\r\n      reason: riskResult.reason || 'All checks passed'\r\n    });\r\n    \r\n    // Test 3: Order Routing\r\n    console.log('\\n3. Testing Order Routing...');\r\n    \r\n    const testOrder = {\r\n      id: 'test-order-001',\r\n      type: 'market',\r\n      symbol: 'BTC/USDT',\r\n      side: 'buy',\r\n      amount: 0.001\r\n    };\r\n    \r\n    const routingResult = await tradingEngine.routeCustomOrders(testOrder);\r\n    console.log('✅ Order routing successful:', {\r\n      route: routingResult.route,\r\n      hasModifications: !!routingResult.modifications\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const signalData = {\r\n      id: 'cycle-test-signal-001',\r\n      type: 'strategy',\r\n      symbol: 'ETH/USDT',\r\n      action: 'sell' as const,\r\n      confidence: 0.75,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 3000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-cycle-001', signalData);\r\n    console.log('✅ Signal execution pipeline:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Exchange Integration Validation (Simulation Mode)\r\n    console.log('\\n5. Testing Exchange Integration (Simulation)...');\r\n    \r\n    // Since we don't have valid API keys, test the exchange logic without connection\r\n    console.log('ℹ️ Running exchange integration in simulation mode');\r\n    \r\n    // Test risk validation logic\r\n    const riskConfig = {\r\n      maxPositionSize: 0.01,\r\n      maxLeverage: 10,\r\n      maxDailyLoss: 5,\r\n      maxDrawdown: 10,\r\n      maxConcurrentTrades: 3,\r\n      emergencyStop: false,\r\n      riskScore: 5,\r\n      accountBalance: 10000\r\n    };\r\n    \r\n    // Simulate order validation without exchange connection\r\n    const mockOrderRequest = {\r\n      symbol: 'ETHUSDT',\r\n      side: 'buy' as const,\r\n      type: 'market' as const,\r\n      amount: 0.005,\r\n      marketType: MarketType.FUTURES,\r\n      leverage: 5\r\n    };\r\n    \r\n    console.log('✅ Exchange integration simulation:', {\r\n      orderValid: mockOrderRequest.amount <= riskConfig.maxPositionSize,\r\n      leverageValid: (mockOrderRequest.leverage || 1) <= riskConfig.maxLeverage,\r\n      emergencyStop: riskConfig.emergencyStop\r\n    });\r\n    \r\n    // Test 6: Bot Runtime Compatibility\r\n    console.log('\\n6. Testing Bot Runtime System...');\r\n    \r\n    // Test bot configuration validation\r\n    const testBotConfig = {\r\n      id: 'test-bot-runtime-001',\r\n      name: 'Cycle Integration Test Bot',\r\n      userId: 'test-user-001',\r\n      strategy: 'target-reacher',\r\n      symbol: 'BTC/USDT',\r\n      isActive: true,\r\n      riskConfig: {\r\n        maxPositionSize: 0.01,\r\n        stopLossPercentage: 2,\r\n        takeProfitPercentage: 5\r\n      },\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n    \r\n    console.log('✅ Bot configuration validation passed:', {\r\n      botId: testBotConfig.id,\r\n      strategy: testBotConfig.strategy,\r\n      symbol: testBotConfig.symbol\r\n    });\r\n    \r\n    // Test 7: Integration Flow Validation\r\n    console.log('\\n7. Testing Complete Integration Flow...');\r\n    \r\n    // Simulate a complete trading cycle\r\n    const integrationFlowSteps = [\r\n      '📊 Market data analysis',\r\n      '🧠 Strategy signal generation', \r\n      '⚡ Signal processing',\r\n      '🛡️ Risk management validation',\r\n      '📈 Trade decision making',\r\n      '🔄 Order routing',\r\n      '✅ Execution confirmation'\r\n    ];\r\n    \r\n    for (const step of integrationFlowSteps) {\r\n      console.log(`   ${step}`);\r\n      // Simulate processing time\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n    \r\n    console.log('✅ Complete integration flow simulation successful');\r\n    \r\n    // Test 8: Error Handling and Recovery\r\n    console.log('\\n8. Testing Error Handling...');\r\n    \r\n    try {\r\n      // Test invalid signal handling\r\n      await executeSignal('invalid-bot', {\r\n        id: 'invalid-signal',\r\n        type: 'invalid',\r\n        symbol: '',\r\n        action: 'buy' as const,\r\n        confidence: -1, // Invalid confidence\r\n        timestamp: Date.now()\r\n      });\r\n    } catch (error) {\r\n      console.log('✅ Error handling working - invalid signals rejected');\r\n    }\r\n    \r\n    try {\r\n      // Test invalid position risk validation\r\n      await tradingEngine.applyAdvancedRiskRules({\r\n        size: 999999, // Massive position size\r\n        symbol: 'INVALID/PAIR'\r\n      });\r\n      console.log('✅ Risk management correctly handled edge cases');\r\n    } catch (error) {\r\n      console.log('✅ Risk validation error handling working');\r\n    }\r\n    \r\n    // Test 9: Performance and Monitoring\r\n    console.log('\\n9. Testing Performance Monitoring...');\r\n    \r\n    const performanceMetrics = {\r\n      signalProcessingTime: 50, // ms\r\n      riskValidationTime: 25,   // ms\r\n      orderRoutingTime: 15,     // ms\r\n      executionTime: 100,       // ms\r\n      totalCycleTime: 190       // ms\r\n    };\r\n    \r\n    console.log('✅ Performance metrics within acceptable range:', performanceMetrics);\r\n    \r\n    // Test 10: State Management and Persistence\r\n    console.log('\\n10. Testing State Management...');\r\n    \r\n    const botStateSnapshot = {\r\n      botId: 'test-bot-cycle-001',\r\n      status: 'running',\r\n      performance: {\r\n        tickCount: 100,\r\n        signalCount: 25,\r\n        tradeCount: 8,\r\n        errorCount: 0,\r\n        winRate: 0.75,\r\n        totalProfit: 150.50\r\n      },\r\n      lastUpdate: new Date()\r\n    };\r\n    \r\n    console.log('✅ State management operational:', {\r\n      botId: botStateSnapshot.botId,\r\n      status: botStateSnapshot.status,\r\n      winRate: botStateSnapshot.performance.winRate\r\n    });\r\n    \r\n    console.log('\\n🎉 All Bot Trading Cycle Integration Tests Passed!');\r\n    console.log('\\n📋 Validation Summary:');\r\n    console.log('   ✅ Trading Engine Integration');\r\n    console.log('   ✅ Signal Processing Pipeline');\r\n    console.log('   ✅ Risk Management System');\r\n    console.log('   ✅ Order Routing Logic');\r\n    console.log('   ✅ Exchange Connectivity');\r\n    console.log('   ✅ Bot Runtime Compatibility');\r\n    console.log('   ✅ Error Handling & Recovery');\r\n    console.log('   ✅ Performance Monitoring');\r\n    console.log('   ✅ State Management');\r\n    console.log('   ✅ Complete Integration Flow');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Bot Trading Cycle Integration Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "23391937599010ca693e49fc69f751bf"
        },
        {
          "type": "function",
          "name": "validateBotTradingCycleIntegration",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\bot-trading-cycle-validation.ts",
          "startLine": 9,
          "endLine": 265,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 257,
          "content": "{\r\n  console.log('🔍 Starting Bot Trading Cycle Integration Validation...');\r\n  \r\n  try {\r\n    // Test 1: Enhanced Trading Engine Initialization\r\n    console.log('\\n1. Testing Enhanced Trading Engine...');\r\n    \r\n    const tradingEngine = new EnhancedTradingEngine();\r\n    console.log('✅ Enhanced Trading Engine initialized successfully');\r\n    \r\n    // Test signal processing\r\n    const testSignals = [\r\n      {\r\n        id: 'test-signal-001',\r\n        symbol: 'BTC/USDT',\r\n        action: 'buy',\r\n        confidence: 0.85,\r\n        amount: 0.001,\r\n        timestamp: Date.now(),\r\n        marketData: {\r\n          volatility: 0.02,\r\n          volume: 1000000,\r\n          orderBookImbalance: 0.1\r\n        }\r\n      }\r\n    ];\r\n    \r\n    const processedSignals = await tradingEngine.processAdvancedSignals(testSignals);\r\n    console.log('✅ Signal processing successful:', {\r\n      processedCount: processedSignals.length,\r\n      enhanced: processedSignals[0]?.processed,\r\n      jabbrLabsScore: processedSignals[0]?.jabbrLabsScore\r\n    });\r\n    \r\n    // Test 2: Risk Management Integration\r\n    console.log('\\n2. Testing Risk Management Rules...');\r\n    \r\n    const testPosition = {\r\n      id: 'test-position-001',\r\n      size: 0.01,\r\n      symbol: 'BTC/USDT',\r\n      marketData: {\r\n        volatility: 0.02,\r\n        volume: 1000000\r\n      }\r\n    };\r\n    \r\n    const riskResult = await tradingEngine.applyAdvancedRiskRules(testPosition);\r\n    console.log('✅ Risk management validation:', {\r\n      approved: riskResult.approved,\r\n      reason: riskResult.reason || 'All checks passed'\r\n    });\r\n    \r\n    // Test 3: Order Routing\r\n    console.log('\\n3. Testing Order Routing...');\r\n    \r\n    const testOrder = {\r\n      id: 'test-order-001',\r\n      type: 'market',\r\n      symbol: 'BTC/USDT',\r\n      side: 'buy',\r\n      amount: 0.001\r\n    };\r\n    \r\n    const routingResult = await tradingEngine.routeCustomOrders(testOrder);\r\n    console.log('✅ Order routing successful:', {\r\n      route: routingResult.route,\r\n      hasModifications: !!routingResult.modifications\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const signalData = {\r\n      id: 'cycle-test-signal-001',\r\n      type: 'strategy',\r\n      symbol: 'ETH/USDT',\r\n      action: 'sell' as const,\r\n      confidence: 0.75,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 3000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-cycle-001', signalData);\r\n    console.log('✅ Signal execution pipeline:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Exchange Integration Validation (Simulation Mode)\r\n    console.log('\\n5. Testing Exchange Integration (Simulation)...');\r\n    \r\n    // Since we don't have valid API keys, test the exchange logic without connection\r\n    console.log('ℹ️ Running exchange integration in simulation mode');\r\n    \r\n    // Test risk validation logic\r\n    const riskConfig = {\r\n      maxPositionSize: 0.01,\r\n      maxLeverage: 10,\r\n      maxDailyLoss: 5,\r\n      maxDrawdown: 10,\r\n      maxConcurrentTrades: 3,\r\n      emergencyStop: false,\r\n      riskScore: 5,\r\n      accountBalance: 10000\r\n    };\r\n    \r\n    // Simulate order validation without exchange connection\r\n    const mockOrderRequest = {\r\n      symbol: 'ETHUSDT',\r\n      side: 'buy' as const,\r\n      type: 'market' as const,\r\n      amount: 0.005,\r\n      marketType: MarketType.FUTURES,\r\n      leverage: 5\r\n    };\r\n    \r\n    console.log('✅ Exchange integration simulation:', {\r\n      orderValid: mockOrderRequest.amount <= riskConfig.maxPositionSize,\r\n      leverageValid: (mockOrderRequest.leverage || 1) <= riskConfig.maxLeverage,\r\n      emergencyStop: riskConfig.emergencyStop\r\n    });\r\n    \r\n    // Test 6: Bot Runtime Compatibility\r\n    console.log('\\n6. Testing Bot Runtime System...');\r\n    \r\n    // Test bot configuration validation\r\n    const testBotConfig = {\r\n      id: 'test-bot-runtime-001',\r\n      name: 'Cycle Integration Test Bot',\r\n      userId: 'test-user-001',\r\n      strategy: 'target-reacher',\r\n      symbol: 'BTC/USDT',\r\n      isActive: true,\r\n      riskConfig: {\r\n        maxPositionSize: 0.01,\r\n        stopLossPercentage: 2,\r\n        takeProfitPercentage: 5\r\n      },\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n    \r\n    console.log('✅ Bot configuration validation passed:', {\r\n      botId: testBotConfig.id,\r\n      strategy: testBotConfig.strategy,\r\n      symbol: testBotConfig.symbol\r\n    });\r\n    \r\n    // Test 7: Integration Flow Validation\r\n    console.log('\\n7. Testing Complete Integration Flow...');\r\n    \r\n    // Simulate a complete trading cycle\r\n    const integrationFlowSteps = [\r\n      '📊 Market data analysis',\r\n      '🧠 Strategy signal generation', \r\n      '⚡ Signal processing',\r\n      '🛡️ Risk management validation',\r\n      '📈 Trade decision making',\r\n      '🔄 Order routing',\r\n      '✅ Execution confirmation'\r\n    ];\r\n    \r\n    for (const step of integrationFlowSteps) {\r\n      console.log(`   ${step}`);\r\n      // Simulate processing time\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n    \r\n    console.log('✅ Complete integration flow simulation successful');\r\n    \r\n    // Test 8: Error Handling and Recovery\r\n    console.log('\\n8. Testing Error Handling...');\r\n    \r\n    try {\r\n      // Test invalid signal handling\r\n      await executeSignal('invalid-bot', {\r\n        id: 'invalid-signal',\r\n        type: 'invalid',\r\n        symbol: '',\r\n        action: 'buy' as const,\r\n        confidence: -1, // Invalid confidence\r\n        timestamp: Date.now()\r\n      });\r\n    } catch (error) {\r\n      console.log('✅ Error handling working - invalid signals rejected');\r\n    }\r\n    \r\n    try {\r\n      // Test invalid position risk validation\r\n      await tradingEngine.applyAdvancedRiskRules({\r\n        size: 999999, // Massive position size\r\n        symbol: 'INVALID/PAIR'\r\n      });\r\n      console.log('✅ Risk management correctly handled edge cases');\r\n    } catch (error) {\r\n      console.log('✅ Risk validation error handling working');\r\n    }\r\n    \r\n    // Test 9: Performance and Monitoring\r\n    console.log('\\n9. Testing Performance Monitoring...');\r\n    \r\n    const performanceMetrics = {\r\n      signalProcessingTime: 50, // ms\r\n      riskValidationTime: 25,   // ms\r\n      orderRoutingTime: 15,     // ms\r\n      executionTime: 100,       // ms\r\n      totalCycleTime: 190       // ms\r\n    };\r\n    \r\n    console.log('✅ Performance metrics within acceptable range:', performanceMetrics);\r\n    \r\n    // Test 10: State Management and Persistence\r\n    console.log('\\n10. Testing State Management...');\r\n    \r\n    const botStateSnapshot = {\r\n      botId: 'test-bot-cycle-001',\r\n      status: 'running',\r\n      performance: {\r\n        tickCount: 100,\r\n        signalCount: 25,\r\n        tradeCount: 8,\r\n        errorCount: 0,\r\n        winRate: 0.75,\r\n        totalProfit: 150.50\r\n      },\r\n      lastUpdate: new Date()\r\n    };\r\n    \r\n    console.log('✅ State management operational:', {\r\n      botId: botStateSnapshot.botId,\r\n      status: botStateSnapshot.status,\r\n      winRate: botStateSnapshot.performance.winRate\r\n    });\r\n    \r\n    console.log('\\n🎉 All Bot Trading Cycle Integration Tests Passed!');\r\n    console.log('\\n📋 Validation Summary:');\r\n    console.log('   ✅ Trading Engine Integration');\r\n    console.log('   ✅ Signal Processing Pipeline');\r\n    console.log('   ✅ Risk Management System');\r\n    console.log('   ✅ Order Routing Logic');\r\n    console.log('   ✅ Exchange Connectivity');\r\n    console.log('   ✅ Bot Runtime Compatibility');\r\n    console.log('   ✅ Error Handling & Recovery');\r\n    console.log('   ✅ Performance Monitoring');\r\n    console.log('   ✅ State Management');\r\n    console.log('   ✅ Complete Integration Flow');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Bot Trading Cycle Integration Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "23391937599010ca693e49fc69f751bf"
        },
        {
          "type": "function",
          "name": "performDatabaseHealthCheck",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\database-health-check.ts",
          "startLine": 6,
          "endLine": 44,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 39,
          "content": "{\r\n  console.log('🔍 Starting database health check...');\r\n  \r\n  try {\r\n    // Initialize database connection\r\n    const dbManager = new DatabaseManager();\r\n    await dbManager.connect();\r\n    \r\n    console.log('✅ Database connection established');\r\n    \r\n    // Test basic query\r\n    const timeResult = await dbManager.query<{ now: Date }>('SELECT NOW() as now');\r\n    if (timeResult && timeResult.length > 0) {\r\n      console.log('✅ Query test successful:', timeResult[0]?.now);\r\n    } else {\r\n      throw new Error('Query returned no results');\r\n    }\r\n    \r\n    // Test database health and connection pool status\r\n    const healthCheck = await dbManager.healthCheck();\r\n    console.log('📊 Database health status:', {\r\n      status: healthCheck.status,\r\n      connected: healthCheck.details.connected,\r\n      poolSize: healthCheck.details.poolSize,\r\n      idleConnections: healthCheck.details.idleCount,\r\n      waitingCount: healthCheck.details.waitingCount,\r\n      responseTime: healthCheck.details.responseTime\r\n    });\r\n    \r\n    // Cleanup\r\n    await dbManager.disconnect();\r\n    console.log('✅ Database health check completed successfully');\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('❌ Database health check failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "5552c2b448adca6e8ace03f1d2533a18"
        },
        {
          "type": "function",
          "name": "performDatabaseHealthCheck",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\database-health-check.ts",
          "startLine": 6,
          "endLine": 44,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 39,
          "content": "{\r\n  console.log('🔍 Starting database health check...');\r\n  \r\n  try {\r\n    // Initialize database connection\r\n    const dbManager = new DatabaseManager();\r\n    await dbManager.connect();\r\n    \r\n    console.log('✅ Database connection established');\r\n    \r\n    // Test basic query\r\n    const timeResult = await dbManager.query<{ now: Date }>('SELECT NOW() as now');\r\n    if (timeResult && timeResult.length > 0) {\r\n      console.log('✅ Query test successful:', timeResult[0]?.now);\r\n    } else {\r\n      throw new Error('Query returned no results');\r\n    }\r\n    \r\n    // Test database health and connection pool status\r\n    const healthCheck = await dbManager.healthCheck();\r\n    console.log('📊 Database health status:', {\r\n      status: healthCheck.status,\r\n      connected: healthCheck.details.connected,\r\n      poolSize: healthCheck.details.poolSize,\r\n      idleConnections: healthCheck.details.idleCount,\r\n      waitingCount: healthCheck.details.waitingCount,\r\n      responseTime: healthCheck.details.responseTime\r\n    });\r\n    \r\n    // Cleanup\r\n    await dbManager.disconnect();\r\n    console.log('✅ Database health check completed successfully');\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('❌ Database health check failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "5552c2b448adca6e8ace03f1d2533a18"
        },
        {
          "type": "function",
          "name": "validatePerformanceMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\performance-monitoring-validation.ts",
          "startLine": 6,
          "endLine": 353,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 348,
          "content": "{\r\n  console.log('🔍 Starting Performance Monitoring and Metrics Validation...');\r\n  \r\n  try {\r\n    // Test 1: Monitoring Service Structure Validation\r\n    console.log('\\n1. Validating Monitoring Service Structure...');\r\n    \r\n    // Check for required monitoring service files\r\n    const monitoringServices = [\r\n      'strategy-monitor.service.ts',\r\n      'database-monitor.service.ts', \r\n      'exchange-monitor.service.ts',\r\n      'application-monitor.service.ts',\r\n      'system-monitor.service.ts',\r\n      'monitoring.service.ts'\r\n    ];\r\n    \r\n    console.log('✅ Monitoring services structure validated:', {\r\n      totalServices: monitoringServices.length,\r\n      servicesAvailable: monitoringServices\r\n    });\r\n    \r\n    // Test 2: Performance Metrics Structure\r\n    console.log('\\n2. Testing Performance Metrics Structure...');\r\n    \r\n    const performanceMetrics = {\r\n      timestamp: Date.now(),\r\n      apiResponseTime: 125, // ms\r\n      orderExecutionTime: 850, // ms  \r\n      webSocketLatency: 35, // ms\r\n      memoryUsage: 256, // MB\r\n      cpuUsage: 15.5, // %\r\n      activeConnections: 45,\r\n      requestsPerSecond: 12.3,\r\n      errorRate: 0.0008, // 0.08%\r\n      throughput: 1250, // requests/hour\r\n      queueDepth: 3\r\n    };\r\n    \r\n    const metricsValid = performanceMetrics.timestamp > 0 && \r\n                        performanceMetrics.apiResponseTime > 0 &&\r\n                        performanceMetrics.cpuUsage >= 0 &&\r\n                        performanceMetrics.errorRate >= 0;\r\n    \r\n    console.log('✅ Performance metrics structure validated:', {\r\n      metricsValid,\r\n      apiResponseTime: `${performanceMetrics.apiResponseTime}ms`,\r\n      orderExecutionTime: `${performanceMetrics.orderExecutionTime}ms`,\r\n      webSocketLatency: `${performanceMetrics.webSocketLatency}ms`,\r\n      memoryUsage: `${performanceMetrics.memoryUsage}MB`,\r\n      cpuUsage: `${performanceMetrics.cpuUsage}%`,\r\n      errorRate: `${(performanceMetrics.errorRate * 100).toFixed(3)}%`\r\n    });\r\n    \r\n    // Test 3: Strategy Performance Metrics\r\n    console.log('\\n3. Testing Strategy Performance Metrics...');\r\n    \r\n    const strategyMetrics = {\r\n      botId: 'test-bot-001',\r\n      strategyName: 'aether',\r\n      strategyVersion: '1.0.0',\r\n      isRunning: true,\r\n      uptime: 3600000, // 1 hour\r\n      totalTrades: 25,\r\n      winningTrades: 18,\r\n      losingTrades: 7,\r\n      totalPnL: 245.67,\r\n      dailyPnL: 45.23,\r\n      winRate: (18 / 25) * 100, // 72%\r\n      maxDrawdown: 15.5,\r\n      currentDrawdown: 2.3,\r\n      averageTradeTime: 45000,\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    const strategyMetricsValid = strategyMetrics.totalTrades === \r\n                                (strategyMetrics.winningTrades + strategyMetrics.losingTrades) &&\r\n                                strategyMetrics.winRate > 0 &&\r\n                                strategyMetrics.totalPnL !== 0;\r\n    \r\n    console.log('✅ Strategy performance metrics validated:', {\r\n      metricsValid: strategyMetricsValid,\r\n      totalTrades: strategyMetrics.totalTrades,\r\n      winRate: `${strategyMetrics.winRate.toFixed(1)}%`,\r\n      totalPnL: `$${strategyMetrics.totalPnL}`,\r\n      uptime: `${strategyMetrics.uptime / 1000}s`\r\n    });\r\n    \r\n    // Test 4: Database Health Metrics\r\n    console.log('\\n4. Testing Database Health Metrics...');\r\n    \r\n    const dbHealthMetrics = {\r\n      status: 'healthy' as const,\r\n      connections: {\r\n        active: 8,\r\n        idle: 12,\r\n        total: 20,\r\n        maxAllowed: 100,\r\n        utilizationPercentage: 20\r\n      },\r\n      queries: {\r\n        totalExecuted: 15420,\r\n        averageTime: 23.5,\r\n        slowQueries: 3,\r\n        failedQueries: 1,\r\n        queriesPerSecond: 42.3\r\n      },\r\n      performance: {\r\n        transactionsPerSecond: 38.7,\r\n        cacheHitRatio: 0.94,\r\n        indexEfficiency: 0.89\r\n      },\r\n      uptime: 7200000, // 2 hours\r\n      lastCheck: new Date()\r\n    };\r\n    \r\n    const dbHealthValid = dbHealthMetrics.status === 'healthy' &&\r\n                         dbHealthMetrics.connections.utilizationPercentage < 80 &&\r\n                         dbHealthMetrics.performance.cacheHitRatio > 0.8;\r\n    \r\n    console.log('✅ Database health metrics validated:', {\r\n      healthValid: dbHealthValid,\r\n      status: dbHealthMetrics.status,\r\n      connectionUtilization: `${dbHealthMetrics.connections.utilizationPercentage}%`,\r\n      avgQueryTime: `${dbHealthMetrics.queries.averageTime}ms`,\r\n      cacheHitRatio: `${(dbHealthMetrics.performance.cacheHitRatio * 100).toFixed(1)}%`\r\n    });\r\n    \r\n    // Test 5: Exchange Connection Metrics\r\n    console.log('\\n5. Testing Exchange Connection Metrics...');\r\n    \r\n    const exchangeMetrics = {\r\n      exchange: 'bybit',\r\n      isConnected: true,\r\n      lastPing: Date.now(),\r\n      avgLatency: 45,\r\n      errorRate: 0.001,\r\n      totalRequests: 1250,\r\n      failedRequests: 1,\r\n      rateLimitStatus: {\r\n        remaining: 980,\r\n        limit: 1000,\r\n        resetTime: Date.now() + 60000\r\n      },\r\n      apiCalls: {\r\n        perMinute: 15,\r\n        perHour: 890,\r\n        dailyLimit: 10000\r\n      }\r\n    };\r\n    \r\n    const exchangeHealthy = exchangeMetrics.isConnected &&\r\n                           exchangeMetrics.avgLatency < 200 &&\r\n                           exchangeMetrics.errorRate < 0.01 &&\r\n                           exchangeMetrics.rateLimitStatus.remaining > 100;\r\n    \r\n    console.log('✅ Exchange connection metrics validated:', {\r\n      exchangeHealthy,\r\n      exchange: exchangeMetrics.exchange,\r\n      isConnected: exchangeMetrics.isConnected,\r\n      avgLatency: `${exchangeMetrics.avgLatency}ms`,\r\n      errorRate: `${(exchangeMetrics.errorRate * 100).toFixed(3)}%`,\r\n      rateLimitRemaining: exchangeMetrics.rateLimitStatus.remaining\r\n    });\r\n    \r\n    // Test 6: System Resource Metrics\r\n    console.log('\\n6. Testing System Resource Metrics...');\r\n    \r\n    const systemMetrics = {\r\n      cpu: {\r\n        usage: 18.5, // %\r\n        cores: 8,\r\n        loadAverage: [0.45, 0.52, 0.38]\r\n      },\r\n      memory: {\r\n        total: 16384, // MB\r\n        used: 6240, // MB\r\n        free: 10144, // MB\r\n        usage: 38.1 // %\r\n      },\r\n      disk: {\r\n        total: 512000, // MB\r\n        used: 156700, // MB\r\n        free: 355300, // MB\r\n        usage: 30.6 // %\r\n      },\r\n      network: {\r\n        bytesIn: 2340000,\r\n        bytesOut: 4560000,\r\n        packetsIn: 15420,\r\n        packetsOut: 18930\r\n      }\r\n    };\r\n    \r\n    const systemHealthy = systemMetrics.cpu.usage < 80 &&\r\n                         systemMetrics.memory.usage < 85 &&\r\n                         systemMetrics.disk.usage < 90;\r\n    \r\n    console.log('✅ System resource metrics validated:', {\r\n      systemHealthy,\r\n      cpuUsage: `${systemMetrics.cpu.usage}%`,\r\n      memoryUsage: `${systemMetrics.memory.usage}%`,\r\n      diskUsage: `${systemMetrics.disk.usage}%`,\r\n      cores: systemMetrics.cpu.cores\r\n    });\r\n    \r\n    // Test 7: Performance Thresholds and Alerting\r\n    console.log('\\n7. Testing Performance Thresholds and Alerting...');\r\n    \r\n    const performanceThresholds = {\r\n      apiResponseTime: { warning: 300, critical: 500 },\r\n      orderExecutionTime: { warning: 1500, critical: 2000 },\r\n      webSocketLatency: { warning: 100, critical: 200 },\r\n      memoryUsage: { warning: 70, critical: 85 },\r\n      cpuUsage: { warning: 70, critical: 85 },\r\n      errorRate: { warning: 0.005, critical: 0.01 },\r\n      diskUsage: { warning: 80, critical: 90 }\r\n    };\r\n    \r\n    // Check current metrics against thresholds\r\n    const alertStatus = {\r\n      apiResponseTime: performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.warning ? 'good' : \r\n                      performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.critical ? 'warning' : 'critical',\r\n      \r\n      orderExecutionTime: performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.warning ? 'good' : \r\n                         performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.critical ? 'warning' : 'critical',\r\n      \r\n      cpuUsage: systemMetrics.cpu.usage < performanceThresholds.cpuUsage.warning ? 'good' : \r\n               systemMetrics.cpu.usage < performanceThresholds.cpuUsage.critical ? 'warning' : 'critical',\r\n      \r\n      memoryUsage: systemMetrics.memory.usage < performanceThresholds.memoryUsage.warning ? 'good' : \r\n                  systemMetrics.memory.usage < performanceThresholds.memoryUsage.critical ? 'warning' : 'critical',\r\n      \r\n      errorRate: performanceMetrics.errorRate < performanceThresholds.errorRate.warning ? 'good' : \r\n                performanceMetrics.errorRate < performanceThresholds.errorRate.critical ? 'warning' : 'critical'\r\n    };\r\n    \r\n    const criticalAlerts = Object.values(alertStatus).filter(status => status === 'critical').length;\r\n    const warningAlerts = Object.values(alertStatus).filter(status => status === 'warning').length;\r\n    \r\n    console.log('✅ Performance thresholds and alerting validated:', {\r\n      criticalAlerts,\r\n      warningAlerts,\r\n      overallStatus: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'good',\r\n      alertDetails: alertStatus\r\n    });\r\n    \r\n    // Test 8: Metrics Aggregation and Reporting\r\n    console.log('\\n8. Testing Metrics Aggregation and Reporting...');\r\n    \r\n    const aggregatedMetrics = {\r\n      timeWindow: '1h',\r\n      summary: {\r\n        totalRequests: 4523,\r\n        successfulRequests: 4520,\r\n        failedRequests: 3,\r\n        avgResponseTime: 142,\r\n        p95ResponseTime: 285,\r\n        p99ResponseTime: 445,\r\n        uniqueUsers: 128,\r\n        peakConcurrency: 67\r\n      },\r\n      trends: {\r\n        responseTimeTrend: 'stable', // increasing, decreasing, stable\r\n        errorRateTrend: 'decreasing',\r\n        throughputTrend: 'increasing'\r\n      },\r\n      resourceUtilization: {\r\n        cpu: { avg: 18.5, peak: 34.2, trend: 'stable' },\r\n        memory: { avg: 312, peak: 456, trend: 'stable' },\r\n        network: { in: 2.3, out: 4.7, trend: 'increasing' }\r\n      }\r\n    };\r\n    \r\n    const aggregationValid = aggregatedMetrics.summary.totalRequests === \r\n                            (aggregatedMetrics.summary.successfulRequests + aggregatedMetrics.summary.failedRequests) &&\r\n                            aggregatedMetrics.summary.avgResponseTime > 0;\r\n    \r\n    console.log('✅ Metrics aggregation and reporting validated:', {\r\n      aggregationValid,\r\n      timeWindow: aggregatedMetrics.timeWindow,\r\n      totalRequests: aggregatedMetrics.summary.totalRequests,\r\n      successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n      avgResponseTime: `${aggregatedMetrics.summary.avgResponseTime}ms`,\r\n      p95ResponseTime: `${aggregatedMetrics.summary.p95ResponseTime}ms`\r\n    });\r\n    \r\n    // Test 9: Dashboard Data Structure\r\n    console.log('\\n9. Testing Dashboard Data Structure...');\r\n    \r\n    const dashboardData = {\r\n      realTime: {\r\n        status: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'healthy',\r\n        activeUsers: 42,\r\n        requestsPerSecond: performanceMetrics.requestsPerSecond,\r\n        errorRate: performanceMetrics.errorRate,\r\n        systemLoad: systemMetrics.cpu.usage,\r\n        uptime: systemMetrics.cpu.loadAverage[0]\r\n      },\r\n      timeSeries: {\r\n        labels: ['00:00', '00:15', '00:30', '00:45', '01:00'],\r\n        datasets: {\r\n          responseTime: [120, 135, 142, 138, 125],\r\n          throughput: [10.2, 11.8, 12.3, 11.9, 10.7],\r\n          errors: [0, 1, 0, 2, 0],\r\n          cpuUsage: [15.2, 16.8, 18.5, 17.3, 15.9],\r\n          memoryUsage: [35.4, 36.2, 38.1, 37.8, 36.9]\r\n        }\r\n      },\r\n      summary: {\r\n        uptime: '99.97%',\r\n        totalTrades: strategyMetrics.totalTrades,\r\n        successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n        avgProfit: '+2.34%'\r\n      }\r\n    };\r\n    \r\n    const dashboardValid = dashboardData.timeSeries.labels.length === \r\n                          dashboardData.timeSeries.datasets.responseTime.length &&\r\n                          dashboardData.realTime.status in ['healthy', 'warning', 'critical'];\r\n    \r\n    console.log('✅ Dashboard data structure validated:', {\r\n      dashboardValid,\r\n      realTimeStatus: dashboardData.realTime.status,\r\n      activeUsers: dashboardData.realTime.activeUsers,\r\n      dataPoints: dashboardData.timeSeries.labels.length,\r\n      uptime: dashboardData.summary.uptime\r\n    });\r\n    \r\n    console.log('\\n🎉 All Performance Monitoring and Metrics Validation Tests Passed!');\r\n    console.log('\\n📊 Validation Summary:');\r\n    console.log('   ✅ Monitoring Service Infrastructure');\r\n    console.log('   ✅ Performance Metrics Collection');\r\n    console.log('   ✅ Strategy Performance Tracking');\r\n    console.log('   ✅ Database Health Monitoring');\r\n    console.log('   ✅ Exchange Connection Monitoring');\r\n    console.log('   ✅ System Resource Monitoring');\r\n    console.log('   ✅ Performance Thresholds & Alerting');\r\n    console.log('   ✅ Metrics Aggregation & Reporting');\r\n    console.log('   ✅ Dashboard Data Preparation');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Performance Monitoring Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "cadd453a97bf48586c046b2ce64e191f"
        },
        {
          "type": "function",
          "name": "validatePerformanceMonitoring",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\performance-monitoring-validation.ts",
          "startLine": 6,
          "endLine": 353,
          "complexity": 17,
          "dependencies": [],
          "usageCount": 0,
          "size": 348,
          "content": "{\r\n  console.log('🔍 Starting Performance Monitoring and Metrics Validation...');\r\n  \r\n  try {\r\n    // Test 1: Monitoring Service Structure Validation\r\n    console.log('\\n1. Validating Monitoring Service Structure...');\r\n    \r\n    // Check for required monitoring service files\r\n    const monitoringServices = [\r\n      'strategy-monitor.service.ts',\r\n      'database-monitor.service.ts', \r\n      'exchange-monitor.service.ts',\r\n      'application-monitor.service.ts',\r\n      'system-monitor.service.ts',\r\n      'monitoring.service.ts'\r\n    ];\r\n    \r\n    console.log('✅ Monitoring services structure validated:', {\r\n      totalServices: monitoringServices.length,\r\n      servicesAvailable: monitoringServices\r\n    });\r\n    \r\n    // Test 2: Performance Metrics Structure\r\n    console.log('\\n2. Testing Performance Metrics Structure...');\r\n    \r\n    const performanceMetrics = {\r\n      timestamp: Date.now(),\r\n      apiResponseTime: 125, // ms\r\n      orderExecutionTime: 850, // ms  \r\n      webSocketLatency: 35, // ms\r\n      memoryUsage: 256, // MB\r\n      cpuUsage: 15.5, // %\r\n      activeConnections: 45,\r\n      requestsPerSecond: 12.3,\r\n      errorRate: 0.0008, // 0.08%\r\n      throughput: 1250, // requests/hour\r\n      queueDepth: 3\r\n    };\r\n    \r\n    const metricsValid = performanceMetrics.timestamp > 0 && \r\n                        performanceMetrics.apiResponseTime > 0 &&\r\n                        performanceMetrics.cpuUsage >= 0 &&\r\n                        performanceMetrics.errorRate >= 0;\r\n    \r\n    console.log('✅ Performance metrics structure validated:', {\r\n      metricsValid,\r\n      apiResponseTime: `${performanceMetrics.apiResponseTime}ms`,\r\n      orderExecutionTime: `${performanceMetrics.orderExecutionTime}ms`,\r\n      webSocketLatency: `${performanceMetrics.webSocketLatency}ms`,\r\n      memoryUsage: `${performanceMetrics.memoryUsage}MB`,\r\n      cpuUsage: `${performanceMetrics.cpuUsage}%`,\r\n      errorRate: `${(performanceMetrics.errorRate * 100).toFixed(3)}%`\r\n    });\r\n    \r\n    // Test 3: Strategy Performance Metrics\r\n    console.log('\\n3. Testing Strategy Performance Metrics...');\r\n    \r\n    const strategyMetrics = {\r\n      botId: 'test-bot-001',\r\n      strategyName: 'aether',\r\n      strategyVersion: '1.0.0',\r\n      isRunning: true,\r\n      uptime: 3600000, // 1 hour\r\n      totalTrades: 25,\r\n      winningTrades: 18,\r\n      losingTrades: 7,\r\n      totalPnL: 245.67,\r\n      dailyPnL: 45.23,\r\n      winRate: (18 / 25) * 100, // 72%\r\n      maxDrawdown: 15.5,\r\n      currentDrawdown: 2.3,\r\n      averageTradeTime: 45000,\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    const strategyMetricsValid = strategyMetrics.totalTrades === \r\n                                (strategyMetrics.winningTrades + strategyMetrics.losingTrades) &&\r\n                                strategyMetrics.winRate > 0 &&\r\n                                strategyMetrics.totalPnL !== 0;\r\n    \r\n    console.log('✅ Strategy performance metrics validated:', {\r\n      metricsValid: strategyMetricsValid,\r\n      totalTrades: strategyMetrics.totalTrades,\r\n      winRate: `${strategyMetrics.winRate.toFixed(1)}%`,\r\n      totalPnL: `$${strategyMetrics.totalPnL}`,\r\n      uptime: `${strategyMetrics.uptime / 1000}s`\r\n    });\r\n    \r\n    // Test 4: Database Health Metrics\r\n    console.log('\\n4. Testing Database Health Metrics...');\r\n    \r\n    const dbHealthMetrics = {\r\n      status: 'healthy' as const,\r\n      connections: {\r\n        active: 8,\r\n        idle: 12,\r\n        total: 20,\r\n        maxAllowed: 100,\r\n        utilizationPercentage: 20\r\n      },\r\n      queries: {\r\n        totalExecuted: 15420,\r\n        averageTime: 23.5,\r\n        slowQueries: 3,\r\n        failedQueries: 1,\r\n        queriesPerSecond: 42.3\r\n      },\r\n      performance: {\r\n        transactionsPerSecond: 38.7,\r\n        cacheHitRatio: 0.94,\r\n        indexEfficiency: 0.89\r\n      },\r\n      uptime: 7200000, // 2 hours\r\n      lastCheck: new Date()\r\n    };\r\n    \r\n    const dbHealthValid = dbHealthMetrics.status === 'healthy' &&\r\n                         dbHealthMetrics.connections.utilizationPercentage < 80 &&\r\n                         dbHealthMetrics.performance.cacheHitRatio > 0.8;\r\n    \r\n    console.log('✅ Database health metrics validated:', {\r\n      healthValid: dbHealthValid,\r\n      status: dbHealthMetrics.status,\r\n      connectionUtilization: `${dbHealthMetrics.connections.utilizationPercentage}%`,\r\n      avgQueryTime: `${dbHealthMetrics.queries.averageTime}ms`,\r\n      cacheHitRatio: `${(dbHealthMetrics.performance.cacheHitRatio * 100).toFixed(1)}%`\r\n    });\r\n    \r\n    // Test 5: Exchange Connection Metrics\r\n    console.log('\\n5. Testing Exchange Connection Metrics...');\r\n    \r\n    const exchangeMetrics = {\r\n      exchange: 'bybit',\r\n      isConnected: true,\r\n      lastPing: Date.now(),\r\n      avgLatency: 45,\r\n      errorRate: 0.001,\r\n      totalRequests: 1250,\r\n      failedRequests: 1,\r\n      rateLimitStatus: {\r\n        remaining: 980,\r\n        limit: 1000,\r\n        resetTime: Date.now() + 60000\r\n      },\r\n      apiCalls: {\r\n        perMinute: 15,\r\n        perHour: 890,\r\n        dailyLimit: 10000\r\n      }\r\n    };\r\n    \r\n    const exchangeHealthy = exchangeMetrics.isConnected &&\r\n                           exchangeMetrics.avgLatency < 200 &&\r\n                           exchangeMetrics.errorRate < 0.01 &&\r\n                           exchangeMetrics.rateLimitStatus.remaining > 100;\r\n    \r\n    console.log('✅ Exchange connection metrics validated:', {\r\n      exchangeHealthy,\r\n      exchange: exchangeMetrics.exchange,\r\n      isConnected: exchangeMetrics.isConnected,\r\n      avgLatency: `${exchangeMetrics.avgLatency}ms`,\r\n      errorRate: `${(exchangeMetrics.errorRate * 100).toFixed(3)}%`,\r\n      rateLimitRemaining: exchangeMetrics.rateLimitStatus.remaining\r\n    });\r\n    \r\n    // Test 6: System Resource Metrics\r\n    console.log('\\n6. Testing System Resource Metrics...');\r\n    \r\n    const systemMetrics = {\r\n      cpu: {\r\n        usage: 18.5, // %\r\n        cores: 8,\r\n        loadAverage: [0.45, 0.52, 0.38]\r\n      },\r\n      memory: {\r\n        total: 16384, // MB\r\n        used: 6240, // MB\r\n        free: 10144, // MB\r\n        usage: 38.1 // %\r\n      },\r\n      disk: {\r\n        total: 512000, // MB\r\n        used: 156700, // MB\r\n        free: 355300, // MB\r\n        usage: 30.6 // %\r\n      },\r\n      network: {\r\n        bytesIn: 2340000,\r\n        bytesOut: 4560000,\r\n        packetsIn: 15420,\r\n        packetsOut: 18930\r\n      }\r\n    };\r\n    \r\n    const systemHealthy = systemMetrics.cpu.usage < 80 &&\r\n                         systemMetrics.memory.usage < 85 &&\r\n                         systemMetrics.disk.usage < 90;\r\n    \r\n    console.log('✅ System resource metrics validated:', {\r\n      systemHealthy,\r\n      cpuUsage: `${systemMetrics.cpu.usage}%`,\r\n      memoryUsage: `${systemMetrics.memory.usage}%`,\r\n      diskUsage: `${systemMetrics.disk.usage}%`,\r\n      cores: systemMetrics.cpu.cores\r\n    });\r\n    \r\n    // Test 7: Performance Thresholds and Alerting\r\n    console.log('\\n7. Testing Performance Thresholds and Alerting...');\r\n    \r\n    const performanceThresholds = {\r\n      apiResponseTime: { warning: 300, critical: 500 },\r\n      orderExecutionTime: { warning: 1500, critical: 2000 },\r\n      webSocketLatency: { warning: 100, critical: 200 },\r\n      memoryUsage: { warning: 70, critical: 85 },\r\n      cpuUsage: { warning: 70, critical: 85 },\r\n      errorRate: { warning: 0.005, critical: 0.01 },\r\n      diskUsage: { warning: 80, critical: 90 }\r\n    };\r\n    \r\n    // Check current metrics against thresholds\r\n    const alertStatus = {\r\n      apiResponseTime: performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.warning ? 'good' : \r\n                      performanceMetrics.apiResponseTime < performanceThresholds.apiResponseTime.critical ? 'warning' : 'critical',\r\n      \r\n      orderExecutionTime: performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.warning ? 'good' : \r\n                         performanceMetrics.orderExecutionTime < performanceThresholds.orderExecutionTime.critical ? 'warning' : 'critical',\r\n      \r\n      cpuUsage: systemMetrics.cpu.usage < performanceThresholds.cpuUsage.warning ? 'good' : \r\n               systemMetrics.cpu.usage < performanceThresholds.cpuUsage.critical ? 'warning' : 'critical',\r\n      \r\n      memoryUsage: systemMetrics.memory.usage < performanceThresholds.memoryUsage.warning ? 'good' : \r\n                  systemMetrics.memory.usage < performanceThresholds.memoryUsage.critical ? 'warning' : 'critical',\r\n      \r\n      errorRate: performanceMetrics.errorRate < performanceThresholds.errorRate.warning ? 'good' : \r\n                performanceMetrics.errorRate < performanceThresholds.errorRate.critical ? 'warning' : 'critical'\r\n    };\r\n    \r\n    const criticalAlerts = Object.values(alertStatus).filter(status => status === 'critical').length;\r\n    const warningAlerts = Object.values(alertStatus).filter(status => status === 'warning').length;\r\n    \r\n    console.log('✅ Performance thresholds and alerting validated:', {\r\n      criticalAlerts,\r\n      warningAlerts,\r\n      overallStatus: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'good',\r\n      alertDetails: alertStatus\r\n    });\r\n    \r\n    // Test 8: Metrics Aggregation and Reporting\r\n    console.log('\\n8. Testing Metrics Aggregation and Reporting...');\r\n    \r\n    const aggregatedMetrics = {\r\n      timeWindow: '1h',\r\n      summary: {\r\n        totalRequests: 4523,\r\n        successfulRequests: 4520,\r\n        failedRequests: 3,\r\n        avgResponseTime: 142,\r\n        p95ResponseTime: 285,\r\n        p99ResponseTime: 445,\r\n        uniqueUsers: 128,\r\n        peakConcurrency: 67\r\n      },\r\n      trends: {\r\n        responseTimeTrend: 'stable', // increasing, decreasing, stable\r\n        errorRateTrend: 'decreasing',\r\n        throughputTrend: 'increasing'\r\n      },\r\n      resourceUtilization: {\r\n        cpu: { avg: 18.5, peak: 34.2, trend: 'stable' },\r\n        memory: { avg: 312, peak: 456, trend: 'stable' },\r\n        network: { in: 2.3, out: 4.7, trend: 'increasing' }\r\n      }\r\n    };\r\n    \r\n    const aggregationValid = aggregatedMetrics.summary.totalRequests === \r\n                            (aggregatedMetrics.summary.successfulRequests + aggregatedMetrics.summary.failedRequests) &&\r\n                            aggregatedMetrics.summary.avgResponseTime > 0;\r\n    \r\n    console.log('✅ Metrics aggregation and reporting validated:', {\r\n      aggregationValid,\r\n      timeWindow: aggregatedMetrics.timeWindow,\r\n      totalRequests: aggregatedMetrics.summary.totalRequests,\r\n      successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n      avgResponseTime: `${aggregatedMetrics.summary.avgResponseTime}ms`,\r\n      p95ResponseTime: `${aggregatedMetrics.summary.p95ResponseTime}ms`\r\n    });\r\n    \r\n    // Test 9: Dashboard Data Structure\r\n    console.log('\\n9. Testing Dashboard Data Structure...');\r\n    \r\n    const dashboardData = {\r\n      realTime: {\r\n        status: criticalAlerts > 0 ? 'critical' : warningAlerts > 0 ? 'warning' : 'healthy',\r\n        activeUsers: 42,\r\n        requestsPerSecond: performanceMetrics.requestsPerSecond,\r\n        errorRate: performanceMetrics.errorRate,\r\n        systemLoad: systemMetrics.cpu.usage,\r\n        uptime: systemMetrics.cpu.loadAverage[0]\r\n      },\r\n      timeSeries: {\r\n        labels: ['00:00', '00:15', '00:30', '00:45', '01:00'],\r\n        datasets: {\r\n          responseTime: [120, 135, 142, 138, 125],\r\n          throughput: [10.2, 11.8, 12.3, 11.9, 10.7],\r\n          errors: [0, 1, 0, 2, 0],\r\n          cpuUsage: [15.2, 16.8, 18.5, 17.3, 15.9],\r\n          memoryUsage: [35.4, 36.2, 38.1, 37.8, 36.9]\r\n        }\r\n      },\r\n      summary: {\r\n        uptime: '99.97%',\r\n        totalTrades: strategyMetrics.totalTrades,\r\n        successRate: `${((aggregatedMetrics.summary.successfulRequests / aggregatedMetrics.summary.totalRequests) * 100).toFixed(2)}%`,\r\n        avgProfit: '+2.34%'\r\n      }\r\n    };\r\n    \r\n    const dashboardValid = dashboardData.timeSeries.labels.length === \r\n                          dashboardData.timeSeries.datasets.responseTime.length &&\r\n                          dashboardData.realTime.status in ['healthy', 'warning', 'critical'];\r\n    \r\n    console.log('✅ Dashboard data structure validated:', {\r\n      dashboardValid,\r\n      realTimeStatus: dashboardData.realTime.status,\r\n      activeUsers: dashboardData.realTime.activeUsers,\r\n      dataPoints: dashboardData.timeSeries.labels.length,\r\n      uptime: dashboardData.summary.uptime\r\n    });\r\n    \r\n    console.log('\\n🎉 All Performance Monitoring and Metrics Validation Tests Passed!');\r\n    console.log('\\n📊 Validation Summary:');\r\n    console.log('   ✅ Monitoring Service Infrastructure');\r\n    console.log('   ✅ Performance Metrics Collection');\r\n    console.log('   ✅ Strategy Performance Tracking');\r\n    console.log('   ✅ Database Health Monitoring');\r\n    console.log('   ✅ Exchange Connection Monitoring');\r\n    console.log('   ✅ System Resource Monitoring');\r\n    console.log('   ✅ Performance Thresholds & Alerting');\r\n    console.log('   ✅ Metrics Aggregation & Reporting');\r\n    console.log('   ✅ Dashboard Data Preparation');\r\n    \r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Performance Monitoring Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "cadd453a97bf48586c046b2ce64e191f"
        },
        {
          "type": "function",
          "name": "main",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\production-readiness-validation.ts",
          "startLine": 499,
          "endLine": 505,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  const validator = new ProductionReadinessValidator();\r\n  const report = await validator.runFullValidation();\r\n  \r\n  // Exit with appropriate code\r\n  process.exit(report.overall === 'not-ready' ? 1 : 0);\r\n}",
          "hash": "1cf97ef4246c71d942a9297907426311"
        },
        {
          "type": "function",
          "name": "main",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\production-readiness-validation.ts",
          "startLine": 492,
          "endLine": 498,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 7,
          "content": "{\r\n  const validator = new ProductionReadinessValidator();\r\n  const report = await validator.runFullValidation();\r\n  \r\n  // Exit with appropriate code\r\n  process.exit(report.overall === 'not-ready' ? 1 : 0);\r\n}",
          "hash": "1cf97ef4246c71d942a9297907426311"
        },
        {
          "type": "function",
          "name": "validateSignalProcessing",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\signal-processing-validation.ts",
          "startLine": 17,
          "endLine": 167,
          "complexity": 13,
          "dependencies": [],
          "usageCount": 0,
          "size": 151,
          "content": "{\r\n  console.log('🔍 Starting JabbrLabs Signal Processing Validation...');\r\n  \r\n  try {\r\n    // Test 1: Aether Signal Generator\r\n    console.log('\\n1. Testing Aether Signal Generator...');\r\n    const aetherGenerator = new AetherSignalGenerator(DEFAULT_AETHER_PARAMETERS);\r\n    \r\n    // Sample market data (ensure sufficient data for MACD calculation)\r\n    const orderBookImbalance = 0.15;\r\n    const volatility = 0.025;\r\n    const crowdingScore = -0.3;\r\n    const priceHistory = [\r\n      100, 101, 102, 103, 102, 101, 102, 103, 104, 105,\r\n      106, 105, 104, 103, 104, 105, 106, 107, 108, 107,\r\n      106, 107, 108, 109, 110, 111, 110, 109, 108, 109,\r\n      110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\r\n      120, 119, 118, 117, 118, 119, 120, 121, 122, 123,\r\n      124, 123, 122, 121, 122, 123, 124, 125, 126, 127\r\n    ];\r\n    \r\n    const aetherSignal = aetherGenerator.calculateSignal(\r\n      orderBookImbalance,\r\n      volatility, \r\n      crowdingScore,\r\n      priceHistory\r\n    );\r\n    \r\n    console.log('✅ Aether Signal Generated:', {\r\n      value: aetherSignal.value.toFixed(4),\r\n      confidence: aetherSignal.confidence.toFixed(4),\r\n      regime: aetherSignal.regime,\r\n      timestamp: aetherSignal.timestamp\r\n    });\r\n    \r\n    // Validate signal constraints\r\n    if (!Number.isFinite(aetherSignal.value) || aetherSignal.value < -1 || aetherSignal.value > 1) {\r\n      throw new Error(`Aether signal value out of range or invalid: ${aetherSignal.value}`);\r\n    }\r\n    if (!Number.isFinite(aetherSignal.confidence) || aetherSignal.confidence < 0 || aetherSignal.confidence > 1) {\r\n      throw new Error(`Aether confidence out of range or invalid: ${aetherSignal.confidence}`);\r\n    }\r\n    \r\n    // Test 2: Technical Indicators\r\n    console.log('\\n2. Testing Technical Indicators...');\r\n    \r\n    const sma20 = calculateSMA(priceHistory, 20);\r\n    const ema20 = calculateEMA(priceHistory, 20);\r\n    // TODO: Fix MACD calculation - temporarily skipped\r\n    // const macd = calculateMACD(priceHistory);\r\n    const rsi14 = calculateRSI(priceHistory, 14);\r\n    \r\n    console.log('✅ Technical Indicators:', {\r\n      sma20Length: sma20.length,\r\n      ema20Length: ema20.length,\r\n      // macdLength: macd.macd.length,\r\n      rsi14Length: rsi14.length\r\n    });\r\n    \r\n    // Validate indicator outputs\r\n    if (sma20.length === 0 || ema20.length === 0) {\r\n      throw new Error('Moving averages not calculated');\r\n    }\r\n    // if (macd.macd.length === 0 || macd.signal.length === 0) {\r\n    //   throw new Error('MACD not calculated');\r\n    // }\r\n    if (rsi14.length === 0) {\r\n      throw new Error('RSI not calculated');\r\n    }\r\n    \r\n    // Test 3: Signal Generation\r\n    console.log('\\n3. Testing Signal Generation...');\r\n    \r\n    const maSignals = getMASignals(ema20, sma20);\r\n    // TODO: Fix MACD signals when MACD is working\r\n    // const macdSignals = getMACDSignals(macd);\r\n    const rsiSignals = getRSISignals(rsi14);\r\n    \r\n    console.log('✅ Signals Generated:', {\r\n      maSignalsLength: maSignals.length,\r\n      // macdSignalsLength: macdSignals.length,\r\n      rsiSignalsLength: rsiSignals.length\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const testSignal = {\r\n      id: 'test-signal-001',\r\n      type: 'aether',\r\n      symbol: 'BTC/USDT',\r\n      action: 'buy' as const,\r\n      confidence: aetherSignal.confidence,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 100000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-001', testSignal);\r\n    \r\n    console.log('✅ Signal Execution Result:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Data Input Validation\r\n    console.log('\\n5. Testing Data Input Validation...');\r\n    \r\n    // Test with invalid inputs\r\n    try {\r\n      aetherGenerator.calculateSignal(NaN, 0.025, 0.3, priceHistory);\r\n      throw new Error('Should have failed with NaN input');\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes('Should have failed')) {\r\n        throw error;\r\n      }\r\n      console.log('✅ Input validation working - NaN rejected');\r\n    }\r\n    \r\n    try {\r\n      calculateSMA([], 20);\r\n      console.log('✅ Empty array handling working');\r\n    } catch (error) {\r\n      console.log('✅ Empty array validation working');\r\n    }\r\n    \r\n    // Test 6: Parameter Updates\r\n    console.log('\\n6. Testing Parameter Management...');\r\n    \r\n    const originalParams = aetherGenerator.getParameters();\r\n    aetherGenerator.updateParameters({ hurstExponent: 0.8 });\r\n    const updatedParams = aetherGenerator.getParameters();\r\n    \r\n    if (updatedParams.hurstExponent !== 0.8) {\r\n      throw new Error('Parameter update failed');\r\n    }\r\n    \r\n    console.log('✅ Parameter management working');\r\n    \r\n    // Reset for consistency\r\n    aetherGenerator.updateParameters(originalParams);\r\n    \r\n    console.log('\\n🎉 All Signal Processing Validation Tests Passed!');\r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Signal Processing Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "073cf636ca04495d3baf9d6864759624"
        },
        {
          "type": "function",
          "name": "validateSignalProcessing",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\signal-processing-validation.ts",
          "startLine": 17,
          "endLine": 167,
          "complexity": 13,
          "dependencies": [],
          "usageCount": 0,
          "size": 151,
          "content": "{\r\n  console.log('🔍 Starting JabbrLabs Signal Processing Validation...');\r\n  \r\n  try {\r\n    // Test 1: Aether Signal Generator\r\n    console.log('\\n1. Testing Aether Signal Generator...');\r\n    const aetherGenerator = new AetherSignalGenerator(DEFAULT_AETHER_PARAMETERS);\r\n    \r\n    // Sample market data (ensure sufficient data for MACD calculation)\r\n    const orderBookImbalance = 0.15;\r\n    const volatility = 0.025;\r\n    const crowdingScore = -0.3;\r\n    const priceHistory = [\r\n      100, 101, 102, 103, 102, 101, 102, 103, 104, 105,\r\n      106, 105, 104, 103, 104, 105, 106, 107, 108, 107,\r\n      106, 107, 108, 109, 110, 111, 110, 109, 108, 109,\r\n      110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\r\n      120, 119, 118, 117, 118, 119, 120, 121, 122, 123,\r\n      124, 123, 122, 121, 122, 123, 124, 125, 126, 127\r\n    ];\r\n    \r\n    const aetherSignal = aetherGenerator.calculateSignal(\r\n      orderBookImbalance,\r\n      volatility, \r\n      crowdingScore,\r\n      priceHistory\r\n    );\r\n    \r\n    console.log('✅ Aether Signal Generated:', {\r\n      value: aetherSignal.value.toFixed(4),\r\n      confidence: aetherSignal.confidence.toFixed(4),\r\n      regime: aetherSignal.regime,\r\n      timestamp: aetherSignal.timestamp\r\n    });\r\n    \r\n    // Validate signal constraints\r\n    if (!Number.isFinite(aetherSignal.value) || aetherSignal.value < -1 || aetherSignal.value > 1) {\r\n      throw new Error(`Aether signal value out of range or invalid: ${aetherSignal.value}`);\r\n    }\r\n    if (!Number.isFinite(aetherSignal.confidence) || aetherSignal.confidence < 0 || aetherSignal.confidence > 1) {\r\n      throw new Error(`Aether confidence out of range or invalid: ${aetherSignal.confidence}`);\r\n    }\r\n    \r\n    // Test 2: Technical Indicators\r\n    console.log('\\n2. Testing Technical Indicators...');\r\n    \r\n    const sma20 = calculateSMA(priceHistory, 20);\r\n    const ema20 = calculateEMA(priceHistory, 20);\r\n    // TODO: Fix MACD calculation - temporarily skipped\r\n    // const macd = calculateMACD(priceHistory);\r\n    const rsi14 = calculateRSI(priceHistory, 14);\r\n    \r\n    console.log('✅ Technical Indicators:', {\r\n      sma20Length: sma20.length,\r\n      ema20Length: ema20.length,\r\n      // macdLength: macd.macd.length,\r\n      rsi14Length: rsi14.length\r\n    });\r\n    \r\n    // Validate indicator outputs\r\n    if (sma20.length === 0 || ema20.length === 0) {\r\n      throw new Error('Moving averages not calculated');\r\n    }\r\n    // if (macd.macd.length === 0 || macd.signal.length === 0) {\r\n    //   throw new Error('MACD not calculated');\r\n    // }\r\n    if (rsi14.length === 0) {\r\n      throw new Error('RSI not calculated');\r\n    }\r\n    \r\n    // Test 3: Signal Generation\r\n    console.log('\\n3. Testing Signal Generation...');\r\n    \r\n    const maSignals = getMASignals(ema20, sma20);\r\n    // TODO: Fix MACD signals when MACD is working\r\n    // const macdSignals = getMACDSignals(macd);\r\n    const rsiSignals = getRSISignals(rsi14);\r\n    \r\n    console.log('✅ Signals Generated:', {\r\n      maSignalsLength: maSignals.length,\r\n      // macdSignalsLength: macdSignals.length,\r\n      rsiSignalsLength: rsiSignals.length\r\n    });\r\n    \r\n    // Test 4: Signal Execution Pipeline\r\n    console.log('\\n4. Testing Signal Execution Pipeline...');\r\n    \r\n    const testSignal = {\r\n      id: 'test-signal-001',\r\n      type: 'aether',\r\n      symbol: 'BTC/USDT',\r\n      action: 'buy' as const,\r\n      confidence: aetherSignal.confidence,\r\n      timestamp: Date.now(),\r\n      amount: 0.01,\r\n      price: 100000\r\n    };\r\n    \r\n    const executionResult = await executeSignal('test-bot-001', testSignal);\r\n    \r\n    console.log('✅ Signal Execution Result:', {\r\n      success: executionResult.success,\r\n      orderId: executionResult.orderId,\r\n      error: executionResult.error\r\n    });\r\n    \r\n    // Test 5: Data Input Validation\r\n    console.log('\\n5. Testing Data Input Validation...');\r\n    \r\n    // Test with invalid inputs\r\n    try {\r\n      aetherGenerator.calculateSignal(NaN, 0.025, 0.3, priceHistory);\r\n      throw new Error('Should have failed with NaN input');\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes('Should have failed')) {\r\n        throw error;\r\n      }\r\n      console.log('✅ Input validation working - NaN rejected');\r\n    }\r\n    \r\n    try {\r\n      calculateSMA([], 20);\r\n      console.log('✅ Empty array handling working');\r\n    } catch (error) {\r\n      console.log('✅ Empty array validation working');\r\n    }\r\n    \r\n    // Test 6: Parameter Updates\r\n    console.log('\\n6. Testing Parameter Management...');\r\n    \r\n    const originalParams = aetherGenerator.getParameters();\r\n    aetherGenerator.updateParameters({ hurstExponent: 0.8 });\r\n    const updatedParams = aetherGenerator.getParameters();\r\n    \r\n    if (updatedParams.hurstExponent !== 0.8) {\r\n      throw new Error('Parameter update failed');\r\n    }\r\n    \r\n    console.log('✅ Parameter management working');\r\n    \r\n    // Reset for consistency\r\n    aetherGenerator.updateParameters(originalParams);\r\n    \r\n    console.log('\\n🎉 All Signal Processing Validation Tests Passed!');\r\n    return true;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Signal Processing Validation Failed:', error);\r\n    return false;\r\n  }\r\n}",
          "hash": "073cf636ca04495d3baf9d6864759624"
        },
        {
          "type": "function",
          "name": "testDatabaseConnection",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts",
          "startLine": 32,
          "endLine": 100,
          "complexity": 10,
          "dependencies": [],
          "usageCount": 0,
          "size": 69,
          "content": "{\r\n  const result: DatabaseTestResult = {\r\n    connectionStatus: 'failed',\r\n    queryStatus: 'failed', \r\n    migrationStatus: 'failed',\r\n    details: {}\r\n  };\r\n\r\n  try {\r\n    logger.info('🔌 Testing database connection...');\r\n    \r\n    const startTime = Date.now();\r\n    \r\n    // Test basic connection\r\n    const testQuery = 'SELECT version() as server_version, current_timestamp as current_time';\r\n    const queryResult = await dbInstance.query<{server_version: string; current_time: string}>(testQuery);\r\n    \r\n    const connectionTime = Date.now() - startTime;\r\n    result.connectionStatus = 'success';\r\n    result.details.connectionTime = connectionTime;\r\n    \r\n    if (queryResult && queryResult.length > 0 && queryResult[0]) {\r\n      result.queryStatus = 'success';\r\n      result.details.serverVersion = queryResult[0].server_version;\r\n      logger.info(`✅ Database connection successful (${connectionTime}ms)`);\r\n      logger.info(`📊 Server version: ${queryResult[0].server_version}`);\r\n    }\r\n\r\n    // Test connection pool status\r\n    try {\r\n      const poolQuery = 'SELECT count(*) as active_connections FROM pg_stat_activity WHERE state = \\'active\\'';\r\n      const poolResult = await dbInstance.query<{active_connections: string}>(poolQuery);\r\n      \r\n      if (poolResult && poolResult.length > 0 && poolResult[0]) {\r\n        result.details.activeConnections = parseInt(poolResult[0].active_connections);\r\n        logger.info(`🔗 Active connections: ${result.details.activeConnections}`);\r\n      }\r\n    } catch (poolError) {\r\n      logger.warn('⚠️  Could not retrieve connection pool status:', poolError);\r\n    }\r\n\r\n    // Test migration status\r\n    try {\r\n      const migrationQuery = `\r\n        SELECT EXISTS (\r\n          SELECT FROM information_schema.tables \r\n          WHERE table_schema = 'public' \r\n          AND table_name = 'users'\r\n        ) as users_table_exists\r\n      `;\r\n      const migrationResult = await dbInstance.query<{users_table_exists: boolean}>(migrationQuery);\r\n      \r\n      if (migrationResult && migrationResult.length > 0 && migrationResult[0]) {\r\n        const tablesExist = migrationResult[0].users_table_exists;\r\n        result.migrationStatus = tablesExist ? 'success' : 'failed';\r\n        logger.info(`📋 Database migrations: ${tablesExist ? 'Applied' : 'Not Applied'}`);\r\n      }\r\n    } catch (migrationError) {\r\n      logger.warn('⚠️  Could not check migration status:', migrationError);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Database connection failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "1bb88a8484fec42d3efa6c902038863c"
        },
        {
          "type": "function",
          "name": "testDatabaseConnection",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts",
          "startLine": 32,
          "endLine": 100,
          "complexity": 10,
          "dependencies": [],
          "usageCount": 0,
          "size": 69,
          "content": "{\r\n  const result: DatabaseTestResult = {\r\n    connectionStatus: 'failed',\r\n    queryStatus: 'failed', \r\n    migrationStatus: 'failed',\r\n    details: {}\r\n  };\r\n\r\n  try {\r\n    logger.info('🔌 Testing database connection...');\r\n    \r\n    const startTime = Date.now();\r\n    \r\n    // Test basic connection\r\n    const testQuery = 'SELECT version() as server_version, current_timestamp as current_time';\r\n    const queryResult = await dbInstance.query<{server_version: string; current_time: string}>(testQuery);\r\n    \r\n    const connectionTime = Date.now() - startTime;\r\n    result.connectionStatus = 'success';\r\n    result.details.connectionTime = connectionTime;\r\n    \r\n    if (queryResult && queryResult.length > 0 && queryResult[0]) {\r\n      result.queryStatus = 'success';\r\n      result.details.serverVersion = queryResult[0].server_version;\r\n      logger.info(`✅ Database connection successful (${connectionTime}ms)`);\r\n      logger.info(`📊 Server version: ${queryResult[0].server_version}`);\r\n    }\r\n\r\n    // Test connection pool status\r\n    try {\r\n      const poolQuery = 'SELECT count(*) as active_connections FROM pg_stat_activity WHERE state = \\'active\\'';\r\n      const poolResult = await dbInstance.query<{active_connections: string}>(poolQuery);\r\n      \r\n      if (poolResult && poolResult.length > 0 && poolResult[0]) {\r\n        result.details.activeConnections = parseInt(poolResult[0].active_connections);\r\n        logger.info(`🔗 Active connections: ${result.details.activeConnections}`);\r\n      }\r\n    } catch (poolError) {\r\n      logger.warn('⚠️  Could not retrieve connection pool status:', poolError);\r\n    }\r\n\r\n    // Test migration status\r\n    try {\r\n      const migrationQuery = `\r\n        SELECT EXISTS (\r\n          SELECT FROM information_schema.tables \r\n          WHERE table_schema = 'public' \r\n          AND table_name = 'users'\r\n        ) as users_table_exists\r\n      `;\r\n      const migrationResult = await dbInstance.query<{users_table_exists: boolean}>(migrationQuery);\r\n      \r\n      if (migrationResult && migrationResult.length > 0 && migrationResult[0]) {\r\n        const tablesExist = migrationResult[0].users_table_exists;\r\n        result.migrationStatus = tablesExist ? 'success' : 'failed';\r\n        logger.info(`📋 Database migrations: ${tablesExist ? 'Applied' : 'Not Applied'}`);\r\n      }\r\n    } catch (migrationError) {\r\n      logger.warn('⚠️  Could not check migration status:', migrationError);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Database connection failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "1bb88a8484fec42d3efa6c902038863c"
        },
        {
          "type": "function",
          "name": "testMonitoringServices",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts",
          "startLine": 102,
          "endLine": 144,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n  const result: MonitoringTestResult = {\r\n    databaseMonitor: false,\r\n    metricsCollector: false,\r\n    healthCheck: false\r\n  };\r\n\r\n  try {\r\n    logger.info('📊 Testing monitoring services...');\r\n    \r\n    // Test if monitoring services can be imported\r\n    try {\r\n      const { DatabaseMonitorService } = await import('../services/database-monitor.service');\r\n      result.databaseMonitor = true;\r\n      logger.info('✅ Database monitor service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Database monitor service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { MetricsCollectorService } = await import('../services/metrics-collector.service');\r\n      result.metricsCollector = true;\r\n      logger.info('✅ Metrics collector service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Metrics collector service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { HealthCheckService } = await import('../services/health-check.service');\r\n      result.healthCheck = true;\r\n      logger.info('✅ Health check service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Health check service not available:', (error as Error).message);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Monitoring services test failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "eb0fcdc0b0cc125723cbb0f6e9a965fd"
        },
        {
          "type": "function",
          "name": "testMonitoringServices",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts",
          "startLine": 102,
          "endLine": 144,
          "complexity": 7,
          "dependencies": [],
          "usageCount": 0,
          "size": 43,
          "content": "{\r\n  const result: MonitoringTestResult = {\r\n    databaseMonitor: false,\r\n    metricsCollector: false,\r\n    healthCheck: false\r\n  };\r\n\r\n  try {\r\n    logger.info('📊 Testing monitoring services...');\r\n    \r\n    // Test if monitoring services can be imported\r\n    try {\r\n      const { DatabaseMonitorService } = await import('../services/database-monitor.service');\r\n      result.databaseMonitor = true;\r\n      logger.info('✅ Database monitor service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Database monitor service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { MetricsCollectorService } = await import('../services/metrics-collector.service');\r\n      result.metricsCollector = true;\r\n      logger.info('✅ Metrics collector service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Metrics collector service not available:', (error as Error).message);\r\n    }\r\n\r\n    try {\r\n      const { HealthCheckService } = await import('../services/health-check.service');\r\n      result.healthCheck = true;\r\n      logger.info('✅ Health check service available');\r\n    } catch (error) {\r\n      logger.warn('⚠️  Health check service not available:', (error as Error).message);\r\n    }\r\n\r\n    return result;\r\n\r\n  } catch (error) {\r\n    result.error = error instanceof Error ? error.message : String(error);\r\n    logger.error('❌ Monitoring services test failed:', error);\r\n    return result;\r\n  }\r\n}",
          "hash": "eb0fcdc0b0cc125723cbb0f6e9a965fd"
        },
        {
          "type": "function",
          "name": "runTests",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts",
          "startLine": 146,
          "endLine": 195,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 50,
          "content": "{\r\n  logger.info('🚀 Starting Database & Monitoring Services Test...\\n');\r\n\r\n  const summary: TestSummary = {\r\n    database: await testDatabaseConnection(),\r\n    monitoring: await testMonitoringServices(),\r\n    overall: 'failed',\r\n    timestamp: new Date().toISOString()\r\n  };\r\n\r\n  // Determine overall status\r\n  const dbSuccess = summary.database.connectionStatus === 'success' && \r\n                   summary.database.queryStatus === 'success';\r\n  const monitoringSuccess = summary.monitoring.databaseMonitor || \r\n                           summary.monitoring.metricsCollector || \r\n                           summary.monitoring.healthCheck;\r\n\r\n  summary.overall = dbSuccess && monitoringSuccess ? 'success' : 'failed';\r\n\r\n  // Print summary\r\n  console.log('\\n📋 Test Summary:');\r\n  console.log('================');\r\n  console.log(`Database Connection: ${summary.database.connectionStatus}`);\r\n  console.log(`Database Queries: ${summary.database.queryStatus}`);\r\n  console.log(`Database Migrations: ${summary.database.migrationStatus}`);\r\n  console.log(`Monitoring Services: ${monitoringSuccess ? 'Available' : 'Unavailable'}`);\r\n  console.log(`Overall Status: ${summary.overall}`);\r\n  \r\n  if (summary.database.details.connectionTime) {\r\n    console.log(`Connection Time: ${summary.database.details.connectionTime}ms`);\r\n  }\r\n  \r\n  if (summary.database.details.serverVersion) {\r\n    console.log(`Database Version: ${summary.database.details.serverVersion}`);\r\n  }\r\n\r\n  // Save results to file\r\n  const fs = await import('fs/promises');\r\n  const path = await import('path');\r\n  \r\n  const resultsDir = path.join(__dirname, '../../test-results');\r\n  await fs.mkdir(resultsDir, { recursive: true });\r\n  \r\n  const resultsFile = path.join(resultsDir, `db-monitoring-test-${Date.now()}.json`);\r\n  await fs.writeFile(resultsFile, JSON.stringify(summary, null, 2));\r\n  \r\n  logger.info(`📝 Test results saved to: ${resultsFile}`);\r\n\r\n  return summary;\r\n}",
          "hash": "46794edfc4b775dc3e6ba4e2940f113e"
        },
        {
          "type": "function",
          "name": "runTests",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts",
          "startLine": 146,
          "endLine": 195,
          "complexity": 5,
          "dependencies": [],
          "usageCount": 0,
          "size": 50,
          "content": "{\r\n  logger.info('🚀 Starting Database & Monitoring Services Test...\\n');\r\n\r\n  const summary: TestSummary = {\r\n    database: await testDatabaseConnection(),\r\n    monitoring: await testMonitoringServices(),\r\n    overall: 'failed',\r\n    timestamp: new Date().toISOString()\r\n  };\r\n\r\n  // Determine overall status\r\n  const dbSuccess = summary.database.connectionStatus === 'success' && \r\n                   summary.database.queryStatus === 'success';\r\n  const monitoringSuccess = summary.monitoring.databaseMonitor || \r\n                           summary.monitoring.metricsCollector || \r\n                           summary.monitoring.healthCheck;\r\n\r\n  summary.overall = dbSuccess && monitoringSuccess ? 'success' : 'failed';\r\n\r\n  // Print summary\r\n  console.log('\\n📋 Test Summary:');\r\n  console.log('================');\r\n  console.log(`Database Connection: ${summary.database.connectionStatus}`);\r\n  console.log(`Database Queries: ${summary.database.queryStatus}`);\r\n  console.log(`Database Migrations: ${summary.database.migrationStatus}`);\r\n  console.log(`Monitoring Services: ${monitoringSuccess ? 'Available' : 'Unavailable'}`);\r\n  console.log(`Overall Status: ${summary.overall}`);\r\n  \r\n  if (summary.database.details.connectionTime) {\r\n    console.log(`Connection Time: ${summary.database.details.connectionTime}ms`);\r\n  }\r\n  \r\n  if (summary.database.details.serverVersion) {\r\n    console.log(`Database Version: ${summary.database.details.serverVersion}`);\r\n  }\r\n\r\n  // Save results to file\r\n  const fs = await import('fs/promises');\r\n  const path = await import('path');\r\n  \r\n  const resultsDir = path.join(__dirname, '../../test-results');\r\n  await fs.mkdir(resultsDir, { recursive: true });\r\n  \r\n  const resultsFile = path.join(resultsDir, `db-monitoring-test-${Date.now()}.json`);\r\n  await fs.writeFile(resultsFile, JSON.stringify(summary, null, 2));\r\n  \r\n  logger.info(`📝 Test results saved to: ${resultsFile}`);\r\n\r\n  return summary;\r\n}",
          "hash": "46794edfc4b775dc3e6ba4e2940f113e"
        },
        {
          "type": "function",
          "name": "volatility",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\data-service.ts",
          "startLine": 109,
          "endLine": 116,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: currentTime,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "13933002539672e77a9fd2de9a09815d"
        },
        {
          "type": "function",
          "name": "close",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\data-service.ts",
          "startLine": 117,
          "endLine": 124,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp: currentTime,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "13933002539672e77a9fd2de9a09815d"
        },
        {
          "type": "function",
          "name": "cacheHitRatio",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\database-monitor.service.ts",
          "startLine": 517,
          "endLine": 522,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 6,
          "content": "{\r\n        transactionsPerSecond,\r\n        lockWaitTime: lockCount * 10, // Simplified estimate\r\n        cacheHitRatio,\r\n        indexEfficiency: cacheHitRatio // Simplified - would need more complex calculation\r\n      }",
          "hash": "58b0fdbd19d3d1f74d54e0ce41d426bf"
        },
        {
          "type": "function",
          "name": "uptime",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\database-monitor.service.ts",
          "startLine": 524,
          "endLine": 529,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 6,
          "content": "{\r\n        transactionsPerSecond,\r\n        lockWaitTime: lockCount * 10, // Simplified estimate\r\n        cacheHitRatio,\r\n        indexEfficiency: cacheHitRatio // Simplified - would need more complex calculation\r\n      }",
          "hash": "58b0fdbd19d3d1f74d54e0ce41d426bf"
        },
        {
          "type": "function",
          "name": "generateBullishCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\fixtures\\candles.ts",
          "startLine": 9,
          "endLine": 38,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 30,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  let price = startPrice;\r\n  \r\n  // Determine milliseconds based on timeframe\r\n  const msPerCandle = timeframeToMs(timeframe);\r\n  \r\n  for (let i = 0; i < count; i++) {\r\n    // Generate slightly uptrending prices\r\n    const open = price;\r\n    const close = price * (1 + 0.01 + Math.random() * 0.01); // 1-2% increase\r\n    const high = Math.max(open, close) * (1 + Math.random() * 0.005); // 0-0.5% above max\r\n    const low = Math.min(open, close) * (1 - Math.random() * 0.005); // 0-0.5% below min\r\n    const volume = 1000 + Math.random() * 1000;\r\n    \r\n    candles.push({\r\n      timestamp: Date.now() - (count - i) * msPerCandle,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n    \r\n    // Update price for next candle\r\n    price = close;\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "3e8b8ae084be69ec7eecabe281a6f481"
        },
        {
          "type": "function",
          "name": "generateBearishCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\fixtures\\candles.ts",
          "startLine": 41,
          "endLine": 70,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 30,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  let price = startPrice;\r\n  \r\n  // Determine milliseconds based on timeframe\r\n  const msPerCandle = timeframeToMs(timeframe);\r\n  \r\n  for (let i = 0; i < count; i++) {\r\n    // Generate slightly downtrending prices\r\n    const open = price;\r\n    const close = price * (1 - 0.01 - Math.random() * 0.01); // 1-2% decrease\r\n    const high = Math.max(open, close) * (1 + Math.random() * 0.005); // 0-0.5% above max\r\n    const low = Math.min(open, close) * (1 - Math.random() * 0.005); // 0-0.5% below min\r\n    const volume = 1000 + Math.random() * 1000;\r\n    \r\n    candles.push({\r\n      timestamp: Date.now() - (count - i) * msPerCandle,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n    \r\n    // Update price for next candle\r\n    price = close;\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "ce84ff349629f9b1f6a24c90aaa6a529"
        },
        {
          "type": "function",
          "name": "noise",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 31,
          "endLine": 38,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "2567bc98f2c9e7162da67f601c80d1ad"
        },
        {
          "type": "function",
          "name": "noise",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-signals.ts",
          "startLine": 19,
          "endLine": 26,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    }",
          "hash": "2567bc98f2c9e7162da67f601c80d1ad"
        },
        {
          "type": "function",
          "name": "getCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 93,
          "endLine": 100,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n        symbol: 'BTC/USDT',\r\n        last: candles[candles.length - 1]?.close || 0,\r\n        bid: 0,\r\n        ask: 0,\r\n        volume: 0,\r\n        timestamp: Date.now()\r\n      }",
          "hash": "933f3fab0167097e4f6f0898fb2a2eb8"
        },
        {
          "type": "function",
          "name": "getTicker",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 94,
          "endLine": 101,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n        symbol: 'BTC/USDT',\r\n        last: candles[candles.length - 1]?.close || 0,\r\n        bid: 0,\r\n        ask: 0,\r\n        volume: 0,\r\n        timestamp: Date.now()\r\n      }",
          "hash": "933f3fab0167097e4f6f0898fb2a2eb8"
        },
        {
          "type": "function",
          "name": "getPosition",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 122,
          "endLine": 124,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n        console.log(`[${new Date().toISOString()}] CLOSE position`);\r\n      }",
          "hash": "9b2b12f940dfb368b7749a7c22dd8f44"
        },
        {
          "type": "function",
          "name": "closePosition",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 123,
          "endLine": 125,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n        console.log(`[${new Date().toISOString()}] CLOSE position`);\r\n      }",
          "hash": "9b2b12f940dfb368b7749a7c22dd8f44"
        },
        {
          "type": "function",
          "name": "unrealizedPnl",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 219,
          "endLine": 234,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 16,
          "content": "{\r\n      const unrealizedPnl = (entryPrice - currentPrice) * positionSize;\r\n      equity = capital + unrealizedPnl;\r\n    }\r\n    \r\n    // Mock position data\r\n    if (position) {\r\n      context.tradeExecutor.getPosition = async () => ({\r\n        symbol,\r\n        side: position as 'long' | 'short', // Type assertion to match Position interface\r\n        size: positionSize,\r\n        entryPrice,\r\n        currentPrice,\r\n        unrealizedPnl: equity - capital,\r\n        timestamp: currentTimestamp\r\n      }",
          "hash": "451c91bef1ee2b3fd7cd18e3861bc325"
        },
        {
          "type": "function",
          "name": "unrealizedPnl",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts",
          "startLine": 222,
          "endLine": 231,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n      context.tradeExecutor.getPosition = async () => ({\r\n        symbol,\r\n        side: position as 'long' | 'short', // Type assertion to match Position interface\r\n        size: positionSize,\r\n        entryPrice,\r\n        currentPrice,\r\n        unrealizedPnl: equity - capital,\r\n        timestamp: currentTimestamp\r\n      }",
          "hash": "7ccbac45304455393de52eb65474aea7"
        },
        {
          "type": "function",
          "name": "handleSort",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\page.tsx",
          "startLine": 194,
          "endLine": 199,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 6,
          "content": "{\r\n    setSortConfig(prev => ({\r\n      field,\r\n      direction: prev.field === field && prev.direction === 'asc' ? 'desc' : 'asc'\r\n    }));\r\n  }",
          "hash": "a4d182ba0b82faa793b0b0e809a271d0"
        },
        {
          "type": "function",
          "name": "handleSortChange",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\TradingActivityMonitor.tsx",
          "startLine": 301,
          "endLine": 306,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 6,
          "content": "{\r\n    setSortOptions(prev => ({\r\n      field,\r\n      direction: prev.field === field && prev.direction === 'desc' ? 'asc' : 'desc'\r\n    }));\r\n  }",
          "hash": "45327625577bcf80a47821de99635fd7"
        },
        {
          "type": "function",
          "name": "getUniqueStrategies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\page.tsx",
          "startLine": 231,
          "endLine": 241,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-100 p-8\">\r\n        <div className=\"max-w-6xl mx-auto\">\r\n          <div className=\"flex items-center justify-center h-64\">\r\n            <div className=\"text-lg text-gray-600\">Loading bots...</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }",
          "hash": "ed491ad84225f8ee469443e0a0ca3c8e"
        },
        {
          "type": "function",
          "name": "getUniqueExchanges",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\page.tsx",
          "startLine": 232,
          "endLine": 242,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-100 p-8\">\r\n        <div className=\"max-w-6xl mx-auto\">\r\n          <div className=\"flex items-center justify-center h-64\">\r\n            <div className=\"text-lg text-gray-600\">Loading bots...</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }",
          "hash": "ed491ad84225f8ee469443e0a0ca3c8e"
        },
        {
          "type": "function",
          "name": "acknowledgeAlert",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\AlertSystem.tsx",
          "startLine": 163,
          "endLine": 183,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n    try {\r\n      const response = await fetch(`/api/alerts/${alertId}/acknowledge`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${localStorage.getItem('token')}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (response.ok) {\r\n        setAlerts(prev => prev.map(alert => \r\n          alert.id === alertId \r\n            ? { ...alert, acknowledged: true, acknowledgedAt: new Date() }\r\n            : alert\r\n        ));\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to acknowledge alert:', error);\r\n    }\r\n  }",
          "hash": "cff7f5c4f44c8d95392e9ecddad9cfa9"
        },
        {
          "type": "function",
          "name": "resolveAlert",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\AlertSystem.tsx",
          "startLine": 186,
          "endLine": 206,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n    try {\r\n      const response = await fetch(`/api/alerts/${alertId}/resolve`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${localStorage.getItem('token')}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (response.ok) {\r\n        setAlerts(prev => prev.map(alert => \r\n          alert.id === alertId \r\n            ? { ...alert, resolved: true, resolvedAt: new Date() }\r\n            : alert\r\n        ));\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to resolve alert:', error);\r\n    }\r\n  }",
          "hash": "d1fa84598b57581cdda1a431d2b8a92c"
        },
        {
          "type": "function",
          "name": "formatCurrency",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\PositionPnLVisualization.tsx",
          "startLine": 445,
          "endLine": 452,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n    return new Intl.NumberFormat('en-US', {\r\n      style: 'currency',\r\n      currency: 'USD',\r\n      minimumFractionDigits: 2,\r\n      maximumFractionDigits: 2\r\n    }).format(value)\r\n  }",
          "hash": "e213750caec98d8b1a9d1b88f71f1fb5"
        },
        {
          "type": "function",
          "name": "formatCurrency",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx",
          "startLine": 146,
          "endLine": 153,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n    return new Intl.NumberFormat('en-US', {\r\n      style: 'currency',\r\n      currency: 'USD',\r\n      minimumFractionDigits: 2,\r\n      maximumFractionDigits: 2\r\n    }).format(amount);\r\n  }",
          "hash": "6db87d21708e4cc883619335d24cb981"
        },
        {
          "type": "function",
          "name": "formatPercentage",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\PositionPnLVisualization.tsx",
          "startLine": 454,
          "endLine": 456,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n    return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`\r\n  }",
          "hash": "6fa6e2bdf686d919e438d3bdd9d1219d"
        },
        {
          "type": "function",
          "name": "formatPercentage",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx",
          "startLine": 155,
          "endLine": 157,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n    return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;\r\n  }",
          "hash": "f01031323e28760c45b43985ec322286"
        },
        {
          "type": "function",
          "name": "formatCurrency",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 129,
          "endLine": 136,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n  return new Intl.NumberFormat('en-US', {\r\n    style: 'currency',\r\n    currency,\r\n    minimumFractionDigits: 2,\r\n    maximumFractionDigits: 2\r\n  }).format(amount);\r\n}",
          "hash": "0c25ff518b9c15f431ec7e43dd9f467c"
        },
        {
          "type": "function",
          "name": "formatUptime",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx",
          "startLine": 159,
          "endLine": 171,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n    const seconds = Math.floor(uptime / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const hours = Math.floor(minutes / 60);\r\n    \r\n    if (hours > 0) {\r\n      return `${hours}h ${minutes % 60}m`;\r\n    } else if (minutes > 0) {\r\n      return `${minutes}m ${seconds % 60}s`;\r\n    } \r\n      return `${seconds}s`;\r\n    \r\n  }",
          "hash": "bd38d60a0d20091072cad386bf2345b9"
        },
        {
          "type": "function",
          "name": "formatUptime",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 148,
          "endLine": 158,
          "complexity": 4,
          "dependencies": [],
          "usageCount": 0,
          "size": 11,
          "content": "{\r\n  const seconds = Math.floor(uptime / 1000);\r\n  const minutes = Math.floor(seconds / 60);\r\n  const hours = Math.floor(minutes / 60);\r\n  const days = Math.floor(hours / 24);\r\n  \r\n  if (days > 0) return `${days}d ${hours % 24}h`;\r\n  if (hours > 0) return `${hours}h ${minutes % 60}m`;\r\n  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\r\n  return `${seconds}s`;\r\n}",
          "hash": "c3cc923ce7d32dcc1ac4095d7fd43856"
        },
        {
          "type": "function",
          "name": "getStatusColor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx",
          "startLine": 179,
          "endLine": 181,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n    return isRunning ? 'text-green-600 bg-green-100' : 'text-gray-600 bg-gray-100';\r\n  }",
          "hash": "a894955437926fd19f40c1fd09654779"
        },
        {
          "type": "function",
          "name": "getRunningStatusColor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 107,
          "endLine": 109,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 3,
          "content": "{\r\n  return isRunning ? 'text-green-600 bg-green-100' : 'text-gray-600 bg-gray-100';\r\n}",
          "hash": "a894955437926fd19f40c1fd09654779"
        },
        {
          "type": "function",
          "name": "subscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 51,
          "endLine": 63,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "unsubscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 52,
          "endLine": 64,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "reconnect",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 53,
          "endLine": 65,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "startBot",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 56,
          "endLine": 68,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "stopBot",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 57,
          "endLine": 69,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "pauseBot",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx",
          "startLine": 58,
          "endLine": 70,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 13,
          "content": "{\r\n  children: React.ReactNode;\r\n  wsUrl?: string;\r\n  token?: string;\r\n}\r\n\r\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ \r\n  children, \r\n  wsUrl = 'ws://localhost:3002/ws',\r\n  token \r\n}) => {\r\n  // Data state\r\n  const [marketData, setMarketData] = useState<Record<string, MarketData>>({}",
          "hash": "3cbce9f686e931573207a7f3dd9cc649"
        },
        {
          "type": "function",
          "name": "sendMessage",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 22,
          "endLine": 33,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        },
        {
          "type": "function",
          "name": "subscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 23,
          "endLine": 34,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        },
        {
          "type": "function",
          "name": "unsubscribe",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 24,
          "endLine": 35,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        },
        {
          "type": "function",
          "name": "reconnect",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts",
          "startLine": 25,
          "endLine": 36,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 12,
          "content": "{\r\n  const {\r\n    url,\r\n    token,\r\n    onOpen,\r\n    onMessage,\r\n    onError,\r\n    onClose,\r\n    reconnectInterval = 3000,\r\n    maxReconnectAttempts = 10,\r\n    heartbeatInterval = 30000\r\n  }",
          "hash": "a8e7c292d15ca8f5369f38b229a03bab"
        },
        {
          "type": "function",
          "name": "formatCurrency",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\index.ts",
          "startLine": 237,
          "endLine": 244,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 8,
          "content": "{\r\n    return new Intl.NumberFormat('en-US', {\r\n      style: 'currency',\r\n      currency,\r\n      minimumFractionDigits: 2,\r\n      maximumFractionDigits: 8\r\n    }).format(amount);\r\n  }",
          "hash": "c20a96983c47506f995dfac310e8b21e"
        },
        {
          "type": "function",
          "name": "generateBullishCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\test-utils\\data-generators.ts",
          "startLine": 50,
          "endLine": 76,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 27,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  const timeframeMs = timeframeToMs(timeframe);\r\n  let currentPrice = startPrice;\r\n  const startTime = new Date().getTime() - (count * timeframeMs);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const open = currentPrice;\r\n    const priceIncrease = Math.random() * 2 + 0.5; // 0.5-2.5 increase\r\n    const high = open + priceIncrease + Math.random() * 0.5;\r\n    const low = open - Math.random() * 0.3;\r\n    const close = open + priceIncrease;\r\n    \r\n    candles.push({\r\n      timestamp: startTime + (i * timeframeMs),\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume: 1000 + Math.random() * 500\r\n    });\r\n    \r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "b91b1a119c6f6f97ee962594832542e5"
        },
        {
          "type": "function",
          "name": "generateBearishCandles",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\test-utils\\data-generators.ts",
          "startLine": 85,
          "endLine": 111,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 27,
          "content": "{\r\n  const candles: Candle[] = [];\r\n  const timeframeMs = timeframeToMs(timeframe);\r\n  let currentPrice = startPrice;\r\n  const startTime = new Date().getTime() - (count * timeframeMs);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const open = currentPrice;\r\n    const priceDecrease = Math.random() * 2 + 0.5; // 0.5-2.5 decrease\r\n    const high = open + Math.random() * 0.3;\r\n    const low = open - priceDecrease - Math.random() * 0.5;\r\n    const close = open - priceDecrease;\r\n    \r\n    candles.push({\r\n      timestamp: startTime + (i * timeframeMs),\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume: 1000 + Math.random() * 500\r\n    });\r\n    \r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n}",
          "hash": "2e593a1d491122421ee7f554e95a949b"
        },
        {
          "type": "function",
          "name": "getConnectionStatusColor",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 59,
          "endLine": 63,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 5,
          "content": "{ \r\n  isConnected, \r\n  isConnecting, \r\n  connectionError \r\n}",
          "hash": "97eab06b9194f946b603d08631602afd"
        },
        {
          "type": "function",
          "name": "getConnectionStatusText",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts",
          "startLine": 73,
          "endLine": 77,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 5,
          "content": "{ \r\n  isConnected, \r\n  isConnecting, \r\n  connectionError \r\n}",
          "hash": "97eab06b9194f946b603d08631602afd"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\duplicate-method-detector.ts",
          "startLine": 318,
          "endLine": 339,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory()) {\r\n            // Skip excluded directories\r\n            if (this.shouldExcludePath(entry.name)) continue;\r\n            scanDirectory(fullPath);\r\n          } else if (entry.isFile()) {\r\n            // Include TypeScript files\r\n            if (this.isTypeScriptFile(entry.name) && !this.shouldExcludePath(fullPath)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    }",
          "hash": "6251a466558560f2591e15539c810345"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 110,
          "endLine": 130,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory()) {\r\n            if (!this.shouldExcludePath(entry.name, options)) {\r\n              scanDirectory(fullPath);\r\n            }\r\n          } else if (entry.isFile()) {\r\n            if (this.isDocumentationFile(entry.name) && !this.shouldExcludePath(fullPath, options)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    }",
          "hash": "8d23d5ac062a47b415aa74e51ade80d0"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 139,
          "endLine": 159,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory()) {\r\n            if (!this.shouldExcludePath(entry.name, options)) {\r\n              scanDirectory(fullPath);\r\n            }\r\n          } else if (entry.isFile()) {\r\n            if (this.isCodeFile(entry.name) && !this.shouldExcludePath(fullPath, options)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    }",
          "hash": "41274424f6eb7bb10c71983c334e5ce9"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\duplication-analyzer.ts",
          "startLine": 87,
          "endLine": 108,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (!fs.existsSync(currentDir)) {return;}\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    }",
          "hash": "a0f2e352781a2f98f34b19d3e9c85a00"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\manual-duplication-reviewer.ts",
          "startLine": 83,
          "endLine": 103,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 21,
          "content": "{\r\n      if (!fs.existsSync(currentDir)) {return;}\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    }",
          "hash": "b41ab7b85faf46687f47e0046c4bda2a"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 379,
          "endLine": 400,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (!fs.existsSync(currentDir)) return;\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    }",
          "hash": "32e17252f345a668d67b1cdf9368b04e"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 301,
          "endLine": 322,
          "complexity": 8,
          "dependencies": [],
          "usageCount": 0,
          "size": 22,
          "content": "{\r\n      if (!fs.existsSync(currentDir)) return;\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    }",
          "hash": "32e17252f345a668d67b1cdf9368b04e"
        },
        {
          "type": "function",
          "name": "scanDirectory",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 185,
          "endLine": 208,
          "complexity": 9,
          "dependencies": [],
          "usageCount": 0,
          "size": 24,
          "content": "{\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory() && !this.shouldExcludePath(entry.name, options)) {\r\n            directories.push(fullPath);\r\n            scanDirectory(fullPath);\r\n          } else if (entry.isFile() && !this.shouldExcludePath(fullPath, options)) {\r\n            files.push(fullPath);\r\n            \r\n            if (entry.name === 'package.json') {\r\n              packageFiles.push(fullPath);\r\n            } else if (this.isConfigFile(entry.name)) {\r\n              configFiles.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    }",
          "hash": "0fbe283e85e9a4495076955ba6b87af9"
        },
        {
          "type": "function",
          "name": "openBrackets",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 397,
          "endLine": 406,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unmatched square brackets in line',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Check for missing opening or closing brackets'\r\n            });\r\n          }",
          "hash": "661ca5cd08569869ea3b1caa70db1217"
        },
        {
          "type": "function",
          "name": "closeBrackets",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts",
          "startLine": 398,
          "endLine": 407,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 10,
          "content": "{\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unmatched square brackets in line',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Check for missing opening or closing brackets'\r\n            });\r\n          }",
          "hash": "661ca5cd08569869ea3b1caa70db1217"
        },
        {
          "type": "function",
          "name": "check",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 74,
          "endLine": 132,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 59,
          "content": "{\r\n        id: 'test-execution',\r\n        name: 'Test Execution',\r\n        description: 'Ensure all tests pass after implementation changes',\r\n        severity: 'error',\r\n        check: async () => this.checkTestExecution()\r\n      },\r\n      {\r\n        id: 'lint-compliance',\r\n        name: 'Lint Compliance',\r\n        description: 'Verify code follows linting rules and standards',\r\n        severity: 'warning',\r\n        check: async () => this.checkLintCompliance()\r\n      },\r\n      {\r\n        id: 'import-resolution',\r\n        name: 'Import Resolution',\r\n        description: 'Check that all imports resolve correctly across workspaces',\r\n        severity: 'error',\r\n        check: async () => this.checkImportResolution()\r\n      },\r\n      {\r\n        id: 'documentation-sync',\r\n        name: 'Documentation Synchronization',\r\n        description: 'Ensure documentation is updated and synchronized with code changes',\r\n        severity: 'warning',\r\n        check: async () => this.checkDocumentationSync()\r\n      },\r\n      {\r\n        id: 'security-compliance',\r\n        name: 'Security Compliance',\r\n        description: 'Verify no new security vulnerabilities are introduced',\r\n        severity: 'error',\r\n        check: async () => this.checkSecurityCompliance()\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Check TypeScript compilation across all workspaces\r\n   */\r\n  private async checkTypeScriptCompilation(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔧 Checking TypeScript compilation...');\r\n      \r\n      const workspaces = ['packages/backend', 'packages/frontend', 'packages/shared'];\r\n      const errors: string[] = [];\r\n      \r\n      for (const workspace of workspaces) {\r\n        try {\r\n          const output = execSync(`npm run build --workspace=${workspace}`, {\r\n            stdio: 'pipe',\r\n            encoding: 'utf8',\r\n            cwd: this.projectRoot\r\n          });\r\n        } catch (error: any) {\r\n          errors.push(`${workspace}: ${error.message}`);\r\n        }\r\n      }",
          "hash": "c7aa0fbb064d9773d54e48b869a6cde5"
        },
        {
          "type": "function",
          "name": "check",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 81,
          "endLine": 132,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 52,
          "content": "{\r\n        id: 'lint-compliance',\r\n        name: 'Lint Compliance',\r\n        description: 'Verify code follows linting rules and standards',\r\n        severity: 'warning',\r\n        check: async () => this.checkLintCompliance()\r\n      },\r\n      {\r\n        id: 'import-resolution',\r\n        name: 'Import Resolution',\r\n        description: 'Check that all imports resolve correctly across workspaces',\r\n        severity: 'error',\r\n        check: async () => this.checkImportResolution()\r\n      },\r\n      {\r\n        id: 'documentation-sync',\r\n        name: 'Documentation Synchronization',\r\n        description: 'Ensure documentation is updated and synchronized with code changes',\r\n        severity: 'warning',\r\n        check: async () => this.checkDocumentationSync()\r\n      },\r\n      {\r\n        id: 'security-compliance',\r\n        name: 'Security Compliance',\r\n        description: 'Verify no new security vulnerabilities are introduced',\r\n        severity: 'error',\r\n        check: async () => this.checkSecurityCompliance()\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Check TypeScript compilation across all workspaces\r\n   */\r\n  private async checkTypeScriptCompilation(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔧 Checking TypeScript compilation...');\r\n      \r\n      const workspaces = ['packages/backend', 'packages/frontend', 'packages/shared'];\r\n      const errors: string[] = [];\r\n      \r\n      for (const workspace of workspaces) {\r\n        try {\r\n          const output = execSync(`npm run build --workspace=${workspace}`, {\r\n            stdio: 'pipe',\r\n            encoding: 'utf8',\r\n            cwd: this.projectRoot\r\n          });\r\n        } catch (error: any) {\r\n          errors.push(`${workspace}: ${error.message}`);\r\n        }\r\n      }",
          "hash": "6e991aa85b36682f4f61d8b204b87298"
        },
        {
          "type": "function",
          "name": "check",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 88,
          "endLine": 132,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 45,
          "content": "{\r\n        id: 'import-resolution',\r\n        name: 'Import Resolution',\r\n        description: 'Check that all imports resolve correctly across workspaces',\r\n        severity: 'error',\r\n        check: async () => this.checkImportResolution()\r\n      },\r\n      {\r\n        id: 'documentation-sync',\r\n        name: 'Documentation Synchronization',\r\n        description: 'Ensure documentation is updated and synchronized with code changes',\r\n        severity: 'warning',\r\n        check: async () => this.checkDocumentationSync()\r\n      },\r\n      {\r\n        id: 'security-compliance',\r\n        name: 'Security Compliance',\r\n        description: 'Verify no new security vulnerabilities are introduced',\r\n        severity: 'error',\r\n        check: async () => this.checkSecurityCompliance()\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Check TypeScript compilation across all workspaces\r\n   */\r\n  private async checkTypeScriptCompilation(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔧 Checking TypeScript compilation...');\r\n      \r\n      const workspaces = ['packages/backend', 'packages/frontend', 'packages/shared'];\r\n      const errors: string[] = [];\r\n      \r\n      for (const workspace of workspaces) {\r\n        try {\r\n          const output = execSync(`npm run build --workspace=${workspace}`, {\r\n            stdio: 'pipe',\r\n            encoding: 'utf8',\r\n            cwd: this.projectRoot\r\n          });\r\n        } catch (error: any) {\r\n          errors.push(`${workspace}: ${error.message}`);\r\n        }\r\n      }",
          "hash": "a6b665501c0bc4967a12eaa0efc2c6b1"
        },
        {
          "type": "function",
          "name": "check",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 95,
          "endLine": 132,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 38,
          "content": "{\r\n        id: 'documentation-sync',\r\n        name: 'Documentation Synchronization',\r\n        description: 'Ensure documentation is updated and synchronized with code changes',\r\n        severity: 'warning',\r\n        check: async () => this.checkDocumentationSync()\r\n      },\r\n      {\r\n        id: 'security-compliance',\r\n        name: 'Security Compliance',\r\n        description: 'Verify no new security vulnerabilities are introduced',\r\n        severity: 'error',\r\n        check: async () => this.checkSecurityCompliance()\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Check TypeScript compilation across all workspaces\r\n   */\r\n  private async checkTypeScriptCompilation(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔧 Checking TypeScript compilation...');\r\n      \r\n      const workspaces = ['packages/backend', 'packages/frontend', 'packages/shared'];\r\n      const errors: string[] = [];\r\n      \r\n      for (const workspace of workspaces) {\r\n        try {\r\n          const output = execSync(`npm run build --workspace=${workspace}`, {\r\n            stdio: 'pipe',\r\n            encoding: 'utf8',\r\n            cwd: this.projectRoot\r\n          });\r\n        } catch (error: any) {\r\n          errors.push(`${workspace}: ${error.message}`);\r\n        }\r\n      }",
          "hash": "324a69f737cbd029a5388f282e057920"
        },
        {
          "type": "function",
          "name": "check",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 102,
          "endLine": 132,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 31,
          "content": "{\r\n        id: 'security-compliance',\r\n        name: 'Security Compliance',\r\n        description: 'Verify no new security vulnerabilities are introduced',\r\n        severity: 'error',\r\n        check: async () => this.checkSecurityCompliance()\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Check TypeScript compilation across all workspaces\r\n   */\r\n  private async checkTypeScriptCompilation(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔧 Checking TypeScript compilation...');\r\n      \r\n      const workspaces = ['packages/backend', 'packages/frontend', 'packages/shared'];\r\n      const errors: string[] = [];\r\n      \r\n      for (const workspace of workspaces) {\r\n        try {\r\n          const output = execSync(`npm run build --workspace=${workspace}`, {\r\n            stdio: 'pipe',\r\n            encoding: 'utf8',\r\n            cwd: this.projectRoot\r\n          });\r\n        } catch (error: any) {\r\n          errors.push(`${workspace}: ${error.message}`);\r\n        }\r\n      }",
          "hash": "e57b4bc35bf3fe896a8790de0800215c"
        },
        {
          "type": "function",
          "name": "warningCount",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 230,
          "endLine": 238,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 9,
          "content": "{\r\n        passed: errorCount === 0,\r\n        message: `Linting found ${errorCount} errors and ${warningCount} warnings`,\r\n        details: [errorOutput],\r\n        suggestions: [\r\n          'Run npm run lint:fix to automatically fix some issues',\r\n          'Review and fix remaining linting errors manually'\r\n        ]\r\n      }",
          "hash": "e9053fe195c0256a8bc6f90750ea5fdf"
        },
        {
          "type": "function",
          "name": "errorCount",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts",
          "startLine": 231,
          "endLine": 239,
          "complexity": 1,
          "dependencies": [],
          "usageCount": 0,
          "size": 9,
          "content": "{\r\n        passed: errorCount === 0,\r\n        message: `Linting found ${errorCount} errors and ${warningCount} warnings`,\r\n        details: [errorOutput],\r\n        suggestions: [\r\n          'Run npm run lint:fix to automatically fix some issues',\r\n          'Review and fix remaining linting errors manually'\r\n        ]\r\n      }",
          "hash": "e9053fe195c0256a8bc6f90750ea5fdf"
        },
        {
          "type": "function",
          "name": "applies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 80,
          "endLine": 161,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 82,
          "content": "{\r\n        id: 'camelCase-functions',\r\n        name: 'Function camelCase', \r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Functions should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'function'\r\n      },\r\n      {\r\n        id: 'PascalCase-classes',\r\n        name: 'Class PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Classes should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'class'\r\n      },\r\n      {\r\n        id: 'PascalCase-interfaces',\r\n        name: 'Interface PascalCase',\r\n        pattern: /^I?[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Interfaces should use PascalCase naming (optionally prefixed with I)',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'interface'\r\n      },\r\n      {\r\n        id: 'PascalCase-types',\r\n        name: 'Type PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Type aliases should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'type'\r\n      },\r\n      {\r\n        id: 'UPPER_SNAKE_CASE-enums',\r\n        name: 'Enum UPPER_SNAKE_CASE',\r\n        pattern: /^[A-Z][A-Z0-9_]*$/,\r\n        description: 'Enum values should use UPPER_SNAKE_CASE naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'enum'\r\n      },\r\n      {\r\n        id: 'camelCase-methods',\r\n        name: 'Method camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Methods should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'method'\r\n      },\r\n      {\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }",
          "hash": "960aef7582b84ce727adc98465eacec6"
        },
        {
          "type": "function",
          "name": "applies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 88,
          "endLine": 161,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 74,
          "content": "{\r\n        id: 'PascalCase-classes',\r\n        name: 'Class PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Classes should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'class'\r\n      },\r\n      {\r\n        id: 'PascalCase-interfaces',\r\n        name: 'Interface PascalCase',\r\n        pattern: /^I?[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Interfaces should use PascalCase naming (optionally prefixed with I)',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'interface'\r\n      },\r\n      {\r\n        id: 'PascalCase-types',\r\n        name: 'Type PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Type aliases should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'type'\r\n      },\r\n      {\r\n        id: 'UPPER_SNAKE_CASE-enums',\r\n        name: 'Enum UPPER_SNAKE_CASE',\r\n        pattern: /^[A-Z][A-Z0-9_]*$/,\r\n        description: 'Enum values should use UPPER_SNAKE_CASE naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'enum'\r\n      },\r\n      {\r\n        id: 'camelCase-methods',\r\n        name: 'Method camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Methods should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'method'\r\n      },\r\n      {\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }",
          "hash": "8d783af28754a70d2f90ac381e6cf4e1"
        },
        {
          "type": "function",
          "name": "applies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 96,
          "endLine": 161,
          "complexity": 3,
          "dependencies": [],
          "usageCount": 0,
          "size": 66,
          "content": "{\r\n        id: 'PascalCase-interfaces',\r\n        name: 'Interface PascalCase',\r\n        pattern: /^I?[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Interfaces should use PascalCase naming (optionally prefixed with I)',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'interface'\r\n      },\r\n      {\r\n        id: 'PascalCase-types',\r\n        name: 'Type PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Type aliases should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'type'\r\n      },\r\n      {\r\n        id: 'UPPER_SNAKE_CASE-enums',\r\n        name: 'Enum UPPER_SNAKE_CASE',\r\n        pattern: /^[A-Z][A-Z0-9_]*$/,\r\n        description: 'Enum values should use UPPER_SNAKE_CASE naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'enum'\r\n      },\r\n      {\r\n        id: 'camelCase-methods',\r\n        name: 'Method camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Methods should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'method'\r\n      },\r\n      {\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }",
          "hash": "9e26031179fae4a6b1e43d5fa6dfefd2"
        },
        {
          "type": "function",
          "name": "applies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 104,
          "endLine": 161,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 58,
          "content": "{\r\n        id: 'PascalCase-types',\r\n        name: 'Type PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Type aliases should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'type'\r\n      },\r\n      {\r\n        id: 'UPPER_SNAKE_CASE-enums',\r\n        name: 'Enum UPPER_SNAKE_CASE',\r\n        pattern: /^[A-Z][A-Z0-9_]*$/,\r\n        description: 'Enum values should use UPPER_SNAKE_CASE naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'enum'\r\n      },\r\n      {\r\n        id: 'camelCase-methods',\r\n        name: 'Method camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Methods should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'method'\r\n      },\r\n      {\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }",
          "hash": "1ca75c9dc6a8216843fb5675c205e782"
        },
        {
          "type": "function",
          "name": "applies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 112,
          "endLine": 161,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 50,
          "content": "{\r\n        id: 'UPPER_SNAKE_CASE-enums',\r\n        name: 'Enum UPPER_SNAKE_CASE',\r\n        pattern: /^[A-Z][A-Z0-9_]*$/,\r\n        description: 'Enum values should use UPPER_SNAKE_CASE naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'enum'\r\n      },\r\n      {\r\n        id: 'camelCase-methods',\r\n        name: 'Method camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Methods should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'method'\r\n      },\r\n      {\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }",
          "hash": "f2dfa0ab650650642c82577fe50c357d"
        },
        {
          "type": "function",
          "name": "applies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 120,
          "endLine": 161,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 42,
          "content": "{\r\n        id: 'camelCase-methods',\r\n        name: 'Method camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Methods should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'method'\r\n      },\r\n      {\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }",
          "hash": "12987e2699eaabdf8883bc2f80027c6b"
        },
        {
          "type": "function",
          "name": "applies",
          "filePath": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts",
          "startLine": 128,
          "endLine": 161,
          "complexity": 2,
          "dependencies": [],
          "usageCount": 0,
          "size": 34,
          "content": "{\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }",
          "hash": "af26ec2b785644cdc5edfb4d6c222279"
        }
      ],
      "benefits": {
        "codeReduction": 7036.4,
        "maintainabilityImprovement": 8,
        "performanceGain": 2
      },
      "implementationSteps": [
        "Create centralized utility module",
        "Extract common patterns",
        "Replace duplicated code",
        "Update imports across project"
      ],
      "riskLevel": "low"
    }
  ],
  "performanceInsights": [
    {
      "type": "bottleneck",
      "location": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts:551",
      "description": "Large function \"fx\" with 603 lines may impact performance",
      "currentMetrics": {
        "executionTime": 60.300000000000004
      },
      "optimization": {
        "strategy": "Break down into smaller functions and optimize critical paths",
        "expectedImprovement": "20-40% performance improvement",
        "implementationComplexity": "medium"
      },
      "priority": 10
    },
    {
      "type": "bottleneck",
      "location": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster\\src\\dependency-visualizer.ts:552",
      "description": "Large function \"fy\" with 603 lines may impact performance",
      "currentMetrics": {
        "executionTime": 60.300000000000004
      },
      "optimization": {
        "strategy": "Break down into smaller functions and optimize critical paths",
        "expectedImprovement": "20-40% performance improvement",
        "implementationComplexity": "medium"
      },
      "priority": 10
    },
    {
      "type": "bottleneck",
      "location": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts:551",
      "description": "Large function \"fx\" with 603 lines may impact performance",
      "currentMetrics": {
        "executionTime": 60.300000000000004
      },
      "optimization": {
        "strategy": "Break down into smaller functions and optimize critical paths",
        "expectedImprovement": "20-40% performance improvement",
        "implementationComplexity": "medium"
      },
      "priority": 10
    },
    {
      "type": "bottleneck",
      "location": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.taskmaster.backup.20250705-082510\\src\\dependency-visualizer.ts:552",
      "description": "Large function \"fy\" with 603 lines may impact performance",
      "currentMetrics": {
        "executionTime": 60.300000000000004
      },
      "optimization": {
        "strategy": "Break down into smaller functions and optimize critical paths",
        "expectedImprovement": "20-40% performance improvement",
        "implementationComplexity": "medium"
      },
      "priority": 10
    },
    {
      "type": "bottleneck",
      "location": "E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\performance-monitoring-validation.ts:6",
      "description": "Large function \"validatePerformanceMonitoring\" with 348 lines may impact performance",
      "currentMetrics": {
        "executionTime": 34.800000000000004
      },
      "optimization": {
        "strategy": "Break down into smaller functions and optimize critical paths",
        "expectedImprovement": "20-40% performance improvement",
        "implementationComplexity": "medium"
      },
      "priority": 10
    }
  ],
  "recommendations": {
    "immediate": [
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Break down complex functions into smaller, focused functions",
      "Address performance bottleneck: Large function \"fx\" with 603 lines may impact performance",
      "Address performance bottleneck: Large function \"fy\" with 603 lines may impact performance",
      "Address performance bottleneck: Large function \"fx\" with 603 lines may impact performance",
      "Address performance bottleneck: Large function \"fy\" with 603 lines may impact performance",
      "Address performance bottleneck: Large function \"validatePerformanceMonitoring\" with 348 lines may impact performance"
    ],
    "shortTerm": [
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Extract common function to utility module and replace duplicates",
      "Implement method-centralization: centralizedUtilities"
    ],
    "longTerm": []
  },
  "implementationRoadmap": [
    {
      "phase": "Phase 1: Critical Issues",
      "tasks": [
        "Fix duplicate code patterns",
        "Address high complexity functions",
        "Resolve critical performance bottlenecks"
      ],
      "estimatedEffort": "2-3 weeks",
      "expectedBenefits": [
        "Improved code maintainability",
        "Reduced technical debt",
        "Better performance"
      ]
    },
    {
      "phase": "Phase 2: Code Consolidation",
      "tasks": [
        "Implement utility extraction opportunities",
        "Centralize common methods",
        "Standardize interfaces"
      ],
      "estimatedEffort": "3-4 weeks",
      "expectedBenefits": [
        "Reduced code duplication",
        "Improved developer productivity",
        "Better code organization"
      ]
    },
    {
      "phase": "Phase 3: Long-term Optimization",
      "tasks": [
        "Monitor performance metrics",
        "Implement advanced optimizations",
        "Continuous architectural improvements"
      ],
      "estimatedEffort": "Ongoing",
      "expectedBenefits": [
        "Sustained performance",
        "Scalable architecture",
        "Future-proof codebase"
      ]
    }
  ]
}