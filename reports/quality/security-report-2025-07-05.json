[{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.eslintrc.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\.eslintrc.security.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\jest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\jest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\fixed-sma-backtest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\backtest\\sma-backtest.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":72,"column":22,"nodeType":"MemberExpression","endLine":72,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SMA Strategy Backtest\r\n * \r\n * This script runs a backtest of the SMA signal processor against synthetic price data\r\n * to validate its performance and signal generation.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport { generateSyntheticCandles, type Candle } from '../../../shared/src/test-utils/data-generators';\r\nimport type { SMASignalConfig } from '../../src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalProcessor } from '../../src/JabbrLabs/signals/sma/sma-signal-processor';\r\n\r\n// Configuration\r\nconst config: SMASignalConfig = {\r\n  fastPeriod: 9,\r\n  slowPeriod: 21,\r\n  minChangePercent: 0.5,\r\n  confidenceThreshold: 0.4,\r\n  priceSource: 'close',\r\n  signalMode: 'crossover',\r\n  useEMA: false\r\n};\r\n\r\n// Main function to run the backtest\r\nasync function runBacktest() {\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}\r\n\r\n// Run the backtest\r\nrunBacktest().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\compare-sma-processors.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":92,"column":22,"nodeType":"MemberExpression","endLine":92,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Compare original and improved SMA signal processors\r\n * \r\n * This script runs both the original and improved SMA signal processors\r\n * on the same data and compares their signal generation.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport { ImprovedSMASignalProcessor } from '../../src/JabbrLabs/signals/sma/improved-sma-signal-processor';\r\nimport type { SMASignalConfig} from '../../src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalOutput } from '../../src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalProcessor } from '../../src/JabbrLabs/signals/sma/sma-signal-processor';\r\nimport type { Candle } from '../../src/JabbrLabs/target-reacher/interfaces';\r\n\r\n// Configuration\r\nconst config: SMASignalConfig = {\r\n  fastPeriod: 9,\r\n  slowPeriod: 21,\r\n  minChangePercent: 0.5,\r\n  confidenceThreshold: 0.4, // Lowered threshold for comparison\r\n  priceSource: 'close',\r\n  signalMode: 'crossover',\r\n  useEMA: false\r\n};\r\n\r\n// Generate synthetic price data for testing\r\nfunction generateSyntheticCandles(options: {\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}): Candle[] {\r\n  const candles: Candle[] = [];\r\n  let currentPrice = options.startPrice;\r\n  let trend = 1; // 1 = up, -1 = down\r\n\r\n  for (let i = 0; i < options.dataPoints; i++) {\r\n    // Potentially change trend\r\n    if (Math.random() < options.trendChangeProbability) {\r\n      trend *= -1;\r\n    }\r\n    \r\n    // Calculate price movement\r\n    const trendMovement = trend * options.trendStrength * currentPrice;\r\n    const randomMovement = (Math.random() * 2 - 1) * options.volatility * currentPrice;\r\n    const movement = trendMovement + randomMovement;\r\n    \r\n    // Calculate candle prices\r\n    const open = currentPrice;\r\n    const close = currentPrice + movement;\r\n    const high = Math.max(open, close) + Math.random() * options.volatility * currentPrice;\r\n    const low = Math.min(open, close) - Math.random() * options.volatility * currentPrice;\r\n    const volume = Math.random() * 100000 + 10000;\r\n    \r\n    // Create candle\r\n    candles.push({\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n    \r\n    // Update current price for next iteration\r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n}\r\n\r\n// Process signals and execute trades\r\nfunction processAndTrade(processor: SMASignalProcessor | ImprovedSMASignalProcessor, candles: Candle[]) {\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}\r\n\r\n// Main test function\r\nasync function runComparisonTest() {\r\n  console.log('Starting SMA Signal Processor Comparison Test');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 200,\r\n    volatility: 0.01,\r\n    trendStrength: 0.005,\r\n    trendChangeProbability: 0.05\r\n  });\r\n  \r\n  // Create processors\r\n  const originalProcessor = new SMASignalProcessor(config);\r\n  const improvedProcessor = new ImprovedSMASignalProcessor(config);\r\n  \r\n  // Process with both implementations\r\n  console.log('\\nRunning Original SMA Signal Processor...');\r\n  const originalResults = processAndTrade(originalProcessor, candles);\r\n  \r\n  console.log('\\nRunning Improved SMA Signal Processor...');\r\n  const improvedResults = processAndTrade(improvedProcessor, candles);\r\n  \r\n  // Log comparison results\r\n  console.log('\\n===== COMPARISON RESULTS =====');\r\n  console.log(`Original: ${originalResults.signals.length} signals, ${originalResults.trades.length} trades, P&L: ${originalResults.pnl.toFixed(2)}`);\r\n  console.log(`Improved: ${improvedResults.signals.length} signals, ${improvedResults.trades.length} trades, P&L: ${improvedResults.pnl.toFixed(2)}`);\r\n  \r\n  // Generate comparison report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      original: {\r\n        signalCount: originalResults.signals.length,\r\n        tradeCount: originalResults.trades.length,\r\n        pnl: originalResults.pnl\r\n      },\r\n      improved: {\r\n        signalCount: improvedResults.signals.length,\r\n        tradeCount: improvedResults.trades.length,\r\n        pnl: improvedResults.pnl\r\n      },\r\n      comparison: {\r\n        signalDifference: improvedResults.signals.length - originalResults.signals.length,\r\n        pnlDifference: improvedResults.pnl - originalResults.pnl\r\n      }\r\n    },\r\n    details: {\r\n      original: {\r\n        signals: originalResults.signals,\r\n        trades: originalResults.trades\r\n      },\r\n      improved: {\r\n        signals: improvedResults.signals,\r\n        trades: improvedResults.trades\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-comparison-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Comparison report saved to sma-comparison-report.json');\r\n}\r\n\r\nrunComparisonTest().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\debug-sma-signals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\debug\\simple-sma-debug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\performance\\performance-analyzer.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":110,"column":22,"nodeType":"MemberExpression","endLine":110,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":125,"column":71,"nodeType":"MemberExpression","endLine":125,"endColumn":80}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\n/**\r\n * Performance Analysis Script\r\n * \r\n * Runs comprehensive performance tests and analysis on the trading bot platform\r\n */\r\n\r\nimport * as path from 'path';\r\nimport * as fs from 'fs/promises';\r\nimport { performanceProfiler } from '../../src/utils/performance-profiler';\r\nimport SystemMonitorService from '../../src/services/system-monitor.service';\r\n\r\n// Import key components for testing\r\nimport { IndicatorService } from '../../src/services/indicator.service';\r\n\r\ninterface PerformanceTestSuite {\r\n  name: string;\r\n  description: string;\r\n  tests: PerformanceTest[];\r\n}\r\n\r\ninterface PerformanceTest {\r\n  name: string;\r\n  category: 'api' | 'database' | 'strategy' | 'websocket' | 'calculation' | 'other';\r\n  testFunction: () => Promise<any>;\r\n  iterations?: number;\r\n  warmupIterations?: number;\r\n}\r\n\r\nclass PerformanceAnalyzer {\r\n  private systemMonitor: SystemMonitorService;\r\n  private testResults: any[] = [];\r\n\r\n  constructor() {\r\n    this.systemMonitor = new SystemMonitorService({\r\n      collectInterval: 1000, // 1 second for detailed monitoring\r\n      enableAlerts: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Run all performance tests\r\n   */\r\n  async runAnalysis(): Promise<void> {\r\n    console.log('🚀 Starting Performance Analysis...\\n');\r\n    \r\n    // Start system monitoring\r\n    this.systemMonitor.start();\r\n    \r\n    try {\r\n      // Define test suites\r\n      const testSuites: PerformanceTestSuite[] = [\r\n        this.createCalculationTests(),\r\n        this.createIndicatorTests(),\r\n        this.createSignalProcessingTests(),\r\n        this.createMemoryTests()\r\n      ];\r\n\r\n      // Run each test suite\r\n      for (const suite of testSuites) {\r\n        await this.runTestSuite(suite);\r\n      }\r\n\r\n      // Generate comprehensive report\r\n      await this.generateReport();\r\n\r\n    } finally {\r\n      this.systemMonitor.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create calculation performance tests\r\n   */\r\n  private createCalculationTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Mathematical Calculations',\r\n      description: 'Tests performance of mathematical operations used in trading algorithms',\r\n      tests: [\r\n        {\r\n          name: 'Simple Moving Average Calculation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            \r\n            // Calculate SMA\r\n            const sma: number[] = [];\r\n            for (let i = period - 1; i < data.length; i++) {\r\n              const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\r\n              sma.push(sum / period);\r\n            }\r\n            \r\n            return sma.length;\r\n          },\r\n          iterations: 1000\r\n        },\r\n        {\r\n          name: 'Exponential Moving Average Calculation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            const multiplier = 2 / (period + 1);\r\n            \r\n            // Calculate EMA\r\n            let ema = data[0];\r\n            for (let i = 1; i < data.length; i++) {\r\n              ema = (data[i] * multiplier) + (ema * (1 - multiplier));\r\n            }\r\n            \r\n            return ema;\r\n          },\r\n          iterations: 1000\r\n        },\r\n        {\r\n          name: 'RSI Calculation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const prices = Array.from({ length: 100 }, () => 100 + Math.random() * 50);\r\n            const period = 14;\r\n            \r\n            // Calculate price changes\r\n            const changes = prices.slice(1).map((price, i) => price - prices[i]);\r\n            \r\n            // Separate gains and losses\r\n            const gains = changes.map(change => change > 0 ? change : 0);\r\n            const losses = changes.map(change => change < 0 ? -change : 0);\r\n            \r\n            // Calculate average gain and loss\r\n            const avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;\r\n            const avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;\r\n            \r\n            // Calculate RS and RSI\r\n            const rs = avgGain / avgLoss;\r\n            const rsi = 100 - (100 / (1 + rs));\r\n            \r\n            return rsi;\r\n          },\r\n          iterations: 500\r\n        },\r\n        {\r\n          name: 'Large Array Processing',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const size = 100000;\r\n            const data = Array.from({ length: size }, (_, i) => Math.random() * 100);\r\n            \r\n            // Perform multiple operations\r\n            const filtered = data.filter(x => x > 50);\r\n            const mapped = filtered.map(x => x * 2);\r\n            const reduced = mapped.reduce((sum, x) => sum + x, 0);\r\n            \r\n            return reduced;\r\n          },\r\n          iterations: 100\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create indicator service tests\r\n   */\r\n  private createIndicatorTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Indicator Service Performance',\r\n      description: 'Tests performance of the indicator calculation service',\r\n      tests: [\r\n        {\r\n          name: 'Multiple Indicator Calculations',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const indicatorService = new IndicatorService();\r\n            const prices = Array.from({ length: 200 }, () => ({\r\n              timestamp: Date.now(),\r\n              open: 100 + Math.random() * 10,\r\n              high: 105 + Math.random() * 10,\r\n              low: 95 + Math.random() * 10,\r\n              close: 100 + Math.random() * 10,\r\n              volume: 1000 + Math.random() * 500\r\n            }));\r\n\r\n            // Calculate multiple indicators\r\n            const sma20 = indicatorService.calculateSMA(prices.map(p => p.close), 20);\r\n            const sma50 = indicatorService.calculateSMA(prices.map(p => p.close), 50);\r\n            const ema12 = indicatorService.calculateEMA(prices.map(p => p.close), 12);\r\n            const rsi = indicatorService.calculateRSI(prices.map(p => p.close), 14);\r\n\r\n            return { sma20: sma20.length, sma50: sma50.length, ema12: ema12.length, rsi: rsi.length };\r\n          },\r\n          iterations: 200\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create signal processing tests\r\n   */\r\n  private createSignalProcessingTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Signal Processing Performance',\r\n      description: 'Tests performance of signal processing algorithms',\r\n      tests: [\r\n        {\r\n          name: 'SMA Signal Generation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const prices = Array.from({ length: 500 }, () => Math.random() * 100);\r\n            const signals = [];\r\n            \r\n            for (let i = 20; i < prices.length; i++) {\r\n              const sma20 = prices.slice(i - 20, i).reduce((a, b) => a + b) / 20;\r\n              const sma50 = i >= 50 ? prices.slice(i - 50, i).reduce((a, b) => a + b) / 50 : 0;\r\n              \r\n              if (sma20 > sma50) {\r\n                signals.push('BUY');\r\n              } else if (sma20 < sma50) {\r\n                signals.push('SELL');\r\n              }\r\n            }\r\n            \r\n            return signals.length;\r\n          },\r\n          iterations: 100\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create memory usage tests\r\n   */\r\n  private createMemoryTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Memory Usage Tests',\r\n      description: 'Tests memory usage and garbage collection performance',\r\n      tests: [\r\n        {\r\n          name: 'Large Array Processing',\r\n          category: 'other',\r\n          testFunction: async () => {\r\n            const initialMemory = process.memoryUsage();\r\n            const data = Array.from({ length: 100000 }, () => Math.random());\r\n            const processed = data.map(x => x * 2).filter(x => x > 1);\r\n            const finalMemory = process.memoryUsage();\r\n            \r\n            return {\r\n              processed: processed.length,\r\n              memoryDelta: finalMemory.heapUsed - initialMemory.heapUsed\r\n            };\r\n          },\r\n          iterations: 10\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Run a test suite\r\n   */\r\n  private async runTestSuite(suite: PerformanceTestSuite): Promise<void> {\r\n    console.log(`\\n📊 Running ${suite.name}`);\r\n    console.log(`   ${suite.description}\\n`);\r\n\r\n    for (const test of suite.tests) {\r\n      await this.runTest(test);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run an individual test\r\n   */\r\n  private async runTest(test: PerformanceTest): Promise<void> {\r\n    const iterations = test.iterations || 100;\r\n    const warmupIterations = test.warmupIterations || 10;\r\n    \r\n    console.log(`   🧪 ${test.name}`);\r\n    \r\n    // Warmup\r\n    for (let i = 0; i < warmupIterations; i++) {\r\n      await test.testFunction();\r\n    }\r\n    \r\n    // Actual test\r\n    const startTime = performanceProfiler.now();\r\n    const results = [];\r\n    \r\n    for (let i = 0; i < iterations; i++) {\r\n      const testStart = performanceProfiler.now();\r\n      const result = await test.testFunction();\r\n      const testEnd = performanceProfiler.now();\r\n      \r\n      results.push({\r\n        duration: testEnd - testStart,\r\n        result\r\n      });\r\n    }\r\n    \r\n    const endTime = performanceProfiler.now();\r\n    const totalDuration = endTime - startTime;\r\n    const avgDuration = totalDuration / iterations;\r\n    \r\n    this.testResults.push({\r\n      suiteName: test.category,\r\n      testName: test.name,\r\n      iterations,\r\n      totalDuration,\r\n      avgDuration,\r\n      minDuration: Math.min(...results.map(r => r.duration)),\r\n      maxDuration: Math.max(...results.map(r => r.duration)),\r\n      results\r\n    });\r\n    \r\n    console.log(`      ⏱️  Average: ${avgDuration.toFixed(2)}ms`);\r\n    console.log(`      📈 Total: ${totalDuration.toFixed(2)}ms`);\r\n  }\r\n\r\n  /**\r\n   * Generate comprehensive report\r\n   */\r\n  private async generateReport(): Promise<void> {\r\n    console.log('\\n📊 Generating Performance Report...\\n');\r\n    \r\n    const report = {\r\n      timestamp: new Date().toISOString(),\r\n      systemInfo: {\r\n        nodeVersion: process.version,\r\n        platform: process.platform,\r\n        arch: process.arch,\r\n        cpus: require('os').cpus().length,\r\n        memory: process.memoryUsage()\r\n      },\r\n      testResults: this.testResults,\r\n      summary: this.generateSummary()\r\n    };\r\n    \r\n    // Save report\r\n    const reportPath = path.join(__dirname, '../../reports/performance-report.json');\r\n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\r\n    \r\n    console.log(`📋 Performance report saved to: ${reportPath}`);\r\n    console.log('\\n📊 Performance Summary:');\r\n    console.log(this.generateSummary());\r\n  }\r\n\r\n  /**\r\n   * Generate performance summary\r\n   */\r\n  private generateSummary(): any {\r\n    const categories = {};\r\n    \r\n    for (const result of this.testResults) {\r\n      if (!categories[result.suiteName]) {\r\n        categories[result.suiteName] = {\r\n          testCount: 0,\r\n          totalAvgDuration: 0,\r\n          tests: []\r\n        };\r\n      }\r\n      \r\n      categories[result.suiteName].testCount++;\r\n      categories[result.suiteName].totalAvgDuration += result.avgDuration;\r\n      categories[result.suiteName].tests.push({\r\n        name: result.testName,\r\n        avgDuration: result.avgDuration,\r\n        iterations: result.iterations\r\n      });\r\n    }\r\n    \r\n    return categories;\r\n  }\r\n}\r\n\r\n// Run analysis if called directly\r\nif (require.main === module) {\r\n  const analyzer = new PerformanceAnalyzer();\r\n  analyzer.runAnalysis().catch(console.error);\r\n}\r\n\r\nexport default PerformanceAnalyzer;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\test-bybit-formats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\test-db-connection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\test-real-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\scripts\\test-real-websocket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\bot-cycle\\bot-cycle-stable.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\bot-cycle\\exchange-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\bot-cycle\\stable-bot-cycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\bot-cycle\\unified-trading-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":118,"column":3,"endLine":118,"endColumn":64,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":139,"column":3,"endLine":139,"endColumn":64,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":152,"column":3,"endLine":152,"endColumn":64,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Unified Trading Engine (JabbrLabs Implementation)\r\n * \r\n * This module provides the JabbrLabs-specific trading engine implementation.\r\n * It extends the core trading engine with advanced features and strategies.\r\n */\r\n\r\n// Re-export the core trading engine for compatibility\r\n// export { UnifiedTradingEngine } from '../../core/unified-trading-engine'\r\n\r\n// JabbrLabs enhancements interface\r\nexport interface JabbrLabsTradingEngine {\r\n  // Advanced signal processing\r\n  processAdvancedSignals: (signals: any[]) => Promise<any[]>\r\n  \r\n  // Enhanced risk management\r\n  applyAdvancedRiskRules: (position: any) => Promise<{ approved: boolean; reason?: string }>\r\n  \r\n  // Custom order routing\r\n  routeCustomOrders: (order: any) => Promise<{ route: string; modifications?: any }>\r\n}\r\n\r\n/**\r\n * JabbrLabs Enhanced Trading Engine\r\n * Provides advanced trading implementations for specialized strategies\r\n */\r\nexport class EnhancedTradingEngine implements JabbrLabsTradingEngine {\r\n  \r\n  /**\r\n   * Process advanced signals with JabbrLabs proprietary algorithms\r\n   */\r\n  async processAdvancedSignals(signals: any[] = []): Promise<any[]> {\r\n    // logger.info('🔬 [JabbrLabs] Processing advanced signals', LogCategory.SIGNAL, { \r\n    //   signalCount: signals.length \r\n    // });\r\n    \r\n    // Apply advanced signal filtering and enhancement\r\n    // logger.info('✅ [JabbrLabs] Advanced signal processing complete', LogCategory.SIGNAL, { \r\n    //   enhanced: enhancedSignals.length \r\n    // });\r\n    \r\n    return signals.map(signal => ({\r\n      ...signal,\r\n      // Add JabbrLabs signal enhancements\r\n      jabbrLabsScore: this.calculateJabbrLabsScore(signal),\r\n      enhancedConfidence: this.enhanceConfidence(signal),\r\n      processed: true,\r\n      processedAt: Date.now()\r\n    }));\r\n  }\r\n  \r\n  /**\r\n   * Apply enhanced risk management rules\r\n   */\r\n  async applyAdvancedRiskRules(position: any): Promise<{ approved: boolean; reason?: string }> {\r\n    // logger.info('🛡️ [JabbrLabs] Applying advanced risk rules', LogCategory.RISK, {\r\n    //   positionId: position?.id \r\n    // });\r\n    \r\n    // JabbrLabs advanced risk checks\r\n    const riskChecks = [\r\n      this.checkPositionSize(position),\r\n      this.checkMarketConditions(position),\r\n      this.checkVolatilityLimits(position)\r\n    ];\r\n    \r\n    const failedChecks = riskChecks.filter(check => !check.passed);\r\n    \r\n    if (failedChecks.length > 0) {\r\n      const reason = failedChecks.map(check => check.reason).join(', ');\r\n      // logger.warn('⚠️ [JabbrLabs] Risk rules failed', LogCategory.RISK, { reason });\r\n      return { approved: false, reason };\r\n    }\r\n    \r\n    // logger.info('✅ [JabbrLabs] Risk rules passed', LogCategory.RISK);\r\n    return { approved: true };\r\n  }\r\n  \r\n  /**\r\n   * Route orders through custom JabbrLabs logic\r\n   */\r\n  async routeCustomOrders(order: any): Promise<{ route: string; modifications?: any }> {\r\n    // logger.info('🚀 [JabbrLabs] Routing custom order', LogCategory.ORDER, { \r\n    //   orderId: order?.id,\r\n    //   type: order?.type \r\n    // });\r\n    \r\n    // Determine optimal routing based on order characteristics\r\n    const route = this.determineOptimalRoute(order);\r\n    const modifications = this.applyOrderOptimizations(order);\r\n    \r\n    // logger.info('✅ [JabbrLabs] Order routing complete', LogCategory.ORDER, { \r\n    //   route,\r\n    //   hasModifications: !!modifications \r\n    // });\r\n    \r\n    return { route, modifications };\r\n  }\r\n  \r\n  // Helper methods\r\n  private calculateJabbrLabsScore(signal: any): number {\r\n    // Proprietary JabbrLabs scoring algorithm\r\n    const baseScore = signal.confidence ?? 0.5;\r\n    const volatilityBonus = (signal.marketData?.volatility ?? 0) * 0.1;\r\n    const volumeBonus = Math.min((signal.marketData?.volume ?? 0) / 1000000, 0.2);\r\n    \r\n    return Math.min(1, baseScore + volatilityBonus + volumeBonus);\r\n  }\r\n  \r\n  private enhanceConfidence(signal: any): number {\r\n    // Enhanced confidence calculation\r\n    const baseConfidence = signal.confidence ?? 0.5;\r\n    const marketStrength = signal.marketData?.orderBookImbalance ?? 0.5;\r\n    \r\n    return (baseConfidence + marketStrength) / 2;\r\n  }\r\n  \r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  private checkPositionSize(_position: any): { passed: boolean; reason?: string } {\r\n    const maxPositionSize = 10000; // Example limit\r\n    const size = Math.abs(_position?.size ?? 0);\r\n    if (size > maxPositionSize) {\r\n      return { passed: false, reason: `Position size ${size} exceeds limit ${maxPositionSize}` };\r\n    }\r\n    return { passed: true };\r\n  }\r\n  \r\n  private checkMarketConditions(_position: any): { passed: boolean; reason?: string } {\r\n    // Check if market conditions are suitable for trading\r\n    const volatility = _position?.marketData?.volatility ?? 0;\r\n    \r\n    if (volatility > 0.1) { // 10% volatility limit\r\n      return { passed: false, reason: `Market volatility ${volatility} too high` };\r\n    }\r\n    \r\n    return { passed: true };\r\n  }\r\n  \r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  private checkVolatilityLimits(_position: any): { passed: boolean; reason?: string } {\r\n    // intentionally unused\r\n    return { passed: true };\r\n  }\r\n  \r\n  private determineOptimalRoute(_order: any): string {\r\n    // Determine best execution route\r\n    if (_order?.type === 'market') {return 'fast-execution';}\r\n    if (_order?.type === 'limit') {return 'optimal-fill';}\r\n    return 'standard';\r\n  }\r\n  \r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  private applyOrderOptimizations(_order: any): any {\r\n    return null;\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\bot-trading-cycle-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\atr.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\average-price.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":41,"column":19,"nodeType":"MemberExpression","endLine":41,"endColumn":36}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Average Price Indicator\r\n *\r\n * Provides a function to calculate the average (mean) price from an array of candle data.\r\n *\r\n * Usage:\r\n *   import { calculateAveragePrice } from './average-price'\r\n *\r\n *   const avg = calculateAveragePrice(candles)\r\n */\r\n\r\n// NOTE: This file is self-contained and does NOT import itself. There is no real circular dependency here. If flagged, this is a tool limitation, not a code issue.\r\n\r\nexport interface Candle {\r\n  open: number\r\n  high: number\r\n  low: number\r\n  close: number\r\n  volume?: number\r\n  timestamp?: number\r\n}\r\n\r\n/**\r\n * Calculate the average (mean) price from an array of candles.\r\n * Uses the average of the low prices by default, but can be extended.\r\n *\r\n * @param candles Array of candle objects\r\n * @param priceType 'low' | 'close' | 'high' | 'open' (default: 'low')\r\n * @returns Average price\r\n */\r\nexport function calculateAveragePrice(\r\n  candles: Candle[],\r\n  priceType: 'low' | 'close' | 'high' | 'open' = 'low'\r\n): number {\r\n  if (!candles.length) {throw new Error('No candle data provided')}\r\n  const sum = candles.reduce((acc, candle) => {\r\n    const validPriceTypes = ['low', 'close', 'high', 'open'] as const;\r\n    if (!validPriceTypes.includes(priceType)) {\r\n      throw new Error(`Invalid price type: ${priceType}`);\r\n    }\r\n    return acc + (candle[priceType] ?? 0);\r\n  }, 0);\r\n  return sum / candles.length\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\bollinger-bands-indicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\bollinger-bands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\ema-indicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\indicator-interface.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":143,"column":42,"nodeType":"MemberExpression","endLine":143,"endColumn":61}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Unified Indicator Interface\r\n * \r\n * Provides a standard interface for technical indicators to ensure\r\n * consistent usage across the platform.\r\n */\r\n\r\nimport type { Candle } from '../target-reacher/interfaces';\r\n\r\n/**\r\n * Indicator metadata for documentation and validation\r\n */\r\nexport interface IndicatorMetadata {\r\n  name: string;\r\n  description: string;\r\n  category: 'trend' | 'momentum' | 'volatility' | 'volume' | 'overlay' | 'oscillator';\r\n  parameters: Array<{\r\n    name: string;\r\n    type: 'number' | 'boolean' | 'string';\r\n    description: string;\r\n    default: any;\r\n    min?: number;\r\n    max?: number;\r\n    required?: boolean;\r\n  }>;\r\n  outputs: Array<{\r\n    name: string;\r\n    type: 'number' | 'array';\r\n    description: string;\r\n  }>;\r\n  minimumDataPoints: number;\r\n  version: string;\r\n}\r\n\r\n/**\r\n * Indicator calculation result with metadata\r\n */\r\nexport interface IndicatorResult<T = number | number[]> {\r\n  value: T;\r\n  metadata?: {\r\n    timestamp?: number;\r\n    confidence?: number;\r\n    parameters?: Record<string, unknown>;\r\n    dataPoints?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Base interface for all indicators\r\n */\r\nexport interface IIndicator<T = number | number[]> {\r\n  /**\r\n   * Get indicator metadata\r\n   */\r\n  getMetadata(): IndicatorMetadata;\r\n  \r\n  /**\r\n   * Calculate indicator value(s) from price data\r\n   * \r\n   * @param data Input price data\r\n   * @returns Indicator value(s) or result with metadata\r\n   */\r\n  calculate(data: number[]): T;\r\n  \r\n  /**\r\n   * Calculate indicator value(s) from candle data\r\n   * \r\n   * @param candles Input candle data\r\n   * @param priceSource Which price to use from candles\r\n   * @returns Indicator value(s) or result with metadata\r\n   */\r\n  calculateFromCandles(candles: Candle[], priceSource?: 'open' | 'high' | 'low' | 'close'): T;\r\n  \r\n  /**\r\n   * Calculate with detailed result including metadata\r\n   * \r\n   * @param data Input price data\r\n   * @returns Detailed result with metadata\r\n   */\r\n  calculateWithMetadata(data: number[]): IndicatorResult<T>;\r\n  \r\n  /**\r\n   * Validate input parameters\r\n   * \r\n   * @param parameters Parameters to validate\r\n   * @returns Validation result\r\n   */\r\n  validateParameters(parameters: Record<string, unknown>): { valid: boolean; errors: string[] };\r\n  \r\n  /**\r\n   * Get indicator name\r\n   */\r\n  getName(): string;\r\n  \r\n  /**\r\n   * Get indicator parameters\r\n   */\r\n  getParameters(): Record<string, unknown>;\r\n  \r\n  /**\r\n   * Update indicator parameters\r\n   * \r\n   * @param parameters New parameters to update\r\n   */\r\n  updateParameters(parameters: Record<string, unknown>): void;\r\n  \r\n  /**\r\n   * Reset indicator state (for stateful indicators)\r\n   */\r\n  reset(): void;\r\n  \r\n  /**\r\n   * Clone the indicator with same parameters\r\n   */\r\n  clone(): IIndicator<T>;\r\n}\r\n\r\n/**\r\n * Base abstract class for indicators\r\n */\r\nexport abstract class BaseIndicator<T = number | number[]> implements IIndicator<T> {\r\n  protected name: string;\r\n  protected parameters: Record<string, unknown>;\r\n  protected metadata: IndicatorMetadata;\r\n  \r\n  constructor(metadata: IndicatorMetadata, parameters: Record<string, unknown> = {}) {\r\n    this.metadata = metadata;\r\n    this.name = metadata.name;\r\n    this.parameters = this.setDefaultParameters(parameters);\r\n  }\r\n  \r\n  abstract calculate(data: number[]): T;\r\n  \r\n  getMetadata(): IndicatorMetadata {\r\n    return { ...this.metadata };\r\n  }\r\n  \r\n  calculateFromCandles(candles: Candle[], priceSource: 'open' | 'high' | 'low' | 'close' = 'close'): T {\r\n    const validPriceSources = ['open', 'high', 'low', 'close'] as const;\r\n    if (!validPriceSources.includes(priceSource)) {\r\n      throw new Error(`Invalid price source: ${priceSource}`);\r\n    }\r\n    const prices = candles.map(candle => candle[priceSource]);\r\n    return this.calculate(prices);\r\n  }\r\n  \r\n  calculateWithMetadata(data: number[]): IndicatorResult<T> {\r\n    const value = this.calculate(data);\r\n    // Check for NaN/Infinity in result (supports number or array)\r\n    const checkFinite = (v: any) => {\r\n      if (typeof v === 'number') {return isFinite(v) && !isNaN(v);}\r\n      if (Array.isArray(v)) {return v.every(x => typeof x === 'number' && isFinite(x) && !isNaN(x));}\r\n      return false;\r\n    };\r\n    if (!checkFinite(value)) {\r\n      throw new Error(`Indicator ${this.name} calculation returned non-finite value(s). Check input data and parameters.`);\r\n    }\r\n    return {\r\n      value,\r\n      metadata: {\r\n        timestamp: Date.now(),\r\n        parameters: this.getParameters(),\r\n        dataPoints: data.length\r\n      }\r\n    };\r\n  }\r\n  \r\n  validateParameters(parameters: Record<string, unknown>): { valid: boolean; errors: string[] } {\r\n    const errors: string[] = [];\r\n    \r\n    for (const paramDef of this.metadata.parameters) {\r\n      const value = parameters[paramDef.name];\r\n      \r\n      // Check required parameters\r\n      if (paramDef.required && (value === undefined || value === null)) {\r\n        errors.push(`Parameter '${paramDef.name}' is required`);\r\n        continue;\r\n      }\r\n      \r\n      if (value !== undefined && value !== null) {\r\n        // Type validation\r\n        if (paramDef.type === 'number' && typeof value !== 'number') {\r\n          errors.push(`Parameter '${paramDef.name}' must be a number`);\r\n          continue;\r\n        }\r\n        \r\n        if (paramDef.type === 'boolean' && typeof value !== 'boolean') {\r\n          errors.push(`Parameter '${paramDef.name}' must be a boolean`);\r\n          continue;\r\n        }\r\n        \r\n        if (paramDef.type === 'string' && typeof value !== 'string') {\r\n          errors.push(`Parameter '${paramDef.name}' must be a string`);\r\n          continue;\r\n        }\r\n        \r\n        // Range validation for numbers\r\n        if (paramDef.type === 'number' && typeof value === 'number') {\r\n          if (paramDef.min !== undefined && value < paramDef.min) {\r\n            errors.push(`Parameter '${paramDef.name}' must be at least ${paramDef.min}`);\r\n          }\r\n          \r\n          if (paramDef.max !== undefined && value > paramDef.max) {\r\n            errors.push(`Parameter '${paramDef.name}' must be at most ${paramDef.max}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return { valid: errors.length === 0, errors };\r\n  }\r\n  \r\n  getName(): string {\r\n    return this.name;\r\n  }\r\n  \r\n  getParameters(): Record<string, unknown> {\r\n    return { ...this.parameters };\r\n  }\r\n  \r\n  updateParameters(parameters: Record<string, unknown>): void {\r\n    const validation = this.validateParameters(parameters);\r\n    if (!validation.valid) {\r\n      throw new Error(`Invalid parameters: ${validation.errors.join(', ')}`);\r\n    }\r\n    \r\n    this.parameters = { ...this.parameters, ...parameters };\r\n  }\r\n  \r\n  reset(): void {\r\n    // Default implementation - override in stateful indicators\r\n  }\r\n  \r\n  abstract clone(): IIndicator<T>;\r\n  \r\n  /**\r\n   * Set default parameters from metadata\r\n   */\r\n  private setDefaultParameters(parameters: Record<string, unknown>): Record<string, unknown> {\r\n    const result = { ...parameters };\r\n    \r\n    for (const paramDef of this.metadata.parameters) {\r\n      if (result[paramDef.name] === undefined) {\r\n        result[paramDef.name] = paramDef.default;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Validate that enough data points are available\r\n   * \r\n   * @param data Input data array\r\n   * @param minLength Minimum required length (optional, uses metadata if not provided)\r\n   */\r\n  protected validateDataLength(data: number[], minLength?: number): void {\r\n    const requiredLength = minLength || this.metadata.minimumDataPoints;\r\n    if (data.length < requiredLength) {\r\n      throw new Error(`Insufficient data for ${this.name} calculation. Need at least ${requiredLength} data points, got ${data.length}.`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get numeric parameter value with validation\r\n   * \r\n   * @param key Parameter key\r\n   * @param defaultValue Default value if parameter is not set\r\n   * @returns Parameter value\r\n   */\r\n  protected getNumericParameter(key: string, defaultValue: number): number {\r\n    if (typeof key !== 'string' || !key) {\r\n      throw new Error('Parameter key must be a non-empty string');\r\n    }\r\n    const value = Object.prototype.hasOwnProperty.call(this.parameters, key) ? this.parameters[key as keyof typeof this.parameters] : undefined;\r\n    if (value === undefined) {\r\n      return defaultValue;\r\n    }\r\n    \r\n    const numValue = Number(value);\r\n    if (isNaN(numValue)) {\r\n      throw new Error(`Invalid parameter value for ${key}: ${value} is not a number`);\r\n    }\r\n    \r\n    return numValue;\r\n  }\r\n  \r\n  /**\r\n   * Get boolean parameter value with validation\r\n   * \r\n   * @param key Parameter key\r\n   * @param defaultValue Default value if parameter is not set\r\n   * @returns Parameter value\r\n   */\r\n  protected getBooleanParameter(key: string, defaultValue: boolean): boolean {\r\n    if (typeof key !== 'string' || !key) {\r\n      throw new Error('Parameter key must be a non-empty string');\r\n    }\r\n    const value = Object.prototype.hasOwnProperty.call(this.parameters, key) ? this.parameters[key as keyof typeof this.parameters] : undefined;\r\n    if (value === undefined) {\r\n      return defaultValue;\r\n    }\r\n    \r\n    return Boolean(value);\r\n  }\r\n  \r\n  /**\r\n   * Validate numeric array input\r\n   * \r\n   * @param data Input data array\r\n   * @returns Validated data array\r\n   */\r\n  protected validateNumericArray(data: number[]): number[] {\r\n    if (!Array.isArray(data)) {\r\n      throw new Error(`Input data must be an array for ${this.name}`);\r\n    }\r\n    // Reject NaN, Infinity, -Infinity, and non-numbers\r\n    const validData = data.filter(value => typeof value === 'number' && !isNaN(value) && isFinite(value));\r\n    if (validData.length !== data.length) {\r\n      throw new Error(`Input data contains invalid values for ${this.name}. All values must be finite numbers.`);\r\n    }\r\n    return validData;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\macd-indicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\macd.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\moving-averages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\rsi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\sma-indicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\indicators\\standard-deviation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signal-processing\\signal-processing-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signal-processing\\signal-translator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\aether\\core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\aether\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\aether\\models.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\aether\\parameters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\aether\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\sma\\improved-sma-signal-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\sma\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\sma\\models.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\sma\\sma-crossover-strategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\signals\\sma\\sma-signal-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\target-reacher\\config-validator.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":27,"column":9,"nodeType":"MemberExpression","endLine":27,"endColumn":19},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":27,"column":37,"nodeType":"MemberExpression","endLine":27,"endColumn":47},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":41,"column":19,"nodeType":"MemberExpression","endLine":41,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":70,"column":19,"nodeType":"MemberExpression","endLine":70,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":97,"column":19,"nodeType":"MemberExpression","endLine":97,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":113,"column":19,"nodeType":"MemberExpression","endLine":113,"endColumn":29}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Canonical config validator for Target Reacher. No duplications.\r\nimport type {\r\n  ConfigValidationResult,\r\n  ValidationError,\r\n  ValidationWarning\r\n} from './interfaces'\r\n\r\nexport class ConfigValidator {\r\n  private errors: ValidationError[] = [];\r\n  private warnings: ValidationWarning[] = [];\r\n\r\n  reset(): void {\r\n    this.errors = [];\r\n    this.warnings = [];\r\n  }\r\n\r\n  addError(field: string, message: string, code = 'VALIDATION_ERROR'): void {\r\n    this.errors.push({ field, message, code });\r\n  }\r\n\r\n  addWarning(field: string, message: string, suggestion?: string): void {\r\n    this.warnings.push({ field, message, suggestion });\r\n  }\r\n\r\n  required(obj: Record<string, unknown>, field: string, fieldName?: string): boolean {\r\n    const name = fieldName ?? field;\r\n    if (obj[field] === undefined || obj[field] === null) {\r\n      this.addError(field, `${name} is required`, 'REQUIRED');\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  number(obj: Record<string, unknown>, field: string, options: {\r\n    min?: number;\r\n    max?: number;\r\n    integer?: boolean;\r\n    fieldName?: string;\r\n  } = {}): boolean {\r\n    const name = options.fieldName ?? field;\r\n    const value = obj[field];\r\n    if (value === undefined) {return true;}\r\n    if (typeof value !== 'number' || isNaN(value)) {\r\n      this.addError(field, `${name} must be a number`, 'INVALID_TYPE');\r\n      return false;\r\n    }\r\n    if (options.integer && !Number.isInteger(value)) {\r\n      this.addError(field, `${name} must be an integer`, 'INVALID_TYPE');\r\n      return false;\r\n    }\r\n    if (options.min !== undefined && value < options.min) {\r\n      this.addError(field, `${name} must be at least ${options.min}`, 'OUT_OF_RANGE');\r\n      return false;\r\n    }\r\n    if (options.max !== undefined && value > options.max) {\r\n      this.addError(field, `${name} must be at most ${options.max}`, 'OUT_OF_RANGE');\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  string(obj: Record<string, unknown>, field: string, options: {\r\n    minLength?: number;\r\n    maxLength?: number;\r\n    pattern?: RegExp;\r\n    enum?: string[];\r\n    fieldName?: string;\r\n  } = {}): boolean {\r\n    const name = options.fieldName ?? field;\r\n    const value = obj[field];\r\n    if (value === undefined) {return true;}\r\n    if (typeof value !== 'string') {\r\n      this.addError(field, `${name} must be a string`, 'INVALID_TYPE');\r\n      return false;\r\n    }\r\n    if (options.minLength !== undefined && value.length < options.minLength) {\r\n      this.addError(field, `${name} must be at least ${options.minLength} characters`, 'TOO_SHORT');\r\n      return false;\r\n    }\r\n    if (options.maxLength !== undefined && value.length > options.maxLength) {\r\n      this.addError(field, `${name} must be at most ${options.maxLength} characters`, 'TOO_LONG');\r\n      return false;\r\n    }\r\n    if (options.pattern && !options.pattern.test(value)) {\r\n      this.addError(field, `${name} format is invalid`, 'INVALID_FORMAT');\r\n      return false;\r\n    }\r\n    if (options.enum && !options.enum.includes(value)) {\r\n      this.addError(field, `${name} must be one of: ${options.enum.join(', ')}`, 'INVALID_VALUE');\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  object(obj: Record<string, unknown>, field: string, validator: (value: unknown) => boolean, fieldName?: string): boolean {\r\n    const name = fieldName ?? field;\r\n    const value = obj[field];\r\n    if (value === undefined) {return true;}\r\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\r\n      this.addError(field, `${name} must be an object`, 'INVALID_TYPE');\r\n      return false;\r\n    }\r\n    return validator(value);\r\n  }\r\n\r\n  array(obj: Record<string, unknown>, field: string, options: {\r\n    minLength?: number;\r\n    maxLength?: number;\r\n    itemValidator?: (item: unknown, index: number) => boolean;\r\n    fieldName?: string;\r\n  } = {}): boolean {\r\n    const name = options.fieldName ?? field;\r\n    const value = obj[field];\r\n    if (value === undefined) {return true;}\r\n    if (!Array.isArray(value)) {\r\n      this.addError(field, `${name} must be an array`, 'INVALID_TYPE');\r\n      return false;\r\n    }\r\n    if (options.minLength !== undefined && value.length < options.minLength) {\r\n      this.addError(field, `${name} must have at least ${options.minLength} items`, 'TOO_SHORT');\r\n      return false;\r\n    }\r\n    if (options.maxLength !== undefined && value.length > options.maxLength) {\r\n      this.addError(field, `${name} must have at most ${options.maxLength} items`, 'TOO_LONG');\r\n      return false;\r\n    }\r\n    if (options.itemValidator) {\r\n      for (let i = 0; i < value.length; i++) {\r\n        if (!options.itemValidator(value.at(i), i)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  warn(condition: boolean, field: string, message: string, suggestion?: string): void {\r\n    if (condition) {\r\n      this.addWarning(field, message, suggestion);\r\n    }\r\n  }\r\n\r\n  getResult(): ConfigValidationResult {\r\n    return {\r\n      valid: this.errors.length === 0,\r\n      errors: [...this.errors],\r\n      warnings: [...this.warnings],\r\n    };\r\n  }\r\n}\r\n\r\nexport function validateConfig(config: Record<string, unknown>, validatorFn: (validator: ConfigValidator) => void): ConfigValidationResult {\r\n  const validator = new ConfigValidator();\r\n  validator.reset();\r\n  validatorFn(validator);\r\n  return validator.getResult();\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\target-reacher\\interfaces.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\target-reacher\\modular-target-reacher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\target-reacher\\parameter-mapping.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":10,"column":5,"nodeType":"MemberExpression","endLine":10,"endColumn":15},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":10,"column":18,"nodeType":"MemberExpression","endLine":10,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":21,"column":19,"nodeType":"MemberExpression","endLine":21,"endColumn":27},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":22,"column":5,"nodeType":"MemberExpression","endLine":22,"endColumn":21}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// [Canonical parameter mapping for Target Reacher. No duplications.]\r\n\r\n// Utility to map between camelCase and snake_case for strategy parameters\r\n\r\nexport function camelToSnake(obj: Record<string, unknown>): Record<string, unknown> {\r\n  const out: Record<string, unknown> = {};\r\n  for (const key in obj) {\r\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {continue;}\r\n    const snake = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\r\n    out[snake] = obj[key];\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function snakeToCamel(obj: Record<string, unknown>): Record<string, unknown> {\r\n  if (!obj || typeof obj !== 'object') {return obj;}\r\n  const result: Record<string, unknown> = {};\r\n  for (const key in obj) {\r\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {continue;}\r\n    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\r\n    const value = obj[key];\r\n    result[camelKey] = (value && typeof value === 'object' && !Array.isArray(value))\r\n      ? snakeToCamel(value as Record<string, unknown>)\r\n      : value;\r\n  }\r\n  return result;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\target-reacher\\parameters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\target-reacher\\target-reacher-factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\target-reacher\\target-reacher.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":45,"column":25,"nodeType":"MemberExpression","endLine":45,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":104,"column":3,"endLine":104,"endColumn":64,"severity":2,"nodeType":null},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":138,"column":25,"nodeType":"MemberExpression","endLine":138,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","message":"Definition for rule '@typescript-eslint/no-unused-vars' was not found.","line":197,"column":3,"endLine":197,"endColumn":64,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Modular Target Reacher Strategy\r\n * \r\n * Redesigned Target Reacher strategy using the new modular system\r\n */\r\n\r\nimport type { ConfigValidator } from './config-validator';\r\nimport { validateConfig } from './config-validator'\r\nimport type { \r\n  IStrategy, \r\n  StrategyConfig, \r\n  StrategyContext, \r\n  StrategyResult, \r\n  StrategyState,\r\n  ConfigValidationResult,\r\n  Candle\r\n} from './interfaces'\r\n\r\nexport class ModularTargetReacherStrategy implements IStrategy {\r\n  readonly name = 'target-reacher'\r\n  readonly version = '2.0.0'\r\n  readonly description = 'Modular Target Reacher strategy with fixed and average price sources (pure signal generator)'\r\n  readonly supportedMarkets = ['spot', 'futures', 'cross-margin'] as const\r\n\r\n  constructor(private readonly config: StrategyConfig, private readonly context: StrategyContext) {}\r\n\r\n  async initialize(): Promise<void> {\r\n    // No-op for pure signal strategy\r\n  }\r\n\r\n  async execute(): Promise<StrategyResult> {\r\n    const { priceSource, fixedPrice, averagePeriod, averageType } = this.config.parameters\r\n    const currentPriceRaw = await this.context.marketData.getCurrentPrice(this.context.symbol)\r\n    const currentPrice = typeof currentPriceRaw === 'number' ? currentPriceRaw : Number(currentPriceRaw) || 0\r\n    let targetPrice: number | undefined\r\n\r\n    if (priceSource === 'fixed') {\r\n      targetPrice = typeof fixedPrice === 'number' ? fixedPrice : Number(fixedPrice) || undefined\r\n    } else if (priceSource === 'average') {\r\n      const avgPeriod = typeof averagePeriod === 'number' && !isNaN(averagePeriod) ? averagePeriod : 20;\r\n      const candles: Candle[] = await this.context.marketData.getCandles(this.context.symbol, '1h', avgPeriod)\r\n      const priceKey: keyof Candle = (averageType ?? 'low') as keyof Candle;\r\n      targetPrice = candles.length > 0\r\n        ? candles.reduce((sum, c) => {\r\n            const val = c[priceKey];\r\n            return sum + (typeof val === 'number' ? val : Number(val) || 0);\r\n          }, 0) / candles.length\r\n        : undefined;\r\n    } else {\r\n      throw new Error('Unsupported price source')\r\n    }\r\n\r\n    if (typeof targetPrice === 'number') {\r\n      if (currentPrice <= targetPrice) {\r\n        return { success: true, action: 'buy', reason: `Current price <= target (${targetPrice})` }\r\n      } else if (currentPrice >= targetPrice) {\r\n        return { success: true, action: 'sell', reason: `Current price >= target (${targetPrice})` }\r\n      }\r\n    }\r\n    return { success: true, action: 'hold', reason: 'No signal' }\r\n  }\r\n\r\n  async cleanup(): Promise<void> {\r\n    // No-op for pure signal strategy\r\n  }\r\n\r\n  validateConfig(config: Record<string, unknown>): ConfigValidationResult {\r\n    return validateConfig(config, (validator: ConfigValidator) => {\r\n      validator.required(config, 'parameters')\r\n      const params = config.parameters as Record<string, unknown>\r\n      validator.string(params, 'priceSource', { enum: ['fixed', 'average'], fieldName: 'Price Source' })\r\n      if (params.priceSource === 'fixed') {\r\n        validator.number(params, 'fixedPrice', { min: 0, fieldName: 'Fixed Price' })\r\n      } else if (params.priceSource === 'average') {\r\n        validator.number(params, 'averagePeriod', { min: 1, max: 500, integer: true, fieldName: 'Average Period' })\r\n        validator.string(params, 'averageType', { enum: ['low', 'close', 'high', 'open'], fieldName: 'Average Type' })\r\n      }\r\n    })\r\n  }\r\n\r\n  getDefaultConfig(): StrategyConfig {\r\n    // Provide a unique default config for ModularTargetReacherStrategy\r\n    return {\r\n      type: 'modular-target-reacher',\r\n      parameters: {\r\n        priceSource: 'fixed',\r\n        fixedPrice: 50,\r\n        averagePeriod: 10,\r\n        averageType: 'close',\r\n      },\r\n    };\r\n  }\r\n\r\n  getState(): StrategyState {\r\n    // Provide a unique state for ModularTargetReacherStrategy\r\n    return {\r\n      isRunning: false,\r\n      totalProfit: 0,\r\n      tradesExecuted: 0,\r\n      lastUpdate: new Date(),\r\n      customState: { modular: true },\r\n    };\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  setState(_state: Partial<StrategyState>): void {\r\n    // No-op for pure signal strategy\r\n  }\r\n}\r\n\r\n// Canonical export for production usage\r\n// All backend logic is strictly in ./lib/ per project instructions\r\nexport class TargetReacherStrategy {\r\n  readonly name = 'target-reacher'\r\n  readonly version = '2.0.0'\r\n  readonly description = 'Modular Target Reacher strategy with fixed and average price sources (pure signal generator)'\r\n  readonly supportedMarkets = ['spot', 'futures', 'cross-margin'] as const\r\n\r\n  constructor(private readonly config: StrategyConfig, private readonly context: StrategyContext) {}\r\n\r\n  async initialize(): Promise<void> {\r\n    // No-op for pure signal strategy\r\n  }\r\n\r\n  async execute(): Promise<StrategyResult> {\r\n    const { priceSource, fixedPrice, averagePeriod, averageType } = this.config.parameters;\r\n    const currentPriceRaw = await this.context.marketData.getCurrentPrice(this.context.symbol);\r\n    const currentPrice = typeof currentPriceRaw === 'number' ? currentPriceRaw : Number(currentPriceRaw) || 0;\r\n    let targetPrice: number | undefined;\r\n\r\n    if (priceSource === 'fixed') {\r\n      targetPrice = typeof fixedPrice === 'number' ? fixedPrice : Number(fixedPrice) || undefined;\r\n    } else if (priceSource === 'average') {\r\n      const avgPeriod = typeof averagePeriod === 'number' && !isNaN(averagePeriod) ? averagePeriod : 20;\r\n      const candles: Candle[] = await this.context.marketData.getCandles(this.context.symbol, '1h', avgPeriod);\r\n      const priceKey: keyof Candle = (averageType ?? 'low') as keyof Candle;\r\n      targetPrice = candles.length > 0\r\n        ? candles.reduce((sum, c) => {\r\n            const val = c[priceKey];\r\n            return sum + (typeof val === 'number' ? val : Number(val) || 0);\r\n          }, 0) / candles.length\r\n        : undefined;\r\n    } else {\r\n      throw new Error('Unsupported price source');\r\n    }\r\n\r\n    if (typeof targetPrice === 'number') {\r\n      if (currentPrice <= targetPrice) {\r\n        return { success: true, action: 'buy', reason: `Current price <= target (${targetPrice})` };\r\n      } else if (currentPrice >= targetPrice) {\r\n        return { success: true, action: 'sell', reason: `Current price >= target (${targetPrice})` };\r\n      }\r\n    }\r\n    return { success: true, action: 'hold', reason: 'No signal' };\r\n  }\r\n\r\n  async cleanup(): Promise<void> {\r\n    // No-op for pure signal strategy\r\n  }\r\n\r\n  validateConfig(config: Record<string, unknown>): ConfigValidationResult {\r\n    return validateConfig(config, (validator: ConfigValidator) => {\r\n      validator.required(config, 'parameters');\r\n      const params = config.parameters as Record<string, unknown>;\r\n      validator.string(params, 'priceSource', { enum: ['fixed', 'average'], fieldName: 'Price Source' });\r\n      if (params.priceSource === 'fixed') {\r\n        validator.number(params, 'fixedPrice', { min: 0, fieldName: 'Fixed Price' });\r\n      } else if (params.priceSource === 'average') {\r\n        validator.number(params, 'averagePeriod', { min: 1, max: 500, integer: true, fieldName: 'Average Period' });\r\n        validator.string(params, 'averageType', { enum: ['low', 'close', 'high', 'open'], fieldName: 'Average Type' });\r\n      }\r\n    });\r\n  }\r\n\r\n  getDefaultConfig(): StrategyConfig {\r\n    // Provide a unique default config for TargetReacherStrategy\r\n    return {\r\n      type: 'target-reacher',\r\n      parameters: {\r\n        priceSource: 'fixed',\r\n        fixedPrice: 100,\r\n        averagePeriod: 10,\r\n        averageType: 'close',\r\n      },\r\n    };\r\n  }\r\n\r\n  // Fix: Implement getState to return a valid StrategyState\r\n  getState(): StrategyState {\r\n    return {\r\n      isRunning: false,\r\n      totalProfit: 0,\r\n      tradesExecuted: 0,\r\n      lastUpdate: new Date(),\r\n      customState: {},\r\n    };\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  setState(_state: Partial<StrategyState>): void {\r\n    // No-op for pure signal strategy\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\unified-signals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\JabbrLabs\\unified-strategies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\auth\\auth.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\auth\\auth.middleware.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":139,"column":117,"nodeType":"MemberExpression","endLine":139,"endColumn":148},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":140,"column":111,"nodeType":"MemberExpression","endLine":140,"endColumn":140},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":141,"column":113,"nodeType":"MemberExpression","endLine":141,"endColumn":143}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONSTANTS } from '@jabbr/shared';\r\nimport type { Request, Response, NextFunction } from 'express';\r\n\r\nimport { AuthService } from './auth.service';\r\n\r\n// Extend Express Request type to include user information\r\ndeclare global {\r\n  namespace Express {\r\n    interface Request {\r\n      user?: {\r\n        userId: string;\r\n        email: string;\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport class AuthMiddleware {\r\n  private authService: AuthService;\r\n\r\n  constructor() {\r\n    this.authService = new AuthService();\r\n  }\r\n\r\n  /**\r\n   * Middleware to require authentication\r\n   * Verifies JWT token and attaches user info to request\r\n   */\r\n  requireAuth = (req: Request, res: Response, next: NextFunction): void => {\r\n    try {\r\n      const authHeader = req.headers.authorization;\r\n      const token = this.authService.extractTokenFromHeader(authHeader);\r\n\r\n      if (!token) {\r\n        res.status(401).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.AUTHENTICATION_ERROR,\r\n            message: 'No authentication token provided',\r\n            details: 'Authorization header with Bearer token is required'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      const decoded = this.authService.verifyAccessToken(token);\r\n\r\n      if (!decoded) {\r\n        res.status(401).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.AUTHENTICATION_ERROR,\r\n            message: 'Invalid or expired token',\r\n            details: 'Please login again to get a new token'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Attach user info to request for use in route handlers\r\n      req.user = {\r\n        userId: decoded.userId,\r\n        email: decoded.email\r\n      };\r\n\r\n      next();\r\n    } catch (error) {\r\n      console.error('Auth middleware error:', error);\r\n      res.status(500).json({\r\n        success: false,\r\n        error: {\r\n          code: CONSTANTS.ERROR_CODES.AUTHENTICATION_ERROR,\r\n          message: 'Authentication error',\r\n          details: 'An error occurred while verifying authentication'\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Optional authentication middleware\r\n   * Attaches user info if token is valid, but doesn't require it\r\n   */\r\n  optionalAuth = (req: Request, res: Response, next: NextFunction): void => {\r\n    try {\r\n      const authHeader = req.headers.authorization;\r\n      const token = this.authService.extractTokenFromHeader(authHeader);\r\n\r\n      if (token) {\r\n        const decoded = this.authService.verifyAccessToken(token);\r\n        if (decoded) {\r\n          req.user = {\r\n            userId: decoded.userId,\r\n            email: decoded.email\r\n          };\r\n        }\r\n      }\r\n\r\n      next();\r\n    } catch (error) {\r\n      // Log error but don't block the request\r\n      console.error('Optional auth middleware error:', error);\r\n      next();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Middleware to check if user owns a resource\r\n   * Must be used after requireAuth middleware\r\n   */\r\n  requireOwnership = (resourceUserIdField = 'userId') => {\r\n    return (req: Request, res: Response, next: NextFunction): void => {\r\n      if (!req.user) {\r\n        res.status(401).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.AUTHENTICATION_ERROR,\r\n            message: 'Authentication required',\r\n            details: 'This middleware must be used after requireAuth'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Check if the resource belongs to the authenticated user\r\n      // This can be used with req.params, req.body, or req.query\r\n      // Validate the field name to prevent object injection\r\n      if (typeof resourceUserIdField !== 'string' || !resourceUserIdField) {\r\n        res.status(500).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.AUTHORIZATION_ERROR,\r\n            message: 'Invalid resource field configuration'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      const resourceUserId = (req.params && Object.prototype.hasOwnProperty.call(req.params, resourceUserIdField) ? req.params[resourceUserIdField] : null) || \r\n                           (req.body && Object.prototype.hasOwnProperty.call(req.body, resourceUserIdField) ? req.body[resourceUserIdField] : null) || \r\n                           (req.query && Object.prototype.hasOwnProperty.call(req.query, resourceUserIdField) ? req.query[resourceUserIdField] : null);\r\n\r\n      if (!resourceUserId) {\r\n        res.status(400).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.VALIDATION_ERROR,\r\n            message: 'Resource user ID not found',\r\n            details: `${resourceUserIdField} must be provided in request parameters, body, or query`\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (req.user.userId !== resourceUserId) {\r\n        res.status(403).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.AUTHORIZATION_ERROR,\r\n            message: 'Access denied',\r\n            details: 'You can only access your own resources'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      next();\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Rate limiting middleware for authentication endpoints\r\n   * Simple in-memory rate limiter (in production, use Redis)\r\n   */\r\n  createRateLimiter = (maxAttempts = 5, windowMs: number = 15 * 60 * 1000) => {\r\n    const attempts = new Map<string, { count: number; resetTime: number }>();\r\n\r\n    return (req: Request, res: Response, next: NextFunction): void => {\r\n      const clientIp = req.ip || req.connection.remoteAddress || 'unknown';\r\n      const now = Date.now();\r\n\r\n      // Clean up old entries\r\n      for (const [ip, data] of attempts.entries()) {\r\n        if (now > data.resetTime) {\r\n          attempts.delete(ip);\r\n        }\r\n      }\r\n\r\n      const clientAttempts = attempts.get(clientIp);\r\n\r\n      if (!clientAttempts) {\r\n        attempts.set(clientIp, { count: 1, resetTime: now + windowMs });\r\n        next();\r\n        return;\r\n      }\r\n\r\n      if (now > clientAttempts.resetTime) {\r\n        // Reset window\r\n        attempts.set(clientIp, { count: 1, resetTime: now + windowMs });\r\n        next();\r\n        return;\r\n      }\r\n\r\n      if (clientAttempts.count >= maxAttempts) {\r\n        const remainingTime = Math.ceil((clientAttempts.resetTime - now) / 1000);\r\n        res.status(429).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.RATE_LIMIT_ERROR,\r\n            message: 'Too many attempts',\r\n            details: `Please try again in ${remainingTime} seconds`\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      clientAttempts.count++;\r\n      next();\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Middleware to validate refresh token\r\n   */\r\n  requireRefreshToken = (req: Request, res: Response, next: NextFunction): void => {\r\n    try {\r\n      const { refreshToken } = req.body;\r\n\r\n      if (!refreshToken) {\r\n        res.status(400).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.VALIDATION_ERROR,\r\n            message: 'Refresh token required',\r\n            details: 'refreshToken must be provided in request body'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      const decoded = this.authService.verifyRefreshToken(refreshToken);\r\n\r\n      if (!decoded) {\r\n        res.status(401).json({\r\n          success: false,\r\n          error: {\r\n            code: CONSTANTS.ERROR_CODES.AUTHENTICATION_ERROR,\r\n            message: 'Invalid refresh token',\r\n            details: 'Please login again to get new tokens'\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Attach userId to request for use in refresh endpoint\r\n      req.user = {\r\n        userId: decoded.userId,\r\n        email: '' // Will be filled by the refresh endpoint\r\n      };\r\n\r\n      next();\r\n    } catch (error) {\r\n      console.error('Refresh token middleware error:', error);\r\n      res.status(500).json({\r\n        success: false,\r\n        error: {\r\n          code: CONSTANTS.ERROR_CODES.AUTHENTICATION_ERROR,\r\n          message: 'Token verification error',\r\n          details: 'An error occurred while verifying refresh token'\r\n        }\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n// Export singleton instance\r\nexport const authMiddleware = new AuthMiddleware(); ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\auth\\auth.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\auth\\auth.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-reliability-system.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":473,"column":5,"nodeType":"MemberExpression","endLine":473,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Bot Error Handling and Recovery Integration\r\n * \r\n * Integrates all error handling, recovery, and monitoring components\r\n * to provide a comprehensive bot reliability system.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\n\r\nimport logger from '../services/logging.service';\r\n\r\nimport type { BotManager } from './bot-manager';\r\nimport { BotRuntime } from './bot-runtime';\r\nimport type { WatchdogConfig } from './bot-watchdog';\r\nimport { BotWatchdog } from './bot-watchdog';\r\nimport type { RecoveryConfig } from './error-recovery-manager';\r\nimport { ErrorRecoveryManager } from './error-recovery-manager';\r\nimport HealthCheckService from './health-check.service';\r\n\r\nexport interface BotReliabilityConfig {\r\n  errorRecovery: Partial<RecoveryConfig>;\r\n  watchdog: Partial<WatchdogConfig>;\r\n  integration: {\r\n    enableAutoRestarts: boolean;\r\n    enableFailoverMode: boolean;\r\n    maxSystemErrors: number;\r\n    systemErrorWindow: number; // milliseconds\r\n    alertWebhookUrl?: string;\r\n    enableMetricsCollection: boolean;\r\n  };\r\n}\r\n\r\nexport interface SystemAlert {\r\n  level: 'info' | 'warning' | 'error' | 'critical';\r\n  source: 'error-recovery' | 'watchdog' | 'health-check' | 'system';\r\n  title: string;\r\n  message: string;\r\n  botId?: string;\r\n  timestamp: Date;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\nexport class BotReliabilitySystem extends EventEmitter {\r\n  private config: BotReliabilityConfig;\r\n  private errorRecoveryManager!: ErrorRecoveryManager;\r\n  private botWatchdog!: BotWatchdog;\r\n  private healthCheckService!: HealthCheckService;\r\n  private botManager: BotManager;\r\n  \r\n  private systemErrorCount = 0;\r\n  private systemErrorWindow: NodeJS.Timeout | null = null;\r\n  private alertHistory: SystemAlert[] = [];\r\n  private running = false;\r\n\r\n  constructor(\r\n    botManager: BotManager,\r\n    config: Partial<BotReliabilityConfig> = {}\r\n  ) {\r\n    super();\r\n\r\n    this.botManager = botManager;\r\n    this.config = {\r\n      errorRecovery: {\r\n        maxRetries: 3,\r\n        baseRetryDelay: 1000,\r\n        maxRetryDelay: 30000,\r\n        enableAutoRestart: true,\r\n        alertThreshold: 10,\r\n        ...config.errorRecovery\r\n      },\r\n      watchdog: {\r\n        healthCheckInterval: 30000,\r\n        enableAutoRestart: true,\r\n        restartThreshold: 3,\r\n        alertOnRestart: true,\r\n        ...config.watchdog\r\n      },\r\n      integration: {\r\n        enableAutoRestarts: true,\r\n        enableFailoverMode: false,\r\n        maxSystemErrors: 20,\r\n        systemErrorWindow: 300000, // 5 minutes\r\n        enableMetricsCollection: true,\r\n        ...config.integration\r\n      }\r\n    };\r\n\r\n    this.initializeComponents();\r\n    this.setupIntegrationEvents();\r\n  }\r\n\r\n  /**\r\n   * Initialize all reliability components\r\n   */\r\n  private initializeComponents(): void {\r\n    // Initialize Error Recovery Manager\r\n    this.errorRecoveryManager = new ErrorRecoveryManager(this.config.errorRecovery);\r\n\r\n    // Initialize Bot Watchdog\r\n    this.botWatchdog = new BotWatchdog(\r\n      this.botManager,\r\n      this.errorRecoveryManager,\r\n      this.config.watchdog\r\n    );\r\n\r\n    // Initialize Health Check Service\r\n    this.healthCheckService = new HealthCheckService(\r\n      this.botManager,\r\n      this.errorRecoveryManager,\r\n      this.botWatchdog\r\n    );\r\n\r\n    logger.info('[BotReliability] Initialized all reliability components');\r\n  }\r\n\r\n  /**\r\n   * Setup integration event handlers\r\n   */\r\n  private setupIntegrationEvents(): void {\r\n    // Error Recovery Manager Events\r\n    this.errorRecoveryManager.on('error', (errorRecord) => {\r\n      this.handleErrorRecoveryEvent('error', errorRecord);\r\n    });\r\n\r\n    this.errorRecoveryManager.on('recovery', (errorRecord) => {\r\n      this.handleErrorRecoveryEvent('recovery', errorRecord);\r\n    });\r\n\r\n    this.errorRecoveryManager.on('recovery-failed', (errorRecord) => {\r\n      this.handleErrorRecoveryEvent('recovery-failed', errorRecord);\r\n    });\r\n\r\n    this.errorRecoveryManager.on('admin-alert', (errorRecord) => {\r\n      this.sendAlert({\r\n        level: 'critical',\r\n        source: 'error-recovery',\r\n        title: 'Admin Intervention Required',\r\n        message: `Bot ${errorRecord.context.botId} requires admin intervention: ${errorRecord.context.errorMessage}`,\r\n        botId: errorRecord.context.botId,\r\n        timestamp: new Date(),\r\n        metadata: { errorRecord }\r\n      });\r\n    });\r\n\r\n    this.errorRecoveryManager.on('restart-required', (errorRecord) => {\r\n      this.handleBotRestartRequest(errorRecord.context.botId, 'error-recovery');\r\n    });\r\n\r\n    this.errorRecoveryManager.on('alert-threshold-exceeded', (data) => {\r\n      this.sendAlert({\r\n        level: 'error',\r\n        source: 'error-recovery',\r\n        title: 'Error Threshold Exceeded',\r\n        message: `Bot ${data.botId} has exceeded error threshold: ${data.errorCount}/${data.threshold}`,\r\n        botId: data.botId,\r\n        timestamp: new Date(),\r\n        metadata: data\r\n      });\r\n    });\r\n\r\n    // Bot Watchdog Events\r\n    this.botWatchdog.on('bot-unhealthy', (healthResult) => {\r\n      this.sendAlert({\r\n        level: 'warning',\r\n        source: 'watchdog',\r\n        title: 'Bot Health Degraded',\r\n        message: `Bot ${healthResult.botId} is unhealthy: ${healthResult.issues.join(', ')}`,\r\n        botId: healthResult.botId,\r\n        timestamp: new Date(),\r\n        metadata: { healthResult }\r\n      });\r\n    });\r\n\r\n    this.botWatchdog.on('bot-restart-required', (data) => {\r\n      this.handleBotRestartRequest(data.botId, 'watchdog');\r\n    });\r\n\r\n    this.botWatchdog.on('bot-restarted', (data) => {\r\n      this.sendAlert({\r\n        level: 'info',\r\n        source: 'watchdog',\r\n        title: 'Bot Restarted',\r\n        message: `Bot ${data.botId} has been successfully restarted`,\r\n        botId: data.botId,\r\n        timestamp: new Date(),\r\n        metadata: data\r\n      });\r\n    });\r\n\r\n    this.botWatchdog.on('bot-restart-failed', (data) => {\r\n      this.sendAlert({\r\n        level: 'critical',\r\n        source: 'watchdog',\r\n        title: 'Bot Restart Failed',\r\n        message: `Failed to restart bot ${data.botId}: ${data.error}`,\r\n        botId: data.botId,\r\n        timestamp: new Date(),\r\n        metadata: data\r\n      });\r\n\r\n      this.incrementSystemErrorCount();\r\n    });\r\n\r\n    // Bot Manager Events\r\n    this.botManager.on('bot-error', (data) => {\r\n      this.handleBotError(data.botId, data.error);\r\n    });\r\n\r\n    this.botManager.on('bot-crashed', (data) => {\r\n      this.sendAlert({\r\n        level: 'critical',\r\n        source: 'system',\r\n        title: 'Bot Crashed',\r\n        message: `Bot ${data.botId} has crashed: ${data.reason}`,\r\n        botId: data.botId,\r\n        timestamp: new Date(),\r\n        metadata: data\r\n      });\r\n\r\n      this.incrementSystemErrorCount();\r\n    });\r\n\r\n    logger.info('[BotReliability] Setup integration event handlers');\r\n  }\r\n\r\n  /**\r\n   * Start the reliability system\r\n   */\r\n  start(): void {\r\n    if (this.running) {\r\n      logger.warn('[BotReliability] System is already running');\r\n      return;\r\n    }\r\n\r\n    this.running = true;\r\n    \r\n    logger.info('[BotReliability] Starting bot reliability system', {\r\n      config: this.config\r\n    });\r\n\r\n    // Start all components\r\n    this.botWatchdog.start();\r\n\r\n    // Start system error window tracking\r\n    this.resetSystemErrorWindow();\r\n\r\n    this.sendAlert({\r\n      level: 'info',\r\n      source: 'system',\r\n      title: 'Reliability System Started',\r\n      message: 'Bot reliability system is now active and monitoring all bots',\r\n      timestamp: new Date()\r\n    });\r\n\r\n    this.emit('started');\r\n  }\r\n\r\n  /**\r\n   * Stop the reliability system\r\n   */\r\n  stop(): void {\r\n    if (!this.running) {\r\n      logger.warn('[BotReliability] System is not running');\r\n      return;\r\n    }\r\n\r\n    this.running = false;\r\n\r\n    logger.info('[BotReliability] Stopping bot reliability system');\r\n\r\n    // Stop all components\r\n    this.botWatchdog.stop();\r\n\r\n    // Clear system error window\r\n    if (this.systemErrorWindow) {\r\n      clearTimeout(this.systemErrorWindow);\r\n      this.systemErrorWindow = null;\r\n    }\r\n\r\n    this.sendAlert({\r\n      level: 'info',\r\n      source: 'system',\r\n      title: 'Reliability System Stopped',\r\n      message: 'Bot reliability system has been stopped',\r\n      timestamp: new Date()\r\n    });\r\n\r\n    this.emit('stopped');\r\n  }\r\n\r\n  /**\r\n   * Handle bot errors through the recovery system\r\n   */\r\n  async handleBotError(botId: string, error: Error): Promise<boolean> {\r\n    logger.info('[BotReliability] Handling bot error', {\r\n      botId,\r\n      error: error.message\r\n    });\r\n\r\n    // Use error recovery manager to handle the error\r\n    const recovered = await this.errorRecoveryManager.handleError(error, {\r\n      botId,\r\n      operation: 'bot-operation'\r\n    });\r\n\r\n    if (!recovered) {\r\n      this.incrementSystemErrorCount();\r\n    }\r\n\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * Handle error recovery events\r\n   */\r\n  private handleErrorRecoveryEvent(eventType: string, errorRecord: any): void {\r\n    const alertLevel = this.getAlertLevelForRecoveryEvent(eventType);\r\n    const message = this.getMessageForRecoveryEvent(eventType, errorRecord);\r\n\r\n    if (alertLevel) {\r\n      this.sendAlert({\r\n        level: alertLevel,\r\n        source: 'error-recovery',\r\n        title: `Error Recovery: ${eventType}`,\r\n        message,\r\n        botId: errorRecord.context.botId,\r\n        timestamp: new Date(),\r\n        metadata: { errorRecord, eventType }\r\n      });\r\n    }\r\n\r\n    // Emit for external listeners\r\n    this.emit('error-recovery-event', { eventType, errorRecord });\r\n  }\r\n\r\n  /**\r\n   * Handle bot restart requests\r\n   */\r\n  private async handleBotRestartRequest(botId: string, source: string): Promise<void> {\r\n    if (!this.config.integration.enableAutoRestarts) {\r\n      logger.warn('[BotReliability] Auto-restarts disabled, skipping restart', {\r\n        botId,\r\n        source\r\n      });\r\n      return;\r\n    }\r\n\r\n    logger.info('[BotReliability] Handling bot restart request', {\r\n      botId,\r\n      source\r\n    });\r\n\r\n    try {\r\n      // The watchdog will handle the actual restart\r\n      // We just track the request here\r\n      this.emit('bot-restart-requested', { botId, source });\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : String(error);\r\n      logger.error('[BotReliability] Failed to handle restart request', {\r\n        botId,\r\n        source,\r\n        error: errorMessage\r\n      });\r\n\r\n      this.incrementSystemErrorCount();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Increment system error count and check thresholds\r\n   */\r\n  private incrementSystemErrorCount(): void {\r\n    this.systemErrorCount++;\r\n\r\n    logger.warn('[BotReliability] System error count incremented', {\r\n      count: this.systemErrorCount,\r\n      threshold: this.config.integration.maxSystemErrors\r\n    });\r\n\r\n    if (this.systemErrorCount >= this.config.integration.maxSystemErrors) {\r\n      this.sendAlert({\r\n        level: 'critical',\r\n        source: 'system',\r\n        title: 'System Error Threshold Exceeded',\r\n        message: `System has exceeded maximum error threshold: ${this.systemErrorCount}/${this.config.integration.maxSystemErrors}`,\r\n        timestamp: new Date(),\r\n        metadata: {\r\n          errorCount: this.systemErrorCount,\r\n          threshold: this.config.integration.maxSystemErrors,\r\n          window: this.config.integration.systemErrorWindow\r\n        }\r\n      });\r\n\r\n      // Consider entering failover mode or alerting operations\r\n      if (this.config.integration.enableFailoverMode) {\r\n        this.enterFailoverMode();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset system error window\r\n   */\r\n  private resetSystemErrorWindow(): void {\r\n    if (this.systemErrorWindow) {\r\n      clearTimeout(this.systemErrorWindow);\r\n    }\r\n\r\n    this.systemErrorWindow = setTimeout(() => {\r\n      logger.info('[BotReliability] Resetting system error count', {\r\n        previousCount: this.systemErrorCount\r\n      });\r\n      \r\n      this.systemErrorCount = 0;\r\n      this.resetSystemErrorWindow();\r\n    }, this.config.integration.systemErrorWindow);\r\n  }\r\n\r\n  /**\r\n   * Enter failover mode (emergency procedure)\r\n   */\r\n  private async enterFailoverMode(): Promise<void> {\r\n    logger.error('[BotReliability] Entering failover mode due to system errors');\r\n\r\n    this.sendAlert({\r\n      level: 'critical',\r\n      source: 'system',\r\n      title: 'System Entering Failover Mode',\r\n      message: 'Too many system errors detected, entering emergency failover mode',\r\n      timestamp: new Date()\r\n    });\r\n\r\n    // Stop all bots to prevent further damage\r\n    try {\r\n      const allBots = this.botManager.getAllBotsStatus();\r\n      for (const botId of allBots.keys()) {\r\n        try {\r\n          await this.botManager.stopBot('system', botId);\r\n          logger.info('[BotReliability] Stopped bot in failover mode', { botId });\r\n        } catch (error) {\r\n          logger.error('[BotReliability] Failed to stop bot in failover mode', {\r\n            botId,\r\n            error: error instanceof Error ? error.message : String(error)\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logger.error('[BotReliability] Failed to execute failover procedure', {\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n\r\n    this.emit('failover-mode-entered');\r\n  }\r\n\r\n  /**\r\n   * Send system alert\r\n   */\r\n  private sendAlert(alert: SystemAlert): void {\r\n    // Store alert in history\r\n    this.alertHistory.push(alert);\r\n\r\n    // Keep only recent alerts (last 1000)\r\n    if (this.alertHistory.length > 1000) {\r\n      this.alertHistory.splice(0, this.alertHistory.length - 1000);\r\n    }\r\n\r\n    // Log the alert\r\n    const logLevel = alert.level === 'critical' ? 'error' : \r\n                    alert.level === 'error' ? 'error' :\r\n                    alert.level === 'warning' ? 'warn' : 'info';\r\n\r\n    logger[logLevel](`[BotReliability] ALERT: ${alert.title}`, {\r\n      source: alert.source,\r\n      message: alert.message,\r\n      botId: alert.botId,\r\n      metadata: alert.metadata\r\n    });\r\n\r\n    // Emit alert event\r\n    this.emit('alert', alert);\r\n\r\n    // Send webhook if configured\r\n    if (this.config.integration.alertWebhookUrl) {\r\n      this.sendWebhookAlert(alert);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send webhook alert (placeholder implementation)\r\n   */\r\n  private async sendWebhookAlert(alert: SystemAlert): Promise<void> {\r\n    try {\r\n      // This would send a webhook to external alerting systems\r\n      // For now, just log it\r\n      logger.info('[BotReliability] Would send webhook alert', {\r\n        url: this.config.integration.alertWebhookUrl,\r\n        alert\r\n      });\r\n    } catch (error) {\r\n      logger.error('[BotReliability] Failed to send webhook alert', {\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper methods\r\n   */\r\n  private getAlertLevelForRecoveryEvent(eventType: string): SystemAlert['level'] | null {\r\n    switch (eventType) {\r\n      case 'error':\r\n        return 'warning';\r\n      case 'recovery':\r\n        return 'info';\r\n      case 'recovery-failed':\r\n        return 'error';\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  private getMessageForRecoveryEvent(eventType: string, errorRecord: any): string {\r\n    switch (eventType) {\r\n      case 'error':\r\n        return `Error detected in bot ${errorRecord.context.botId}: ${errorRecord.context.errorMessage}`;\r\n      case 'recovery':\r\n        return `Bot ${errorRecord.context.botId} successfully recovered from error`;\r\n      case 'recovery-failed':\r\n        return `Failed to recover bot ${errorRecord.context.botId} from error: ${errorRecord.context.errorMessage}`;\r\n      default:\r\n        return `Unknown recovery event: ${eventType}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Public methods for monitoring and management\r\n   */\r\n  getSystemStats(): {\r\n    running: boolean;\r\n    systemErrorCount: number;\r\n    alertCount: number;\r\n    errorRecoveryStats: any;\r\n    watchdogStats: any;\r\n  } {\r\n    return {\r\n      running: this.running,\r\n      systemErrorCount: this.systemErrorCount,\r\n      alertCount: this.alertHistory.length,\r\n      errorRecoveryStats: this.errorRecoveryManager.getStats(),\r\n      watchdogStats: this.botWatchdog.getWatchdogStats()\r\n    };\r\n  }\r\n\r\n  getRecentAlerts(limit = 50): SystemAlert[] {\r\n    return this.alertHistory.slice(-limit);\r\n  }\r\n\r\n  getErrorRecoveryManager(): ErrorRecoveryManager {\r\n    return this.errorRecoveryManager;\r\n  }\r\n\r\n  getBotWatchdog(): BotWatchdog {\r\n    return this.botWatchdog;\r\n  }\r\n\r\n  getHealthCheckService(): HealthCheckService {\r\n    return this.healthCheckService;\r\n  }\r\n\r\n  isRunning(): boolean {\r\n    return this.running;\r\n  }\r\n\r\n  /**\r\n   * Force health check for all bots\r\n   */\r\n  async performSystemHealthCheck(): Promise<any> {\r\n    return await this.healthCheckService.getHealthStatus();\r\n  }\r\n\r\n  /**\r\n   * Clear error history for a bot\r\n   */\r\n  clearBotErrorHistory(botId: string): void {\r\n    this.errorRecoveryManager.clearErrorHistory(botId);\r\n    this.errorRecoveryManager.resetCircuitBreaker(botId);\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  updateConfig(config: Partial<BotReliabilityConfig>): void {\r\n    this.config = {\r\n      ...this.config,\r\n      ...config\r\n    };\r\n\r\n    logger.info('[BotReliability] Configuration updated', { config: this.config });\r\n  }\r\n}\r\n\r\nexport default BotReliabilitySystem;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-runtime.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":864,"column":9,"nodeType":"MemberExpression","endLine":864,"endColumn":44},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":908,"column":9,"nodeType":"MemberExpression","endLine":908,"endColumn":41}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Production-Ready Bot Runtime System\r\n * \r\n * This module handles the complete lifecycle of trading bots in production:\r\n * - Bot initialization and configuration loading\r\n * - Dynamic strategy loading and execution\r\n * - Signal processing and trade execution\r\n * - Error handling and recovery\r\n * - State persistence and monitoring\r\n * - Graceful shutdown and cleanup\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\n\r\nimport type { IStrategy, StrategyResult, StrategyContext, StrategyConfig } from '../JabbrLabs/target-reacher/interfaces';\r\nimport { database } from '../services/database.service';\r\nimport type { StrategyType } from '../strategies/strategy-factory';\r\n\r\nimport type { Bot } from './bots.service';\r\nimport type { StrategySwapOptions } from './dynamic-strategy-loader';\r\nimport { dynamicStrategyLoader } from './dynamic-strategy-loader';\r\nimport type { ErrorRecoveryManager } from './error-recovery-manager';\r\nimport GracefulShutdownManager from './graceful-shutdown-manager';\r\nimport type { ProcessedSignal } from './signal-processor';\r\nimport { SignalProcessor } from './signal-processor';\r\nimport StateManager from './state-manager';\r\nimport type { StrategyExecutionConfig, StrategyExecutionResult } from './strategy-execution-integration';\r\nimport StrategyExecutionIntegration from './strategy-execution-integration';\r\nimport { TradeDecisionEngine } from './trade-decision-engine';\r\nimport type { TradeDecision, ExecutionResult } from './trade-decision-engine';\r\nimport type { TradeExecutor } from './trade-executor';\r\n\r\nexport interface BotRuntimeConfig {\r\n  bot: Bot;\r\n  strategy: IStrategy;\r\n  context: StrategyContext;\r\n  checkInterval: number; // milliseconds\r\n  maxRetries: number;\r\n  retryDelay: number; // milliseconds\r\n  tradeExecutor?: TradeExecutor; // Optional trade executor for real trading\r\n  errorRecoveryManager?: ErrorRecoveryManager; // Optional error recovery manager\r\n  stateManager?: StateManager; // Enhanced state persistence manager\r\n  shutdownManager?: GracefulShutdownManager; // Enhanced graceful shutdown manager\r\n  strategyExecutionIntegration?: StrategyExecutionIntegration; // Enhanced strategy execution\r\n}\r\n\r\nexport interface BotState {\r\n  botId: string;\r\n  status: 'initializing' | 'running' | 'paused' | 'stopping' | 'stopped' | 'error';\r\n  startedAt?: Date;\r\n  lastTickAt?: Date;\r\n  errorCount: number;\r\n  lastError?: string;\r\n  performance: {\r\n    tickCount: number;\r\n    signalCount: number;\r\n    tradeCount: number;\r\n    errorCount: number;\r\n    totalProfit: number;\r\n    totalLoss: number;\r\n    winRate: number;\r\n    avgTradeTime: number;\r\n    maxDrawdown: number;\r\n  };\r\n  currentStrategy?: {\r\n    name: string;\r\n    version: string;\r\n    type: string;\r\n  };\r\n  positions?: Array<{\r\n    symbol: string;\r\n    size: number;\r\n    entryPrice: number;\r\n    currentPrice: number;\r\n    pnl: number;\r\n    openedAt: Date;\r\n  }>;\r\n  orders?: Array<{\r\n    id: string;\r\n    symbol: string;\r\n    type: string;\r\n    status: string;\r\n    size: number;\r\n    price: number;\r\n    createdAt: Date;\r\n  }>;\r\n  strategy?: {\r\n    type: string;\r\n    parameters: Record<string, unknown>;\r\n    indicators: Record<string, unknown>;\r\n    signals: Array<{\r\n      type: string;\r\n      strength: number;\r\n      timestamp: Date;\r\n    }>;\r\n  };\r\n}\r\n\r\nexport class BotRuntime extends EventEmitter {\r\n  private config: BotRuntimeConfig;\r\n  private state: BotState;\r\n  private intervalId?: NodeJS.Timeout;\r\n  private shutdownPromise?: Promise<void>;\r\n  private isShuttingDown = false;\r\n  private signalProcessor: SignalProcessor;\r\n  private tradeDecisionEngine: TradeDecisionEngine;\r\n  private stateManager: StateManager;\r\n  private shutdownManager: GracefulShutdownManager;\r\n  private strategyExecutionIntegration?: StrategyExecutionIntegration;\r\n\r\n  constructor(config: BotRuntimeConfig) {\r\n    super();\r\n    this.config = config;\r\n    this.state = {\r\n      botId: config.bot.id,\r\n      status: 'initializing',\r\n      errorCount: 0,\r\n      performance: {\r\n        tickCount: 0,\r\n        signalCount: 0,\r\n        tradeCount: 0,\r\n        errorCount: 0,\r\n        totalProfit: 0,\r\n        totalLoss: 0,\r\n        winRate: 0,\r\n        avgTradeTime: 0,\r\n        maxDrawdown: 0\r\n      },\r\n      currentStrategy: {\r\n        name: config.strategy.name,\r\n        version: config.strategy.version,\r\n        type: config.bot.strategy\r\n      }\r\n    };\r\n\r\n    // Initialize signal processing and trade decision components\r\n    this.signalProcessor = new SignalProcessor({\r\n      enableRiskValidation: true,\r\n      enableSignalEnrichment: true,\r\n      minConfidenceThreshold: config.bot.configuration?.minConfidence || 0.6,\r\n      maxSignalsPerMinute: config.bot.configuration?.maxSignalsPerMinute || 10\r\n    });\r\n\r\n    this.tradeDecisionEngine = new TradeDecisionEngine({\r\n      enablePositionManagement: true,\r\n      enableStopLoss: config.bot.riskManagement?.enableStopLoss ?? true,\r\n      enableTakeProfit: config.bot.riskManagement?.enableTakeProfit ?? true,\r\n      maxPositionsPerBot: config.bot.configuration?.maxPositions || 3,\r\n      slippageTolerance: config.bot.riskManagement?.maxSlippage || 0.1\r\n    }, config.tradeExecutor);\r\n\r\n    // Initialize enhanced state management\r\n    this.stateManager = config.stateManager || new StateManager({\r\n      enableIncrementalUpdates: true,\r\n      enableCompression: true,\r\n      backupInterval: 300000, // 5 minutes\r\n      maxBackups: 48,\r\n      enableIntegrityChecks: true,\r\n      autoRecovery: true,\r\n      emergencyBackupThreshold: 5\r\n    });\r\n\r\n    // Initialize enhanced graceful shutdown management\r\n    this.shutdownManager = config.shutdownManager || new GracefulShutdownManager(this.stateManager, {\r\n      gracePeriod: 60000, // 1 minute\r\n      positionTimeout: 30000,\r\n      orderTimeout: 15000,\r\n      backupTimeout: 10000,\r\n      enablePositionClosure: true,\r\n      enableOrderCancellation: true,\r\n      enableEmergencyBackup: true\r\n    });\r\n\r\n    // Set up event listeners for signal processing\r\n    this.setupSignalProcessingEvents();\r\n\r\n    // Set up event listeners for enhanced state management\r\n    this.setupStateManagementEvents();\r\n\r\n    // Set up error handling\r\n    this.on('error', (errorData) => {\r\n      if (errorData && typeof errorData === 'object' && errorData.error) {\r\n        // Already handled by explicit handleError call\r\n        return;\r\n      }\r\n      // Handle direct error emissions\r\n      this.handleError(errorData as Error, 'event-emission').catch(err => {\r\n        console.error('Failed to handle error event:', err);\r\n      });\r\n    });\r\n    process.on('SIGINT', this.gracefulShutdown.bind(this));\r\n    process.on('SIGTERM', this.gracefulShutdown.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Initialize the bot runtime\r\n   */\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      console.log('🚀 Initializing bot runtime', {\r\n        botId: this.config.bot.id,\r\n        botName: this.config.bot.name,\r\n        strategy: this.config.bot.strategy\r\n      });\r\n\r\n      // Load and validate configuration\r\n      await this.loadConfiguration();\r\n\r\n      // Initialize strategy\r\n      await this.initializeStrategy();\r\n\r\n      // Initialize strategy execution integration\r\n      await this.initializeStrategyExecution();\r\n\r\n      // Validate exchange connection\r\n      await this.validateExchangeConnection();\r\n\r\n      // Load persisted state if exists\r\n      await this.loadPersistedState();\r\n\r\n      this.state.status = 'stopped';\r\n      \r\n      console.log('✅ Bot runtime initialized successfully', {\r\n        botId: this.config.bot.id\r\n      });\r\n\r\n      this.emit('initialized');\r\n    } catch (error) {\r\n      console.error('❌ Failed to initialize bot runtime', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      \r\n      this.state.status = 'error';\r\n      await this.handleError(\r\n        error instanceof Error ? error : new Error(String(error)), \r\n        'bot-initialization'\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start the bot execution\r\n   */\r\n  async start(): Promise<void> {\r\n    if (this.state.status === 'running') {\r\n      console.warn('⚠️ Bot is already running', {\r\n        botId: this.config.bot.id\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (this.isShuttingDown) {\r\n      throw new Error('Cannot start bot during shutdown');\r\n    }\r\n\r\n    try {\r\n      this.state.status = 'running';\r\n      this.state.startedAt = new Date();\r\n      this.state.errorCount = 0;\r\n\r\n      console.log('▶️ Starting bot execution', {\r\n        botId: this.config.bot.id,\r\n        checkInterval: this.config.checkInterval\r\n      });\r\n\r\n      // Start the main execution loop\r\n      this.intervalId = setInterval(\r\n        this.executionTick.bind(this),\r\n        this.config.checkInterval\r\n      );\r\n\r\n      // Update database status\r\n      await this.updateDatabaseStatus('running');\r\n\r\n      this.emit('started');\r\n    } catch (error) {\r\n      this.state.status = 'error';\r\n      this.state.lastError = error instanceof Error ? error.message : String(error);\r\n      \r\n      console.error('❌ Failed to start bot', {\r\n        botId: this.config.bot.id,\r\n        error: this.state.lastError\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pause the bot execution\r\n   */\r\n  async pause(): Promise<void> {\r\n    if (this.state.status !== 'running') {\r\n      console.warn('⚠️ Bot is not running, cannot pause', {\r\n        botId: this.config.bot.id,\r\n        currentStatus: this.state.status\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.state.status = 'paused';\r\n    \r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId);\r\n      this.intervalId = undefined;\r\n    }\r\n\r\n    await this.updateDatabaseStatus('paused');\r\n\r\n    console.log('⏸️ Bot execution paused', {\r\n      botId: this.config.bot.id\r\n    });\r\n\r\n    this.emit('paused');\r\n  }\r\n\r\n  /**\r\n   * Resume the bot execution\r\n   */\r\n  async resume(): Promise<void> {\r\n    if (this.state.status !== 'paused') {\r\n      console.warn('⚠️ Bot is not paused, cannot resume', {\r\n        botId: this.config.bot.id,\r\n        currentStatus: this.state.status\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.state.status = 'running';\r\n    \r\n    this.intervalId = setInterval(\r\n      this.executionTick.bind(this),\r\n      this.config.checkInterval\r\n    );\r\n\r\n    await this.updateDatabaseStatus('running');\r\n\r\n    console.log('▶️ Bot execution resumed', {\r\n      botId: this.config.bot.id\r\n    });\r\n\r\n    this.emit('resumed');\r\n  }\r\n\r\n  /**\r\n   * Stop the bot execution\r\n   */\r\n  async stop(): Promise<void> {\r\n    if (this.state.status === 'stopped') {\r\n      console.warn('⚠️ Bot is already stopped', {\r\n        botId: this.config.bot.id\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.state.status = 'stopping';\r\n\r\n    console.log('⏹️ Stopping bot execution', {\r\n      botId: this.config.bot.id\r\n    });\r\n\r\n    // Clear the execution interval\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId);\r\n      this.intervalId = undefined;\r\n    }\r\n\r\n    // Cleanup strategy\r\n    try {\r\n      await this.config.strategy.cleanup(this.config.context);\r\n    } catch (error) {\r\n      console.warn('⚠️ Error during strategy cleanup', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n\r\n    // Shutdown strategy execution integration\r\n    try {\r\n      if (this.strategyExecutionIntegration) {\r\n        await this.strategyExecutionIntegration.shutdown();\r\n        console.log('✅ Strategy execution integration shutdown complete', {\r\n          botId: this.config.bot.id\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.warn('⚠️ Error during strategy execution integration shutdown', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n\r\n    // Persist final state\r\n    await this.persistState();\r\n\r\n    // Cleanup enhanced state management components\r\n    try {\r\n      if (this.stateManager) {\r\n        this.stateManager.shutdown();\r\n      }\r\n      if (this.shutdownManager) {\r\n        this.shutdownManager.shutdown();\r\n      }\r\n    } catch (error) {\r\n      console.warn('⚠️ Error cleaning up state management components', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n\r\n    this.state.status = 'stopped';\r\n    await this.updateDatabaseStatus('stopped');\r\n\r\n    console.log('✅ Bot execution stopped', {\r\n      botId: this.config.bot.id,\r\n      performance: this.state.performance\r\n    });\r\n\r\n    this.emit('stopped');\r\n  }\r\n\r\n  /**\r\n   * Get current bot state\r\n   */\r\n  getState(): BotState {\r\n    return { ...this.state };\r\n  }\r\n\r\n  /**\r\n   * Main execution tick - runs at configured intervals\r\n   */\r\n  private async executionTick(): Promise<void> {\r\n    if (this.state.status !== 'running' || this.isShuttingDown) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.state.lastTickAt = new Date();\r\n      this.state.performance.tickCount++;\r\n\r\n      // Execute strategy using enhanced strategy execution integration\r\n      let executionResult: StrategyExecutionResult;\r\n      \r\n      if (this.strategyExecutionIntegration) {\r\n        // Use enhanced strategy execution integration\r\n        executionResult = await this.strategyExecutionIntegration.executeStrategy();\r\n        \r\n        if (!executionResult.success) {\r\n          throw new Error(executionResult.error || 'Strategy execution failed');\r\n        }\r\n\r\n        // Extract the strategy result\r\n        const result = executionResult.result;\r\n        if (!result) {\r\n          console.warn('⚠️ Strategy execution succeeded but no result returned', {\r\n            botId: this.config.bot.id\r\n          });\r\n          return;\r\n        }\r\n\r\n        // Process successful strategy execution\r\n        if (result.action !== 'hold') {\r\n          this.state.performance.signalCount++;\r\n          \r\n          console.log('📊 Enhanced strategy signal generated', {\r\n            botId: this.config.bot.id,\r\n            action: result.action,\r\n            confidence: result.confidence,\r\n            reason: result.reason,\r\n            executionTime: executionResult.executionTime,\r\n            metrics: executionResult.metrics\r\n          });\r\n\r\n          // Process the trading signal\r\n          await this.processSignal(result);\r\n        }\r\n\r\n        // Emit enhanced tick event for monitoring\r\n        this.emit('tick', {\r\n          botId: this.config.bot.id,\r\n          timestamp: this.state.lastTickAt,\r\n          result,\r\n          executionMetrics: executionResult.metrics,\r\n          executionTime: executionResult.executionTime\r\n        });\r\n\r\n      } else {\r\n        // Fallback to original strategy execution\r\n        const result = await this.config.strategy.execute(this.config.context);\r\n\r\n        if (result.action !== 'hold') {\r\n          this.state.performance.signalCount++;\r\n          \r\n          console.log('📊 Strategy signal generated (fallback)', {\r\n            botId: this.config.bot.id,\r\n            action: result.action,\r\n            confidence: result.confidence,\r\n            reason: result.reason\r\n          });\r\n\r\n          // Process the trading signal\r\n          await this.processSignal(result);\r\n        }\r\n\r\n        // Emit tick event for monitoring\r\n        this.emit('tick', {\r\n          botId: this.config.bot.id,\r\n          timestamp: this.state.lastTickAt,\r\n          result\r\n        });\r\n      }\r\n\r\n    } catch (error) {\r\n      this.state.performance.errorCount++;\r\n      \r\n      console.error('❌ Error in execution tick', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error),\r\n        errorCount: this.state.errorCount\r\n      });\r\n\r\n      // Use enhanced error handling\r\n      await this.handleError(\r\n        error instanceof Error ? error : new Error(String(error)), \r\n        'execution-tick'\r\n      );\r\n\r\n      // Check if we should stop due to too many errors\r\n      if (this.state.errorCount >= this.config.maxRetries) {\r\n        console.error('🚨 Too many errors, stopping bot', {\r\n          botId: this.config.bot.id,\r\n          errorCount: this.state.errorCount,\r\n          maxRetries: this.config.maxRetries\r\n        });\r\n\r\n        await this.stop();\r\n        return;\r\n      }\r\n\r\n      // Exponential backoff for retries\r\n      const delay = this.config.retryDelay * Math.pow(2, this.state.errorCount - 1);\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load and validate bot configuration\r\n   */\r\n  private async loadConfiguration(): Promise<void> {\r\n    // Validate required configuration fields\r\n    if (!this.config.bot.configuration) {\r\n      throw new Error('Bot configuration is missing');\r\n    }\r\n\r\n    if (!this.config.bot.exchangeApiKeyId) {\r\n      throw new Error('Exchange API key ID is missing');\r\n    }\r\n\r\n    // Load exchange API credentials\r\n    const apiKeyResult = await database.query(\r\n      'SELECT * FROM exchange_api_keys WHERE id = $1 AND user_id = $2 AND is_active = true',\r\n      [this.config.bot.exchangeApiKeyId, this.config.bot.userId]\r\n    );\r\n\r\n    if (apiKeyResult.length === 0) {\r\n      throw new Error('Exchange API key not found or inactive');\r\n    }\r\n\r\n    console.log('✅ Configuration loaded successfully', {\r\n      botId: this.config.bot.id,\r\n      exchange: this.config.bot.exchange,\r\n      strategy: this.config.bot.strategy\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize the trading strategy\r\n   */\r\n  private async initializeStrategy(): Promise<void> {\r\n    try {\r\n      await this.config.strategy.initialize(this.config.context);\r\n      \r\n      console.log('✅ Strategy initialized successfully', {\r\n        botId: this.config.bot.id,\r\n        strategy: this.config.bot.strategy\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Failed to initialize strategy', {\r\n        botId: this.config.bot.id,\r\n        strategy: this.config.bot.strategy,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize strategy execution integration\r\n   */\r\n  private async initializeStrategyExecution(): Promise<void> {\r\n    try {\r\n      // Use provided strategy execution integration or create default one\r\n      if (this.config.strategyExecutionIntegration) {\r\n        this.strategyExecutionIntegration = this.config.strategyExecutionIntegration;\r\n      } else {\r\n        // Create default strategy execution integration\r\n        const strategyConfig: StrategyExecutionConfig = {\r\n          botId: this.config.bot.id,\r\n          strategyType: this.config.bot.strategy as StrategyType,\r\n          strategyConfig: {\r\n            type: this.config.bot.strategy,\r\n            parameters: this.config.bot.configuration || {}\r\n          },\r\n          executionInterval: this.config.checkInterval,\r\n          enableDynamicLoading: true,\r\n          enablePerformanceTracking: true,\r\n          maxExecutionTime: 30000, // 30 seconds\r\n          retryAttempts: this.config.maxRetries\r\n        };\r\n\r\n        this.strategyExecutionIntegration = new StrategyExecutionIntegration(\r\n          strategyConfig,\r\n          this.config.context\r\n        );\r\n      }\r\n\r\n      // Initialize the strategy execution integration\r\n      await this.strategyExecutionIntegration.initialize();\r\n\r\n      // Set up event listeners for strategy execution\r\n      this.strategyExecutionIntegration.on('strategy-executed', (data) => {\r\n        this.emit('strategy-executed', data);\r\n      });\r\n\r\n      this.strategyExecutionIntegration.on('strategy-execution-error', (data) => {\r\n        this.emit('strategy-execution-error', data);\r\n      });\r\n\r\n      this.strategyExecutionIntegration.on('strategy-swapped', (data) => {\r\n        console.log('🔄 Strategy swapped successfully', data);\r\n        this.emit('strategy-swapped', data);\r\n      });\r\n\r\n      console.log('✅ Strategy execution integration initialized successfully', {\r\n        botId: this.config.bot.id,\r\n        strategyType: this.config.bot.strategy\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to initialize strategy execution integration', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate exchange connection\r\n   */\r\n  private async validateExchangeConnection(): Promise<void> {\r\n    try {\r\n      // This would test the exchange connection using the configured API keys\r\n      // For now, we'll simulate a successful connection\r\n      console.log('✅ Exchange connection validated', {\r\n        botId: this.config.bot.id,\r\n        exchange: this.config.bot.exchange\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Exchange connection validation failed', {\r\n        botId: this.config.bot.id,\r\n        exchange: this.config.bot.exchange,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load persisted state from enhanced state manager\r\n   */\r\n  private async loadPersistedState(): Promise<void> {\r\n    try {\r\n      console.log('🔄 Loading persisted state with enhanced state manager', {\r\n        botId: this.config.bot.id\r\n      });\r\n\r\n      const snapshot = await this.stateManager.loadSnapshot(this.config.bot.id);\r\n      \r\n      if (snapshot) {\r\n        // Merge persisted state with current state\r\n        this.state = {\r\n          ...this.state,\r\n          status: 'stopped', // Always start as stopped for safety\r\n          startedAt: undefined, // Will be set when starting\r\n          errorCount: snapshot.state.runtimeMetrics?.errorCount || this.state.errorCount,\r\n          lastError: snapshot.state.runtimeMetrics?.lastError || this.state.lastError,\r\n          performance: {\r\n            tickCount: snapshot.state.runtimeMetrics?.tickCount || this.state.performance.tickCount,\r\n            signalCount: this.state.performance.signalCount, // Keep current as this is runtime-specific\r\n            tradeCount: snapshot.state.performance?.totalTrades || this.state.performance.tradeCount,\r\n            errorCount: snapshot.state.performance?.errorCount || this.state.performance.errorCount,\r\n            totalProfit: snapshot.state.performance?.totalProfit || this.state.performance.totalProfit,\r\n            totalLoss: snapshot.state.performance?.totalLoss || this.state.performance.totalLoss,\r\n            winRate: snapshot.state.performance?.winRate || this.state.performance.winRate,\r\n            avgTradeTime: snapshot.state.performance?.avgTradeTime || this.state.performance.avgTradeTime,\r\n            maxDrawdown: snapshot.state.performance?.maxDrawdown || this.state.performance.maxDrawdown\r\n          },\r\n          positions: snapshot.state.positions || [],\r\n          orders: snapshot.state.orders || [],\r\n          strategy: snapshot.state.strategy\r\n        };\r\n\r\n        console.log('✅ Enhanced persisted state loaded', {\r\n          botId: this.config.bot.id,\r\n          version: snapshot.version,\r\n          timestamp: snapshot.timestamp,\r\n          performance: this.state.performance\r\n        });\r\n\r\n        this.emit('state-loaded', { snapshot, state: this.state });\r\n      } else {\r\n        console.log('ℹ️ No persisted state found, starting fresh', {\r\n          botId: this.config.bot.id\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.warn('⚠️ Failed to load persisted state, attempting recovery', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n\r\n      // Attempt recovery from backup\r\n      try {\r\n        const recoveredSnapshot = await this.stateManager.recoverFromBackup(this.config.bot.id, {\r\n          restorePositions: true,\r\n          restoreOrders: true,\r\n          restoreConfiguration: true,\r\n          restoreStrategy: true,\r\n          validateIntegrity: true\r\n        });\r\n\r\n        this.state = {\r\n          ...this.state,\r\n          status: 'stopped',\r\n          errorCount: recoveredSnapshot.state.runtimeMetrics?.errorCount || this.state.errorCount,\r\n          lastError: recoveredSnapshot.state.runtimeMetrics?.lastError || this.state.lastError,\r\n          performance: {\r\n            tickCount: recoveredSnapshot.state.runtimeMetrics?.tickCount || this.state.performance.tickCount,\r\n            signalCount: this.state.performance.signalCount,\r\n            tradeCount: recoveredSnapshot.state.performance?.totalTrades || this.state.performance.tradeCount,\r\n            errorCount: recoveredSnapshot.state.performance?.errorCount || this.state.performance.errorCount,\r\n            totalProfit: recoveredSnapshot.state.performance?.totalProfit || this.state.performance.totalProfit,\r\n            totalLoss: recoveredSnapshot.state.performance?.totalLoss || this.state.performance.totalLoss,\r\n            winRate: recoveredSnapshot.state.performance?.winRate || this.state.performance.winRate,\r\n            avgTradeTime: recoveredSnapshot.state.performance?.avgTradeTime || this.state.performance.avgTradeTime,\r\n            maxDrawdown: recoveredSnapshot.state.performance?.maxDrawdown || this.state.performance.maxDrawdown\r\n          },\r\n          positions: recoveredSnapshot.state.positions || [],\r\n          orders: recoveredSnapshot.state.orders || [],\r\n          strategy: recoveredSnapshot.state.strategy\r\n        };\r\n\r\n        console.log('✅ State recovered from backup', {\r\n          botId: this.config.bot.id,\r\n          version: recoveredSnapshot.version\r\n        });\r\n\r\n        this.emit('state-recovered', { recoveredSnapshot, state: this.state });\r\n      } catch (recoveryError) {\r\n        console.error('❌ Failed to recover state from backup', {\r\n          botId: this.config.bot.id,\r\n          error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError)\r\n        });\r\n        // Continue with fresh state\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Persist current state using enhanced state manager\r\n   */\r\n  private async persistState(): Promise<void> {\r\n    try {\r\n      const additionalData = {\r\n        positions: this.state.positions || [],\r\n        orders: this.state.orders || [],\r\n        strategy: this.state.strategy || {\r\n          type: this.config.bot.strategy,\r\n          parameters: this.config.bot.configuration || {},\r\n          indicators: {},\r\n          signals: []\r\n        }\r\n      };\r\n\r\n      const snapshot = await this.stateManager.createSnapshot(\r\n        this.config.bot.id,\r\n        this.state,\r\n        additionalData\r\n      );\r\n\r\n      await this.stateManager.saveSnapshot(snapshot);\r\n\r\n      console.debug('💾 Enhanced state persisted successfully', {\r\n        botId: this.config.bot.id,\r\n        version: snapshot.version,\r\n        timestamp: snapshot.timestamp\r\n      });\r\n\r\n      this.emit('state-persisted', { snapshot });\r\n    } catch (error) {\r\n      console.warn('⚠️ Failed to persist enhanced state', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n\r\n      // Fallback to legacy persistence if enhanced fails\r\n      try {\r\n        await this.legacyPersistState();\r\n      } catch (fallbackError) {\r\n        console.error('❌ Legacy state persistence also failed', {\r\n          botId: this.config.bot.id,\r\n          error: fallbackError instanceof Error ? fallbackError.message : String(fallbackError)\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Legacy state persistence (fallback)\r\n   */\r\n  private async legacyPersistState(): Promise<void> {\r\n    const stateJson = JSON.stringify({\r\n      performance: this.state.performance,\r\n      errorCount: this.state.errorCount,\r\n      lastTickAt: this.state.lastTickAt\r\n    });\r\n\r\n    await database.query(`\r\n      INSERT INTO bot_states (bot_id, state, updated_at)\r\n      VALUES ($1, $2, NOW())\r\n      ON CONFLICT (bot_id)\r\n      DO UPDATE SET state = $2, updated_at = NOW()\r\n    `, [this.config.bot.id, stateJson]);\r\n  }\r\n\r\n  /**\r\n   * Update position in state\r\n   */\r\n  updatePosition(symbol: string, position: any): void {\r\n    if (!this.state.positions) {\r\n      this.state.positions = [];\r\n    }\r\n\r\n    const existingIndex = this.state.positions.findIndex(p => p.symbol === symbol);\r\n    if (existingIndex >= 0) {\r\n      if (position.size === 0) {\r\n        // Remove closed position\r\n        this.state.positions.splice(existingIndex, 1);\r\n      } else {\r\n        // Update existing position\r\n        this.state.positions[existingIndex] = {\r\n          symbol,\r\n          size: position.size,\r\n          entryPrice: position.entryPrice,\r\n          currentPrice: position.currentPrice,\r\n          pnl: position.pnl,\r\n          openedAt: this.state.positions.at(existingIndex)?.openedAt || new Date()\r\n        };\r\n      }\r\n    } else if (position.size !== 0) {\r\n      // Add new position\r\n      this.state.positions.push({\r\n        symbol,\r\n        size: position.size,\r\n        entryPrice: position.entryPrice,\r\n        currentPrice: position.currentPrice,\r\n        pnl: position.pnl,\r\n        openedAt: new Date()\r\n      });\r\n    }\r\n\r\n    // Update state incrementally\r\n    this.stateManager.updateState(this.config.bot.id, {\r\n      positions: this.state.positions\r\n    }).catch(error => {\r\n      console.warn('Failed to update position state', { symbol, error: error.message });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update order in state\r\n   */\r\n  updateOrder(order: any): void {\r\n    if (!this.state.orders) {\r\n      this.state.orders = [];\r\n    }\r\n\r\n    const existingIndex = this.state.orders.findIndex(o => o.id === order.id);\r\n    if (existingIndex >= 0) {\r\n      if (order.status === 'filled' || order.status === 'cancelled') {\r\n        // Remove completed orders\r\n        this.state.orders.splice(existingIndex, 1);\r\n      } else {\r\n        // Update existing order\r\n        this.state.orders[existingIndex] = {\r\n          id: order.id,\r\n          symbol: order.symbol,\r\n          type: order.type,\r\n          status: order.status,\r\n          size: order.size,\r\n          price: order.price,\r\n          createdAt: this.state.orders.at(existingIndex)?.createdAt || new Date()\r\n        };\r\n      }\r\n    } else {\r\n      // Add new order\r\n      this.state.orders.push({\r\n        id: order.id,\r\n        symbol: order.symbol,\r\n        type: order.type,\r\n        status: order.status,\r\n        size: order.size,\r\n        price: order.price,\r\n        createdAt: new Date()\r\n      });\r\n    }\r\n\r\n    // Update state incrementally\r\n    this.stateManager.updateState(this.config.bot.id, {\r\n      orders: this.state.orders\r\n    }).catch(error => {\r\n      console.warn('Failed to update order state', { orderId: order.id, error: error.message });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create scheduled backup\r\n   */\r\n  async createScheduledBackup(): Promise<void> {\r\n    try {\r\n      await this.stateManager.createBackup(\r\n        this.config.bot.id,\r\n        'scheduled',\r\n        'Scheduled backup',\r\n        this.state,\r\n        {\r\n          positions: this.state.positions || [],\r\n          orders: this.state.orders || [],\r\n          strategy: this.state.strategy\r\n        }\r\n      );\r\n\r\n      console.log('📦 Scheduled backup created', {\r\n        botId: this.config.bot.id\r\n      });\r\n    } catch (error) {\r\n      console.warn('⚠️ Failed to create scheduled backup', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create manual backup\r\n   */\r\n  async createManualBackup(reason: string): Promise<void> {\r\n    try {\r\n      await this.stateManager.createBackup(\r\n        this.config.bot.id,\r\n        'manual',\r\n        reason,\r\n        this.state,\r\n        {\r\n          positions: this.state.positions || [],\r\n          orders: this.state.orders || [],\r\n          strategy: this.state.strategy\r\n        }\r\n      );\r\n\r\n      console.log('📦 Manual backup created', {\r\n        botId: this.config.bot.id,\r\n        reason\r\n      });\r\n    } catch (error) {\r\n      console.warn('⚠️ Failed to create manual backup', {\r\n        botId: this.config.bot.id,\r\n        reason,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get state statistics\r\n   */\r\n  getStateStatistics(): any {\r\n    return {\r\n      botId: this.state.botId,\r\n      status: this.state.status,\r\n      uptime: this.state.startedAt ? Date.now() - this.state.startedAt.getTime() : 0,\r\n      performance: this.state.performance,\r\n      positionsCount: this.state.positions?.length || 0,\r\n      ordersCount: this.state.orders?.length || 0,\r\n      lastTickAt: this.state.lastTickAt,\r\n      errorCount: this.state.errorCount,\r\n      lastError: this.state.lastError\r\n    };\r\n  }\r\n  private async updateDatabaseStatus(status: Bot['status']): Promise<void> {\r\n    try {\r\n      await database.query(\r\n        'UPDATE bots SET status = $1, updated_at = NOW() WHERE id = $2',\r\n        [status, this.config.bot.id]\r\n      );\r\n    } catch (error) {\r\n      console.warn('⚠️ Failed to update database status', {\r\n        botId: this.config.bot.id,\r\n        status,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process trading signals from strategy with comprehensive pipeline\r\n   */\r\n  private async processSignal(signal: StrategyResult): Promise<void> {\r\n    try {\r\n      console.log('📊 Starting comprehensive signal processing', {\r\n        botId: this.config.bot.id,\r\n        action: signal.action,\r\n        confidence: signal.confidence,\r\n        reason: signal.reason\r\n      });\r\n\r\n      // Step 1: Process signal through signal processor\r\n      const processedSignal: ProcessedSignal | null = await this.signalProcessor.processSignal(\r\n        signal,\r\n        this.config.bot,\r\n        this.config.context\r\n      );\r\n\r\n      if (!processedSignal) {\r\n        console.warn('⚠️ Signal rejected by signal processor', {\r\n          botId: this.config.bot.id,\r\n          action: signal.action\r\n        });\r\n        return;\r\n      }\r\n\r\n      console.log('✅ Signal processed successfully', {\r\n        botId: this.config.bot.id,\r\n        signalId: processedSignal.processingMetadata.signalId,\r\n        riskScore: processedSignal.riskAssessment.riskScore,\r\n        processingTime: processedSignal.processingMetadata.processingTimeMs\r\n      });\r\n\r\n      // Step 2: Make trade decision\r\n      const tradeDecision: TradeDecision = await this.tradeDecisionEngine.makeTradeDecision(\r\n        processedSignal,\r\n        this.config.bot,\r\n        this.config.context\r\n      );\r\n\r\n      if (!tradeDecision.approved) {\r\n        console.warn('⚠️ Trade rejected by decision engine', {\r\n          botId: this.config.bot.id,\r\n          signalId: processedSignal.processingMetadata.signalId,\r\n          reason: tradeDecision.reason\r\n        });\r\n        return;\r\n      }\r\n\r\n      console.log('✅ Trade decision approved', {\r\n        botId: this.config.bot.id,\r\n        signalId: processedSignal.processingMetadata.signalId,\r\n        estimatedCost: tradeDecision.estimatedCost,\r\n        action: tradeDecision.action\r\n      });\r\n\r\n      // Step 3: Execute the trade\r\n      const executionResult: ExecutionResult = await this.tradeDecisionEngine.executeTrade(\r\n        tradeDecision,\r\n        processedSignal,\r\n        this.config.bot,\r\n        this.config.context\r\n      );\r\n\r\n      if (executionResult.success) {\r\n        // Update performance metrics\r\n        this.state.performance.tradeCount++;\r\n        \r\n        console.log('🎉 Trade executed successfully', {\r\n          botId: this.config.bot.id,\r\n          orderId: executionResult.order?.id,\r\n          executionTime: executionResult.executionTime,\r\n          positionCreated: !!executionResult.position\r\n        });\r\n\r\n        // Emit successful trade event\r\n        this.emit('trade-completed', {\r\n          botId: this.config.bot.id,\r\n          signal: processedSignal,\r\n          decision: tradeDecision,\r\n          result: executionResult,\r\n          timestamp: new Date()\r\n        });\r\n\r\n        // Update bot performance in database\r\n        await this.updateBotPerformance(executionResult);\r\n\r\n      } else {\r\n        console.error('❌ Trade execution failed', {\r\n          botId: this.config.bot.id,\r\n          signalId: processedSignal.processingMetadata.signalId,\r\n          error: executionResult.error,\r\n          executionTime: executionResult.executionTime\r\n        });\r\n\r\n        // Emit failed trade event\r\n        this.emit('trade-failed', {\r\n          botId: this.config.bot.id,\r\n          signal: processedSignal,\r\n          decision: tradeDecision,\r\n          error: executionResult.error,\r\n          timestamp: new Date()\r\n        });\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error('❌ Critical error in signal processing pipeline', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n\r\n      this.emit('signal-processing-error', {\r\n        botId: this.config.bot.id,\r\n        originalSignal: signal,\r\n        error: error instanceof Error ? error.message : String(error),\r\n        timestamp: new Date()\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up event listeners for signal processing components\r\n   */\r\n  private setupSignalProcessingEvents(): void {\r\n    // Signal processor events\r\n    this.signalProcessor.on('signal-processed', (event) => {\r\n      console.log('📊 Signal processor event', event);\r\n      this.emit('signal-validated', event);\r\n    });\r\n\r\n    this.signalProcessor.on('signal-error', (event) => {\r\n      console.error('❌ Signal processor error', event);\r\n      this.emit('signal-validation-failed', event);\r\n    });\r\n\r\n    // Trade decision engine events\r\n    this.tradeDecisionEngine.on('trade-executed', (event) => {\r\n      console.log('🚀 Trade execution event', event);\r\n      this.emit('order-placed', event);\r\n    });\r\n\r\n    this.tradeDecisionEngine.on('trade-failed', (event) => {\r\n      console.error('❌ Trade execution failed event', event);\r\n      this.emit('order-failed', event);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up event listeners for enhanced state management\r\n   */\r\n  private setupStateManagementEvents(): void {\r\n    // State manager events\r\n    this.stateManager.on('snapshot-saved', (snapshot) => {\r\n      console.debug('💾 State snapshot saved', {\r\n        botId: this.config.bot.id,\r\n        version: snapshot.version\r\n      });\r\n    });\r\n\r\n    this.stateManager.on('backup-created', (backup) => {\r\n      console.log('📦 Backup created', {\r\n        botId: this.config.bot.id,\r\n        backupId: backup.id,\r\n        type: backup.type,\r\n        size: backup.size\r\n      });\r\n    });\r\n\r\n    this.stateManager.on('state-recovered', (event) => {\r\n      console.log('🔄 State recovered', {\r\n        botId: this.config.bot.id,\r\n        backupId: event.backup.id,\r\n        recoveryTime: event.backup.createdAt\r\n      });\r\n    });\r\n\r\n    this.stateManager.on('scheduled-backup-required', async () => {\r\n      await this.createScheduledBackup();\r\n    });\r\n\r\n    // Shutdown manager events\r\n    this.shutdownManager.on('shutdown-initiated', (context) => {\r\n      console.log('🔄 Enhanced shutdown initiated', {\r\n        botId: context.botId,\r\n        reason: context.reason\r\n      });\r\n    });\r\n\r\n    this.shutdownManager.on('shutdown-completed', (context) => {\r\n      console.log('✅ Enhanced shutdown completed', {\r\n        botId: context.botId,\r\n        duration: Date.now() - context.startedAt.getTime(),\r\n        completedSteps: context.completedSteps.length\r\n      });\r\n    });\r\n\r\n    this.shutdownManager.on('shutdown-failed', (event) => {\r\n      console.error('❌ Enhanced shutdown failed', {\r\n        botId: event.context.botId,\r\n        error: event.error instanceof Error ? event.error.message : String(event.error)\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update bot performance metrics in database\r\n   */\r\n  private async updateBotPerformance(executionResult: ExecutionResult): Promise<void> {\r\n    try {\r\n      // Calculate performance metrics\r\n      const performance = {\r\n        totalTrades: this.state.performance.tradeCount,\r\n        totalSignals: this.state.performance.signalCount,\r\n        totalTicks: this.state.performance.tickCount,\r\n        errorCount: this.state.performance.errorCount,\r\n        lastTradeAt: new Date(),\r\n        avgExecutionTime: executionResult.executionTime\r\n      };\r\n\r\n      // Update in database\r\n      await database.query(`\r\n        UPDATE bots \r\n        SET performance = $1, updated_at = NOW() \r\n        WHERE id = $2\r\n      `, [JSON.stringify(performance), this.config.bot.id]);\r\n\r\n      console.log('📈 Bot performance updated', {\r\n        botId: this.config.bot.id,\r\n        performance\r\n      });\r\n\r\n    } catch (error) {\r\n      console.warn('⚠️ Failed to update bot performance', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive bot status including signal processing stats\r\n   */\r\n  getBotStatus() {\r\n    return {\r\n      runtime: this.getState(),\r\n      signalProcessor: this.signalProcessor.getStats(),\r\n      tradeDecisionEngine: this.tradeDecisionEngine.getStats(),\r\n      activePositions: this.tradeDecisionEngine.getActivePositions(),\r\n      pendingOrders: this.tradeDecisionEngine.getPendingOrders()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle errors with retry logic and recovery management\r\n   */\r\n  private async handleError(error: Error, operation = 'unknown'): Promise<void> {\r\n    this.state.lastError = error.message;\r\n    this.state.errorCount++;\r\n    \r\n    console.error('🚨 Bot runtime error', {\r\n      botId: this.config.bot.id,\r\n      operation,\r\n      error: error.message,\r\n      stack: error.stack,\r\n      errorCount: this.state.errorCount\r\n    });\r\n\r\n    // Use error recovery manager if available\r\n    if (this.config.errorRecoveryManager) {\r\n      try {\r\n        const recovered = await this.config.errorRecoveryManager.handleError(error, {\r\n          botId: this.config.bot.id,\r\n          operation,\r\n          metadata: {\r\n            state: this.state,\r\n            errorCount: this.state.errorCount,\r\n            strategy: this.config.bot.strategy\r\n          }\r\n        });\r\n\r\n        if (recovered) {\r\n          console.log('✅ Error recovery successful', {\r\n            botId: this.config.bot.id,\r\n            operation\r\n          });\r\n          \r\n          // Reset error count on successful recovery\r\n          this.state.errorCount = Math.max(0, this.state.errorCount - 1);\r\n        } else {\r\n          console.warn('⚠️ Error recovery failed', {\r\n            botId: this.config.bot.id,\r\n            operation,\r\n            errorCount: this.state.errorCount\r\n          });\r\n        }\r\n      } catch (recoveryError) {\r\n        console.error('❌ Error recovery system failed', {\r\n          botId: this.config.bot.id,\r\n          operation,\r\n          originalError: error.message,\r\n          recoveryError: recoveryError instanceof Error ? recoveryError.message : String(recoveryError)\r\n        });\r\n      }\r\n    }\r\n\r\n    // Emit error event for external listeners\r\n    this.emit('error', { error, operation, botId: this.config.bot.id });\r\n\r\n    // Check if bot should be stopped due to too many errors\r\n    if (this.state.errorCount >= this.config.maxRetries) {\r\n      console.error('🚨 Too many errors, stopping bot', {\r\n        botId: this.config.bot.id,\r\n        errorCount: this.state.errorCount,\r\n        maxRetries: this.config.maxRetries\r\n      });\r\n\r\n      this.emit('critical-error', { \r\n        botId: this.config.bot.id, \r\n        errorCount: this.state.errorCount, \r\n        lastError: error.message \r\n      });\r\n\r\n      await this.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhanced graceful shutdown handler\r\n   */\r\n  private async gracefulShutdown(): Promise<void> {\r\n    if (this.shutdownPromise) {\r\n      return this.shutdownPromise;\r\n    }\r\n\r\n    this.isShuttingDown = true;\r\n\r\n    this.shutdownPromise = (async () => {\r\n      console.log('🔄 Initiating enhanced graceful shutdown', {\r\n        botId: this.config.bot.id\r\n      });\r\n\r\n      try {\r\n        // Use enhanced graceful shutdown manager\r\n        await this.shutdownManager.initiateShutdown(\r\n          this.config.bot.id,\r\n          'Process signal shutdown',\r\n          'SIGTERM',\r\n          this.state\r\n        );\r\n\r\n        // Fallback to basic stop if enhanced shutdown fails\r\n        await this.stop();\r\n        \r\n        console.log('✅ Enhanced graceful shutdown completed', {\r\n          botId: this.config.bot.id\r\n        });\r\n\r\n        this.emit('graceful-shutdown-completed', { botId: this.config.bot.id });\r\n      } catch (error) {\r\n        console.error('❌ Error during enhanced graceful shutdown', {\r\n          botId: this.config.bot.id,\r\n          error: error instanceof Error ? error.message : String(error)\r\n        });\r\n\r\n        // Emergency shutdown as last resort\r\n        try {\r\n          await this.shutdownManager.emergencyShutdown(\r\n            this.config.bot.id,\r\n            'Graceful shutdown failed'\r\n          );\r\n        } catch (emergencyError) {\r\n          console.error('❌ Emergency shutdown also failed', {\r\n            botId: this.config.bot.id,\r\n            error: emergencyError instanceof Error ? emergencyError.message : String(emergencyError)\r\n          });\r\n        }\r\n\r\n        this.emit('graceful-shutdown-failed', { \r\n          botId: this.config.bot.id, \r\n          error: error instanceof Error ? error.message : String(error)\r\n        });\r\n      }\r\n    })();\r\n\r\n    return this.shutdownPromise;\r\n  }\r\n\r\n  /**\r\n   * Switch strategy at runtime without stopping the bot\r\n   */\r\n  async switchStrategy(\r\n    newStrategyType: StrategyType,\r\n    newConfig: StrategyConfig,\r\n    options: StrategySwapOptions = {\r\n      preserveState: true,\r\n      validateFirst: true,\r\n      rollbackOnError: true\r\n    },\r\n    pluginId?: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      const wasRunning = this.state.status === 'running';\r\n      \r\n      console.log('🔄 Switching bot strategy at runtime', {\r\n        botId: this.config.bot.id,\r\n        from: this.state.currentStrategy?.name,\r\n        to: newStrategyType,\r\n        wasRunning,\r\n        options\r\n      });\r\n\r\n      // Temporarily pause execution if running\r\n      if (wasRunning) {\r\n        await this.pause();\r\n      }\r\n\r\n      // Use dynamic strategy loader to switch strategy\r\n      const switchResult = await dynamicStrategyLoader.switchStrategy(\r\n        this.config.bot.id,\r\n        newStrategyType,\r\n        newConfig,\r\n        this.config.context,\r\n        options,\r\n        pluginId\r\n      );\r\n\r\n      if (!switchResult.success) {\r\n        console.error('❌ Strategy switch failed', {\r\n          botId: this.config.bot.id,\r\n          error: switchResult.error\r\n        });\r\n\r\n        // Resume if it was running before\r\n        if (wasRunning && this.state.status === 'paused') {\r\n          await this.resume();\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      // Update runtime configuration with new strategy\r\n      this.config.strategy = switchResult.strategy!;\r\n      this.state.currentStrategy = {\r\n        name: switchResult.strategy!.name,\r\n        version: switchResult.strategy!.version,\r\n        type: newStrategyType\r\n      };\r\n\r\n      // Re-initialize strategy in the runtime context\r\n      await this.initializeStrategy();\r\n\r\n      // Resume execution if it was running before\r\n      if (wasRunning) {\r\n        await this.resume();\r\n      }\r\n\r\n      console.log('✅ Strategy switched successfully in bot runtime', {\r\n        botId: this.config.bot.id,\r\n        newStrategy: this.state.currentStrategy\r\n      });\r\n\r\n      this.emit('strategy-switched', {\r\n        botId: this.config.bot.id,\r\n        newStrategy: this.state.currentStrategy,\r\n        preservedState: options.preserveState\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to switch strategy in bot runtime', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n\r\n      this.state.lastError = error instanceof Error ? error.message : String(error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rollback to previous strategy version\r\n   */\r\n  async rollbackStrategy(): Promise<boolean> {\r\n    try {\r\n      const wasRunning = this.state.status === 'running';\r\n\r\n      console.log('🔄 Rolling back bot strategy', {\r\n        botId: this.config.bot.id,\r\n        currentStrategy: this.state.currentStrategy,\r\n        wasRunning\r\n      });\r\n\r\n      // Temporarily pause execution if running\r\n      if (wasRunning) {\r\n        await this.pause();\r\n      }\r\n\r\n      // Use dynamic strategy loader to rollback\r\n      const rollbackResult = await dynamicStrategyLoader.rollbackToPreviousVersion(\r\n        this.config.bot.id,\r\n        this.config.context\r\n      );\r\n\r\n      if (!rollbackResult.success) {\r\n        console.error('❌ Strategy rollback failed', {\r\n          botId: this.config.bot.id,\r\n          error: rollbackResult.error\r\n        });\r\n\r\n        // Resume if it was running before\r\n        if (wasRunning && this.state.status === 'paused') {\r\n          await this.resume();\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      // Update runtime configuration with rolled back strategy\r\n      this.config.strategy = rollbackResult.strategy!;\r\n      this.state.currentStrategy = {\r\n        name: rollbackResult.strategy!.name,\r\n        version: rollbackResult.strategy!.version,\r\n        type: rollbackResult.version!.strategyType\r\n      };\r\n\r\n      // Re-initialize strategy in the runtime context\r\n      await this.initializeStrategy();\r\n\r\n      // Resume execution if it was running before\r\n      if (wasRunning) {\r\n        await this.resume();\r\n      }\r\n\r\n      console.log('✅ Strategy rollback successful in bot runtime', {\r\n        botId: this.config.bot.id,\r\n        rolledBackStrategy: this.state.currentStrategy\r\n      });\r\n\r\n      this.emit('strategy-rollback', {\r\n        botId: this.config.bot.id,\r\n        rolledBackStrategy: this.state.currentStrategy\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to rollback strategy in bot runtime', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n\r\n      this.state.lastError = error instanceof Error ? error.message : String(error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current strategy information\r\n   */\r\n  getCurrentStrategyInfo(): {\r\n    name: string;\r\n    version: string;\r\n    type: string;\r\n    performance?: any;\r\n  } | null {\r\n    if (!this.state.currentStrategy) {\r\n      return null;\r\n    }\r\n\r\n    const performance = dynamicStrategyLoader.getPerformanceMetrics(this.config.bot.id);\r\n    \r\n    return {\r\n      ...this.state.currentStrategy,\r\n      performance\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set or update the trade executor\r\n   */\r\n  setTradeExecutor(tradeExecutor: TradeExecutor): void {\r\n    this.config.tradeExecutor = tradeExecutor;\r\n    this.tradeDecisionEngine.setTradeExecutor(tradeExecutor);\r\n    \r\n    console.log('✅ Trade executor configured for bot runtime', {\r\n      botId: this.config.bot.id\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Hot-swap strategy without stopping the bot\r\n   */\r\n  async hotSwapStrategy(\r\n    newStrategyType: StrategyType,\r\n    newStrategyConfig: StrategyConfig\r\n  ): Promise<boolean> {\r\n    try {\r\n      console.log('🔄 Initiating hot strategy swap in bot runtime', {\r\n        botId: this.config.bot.id,\r\n        currentStrategy: this.config.bot.strategy,\r\n        newStrategy: newStrategyType\r\n      });\r\n\r\n      if (!this.strategyExecutionIntegration) {\r\n        console.error('❌ Strategy execution integration not available for hot swap', {\r\n          botId: this.config.bot.id\r\n        });\r\n        return false;\r\n      }\r\n\r\n      // Perform hot swap using strategy execution integration\r\n      const swapResult = await this.strategyExecutionIntegration.hotSwapStrategy(\r\n        newStrategyType,\r\n        newStrategyConfig\r\n      );\r\n\r\n      if (!swapResult.success) {\r\n        console.error('❌ Hot strategy swap failed', {\r\n          botId: this.config.bot.id,\r\n          error: swapResult.error\r\n        });\r\n        return false;\r\n      }\r\n\r\n      // Update bot configuration and state\r\n      this.config.bot.strategy = newStrategyType as any; // Type conversion for compatibility\r\n      this.config.bot.configuration = newStrategyConfig.parameters;\r\n      \r\n      this.state.currentStrategy = {\r\n        name: swapResult.strategy?.name || newStrategyType,\r\n        version: swapResult.version?.version || '1.0.0',\r\n        type: newStrategyType\r\n      };\r\n\r\n      console.log('✅ Hot strategy swap completed successfully', {\r\n        botId: this.config.bot.id,\r\n        newStrategy: newStrategyType,\r\n        version: swapResult.version?.version\r\n      });\r\n\r\n      this.emit('strategy-hot-swapped', {\r\n        botId: this.config.bot.id,\r\n        newStrategy: newStrategyType,\r\n        version: swapResult.version\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to perform hot strategy swap', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update strategy configuration dynamically\r\n   */\r\n  async updateStrategyConfig(newConfig: Partial<StrategyConfig>): Promise<boolean> {\r\n    try {\r\n      console.log('🔧 Updating strategy configuration', {\r\n        botId: this.config.bot.id,\r\n        updatedFields: Object.keys(newConfig)\r\n      });\r\n\r\n      if (!this.strategyExecutionIntegration) {\r\n        console.error('❌ Strategy execution integration not available for config update', {\r\n          botId: this.config.bot.id\r\n        });\r\n        return false;\r\n      }\r\n\r\n      // Update configuration using strategy execution integration\r\n      const updateResult = await this.strategyExecutionIntegration.updateStrategyConfig(newConfig);\r\n\r\n      if (!updateResult) {\r\n        console.error('❌ Strategy configuration update failed', {\r\n          botId: this.config.bot.id\r\n        });\r\n        return false;\r\n      }\r\n\r\n      // Update bot configuration\r\n      if (newConfig.parameters) {\r\n        this.config.bot.configuration = {\r\n          ...this.config.bot.configuration,\r\n          ...newConfig.parameters\r\n        };\r\n      }\r\n\r\n      console.log('✅ Strategy configuration updated successfully', {\r\n        botId: this.config.bot.id,\r\n        updatedFields: Object.keys(newConfig)\r\n      });\r\n\r\n      this.emit('strategy-config-updated', {\r\n        botId: this.config.bot.id,\r\n        updatedConfig: newConfig\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to update strategy configuration', {\r\n        botId: this.config.bot.id,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get enhanced strategy execution metrics\r\n   */\r\n  getStrategyExecutionMetrics(): any {\r\n    if (!this.strategyExecutionIntegration) {\r\n      return null;\r\n    }\r\n\r\n    return this.strategyExecutionIntegration.getPerformanceMetrics();\r\n  }\r\n\r\n  /**\r\n   * Reset strategy execution metrics\r\n   */\r\n  resetStrategyMetrics(): void {\r\n    if (this.strategyExecutionIntegration) {\r\n      this.strategyExecutionIntegration.resetMetrics();\r\n      \r\n      console.log('📊 Strategy execution metrics reset', {\r\n        botId: this.config.bot.id\r\n      });\r\n\r\n      this.emit('strategy-metrics-reset', {\r\n        botId: this.config.bot.id\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current strategy execution integration info\r\n   */\r\n  getStrategyExecutionInfo(): any {\r\n    if (!this.strategyExecutionIntegration) {\r\n      return {\r\n        available: false,\r\n        reason: 'Strategy execution integration not initialized'\r\n      };\r\n    }\r\n\r\n    return {\r\n      available: true,\r\n      ...this.strategyExecutionIntegration.getCurrentStrategyInfo()\r\n    };\r\n  }\r\n} ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bot-watchdog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bots.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bots.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\bots.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\dynamic-strategy-loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\enhanced-bot-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\error-recovery-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\graceful-shutdown-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\health-check.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\signal-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\state-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\strategy-execution-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\trade-decision-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\bots\\trade-executor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\config\\config-manager.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":376,"column":9,"nodeType":"CallExpression","endLine":376,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs';\r\nimport path from 'path';\r\n\r\nimport dotenv from 'dotenv';\r\nimport { z } from 'zod';\r\n\r\n/**\r\n * Environment Types\r\n */\r\nexport type Environment = 'development' | 'production' | 'test';\r\n\r\n/**\r\n * Configuration Schema\r\n * Validates all application configuration with environment-specific optimizations\r\n */\r\nconst ConfigSchema = z.object({\r\n  // Environment\r\n  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),\r\n  PORT: z.coerce.number().min(1).max(65535).default(3000),\r\n  API_VERSION: z.string().default('v1'),\r\n\r\n  // Database Configuration\r\n  DB_HOST: z.string().default('localhost'),\r\n  DB_PORT: z.coerce.number().min(1).max(65535).default(5432),\r\n  DB_NAME: z.string().default('jabbr_trading_bot'),\r\n  DB_USER: z.string().default('postgres'),\r\n  DB_PASSWORD: z.string().default(''),\r\n  DB_SSL: z.coerce.boolean().default(false),\r\n  \r\n  // Environment-optimized database pool settings\r\n  DB_POOL_MIN: z.coerce.number().min(0).default(2),\r\n  DB_POOL_MAX: z.coerce.number().min(1).default(20),\r\n  DB_POOL_IDLE_TIMEOUT: z.coerce.number().min(1000).default(30000),\r\n  DB_POOL_CONNECTION_TIMEOUT: z.coerce.number().min(1000).default(60000),\r\n\r\n  // JWT Configuration\r\n  JWT_SECRET: z.string().min(32),\r\n  JWT_EXPIRES_IN: z.string().default('24h'),\r\n\r\n  // Redis Configuration\r\n  REDIS_HOST: z.string().default('localhost'),\r\n  REDIS_PORT: z.coerce.number().min(1).max(65535).default(6379),\r\n  REDIS_PASSWORD: z.string().optional(),\r\n  REDIS_DB: z.coerce.number().min(0).default(0),\r\n  REDIS_CLUSTER_MODE: z.coerce.boolean().default(false),\r\n\r\n  // Logging Configuration\r\n  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\r\n  LOG_FILE_PATH: z.string().default('./logs/app.log'),\r\n  LOG_MAX_SIZE: z.string().default('10m'),\r\n  LOG_MAX_FILES: z.coerce.number().min(1).default(5),\r\n  LOG_JSON_FORMAT: z.coerce.boolean().default(false),\r\n\r\n  // Exchange Configuration\r\n  BYBIT_API_KEY: z.string().optional(),\r\n  BYBIT_SECRET: z.string().optional(),\r\n  BYBIT_TESTNET: z.coerce.boolean().default(true),\r\n  USE_MOCK_EXCHANGE: z.coerce.boolean().default(false),\r\n\r\n  // Performance Monitoring\r\n  ENABLE_PERFORMANCE_MONITORING: z.coerce.boolean().default(true),\r\n  PERFORMANCE_SAMPLE_RATE: z.coerce.number().min(0).max(1).default(1.0),\r\n  METRICS_COLLECTION_INTERVAL: z.coerce.number().min(1000).default(60000),\r\n  APM_SERVICE_NAME: z.string().default('jabbr-trading-bot'),\r\n  APM_ENVIRONMENT: z.string().optional(),\r\n\r\n  // Security Configuration\r\n  CORS_ORIGIN: z.string().default('http://localhost:3000'),\r\n  RATE_LIMIT_WINDOW: z.coerce.number().min(1000).default(900000),\r\n  RATE_LIMIT_MAX_REQUESTS: z.coerce.number().min(1).default(100),\r\n  BCRYPT_ROUNDS: z.coerce.number().min(4).max(20).default(10),\r\n  ENABLE_HELMET: z.coerce.boolean().default(true),\r\n  ENABLE_COMPRESSION: z.coerce.boolean().default(true),\r\n\r\n  // WebSocket Configuration\r\n  WS_PORT: z.coerce.number().min(1).max(65535).default(3001),\r\n  WS_PATH: z.string().default('/ws'),\r\n  WS_HEARTBEAT_INTERVAL: z.coerce.number().min(1000).default(30000),\r\n  WS_MAX_CONNECTIONS: z.coerce.number().min(1).default(1000),\r\n\r\n  // Cache Configuration\r\n  CACHE_TTL: z.coerce.number().min(0).default(300),\r\n  CACHE_MAX_KEYS: z.coerce.number().min(1).default(1000),\r\n  ENABLE_QUERY_CACHE: z.coerce.boolean().default(true),\r\n  CACHE_COMPRESSION: z.coerce.boolean().default(false),\r\n\r\n  // File Upload Configuration\r\n  UPLOAD_MAX_FILE_SIZE: z.coerce.number().min(1).default(10485760),\r\n  UPLOAD_ALLOWED_TYPES: z.string().default('image/jpeg,image/png,text/csv'),\r\n  UPLOAD_VIRUS_SCAN: z.coerce.boolean().default(false),\r\n\r\n  // Health Check Configuration\r\n  HEALTH_CHECK_INTERVAL: z.coerce.number().min(1000).default(30000),\r\n  HEALTH_CHECK_TIMEOUT: z.coerce.number().min(1000).default(5000),\r\n  HEALTH_CHECK_PATH: z.string().default('/health'),\r\n\r\n  // Feature Flags\r\n  ENABLE_MOCK_DATA: z.coerce.boolean().default(false),\r\n  ENABLE_TEST_ROUTES: z.coerce.boolean().default(false),\r\n  SKIP_AUTH_FOR_TESTING: z.coerce.boolean().default(false),\r\n  ENABLE_DEBUG_ROUTES: z.coerce.boolean().default(false),\r\n  ENABLE_SWAGGER_UI: z.coerce.boolean().default(false),\r\n  ENABLE_HOT_RELOAD: z.coerce.boolean().default(false),\r\n\r\n  // Advanced Features\r\n  ENABLE_ADVANCED_ANALYTICS: z.coerce.boolean().default(false),\r\n  ENABLE_MACHINE_LEARNING: z.coerce.boolean().default(false),\r\n  ENABLE_RISK_MANAGEMENT: z.coerce.boolean().default(true),\r\n  ENABLE_PORTFOLIO_OPTIMIZATION: z.coerce.boolean().default(false),\r\n\r\n  // Scaling Configuration\r\n  CLUSTER_MODE: z.coerce.boolean().default(false),\r\n  WORKER_PROCESSES: z.union([z.literal('auto'), z.coerce.number().min(1)]).default('auto'),\r\n  GRACEFUL_SHUTDOWN_TIMEOUT: z.coerce.number().min(1000).default(30000),\r\n\r\n  // Test Configuration\r\n  AUTO_MIGRATE: z.coerce.boolean().default(false),\r\n  AUTO_SEED: z.coerce.boolean().default(false),\r\n  CLEAR_DB_BEFORE_TESTS: z.coerce.boolean().default(false),\r\n  TEST_TIMEOUT: z.coerce.number().min(1000).default(30000),\r\n  API_TIMEOUT: z.coerce.number().min(1000).default(5000),\r\n  DB_QUERY_TIMEOUT: z.coerce.number().min(1000).default(10000),\r\n  JEST_MAX_WORKERS: z.coerce.number().min(1).default(4),\r\n  JEST_WORKER_IDLE_MEMORY_LIMIT: z.string().default('512MB'),\r\n\r\n  // External Services\r\n  EMAIL_SERVICE_API_KEY: z.string().optional(),\r\n  SMS_SERVICE_API_KEY: z.string().optional(),\r\n  NOTIFICATION_WEBHOOK_URL: z.string().optional(),\r\n});\r\n\r\nexport type Config = z.infer<typeof ConfigSchema>;\r\n\r\n/**\r\n * Environment-specific configuration optimizations\r\n */\r\nconst EnvironmentOptimizations = {\r\n  development: {\r\n    DB_POOL_MIN: 1,\r\n    DB_POOL_MAX: 10,\r\n    DB_POOL_IDLE_TIMEOUT: 60000,\r\n    LOG_LEVEL: 'debug' as const,\r\n    PERFORMANCE_SAMPLE_RATE: 1.0,\r\n    ENABLE_DEBUG_ROUTES: true,\r\n    ENABLE_SWAGGER_UI: true,\r\n    ENABLE_HOT_RELOAD: true,\r\n    BCRYPT_ROUNDS: 10,\r\n    CORS_ORIGIN: 'http://localhost:3000,http://localhost:3001',\r\n    RATE_LIMIT_MAX_REQUESTS: 1000,\r\n  },\r\n  production: {\r\n    DB_POOL_MIN: 5,\r\n    DB_POOL_MAX: 50,\r\n    DB_POOL_IDLE_TIMEOUT: 120000,\r\n    LOG_LEVEL: 'info' as const,\r\n    LOG_JSON_FORMAT: true,\r\n    PERFORMANCE_SAMPLE_RATE: 0.1,\r\n    ENABLE_DEBUG_ROUTES: false,\r\n    ENABLE_SWAGGER_UI: false,\r\n    ENABLE_TEST_ROUTES: false,\r\n    ENABLE_MOCK_DATA: false,\r\n    BCRYPT_ROUNDS: 12,\r\n    ENABLE_HELMET: true,\r\n    ENABLE_COMPRESSION: true,\r\n    CACHE_COMPRESSION: true,\r\n    DB_SSL: true,\r\n    CLUSTER_MODE: true,\r\n    RATE_LIMIT_MAX_REQUESTS: 100,\r\n  },\r\n  test: {\r\n    DB_POOL_MIN: 1,\r\n    DB_POOL_MAX: 5,\r\n    DB_POOL_IDLE_TIMEOUT: 10000,\r\n    DB_POOL_CONNECTION_TIMEOUT: 15000,\r\n    LOG_LEVEL: 'error' as const,\r\n    PERFORMANCE_SAMPLE_RATE: 0,\r\n    ENABLE_PERFORMANCE_MONITORING: false,\r\n    ENABLE_MOCK_DATA: true,\r\n    ENABLE_TEST_ROUTES: true,\r\n    SKIP_AUTH_FOR_TESTING: true,\r\n    BCRYPT_ROUNDS: 4,\r\n    AUTO_MIGRATE: true,\r\n    AUTO_SEED: true,\r\n    CLEAR_DB_BEFORE_TESTS: true,\r\n    USE_MOCK_EXCHANGE: true,\r\n    ENABLE_QUERY_CACHE: false,\r\n    CACHE_TTL: 60,\r\n    API_TIMEOUT: 5000,\r\n    DB_QUERY_TIMEOUT: 3000,\r\n  },\r\n};\r\n\r\n/**\r\n * Configuration Manager\r\n * Handles loading, validating, and optimizing configuration based on environment\r\n */\r\nexport class ConfigManager {\r\n  private static instance: ConfigManager;\r\n  private config: Config;\r\n  private environment: Environment;\r\n\r\n  private constructor() {\r\n    this.environment = this.detectEnvironment();\r\n    this.loadEnvironmentFile();\r\n    this.config = this.loadAndValidateConfig();\r\n    this.applyEnvironmentOptimizations();\r\n  }\r\n\r\n  /**\r\n   * Get singleton instance\r\n   */\r\n  public static getInstance(): ConfigManager {\r\n    if (!ConfigManager.instance) {\r\n      ConfigManager.instance = new ConfigManager();\r\n    }\r\n    return ConfigManager.instance;\r\n  }\r\n\r\n  /**\r\n   * Get configuration\r\n   */\r\n  public getConfig(): Config {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Get environment\r\n   */\r\n  public getEnvironment(): Environment {\r\n    return this.environment;\r\n  }\r\n\r\n  /**\r\n   * Get database configuration\r\n   */\r\n  public getDatabaseConfig() {\r\n    return {\r\n      host: this.config.DB_HOST,\r\n      port: this.config.DB_PORT,\r\n      database: this.config.DB_NAME,\r\n      user: this.config.DB_USER,\r\n      password: this.config.DB_PASSWORD,\r\n      ssl: this.config.DB_SSL,\r\n      pool: {\r\n        min: this.config.DB_POOL_MIN,\r\n        max: this.config.DB_POOL_MAX,\r\n        idleTimeoutMillis: this.config.DB_POOL_IDLE_TIMEOUT,\r\n        connectionTimeoutMillis: this.config.DB_POOL_CONNECTION_TIMEOUT,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get Redis configuration\r\n   */\r\n  public getRedisConfig() {\r\n    return {\r\n      host: this.config.REDIS_HOST,\r\n      port: this.config.REDIS_PORT,\r\n      password: this.config.REDIS_PASSWORD,\r\n      db: this.config.REDIS_DB,\r\n      clusterMode: this.config.REDIS_CLUSTER_MODE,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get performance monitoring configuration\r\n   */\r\n  public getPerformanceConfig() {\r\n    return {\r\n      enabled: this.config.ENABLE_PERFORMANCE_MONITORING,\r\n      sampleRate: this.config.PERFORMANCE_SAMPLE_RATE,\r\n      metricsInterval: this.config.METRICS_COLLECTION_INTERVAL,\r\n      serviceName: this.config.APM_SERVICE_NAME,\r\n      environment: this.config.APM_ENVIRONMENT || this.environment,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get security configuration\r\n   */\r\n  public getSecurityConfig() {\r\n    return {\r\n      corsOrigin: this.config.CORS_ORIGIN.split(','),\r\n      rateLimit: {\r\n        windowMs: this.config.RATE_LIMIT_WINDOW,\r\n        max: this.config.RATE_LIMIT_MAX_REQUESTS,\r\n      },\r\n      bcryptRounds: this.config.BCRYPT_ROUNDS,\r\n      helmet: this.config.ENABLE_HELMET,\r\n      compression: this.config.ENABLE_COMPRESSION,\r\n      jwt: {\r\n        secret: this.config.JWT_SECRET,\r\n        expiresIn: this.config.JWT_EXPIRES_IN,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get feature flags\r\n   */\r\n  public getFeatureFlags() {\r\n    return {\r\n      mockData: this.config.ENABLE_MOCK_DATA,\r\n      testRoutes: this.config.ENABLE_TEST_ROUTES,\r\n      skipAuth: this.config.SKIP_AUTH_FOR_TESTING,\r\n      debugRoutes: this.config.ENABLE_DEBUG_ROUTES,\r\n      swaggerUI: this.config.ENABLE_SWAGGER_UI,\r\n      hotReload: this.config.ENABLE_HOT_RELOAD,\r\n      advancedAnalytics: this.config.ENABLE_ADVANCED_ANALYTICS,\r\n      machineLearning: this.config.ENABLE_MACHINE_LEARNING,\r\n      riskManagement: this.config.ENABLE_RISK_MANAGEMENT,\r\n      portfolioOptimization: this.config.ENABLE_PORTFOLIO_OPTIMIZATION,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if configuration is valid for environment\r\n   */\r\n  public validateConfiguration(): { valid: boolean; errors: string[] } {\r\n    const errors: string[] = [];\r\n\r\n    // Production-specific validations\r\n    if (this.environment === 'production') {\r\n      if (this.config.JWT_SECRET.length < 64) {\r\n        errors.push('JWT_SECRET must be at least 64 characters in production');\r\n      }\r\n      if (this.config.ENABLE_DEBUG_ROUTES) {\r\n        errors.push('Debug routes must be disabled in production');\r\n      }\r\n      if (this.config.ENABLE_TEST_ROUTES) {\r\n        errors.push('Test routes must be disabled in production');\r\n      }\r\n      if (!this.config.DB_SSL) {\r\n        errors.push('Database SSL must be enabled in production');\r\n      }\r\n    }\r\n\r\n    // Development-specific validations\r\n    if (this.environment === 'development') {\r\n      if (!this.config.ENABLE_DEBUG_ROUTES) {\r\n        console.warn('Debug routes are disabled in development environment');\r\n      }\r\n    }\r\n\r\n    // Test-specific validations\r\n    if (this.environment === 'test') {\r\n      if (!this.config.USE_MOCK_EXCHANGE) {\r\n        errors.push('Mock exchange should be enabled in test environment');\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect current environment\r\n   */\r\n  private detectEnvironment(): Environment {\r\n    const env = process.env.NODE_ENV?.toLowerCase();\r\n    if (env === 'production' || env === 'test') {\r\n      return env;\r\n    }\r\n    return 'development';\r\n  }\r\n\r\n  /**\r\n   * Load environment-specific .env file\r\n   */\r\n  private loadEnvironmentFile(): void {\r\n    const envFile = path.join(process.cwd(), 'config', `.env.${this.environment}`);\r\n    \r\n    if (fs.existsSync(envFile)) {\r\n      dotenv.config({ path: envFile });\r\n      console.log(`✅ Loaded environment configuration: ${envFile}`);\r\n    } else {\r\n      console.warn(`⚠️  Environment file not found: ${envFile}`);\r\n      // Fallback to root .env file\r\n      dotenv.config({ path: path.join(process.cwd(), '../../.env') });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load and validate configuration\r\n   */\r\n  private loadAndValidateConfig(): Config {\r\n    try {\r\n      const config = ConfigSchema.parse(process.env);\r\n      console.log(`✅ Configuration validated for ${this.environment} environment`);\r\n      return config;\r\n    } catch (error) {\r\n      console.error('❌ Configuration validation failed:', error);\r\n      throw new Error(`Invalid configuration: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply environment-specific optimizations\r\n   */\r\n  private applyEnvironmentOptimizations(): void {\r\n    const optimizations = EnvironmentOptimizations[this.environment];\r\n    \r\n    // Apply optimizations\r\n    Object.assign(this.config, optimizations);\r\n    \r\n    console.log(`✅ Applied ${this.environment} environment optimizations`);\r\n    \r\n    // Log key optimizations\r\n    console.log(`📊 Database pool: ${this.config.DB_POOL_MIN}-${this.config.DB_POOL_MAX} connections`);\r\n    console.log(`📝 Log level: ${this.config.LOG_LEVEL}`);\r\n    console.log(`🔍 Performance sampling: ${this.config.PERFORMANCE_SAMPLE_RATE * 100}%`);\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const configManager = ConfigManager.getInstance();\r\nexport const config = configManager.getConfig();\r\n\r\n// Export utility functions\r\nexport function getEnvironment(): Environment {\r\n  return configManager.getEnvironment();\r\n}\r\n\r\nexport function isProduction(): boolean {\r\n  return configManager.getEnvironment() === 'production';\r\n}\r\n\r\nexport function isDevelopment(): boolean {\r\n  return configManager.getEnvironment() === 'development';\r\n}\r\n\r\nexport function isTest(): boolean {\r\n  return configManager.getEnvironment() === 'test';\r\n}\r\n\r\nexport function validateConfig(): { valid: boolean; errors: string[] } {\r\n  return configManager.validateConfiguration();\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\database\\database.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\database\\migration-runner.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdir from package \"fs/promises\" with non literal argument at index 0","line":120,"column":27,"nodeType":"CallExpression","endLine":120,"endColumn":58},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFile from package \"fs/promises\" with non literal argument at index 0","line":128,"column":31,"nodeType":"CallExpression","endLine":128,"endColumn":61},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFile from package \"fs/promises\" with non literal argument at index 0","line":344,"column":11,"nodeType":"CallExpression","endLine":344,"endColumn":52}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs/promises';\r\nimport path from 'path';\r\nimport crypto from 'crypto';\r\n\r\nimport { database } from './database.config';\r\n\r\n/**\r\n * Migration record interface\r\n */\r\ninterface Migration {\r\n  id: number;\r\n  name: string;\r\n  filename: string;\r\n  executed_at: Date;\r\n  checksum: string;\r\n}\r\n\r\n/**\r\n * Database Migration Runner\r\n * Handles executing SQL migration files and tracking migration history\r\n */\r\nexport class MigrationRunner {\r\n  private migrationsPath: string;\r\n\r\n  constructor(migrationsPath?: string) {\r\n    this.migrationsPath = migrationsPath || path.join(__dirname, 'migrations');\r\n  }\r\n\r\n  /**\r\n   * Initialize migration tracking table\r\n   */\r\n  async initializeMigrationTable(): Promise<void> {\r\n    const createTableSQL = `\r\n      CREATE TABLE IF NOT EXISTS migrations (\r\n        id SERIAL PRIMARY KEY,\r\n        name VARCHAR(255) NOT NULL UNIQUE,\r\n        filename VARCHAR(255) NOT NULL,\r\n        executed_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),\r\n        checksum VARCHAR(64) NOT NULL\r\n      );\r\n      \r\n      CREATE INDEX IF NOT EXISTS idx_migrations_name ON migrations(name);\r\n      CREATE INDEX IF NOT EXISTS idx_migrations_executed_at ON migrations(executed_at);\r\n    `;\r\n\r\n    try {\r\n      await database.query(createTableSQL);\r\n      console.log('✅ Migration tracking table initialized');\r\n    } catch (error) {\r\n      console.error('❌ Failed to initialize migration table:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pre-existing database with tables but no migration tracking\r\n   */\r\n  async handlePreExistingDatabase(): Promise<void> {\r\n    try {\r\n      // Check if key tables exist (indicating this is a pre-existing database)\r\n      const tableExistsResult = await database.query(`\r\n        SELECT table_name \r\n        FROM information_schema.tables \r\n        WHERE table_schema = 'public' \r\n        AND table_name IN ('users', 'bots', 'trades', 'positions')\r\n      `);\r\n\r\n      // If tables exist but no migrations are recorded, mark initial migrations as complete\r\n      if (tableExistsResult.length > 0) {\r\n        const executedMigrations = await this.getExecutedMigrations();\r\n        \r\n        if (executedMigrations.length === 0) {\r\n          console.log('🔍 Detected pre-existing database with tables but no migration tracking');\r\n          \r\n          // Mark initial schema as already applied\r\n          const initialMigrationFiles = await this.getMigrationFiles();\r\n          const initialSchema = initialMigrationFiles.find(m => m.name.includes('initial_schema'));\r\n          \r\n          if (initialSchema) {\r\n            await database.query(`\r\n              INSERT INTO migrations (name, filename, checksum)\r\n              VALUES ($1, $2, $3)\r\n              ON CONFLICT (name) DO NOTHING\r\n            `, [initialSchema.name, initialSchema.filename, initialSchema.checksum]);\r\n            \r\n            console.log(`✅ Marked initial schema migration as complete: ${initialSchema.name}`);\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn('⚠️ Warning: Could not check for pre-existing database:', error);\r\n      // Continue with normal migration process\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all executed migrations from database\r\n   */\r\n  async getExecutedMigrations(): Promise<Migration[]> {\r\n    try {\r\n      return await database.query<Migration>(`\r\n        SELECT id, name, filename, executed_at, checksum \r\n        FROM migrations \r\n        ORDER BY id ASC\r\n      `);\r\n    } catch (error) {\r\n      // If table doesn't exist, return empty array\r\n      if (error instanceof Error && error.message.includes('relation \"migrations\" does not exist')) {\r\n        return [];\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all migration files from filesystem\r\n   */\r\n  async getMigrationFiles(): Promise<{ name: string; filename: string; content: string; checksum: string }[]> {\r\n    try {\r\n      const files = await fs.readdir(this.migrationsPath);\r\n      const migrationFiles = files\r\n        .filter(file => file.endsWith('.sql'))\r\n        .sort(); // Ensure consistent ordering\r\n\r\n      const migrations = [];\r\n      for (const filename of migrationFiles) {\r\n        const filePath = path.join(this.migrationsPath, filename);\r\n        const content = await fs.readFile(filePath, 'utf-8');\r\n        const name = this.extractMigrationName(filename);\r\n        const checksum = this.calculateChecksum(content);\r\n\r\n        migrations.push({\r\n          name,\r\n          filename,\r\n          content,\r\n          checksum\r\n        });\r\n      }\r\n\r\n      return migrations;\r\n    } catch (error) {\r\n      console.error('❌ Failed to read migration files:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute pending migrations\r\n   */\r\n  async runMigrations(): Promise<void> {\r\n    console.log('🔄 Starting database migrations...');\r\n\r\n    // Ensure database is connected\r\n    if (!database.isConnectionActive()) {\r\n      await database.connect();\r\n    }\r\n\r\n    // Initialize migration table\r\n    await this.initializeMigrationTable();\r\n\r\n    // Check if this is a pre-existing database with tables\r\n    await this.handlePreExistingDatabase();\r\n\r\n    // Get executed migrations and available migration files\r\n    const [executedMigrations, migrationFiles] = await Promise.all([\r\n      this.getExecutedMigrations(),\r\n      this.getMigrationFiles()\r\n    ]);\r\n\r\n    // Find pending migrations\r\n    const executedNames = new Set(executedMigrations.map(m => m.name));\r\n    const pendingMigrations = migrationFiles.filter(m => !executedNames.has(m.name));\r\n\r\n    if (pendingMigrations.length === 0) {\r\n      console.log('✅ No pending migrations');\r\n      return;\r\n    }\r\n\r\n    console.log(`📋 Found ${pendingMigrations.length} pending migrations:`);\r\n    pendingMigrations.forEach(m => console.log(`   - ${m.name}`));\r\n\r\n    // Execute pending migrations\r\n    for (const migration of pendingMigrations) {\r\n      await this.executeMigration(migration);\r\n    }\r\n\r\n    console.log('✅ All migrations completed successfully');\r\n  }\r\n\r\n  /**\r\n   * Execute a single migration\r\n   */\r\n  private async executeMigration(migration: { name: string; filename: string; content: string; checksum: string }): Promise<void> {\r\n    console.log(`🔄 Executing migration: ${migration.name}`);\r\n\r\n    try {\r\n      await database.transaction(async (client) => {\r\n        // Execute the migration SQL\r\n        await client.query(migration.content);\r\n\r\n        // Record the migration in the tracking table\r\n        await client.query(`\r\n          INSERT INTO migrations (name, filename, checksum)\r\n          VALUES ($1, $2, $3)\r\n        `, [migration.name, migration.filename, migration.checksum]);\r\n      });\r\n\r\n      console.log(`✅ Migration completed: ${migration.name}`);\r\n    } catch (error) {\r\n      console.error(`❌ Migration failed: ${migration.name}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify migration integrity\r\n   */\r\n  async verifyMigrations(): Promise<{ valid: boolean; issues: string[] }> {\r\n    const issues: string[] = [];\r\n\r\n    try {\r\n      const [executedMigrations, migrationFiles] = await Promise.all([\r\n        this.getExecutedMigrations(),\r\n        this.getMigrationFiles()\r\n      ]);\r\n\r\n      // Check for missing migration files\r\n      for (const executed of executedMigrations) {\r\n        const file = migrationFiles.find(f => f.name === executed.name);\r\n        if (!file) {\r\n          issues.push(`Migration file missing: ${executed.filename}`);\r\n          continue;\r\n        }\r\n\r\n        // Check checksum integrity\r\n        if (file.checksum !== executed.checksum) {\r\n          issues.push(`Migration checksum mismatch: ${executed.name} (file may have been modified)`);\r\n        }\r\n      }\r\n\r\n      // Check for out-of-order migrations\r\n      const executedNames = executedMigrations.map(m => m.name);\r\n      const fileNames = migrationFiles.map(f => f.name);\r\n      \r\n      for (let i = 0; i < executedNames.length; i++) {\r\n        const executedName = executedNames.at(i);\r\n        const expectedName = fileNames.at(i);\r\n        \r\n        if (executedName !== expectedName) {\r\n          issues.push(`Migration order mismatch at position ${i}: expected ${expectedName}, found ${executedName}`);\r\n        }\r\n      }\r\n\r\n      return {\r\n        valid: issues.length === 0,\r\n        issues\r\n      };\r\n    } catch (error) {\r\n      issues.push(`Verification failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n      return { valid: false, issues };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get migration status\r\n   */\r\n  async getStatus(): Promise<{\r\n    executed: number;\r\n    pending: number;\r\n    total: number;\r\n    migrations: Array<{\r\n      name: string;\r\n      status: 'executed' | 'pending';\r\n      executed_at?: Date;\r\n    }>;\r\n  }> {\r\n    const [executedMigrations, migrationFiles] = await Promise.all([\r\n      this.getExecutedMigrations(),\r\n      this.getMigrationFiles()\r\n    ]);\r\n\r\n    const executedMap = new Map(executedMigrations.map(m => [m.name, m]));\r\n    \r\n    const migrations = migrationFiles.map(file => {\r\n      const executed = executedMap.get(file.name);\r\n      return {\r\n        name: file.name,\r\n        status: executed ? 'executed' as const : 'pending' as const,\r\n        executed_at: executed?.executed_at\r\n      };\r\n    });\r\n\r\n    return {\r\n      executed: executedMigrations.length,\r\n      pending: migrationFiles.length - executedMigrations.length,\r\n      total: migrationFiles.length,\r\n      migrations\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract migration name from filename\r\n   */\r\n  private extractMigrationName(filename: string): string {\r\n    // Remove .sql extension and use the filename as the name\r\n    return filename.replace(/\\.sql$/, '');\r\n  }\r\n\r\n  /**\r\n   * Calculate checksum for migration content\r\n   */\r\n  private calculateChecksum(content: string): string {\r\n    return crypto.createHash('sha256').update(content).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * Create a new migration file\r\n   */\r\n  async createMigration(name: string): Promise<string> {\r\n    const timestamp = new Date().toISOString().replace(/[:\\-T]/g, '').split('.')[0];\r\n    const filename = `${timestamp}_${name.replace(/\\s+/g, '_').toLowerCase()}.sql`;\r\n    const filepath = path.join(this.migrationsPath, filename);\r\n\r\n    const template = `-- ============================================================================\r\n-- Migration: ${filename}\r\n-- Description: ${name}\r\n-- Created: ${new Date().toISOString()}\r\n-- ============================================================================\r\n\r\n-- Add your SQL statements here\r\n\r\n-- Example:\r\n-- CREATE TABLE example (\r\n--     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\r\n--     name VARCHAR(255) NOT NULL,\r\n--     created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()\r\n-- );\r\n\r\n-- Log migration completion\r\nINSERT INTO logs (level, message, category, metadata)\r\nVALUES ('info', 'Migration ${filename} completed', 'migration', '{\"migration\": \"${filename}\"}');\r\n`;\r\n\r\n    await fs.writeFile(filepath, template, 'utf-8');\r\n    console.log(`✅ Created migration file: ${filename}`);\r\n    return filepath;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const migrationRunner = new MigrationRunner();\r\n\r\n/**\r\n * Convenience function to run migrations\r\n */\r\nexport async function runMigrations(): Promise<void> {\r\n  await migrationRunner.runMigrations();\r\n}\r\n\r\n/**\r\n * Convenience function to check migration status\r\n */\r\nexport async function getMigrationStatus() {\r\n  return migrationRunner.getStatus();\r\n}\r\n\r\n/**\r\n * Convenience function to verify migrations\r\n */\r\nexport async function verifyMigrations() {\r\n  return migrationRunner.verifyMigrations();\r\n} ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\exchanges\\base-exchange.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\exchanges\\bybit-exchange.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":957,"column":39,"nodeType":"MemberExpression","endLine":957,"endColumn":70},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":958,"column":36,"nodeType":"MemberExpression","endLine":958,"endColumn":67}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MarketType } from '@jabbr/shared';\r\nimport type {\r\n  Exchange,\r\n  TradeSide,\r\n  TradeType,\r\n  TradeStatus,\r\n  ExchangeApiKey\r\n} from '@jabbr/shared';\r\nimport * as ccxt from 'ccxt';\r\n\r\nimport { timeSyncService } from '../services/time-sync.service';\r\n\r\nimport { \r\n  BaseExchange \r\n} from './base-exchange';\r\nimport type { \r\n  OrderRequest, \r\n  OrderResponse, \r\n  MarketData, \r\n  PositionInfo, \r\n  AccountBalance, \r\n  ExchangeCapabilities \r\n} from './base-exchange';\r\n\r\n/**\r\n * Bybit Exchange Implementation\r\n * Supports both Spot and Futures trading with comprehensive order management\r\n */\r\nexport class BybitExchange extends BaseExchange {\r\n\r\n  /**\r\n   * Validate an order against risk configuration without placing the order\r\n   */\r\n  async validateOrderRisk(\r\n    orderRequest: OrderRequest,\r\n    riskConfig: {\r\n      maxPositionSize: number;\r\n      maxLeverage: number;\r\n      maxDailyLoss: number;\r\n      maxDrawdown: number;\r\n      maxConcurrentTrades: number;\r\n      emergencyStop: boolean;\r\n      riskScore: number;\r\n      accountBalance?: number;\r\n    }\r\n  ): Promise<{\r\n    isValid: boolean;\r\n    violations: string[];\r\n    warnings: string[];\r\n  }> {\r\n    const violations: string[] = [];\r\n    const warnings: string[] = [];\r\n    try {\r\n      // Emergency Stop\r\n      if (riskConfig.emergencyStop) {\r\n        violations.push('Emergency stop is active - all trading is halted');\r\n        return { isValid: false, violations, warnings };\r\n      }\r\n\r\n      // Leverage Validation\r\n      const requestedLeverage = orderRequest.leverage || 1;\r\n      if (requestedLeverage > riskConfig.maxLeverage) {\r\n        violations.push(`Leverage ${requestedLeverage}x exceeds maximum allowed ${riskConfig.maxLeverage}x`);\r\n      }\r\n\r\n      // Position Size Validation\r\n      const currentPositions = await this.getPositions(orderRequest.symbol);\r\n      const existingPosition = currentPositions.find(pos => pos.symbol === orderRequest.symbol);\r\n      let newPositionSize = orderRequest.amount;\r\n      if (existingPosition && !orderRequest.reduceOnly) {\r\n        if ((existingPosition.side === 'buy' && orderRequest.side === 'buy') ||\r\n            (existingPosition.side === 'sell' && orderRequest.side === 'sell')) {\r\n          newPositionSize = existingPosition.size + orderRequest.amount;\r\n        }\r\n      }\r\n      if (newPositionSize > riskConfig.maxPositionSize) {\r\n        violations.push(`Position size ${newPositionSize} exceeds maximum allowed ${riskConfig.maxPositionSize}`);\r\n      }\r\n\r\n      // Concurrent Trades Validation\r\n      const allPositions = await this.getPositions();\r\n      const openPositionsCount = allPositions.filter(pos => pos.size > 0).length;\r\n      if (!existingPosition && !orderRequest.reduceOnly && openPositionsCount >= riskConfig.maxConcurrentTrades) {\r\n        violations.push(`Already at maximum concurrent trades limit (${riskConfig.maxConcurrentTrades})`);\r\n      }\r\n\r\n      // Daily Loss Check\r\n      if (riskConfig.accountBalance) {\r\n        const totalUnrealizedPnl = allPositions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0);\r\n        const currentDailyLossPercentage = Math.abs(totalUnrealizedPnl / riskConfig.accountBalance) * 100;\r\n        if (currentDailyLossPercentage >= riskConfig.maxDailyLoss) {\r\n          violations.push(`Daily loss limit reached: ${currentDailyLossPercentage.toFixed(2)}% >= ${riskConfig.maxDailyLoss}%`);\r\n        } else if (currentDailyLossPercentage >= riskConfig.maxDailyLoss * 0.8) {\r\n          warnings.push(`Approaching daily loss limit: ${currentDailyLossPercentage.toFixed(2)}% of ${riskConfig.maxDailyLoss}%`);\r\n        }\r\n      }\r\n\r\n      // Drawdown Check\r\n      if (riskConfig.accountBalance) {\r\n        const totalUnrealizedPnl = allPositions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0);\r\n        const currentDrawdownPercentage = totalUnrealizedPnl < 0 ? Math.abs(totalUnrealizedPnl / riskConfig.accountBalance) * 100 : 0;\r\n        if (currentDrawdownPercentage >= riskConfig.maxDrawdown) {\r\n          violations.push(`Drawdown limit reached: ${currentDrawdownPercentage.toFixed(2)}% >= ${riskConfig.maxDrawdown}%`);\r\n        } else if (currentDrawdownPercentage >= riskConfig.maxDrawdown * 0.8) {\r\n          warnings.push(`Approaching drawdown limit: ${currentDrawdownPercentage.toFixed(2)}% of ${riskConfig.maxDrawdown}%`);\r\n        }\r\n      }\r\n\r\n      // Risk Score Validation\r\n      if (riskConfig.riskScore >= 8) {\r\n        if (requestedLeverage > 5) {\r\n          warnings.push(`High risk score (${riskConfig.riskScore}) - consider reducing leverage from ${requestedLeverage}x`);\r\n        }\r\n        if (newPositionSize > riskConfig.maxPositionSize * 0.5) {\r\n          warnings.push(`High risk score (${riskConfig.riskScore}) - consider reducing position size`);\r\n        }\r\n      }\r\n\r\n      return { isValid: violations.length === 0, violations, warnings };\r\n    } catch (error) {\r\n      return { isValid: false, violations: [error instanceof Error ? error.message : String(error)], warnings };\r\n    }\r\n  }\r\n  private client: ccxt.bybit;\r\n  private wsConnections: Map<string, any> = new Map();\r\n  private subscriptions: Set<string> = new Set();\r\n\r\n  constructor(apiKey: ExchangeApiKey, isTestnet = true) {\r\n    super(apiKey, isTestnet);\r\n    \r\n    // Initialize CCXT Bybit client\r\n    this.client = new ccxt.bybit({\r\n      apiKey: this.apiKey.apiKey,\r\n      secret: this.apiKey.apiSecret,\r\n      sandbox: this.isTestnet,\r\n      enableRateLimit: true,\r\n      rateLimit: 120, // 120ms between requests\r\n      options: {\r\n        defaultType: 'swap', // Default to futures, can be overridden\r\n        recvWindow: 60000, // Increased to 60 seconds for better tolerance\r\n        timeDifference: 0\r\n      }\r\n    });\r\n\r\n    console.log(`🏦 Bybit Exchange initialized (${isTestnet ? 'TESTNET' : 'MAINNET'})`);\r\n  }\r\n\r\n  /**\r\n   * Get exchange name\r\n   */\r\n  getName(): Exchange {\r\n    return 'bybit';\r\n  }\r\n\r\n  /**\r\n   * Get exchange capabilities\r\n   */\r\n  getCapabilities(): ExchangeCapabilities {\r\n    return {\r\n      spot: true,\r\n      futures: true,\r\n      options: false,\r\n      margin: true,\r\n      maxLeverage: {\r\n        spot: 10,\r\n        futures: 100\r\n      },\r\n      supportedOrderTypes: ['market', 'limit', 'stop', 'stop-limit'],\r\n      supportedTimeframes: ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '12h', '1d', '3d', '1w'],\r\n      rateLimits: {\r\n        requests: 120, // 120 requests per minute\r\n        window: 60000 // 1 minute\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize connection to Bybit\r\n   */\r\n  async connect(): Promise<void> {\r\n    try {\r\n      console.log('🔌 Connecting to Bybit...');\r\n      \r\n      // First, get server time and sync\r\n      console.log('⏰ Synchronizing time with Bybit...');\r\n      try {\r\n        // Check if fetchTime method is available\r\n        if (typeof this.client.fetchTime === 'function') {\r\n          // Get Bybit server time\r\n          const serverTime = await this.client.fetchTime();\r\n          const bybitServerTime = new Date(serverTime || Date.now());\r\n          \r\n          // Sync with our time service\r\n          await timeSyncService.syncWithExchange('bybit', bybitServerTime);\r\n          const totalDrift = timeSyncService.getTotalDrift();\r\n          console.log(`✅ Time synchronized (drift: ${totalDrift}ms)`);\r\n          \r\n          // Apply time difference to CCXT client (negative to correct)\r\n          this.client.options.timeDifference = -totalDrift;\r\n          console.log(`🔧 Applied time correction: ${-totalDrift}ms to CCXT client`);\r\n        } else {\r\n          console.log('⚠️ fetchTime method not available, using system time');\r\n        }\r\n      } catch (timeError) {\r\n        console.warn('⚠️ Time sync failed, proceeding with system time:', timeError);\r\n      }\r\n      \r\n      // Load markets for the current mode\r\n      await this.client.loadMarkets();\r\n      \r\n      // Test the connection\r\n      const testResult = await this.testConnection();\r\n      if (!testResult) {\r\n        throw new Error('Connection test failed');\r\n      }\r\n\r\n      this.isConnected = true;\r\n      console.log('✅ Connected to Bybit successfully');\r\n      \r\n      this.emit('connected', {\r\n        exchange: 'bybit',\r\n        testnet: this.isTestnet,\r\n        timestamp: new Date()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to connect to Bybit:', error);\r\n      this.isConnected = false;\r\n      this.emit('error', {\r\n        type: 'connection_failed',\r\n        exchange: 'bybit',\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect from Bybit\r\n   */\r\n  async disconnect(): Promise<void> {\r\n    try {\r\n      console.log('🔌 Disconnecting from Bybit...');\r\n      \r\n      // Close all WebSocket connections\r\n      for (const [, ws] of this.wsConnections) {\r\n        if (ws && ws.close) {\r\n          ws.close();\r\n        }\r\n      }\r\n      this.wsConnections.clear();\r\n      this.subscriptions.clear();\r\n\r\n      this.isConnected = false;\r\n      console.log('✅ Disconnected from Bybit');\r\n      \r\n      this.emit('disconnected', {\r\n        exchange: 'bybit',\r\n        timestamp: new Date()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('❌ Error disconnecting from Bybit:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test API connectivity and permissions\r\n   */\r\n  async testConnection(): Promise<boolean> {\r\n    try {\r\n      // Test both spot and futures API access\r\n      const [spotBalance, futuresBalance] = await Promise.allSettled([\r\n        this.client.fetchBalance({ type: 'spot' }),\r\n        this.client.fetchBalance({ type: 'swap' })\r\n      ]);\r\n\r\n      const spotOk = spotBalance.status === 'fulfilled';\r\n      const futuresOk = futuresBalance.status === 'fulfilled';\r\n\r\n      console.log(`📊 API Test Results:`);\r\n      console.log(`   Spot API: ${spotOk ? '✅' : '❌'}`);\r\n      console.log(`   Futures API: ${futuresOk ? '✅' : '❌'}`);\r\n\r\n      return spotOk || futuresOk; // At least one should work\r\n\r\n    } catch (error) {\r\n      console.error('❌ Connection test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // MARKET DATA METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get current market data for a symbol\r\n   */\r\n  async getMarketData(symbol: string, marketType: MarketType): Promise<MarketData> {\r\n    try {\r\n      if (!this.checkRateLimit('getMarketData')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, marketType);\r\n      \r\n      // Set the market type for this request\r\n      this.client.options.defaultType = marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n      \r\n      const ticker = await this.client.fetchTicker(formattedSymbol);\r\n      \r\n      return {\r\n        symbol,\r\n        price: ticker.last || 0,\r\n        bid: ticker.bid || 0,\r\n        ask: ticker.ask || 0,\r\n        volume: ticker.baseVolume || 0,\r\n        change24h: ticker.change || 0,\r\n        high24h: ticker.high || 0,\r\n        low24h: ticker.low || 0,\r\n        timestamp: new Date(ticker.timestamp || Date.now()),\r\n        marketType\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get market data for ${symbol}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get order book for a symbol\r\n   */\r\n  async getOrderBook(symbol: string, marketType: MarketType, depth = 50): Promise<{\r\n    bids: [number, number][];\r\n    asks: [number, number][];\r\n    timestamp: Date;\r\n  }> {\r\n    try {\r\n      if (!this.checkRateLimit('getOrderBook')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, marketType);\r\n      this.client.options.defaultType = marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n      \r\n      const orderBook = await this.client.fetchOrderBook(formattedSymbol, depth);\r\n      \r\n      return {\r\n        bids: orderBook.bids.map((bid: any) => [bid.at(0), bid.at(1)] as [number, number]),\r\n        asks: orderBook.asks.map((ask: any) => [ask.at(0), ask.at(1)] as [number, number]),\r\n        timestamp: new Date(orderBook.timestamp || Date.now())\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get order book for ${symbol}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get recent trades for a symbol\r\n   */\r\n  async getRecentTrades(symbol: string, _marketType: MarketType, limit = 50): Promise<{\r\n    id: string;\r\n    price: number;\r\n    amount: number;\r\n    side: TradeSide;\r\n    timestamp: Date;\r\n  }[]> {\r\n    try {\r\n      if (!this.checkRateLimit('getRecentTrades')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, _marketType);\r\n      this.client.options.defaultType = _marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n      \r\n      const trades = await this.client.fetchTrades(formattedSymbol, undefined, limit);\r\n      \r\n      return trades.map((trade: any) => ({\r\n        id: trade.id || '',\r\n        price: trade.price,\r\n        amount: trade.amount,\r\n        side: trade.side as TradeSide,\r\n        timestamp: new Date(trade.timestamp || Date.now())\r\n      }));\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get recent trades for ${symbol}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get candlestick/kline data\r\n   */\r\n  async getKlines(\r\n    symbol: string, \r\n    interval: string, \r\n    _marketType: MarketType,\r\n    startTime?: Date, \r\n    endTime?: Date, \r\n    limit?: number\r\n  ): Promise<{\r\n    timestamp: Date;\r\n    open: number;\r\n    high: number;\r\n    low: number;\r\n    close: number;\r\n    volume: number;\r\n  }[]> {\r\n    try {\r\n      if (!this.checkRateLimit('getKlines')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, _marketType);\r\n      this.client.options.defaultType = _marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n      \r\n      const since = startTime ? startTime.getTime() : undefined;\r\n      const ohlcv = await this.client.fetchOHLCV(\r\n        formattedSymbol, \r\n        interval, \r\n        since, \r\n        limit\r\n      );\r\n      \r\n      return ohlcv.map((candle: any) => ({\r\n        timestamp: new Date(candle.at(0)),\r\n        open: candle.at(1),\r\n        high: candle.at(2),\r\n        low: candle.at(3),\r\n        close: candle.at(4),\r\n        volume: candle.at(5)\r\n      }));\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get klines for ${symbol}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get server time from Bybit\r\n   */\r\n  async getServerTime(): Promise<Date> {\r\n    try {\r\n      // Use our time sync service which already fetches Bybit time\r\n      return timeSyncService.getExchangeTime('bybit');\r\n    } catch (error) {\r\n      console.error('❌ Failed to get server time:', error);\r\n      return new Date();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format symbol for Bybit\r\n   */\r\n  protected formatSymbol(symbol: string, marketType: MarketType): string {\r\n    // Bybit uses different symbol formats for spot vs futures\r\n    if (marketType === MarketType.SPOT) {\r\n      // Spot: BTCUSDT\r\n      return symbol.toUpperCase();\r\n    } \r\n      // Futures: BTCUSDT (perpetual contracts)\r\n      return symbol.toUpperCase();\r\n    \r\n  }\r\n\r\n  /**\r\n   * Parse symbol from Bybit format\r\n   */\r\n  protected parseSymbol(exchangeSymbol: string): string {\r\n    return exchangeSymbol.toUpperCase();\r\n  }\r\n\r\n  // ============================================================================\r\n  // TRADING METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Place a new order on Bybit\r\n   */\r\n  async placeOrder(orderRequest: OrderRequest): Promise<OrderResponse> {\r\n    try {\r\n      // Validate the order request\r\n      this.validateOrderRequest(orderRequest);\r\n\r\n      if (!this.checkRateLimit('placeOrder')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(orderRequest.symbol, orderRequest.marketType);\r\n      \r\n      // Set the market type for this request\r\n      this.client.options.defaultType = orderRequest.marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n\r\n      // Prepare order parameters\r\n      const orderParams: any = {\r\n        symbol: formattedSymbol,\r\n        type: orderRequest.type,\r\n        side: orderRequest.side,\r\n        amount: orderRequest.amount,\r\n        price: orderRequest.price,\r\n        params: {}\r\n      };\r\n\r\n      // Add futures-specific parameters\r\n      if (orderRequest.marketType === MarketType.FUTURES) {\r\n        if (orderRequest.leverage) {\r\n          orderParams.params.leverage = orderRequest.leverage;\r\n        }\r\n        if (orderRequest.reduceOnly) {\r\n          orderParams.params.reduceOnly = orderRequest.reduceOnly;\r\n        }\r\n        if (orderRequest.timeInForce) {\r\n          orderParams.params.timeInForce = orderRequest.timeInForce;\r\n        }\r\n      }\r\n\r\n      // Add client order ID if provided\r\n      if (orderRequest.clientOrderId) {\r\n        orderParams.params.clientOrderId = orderRequest.clientOrderId;\r\n      }\r\n\r\n      // Add stop price for stop orders\r\n      if (orderRequest.stopPrice && (orderRequest.type === 'stop' || orderRequest.type === 'stop-limit')) {\r\n        orderParams.params.stopPrice = orderRequest.stopPrice;\r\n      }\r\n\r\n      console.log(`📝 Placing ${orderRequest.marketType} order:`, {\r\n        symbol: orderRequest.symbol,\r\n        side: orderRequest.side,\r\n        type: orderRequest.type,\r\n        amount: orderRequest.amount,\r\n        price: orderRequest.price,\r\n        leverage: orderRequest.leverage\r\n      });\r\n\r\n      // Place the order\r\n      const order = await this.client.createOrder(\r\n        orderParams.symbol,\r\n        orderParams.type,\r\n        orderParams.side,\r\n        orderParams.amount,\r\n        orderParams.price,\r\n        orderParams.params\r\n      );\r\n\r\n      const response: OrderResponse = {\r\n        orderId: order.id || '',\r\n        clientOrderId: order.clientOrderId || undefined,\r\n        symbol: orderRequest.symbol,\r\n        side: orderRequest.side,\r\n        type: orderRequest.type,\r\n        amount: orderRequest.amount,\r\n        price: orderRequest.price,\r\n        filled: order.filled || 0,\r\n        remaining: order.remaining || orderRequest.amount,\r\n        status: this.mapOrderStatus(order.status || 'pending'),\r\n        fee: order.fee?.cost || 0,\r\n        timestamp: new Date(order.timestamp || Date.now()),\r\n        marketType: orderRequest.marketType\r\n      };\r\n\r\n      console.log(`✅ Order placed successfully:`, {\r\n        orderId: response.orderId,\r\n        status: response.status\r\n      });\r\n\r\n      // Emit order event\r\n      this.emit('orderPlaced', response);\r\n\r\n      return response;\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to place order:`, error);\r\n      this.emit('orderError', {\r\n        type: 'place_order_failed',\r\n        orderRequest,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel an existing order\r\n   */\r\n  async cancelOrder(orderId: string, symbol: string, marketType: MarketType): Promise<boolean> {\r\n    try {\r\n      if (!this.checkRateLimit('cancelOrder')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, marketType);\r\n      this.client.options.defaultType = marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n\r\n      console.log(`🚫 Cancelling order: ${orderId} for ${symbol}`);\r\n\r\n      const result = await this.client.cancelOrder(orderId, formattedSymbol);\r\n      \r\n      const success = result && (result.status === 'canceled' || result.status === 'cancelled');\r\n\r\n      if (success) {\r\n        console.log(`✅ Order cancelled successfully: ${orderId}`);\r\n        this.emit('orderCancelled', {\r\n          orderId,\r\n          symbol,\r\n          marketType,\r\n          timestamp: new Date()\r\n        });\r\n      }\r\n\r\n      return success;\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to cancel order ${orderId}:`, error);\r\n      this.emit('orderError', {\r\n        type: 'cancel_order_failed',\r\n        orderId,\r\n        symbol,\r\n        marketType,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel all orders for a symbol\r\n   */\r\n  async cancelAllOrders(symbol?: string, marketType?: MarketType): Promise<boolean> {\r\n    try {\r\n      if (!this.checkRateLimit('cancelAllOrders')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      console.log(`🚫 Cancelling all orders${symbol ? ` for ${symbol}` : ''}`);\r\n\r\n      if (symbol && marketType) {\r\n        const formattedSymbol = this.formatSymbol(symbol, marketType);\r\n        this.client.options.defaultType = marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n        \r\n        await this.client.cancelAllOrders(formattedSymbol);\r\n      } else {\r\n        // Cancel all orders across all symbols\r\n        await this.client.cancelAllOrders();\r\n      }\r\n\r\n      console.log(`✅ All orders cancelled successfully`);\r\n      \r\n      this.emit('allOrdersCancelled', {\r\n        symbol,\r\n        marketType,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to cancel all orders:`, error);\r\n      this.emit('orderError', {\r\n        type: 'cancel_all_orders_failed',\r\n        symbol,\r\n        marketType,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get order status\r\n   */\r\n  async getOrder(orderId: string, symbol: string, marketType: MarketType): Promise<OrderResponse> {\r\n    try {\r\n      if (!this.checkRateLimit('getOrder')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, marketType);\r\n      this.client.options.defaultType = marketType === MarketType.SPOT ? 'spot' : 'swap';\r\n\r\n      const order = await this.client.fetchOrder(orderId, formattedSymbol);\r\n\r\n      return {\r\n        orderId: order.id || '',\r\n        clientOrderId: order.clientOrderId || undefined,\r\n        symbol,\r\n        side: order.side as TradeSide,\r\n        type: order.type as TradeType,\r\n        amount: order.amount,\r\n        price: order.price,\r\n        filled: order.filled || 0,\r\n        remaining: order.remaining || 0,\r\n        status: this.mapOrderStatus(order.status || 'pending'),\r\n        fee: order.fee?.cost || 0,\r\n        timestamp: new Date(order.timestamp || Date.now()),\r\n        marketType\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get order ${orderId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get order history for a symbol\r\n   */\r\n  async getOrderHistory(): Promise<OrderResponse[]> {\r\n    try {\r\n      const symbol = 'BTCUSDT';\r\n      this.client.options.defaultType = 'swap';\r\n      const [closedOrders, canceledOrders] = await Promise.all([\r\n        this.client.fetchClosedOrders(symbol),\r\n        this.client.fetchCanceledOrders(symbol)\r\n      ]);\r\n      const allOrders = [...closedOrders, ...canceledOrders]\r\n        .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));\r\n      return allOrders.map((order: any) => ({\r\n        orderId: order.id || '',\r\n        clientOrderId: order.clientOrderId || undefined,\r\n        symbol: order.symbol ? this.parseSymbol(order.symbol) : '',\r\n        side: order.side as TradeSide,\r\n        type: order.type as TradeType,\r\n        amount: order.amount,\r\n        price: order.price,\r\n        filled: order.filled || 0,\r\n        remaining: order.remaining || 0,\r\n        status: this.mapOrderStatus(order.status || 'pending'),\r\n        fee: order.fee?.cost || 0,\r\n        timestamp: new Date(order.timestamp || Date.now()),\r\n        marketType: MarketType.FUTURES\r\n      }));\r\n    } catch (error) {\r\n      console.error('❌ Failed to fetch order history:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get open orders\r\n   */\r\n  async getOpenOrders(): Promise<OrderResponse[]> {\r\n    try {\r\n      const symbol = 'BTCUSDT';\r\n      this.client.options.defaultType = 'swap';\r\n      const orders = await this.client.fetchOpenOrders(symbol);\r\n      return orders.map((order: any) => ({\r\n        orderId: order.id || '',\r\n        clientOrderId: order.clientOrderId || undefined,\r\n        symbol: this.parseSymbol(order.symbol),\r\n        side: order.side as TradeSide,\r\n        type: order.type as TradeType,\r\n        amount: order.amount,\r\n        price: order.price,\r\n        filled: order.filled || 0,\r\n        remaining: order.remaining || 0,\r\n        status: this.mapOrderStatus(order.status || 'pending'),\r\n        fee: order.fee?.cost || 0,\r\n        timestamp: new Date(order.timestamp || Date.now()),\r\n        marketType: MarketType.FUTURES\r\n      }));\r\n    } catch (error) {\r\n      console.error('❌ Failed to get open orders:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // POSITION METHODS (FUTURES)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get current positions\r\n   */\r\n  async getPositions(symbol?: string): Promise<PositionInfo[]> {\r\n    try {\r\n      if (!this.checkRateLimit('getPositions')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      this.client.options.defaultType = 'swap'; // Futures only\r\n      const positions = await this.client.fetchPositions(symbol ? [this.formatSymbol(symbol, MarketType.FUTURES)] : undefined);\r\n\r\n      return positions\r\n        .filter((pos: any) => pos.size > 0) // Only return positions with size > 0\r\n        .map((pos: any) => ({\r\n          symbol: pos.symbol ? this.parseSymbol(pos.symbol) : '',\r\n          side: pos.side as TradeSide,\r\n          size: pos.size || 0,\r\n          entryPrice: pos.entryPrice || 0,\r\n          markPrice: pos.markPrice || 0,\r\n          unrealizedPnl: pos.unrealizedPnl || 0,\r\n          realizedPnl: pos.realizedPnl || 0,\r\n          leverage: pos.leverage || 1,\r\n          margin: pos.margin || 0,\r\n          marginMode: pos.marginMode === 'isolated' ? 'isolated' : 'cross',\r\n          liquidationPrice: pos.liquidationPrice,\r\n          timestamp: new Date(pos.timestamp || Date.now()),\r\n          marketType: MarketType.FUTURES\r\n        }));\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get positions:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set leverage for a symbol\r\n   */\r\n  async setLeverage(symbol: string, leverage: number): Promise<boolean> {\r\n    try {\r\n      if (!this.checkRateLimit('setLeverage')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      // Validate leverage range\r\n      if (leverage < 1 || leverage > 100) {\r\n        throw new Error('Leverage must be between 1 and 100');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, MarketType.FUTURES);\r\n      this.client.options.defaultType = 'swap';\r\n\r\n      console.log(`⚡ Setting leverage to ${leverage}x for ${symbol}`);\r\n\r\n      await this.client.setLeverage(leverage, formattedSymbol);\r\n      console.log(`✅ Leverage set to ${leverage}x for ${symbol}`);\r\n\r\n      this.emit('leverageChanged', {\r\n        symbol,\r\n        leverage,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to set leverage for ${symbol}:`, error);\r\n      this.emit('leverageError', {\r\n        symbol,\r\n        leverage,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set margin mode for a symbol\r\n   */\r\n  async setMarginMode(symbol: string, mode: 'isolated' | 'cross'): Promise<boolean> {\r\n    try {\r\n      if (!this.checkRateLimit('setMarginMode')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const formattedSymbol = this.formatSymbol(symbol, MarketType.FUTURES);\r\n      this.client.options.defaultType = 'swap';\r\n\r\n      console.log(`🔧 Setting margin mode to ${mode} for ${symbol}`);\r\n\r\n      await this.client.setMarginMode(mode, formattedSymbol);\r\n      console.log(`✅ Margin mode set to ${mode} for ${symbol}`);\r\n\r\n      this.emit('marginModeChanged', {\r\n        symbol,\r\n        mode,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to set margin mode for ${symbol}:`, error);\r\n      this.emit('marginModeError', {\r\n        symbol,\r\n        mode,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set position mode (one-way or hedge)\r\n   */\r\n  async setPositionMode(mode: 'one-way' | 'hedge'): Promise<boolean> {\r\n    try {\r\n      if (!this.checkRateLimit('setPositionMode')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      this.client.options.defaultType = 'swap';\r\n      \r\n      console.log(`🔄 Setting position mode to ${mode}`);\r\n      \r\n      // Bybit uses different terminology\r\n      const bybitMode = mode === 'hedge';\r\n      await this.client.setPositionMode(bybitMode);\r\n      \r\n      console.log(`✅ Position mode set to ${mode}`);\r\n\r\n      this.emit('positionModeChanged', {\r\n        mode,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to set position mode:`, error);\r\n      this.emit('positionModeError', {\r\n        mode,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // ACCOUNT METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get account balance\r\n   */\r\n  async getBalance(): Promise<AccountBalance[]> {\r\n    try {\r\n      if (!this.checkRateLimit('getBalance')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      const balanceType = 'swap'; // Always use futures for this method\r\n      this.client.options.defaultType = balanceType;\r\n\r\n      console.log(`💰 Fetching ${balanceType} balance...`);\r\n\r\n      const balance = await this.client.fetchBalance();\r\n\r\n      if (!balance.total) {\r\n        return [];\r\n      }\r\n\r\n      const balances = Object.entries(balance.total)\r\n        .filter(([, total]) => typeof total === 'number' && total > 0)\r\n        .map(([currency, total]) => ({\r\n          currency,\r\n          total: total as number,\r\n          available: (balance.free && (balance.free as any)[currency]) || 0,\r\n          locked: (balance.used && (balance.used as any)[currency]) || 0,\r\n          marketType: MarketType.FUTURES\r\n        }));\r\n\r\n      console.log(`✅ Retrieved ${balances.length} non-zero balances`);\r\n\r\n      return balances;\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get balance:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get trading fees for a symbol or default fees\r\n   */\r\n  async getTradingFees(symbol?: string): Promise<{\r\n    maker: number;\r\n    taker: number;\r\n  }> {\r\n    try {\r\n      if (!this.checkRateLimit('getTradingFees')) {\r\n        throw new Error('Rate limit exceeded');\r\n      }\r\n\r\n      if (symbol) {\r\n        const formattedSymbol = this.formatSymbol(symbol, MarketType.FUTURES);\r\n        this.client.options.defaultType = 'swap';\r\n        \r\n        console.log(`📊 Fetching trading fees for ${symbol}`);\r\n        \r\n        const fees = await this.client.fetchTradingFee(formattedSymbol);\r\n        return {\r\n          maker: fees.maker || 0.0001,\r\n          taker: fees.taker || 0.0006\r\n        };\r\n      } \r\n        // Return default fees for Bybit\r\n        console.log(`📊 Using default Bybit trading fees`);\r\n        return {\r\n          maker: 0.0001, // 0.01%\r\n          taker: 0.0006  // 0.06%\r\n        };\r\n      \r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to get trading fees:`, error);\r\n      // Return default fees on error\r\n      return {\r\n        maker: 0.0001,\r\n        taker: 0.0006\r\n      };\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // WEBSOCKET METHODS\r\n  // ============================================================================\r\n\r\n  async subscribeToMarketData(symbol: string, marketType: MarketType): Promise<void> {\r\n    try {\r\n      const formattedSymbol = this.formatSymbol(symbol, marketType);\r\n      const subscriptionKey = `${marketType}_${formattedSymbol}`;\r\n\r\n      if (this.subscriptions.has(subscriptionKey)) {\r\n        console.log(`📡 Already subscribed to ${symbol} ${marketType} market data`);\r\n        return;\r\n      }\r\n\r\n      console.log(`📡 Subscribing to ${symbol} ${marketType} market data...`);\r\n\r\n      // For now, we'll use a placeholder implementation\r\n      // In a full implementation, this would create WebSocket connections\r\n      // to Bybit's real-time data streams\r\n      \r\n      this.subscriptions.add(subscriptionKey);\r\n      \r\n      console.log(`✅ Subscribed to ${symbol} ${marketType} market data`);\r\n\r\n      this.emit('marketDataSubscribed', {\r\n        symbol,\r\n        marketType,\r\n        timestamp: new Date()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to subscribe to market data for ${symbol}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async unsubscribeFromMarketData(symbol: string, marketType: MarketType): Promise<void> {\r\n    try {\r\n      const formattedSymbol = this.formatSymbol(symbol, marketType);\r\n      const subscriptionKey = `${marketType}_${formattedSymbol}`;\r\n\r\n      if (!this.subscriptions.has(subscriptionKey)) {\r\n        console.log(`📡 Not subscribed to ${symbol} ${marketType} market data`);\r\n        return;\r\n      }\r\n\r\n      console.log(`📡 Unsubscribing from ${symbol} ${marketType} market data...`);\r\n\r\n      this.subscriptions.delete(subscriptionKey);\r\n      \r\n      console.log(`✅ Unsubscribed from ${symbol} ${marketType} market data`);\r\n\r\n      this.emit('marketDataUnsubscribed', {\r\n        symbol,\r\n        marketType,\r\n        timestamp: new Date()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to unsubscribe from market data for ${symbol}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async subscribeToOrderUpdates(): Promise<void> {\r\n    try {\r\n      const subscriptionKey = 'order_updates';\r\n\r\n      if (this.subscriptions.has(subscriptionKey)) {\r\n        console.log(`📡 Already subscribed to order updates`);\r\n        return;\r\n      }\r\n\r\n      console.log(`📡 Subscribing to order updates...`);\r\n\r\n      // For now, we'll use a placeholder implementation\r\n      // In a full implementation, this would create WebSocket connections\r\n      // to Bybit's order update streams\r\n      \r\n      this.subscriptions.add(subscriptionKey);\r\n      \r\n      console.log(`✅ Subscribed to order updates`);\r\n\r\n      this.emit('orderUpdatesSubscribed', {\r\n        timestamp: new Date()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to subscribe to order updates:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async subscribeToPositionUpdates(): Promise<void> {\r\n    try {\r\n      const subscriptionKey = 'position_updates';\r\n\r\n      if (this.subscriptions.has(subscriptionKey)) {\r\n        console.log(`📡 Already subscribed to position updates`);\r\n        return;\r\n      }\r\n\r\n      console.log(`📡 Subscribing to position updates...`);\r\n\r\n      // For now, we'll use a placeholder implementation\r\n      // In a full implementation, this would create WebSocket connections\r\n      // to Bybit's position update streams\r\n      \r\n      this.subscriptions.add(subscriptionKey);\r\n      \r\n      console.log(`✅ Subscribed to position updates`);\r\n\r\n      this.emit('positionUpdatesSubscribed', {\r\n        timestamp: new Date()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Failed to subscribe to position updates:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // ADVANCED ORDER MANAGEMENT METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Place a bracket order: Entry order + Stop Loss + Take Profit\r\n   * This is the core advanced order management function that places all three orders atomically\r\n   */\r\n  async placeBracketOrder(\r\n    entryOrder: {\r\n      symbol: string;\r\n      side: TradeSide;\r\n      type: TradeType;\r\n      amount: number;\r\n      price?: number; // Required for limit orders, optional for market\r\n      marketType: MarketType;\r\n      leverage?: number;\r\n      clientOrderId?: string;\r\n    },\r\n    stopLoss: {\r\n      price: number;\r\n      type?: 'stop_market' | 'stop_limit'; // Default: stop_market\r\n      limitPrice?: number; // Required if type is stop_limit\r\n    },\r\n    takeProfit: {\r\n      price: number;\r\n      type?: 'limit' | 'take_profit_market'; // Default: limit\r\n    }\r\n  ): Promise<{\r\n    entryOrder: OrderResponse;\r\n    stopLossOrder?: OrderResponse;\r\n    takeProfitOrder?: OrderResponse;\r\n    success: boolean;\r\n    errors: string[];\r\n  }> {\r\n    const errors: string[] = [];\r\n    let entryOrderResponse: OrderResponse | null = null;\r\n    let stopLossOrderResponse: OrderResponse | null = null;\r\n    let takeProfitOrderResponse: OrderResponse | null = null;\r\n\r\n    try {\r\n      console.log(`🎯 Placing bracket order for ${entryOrder.symbol}:`, {\r\n        entry: { side: entryOrder.side, type: entryOrder.type, amount: entryOrder.amount, price: entryOrder.price },\r\n        stopLoss: { price: stopLoss.price, type: stopLoss.type || 'stop_market' },\r\n        takeProfit: { price: takeProfit.price, type: takeProfit.type || 'limit' }\r\n      });\r\n\r\n      // Validate bracket order parameters\r\n      this.validateBracketOrder(entryOrder, stopLoss, takeProfit);\r\n\r\n      // Step 1: Place the entry order first\r\n      const entryOrderRequest: OrderRequest = {\r\n        symbol: entryOrder.symbol,\r\n        side: entryOrder.side,\r\n        type: entryOrder.type,\r\n        amount: entryOrder.amount,\r\n        price: entryOrder.price,\r\n        marketType: entryOrder.marketType,\r\n        leverage: entryOrder.leverage,\r\n        clientOrderId: entryOrder.clientOrderId\r\n      };\r\n\r\n      entryOrderResponse = await this.placeOrder(entryOrderRequest);\r\n      console.log(`✅ Entry order placed: ${entryOrderResponse.orderId}`);\r\n\r\n      // Step 2: Place Stop Loss order\r\n      try {\r\n        const stopLossOrderRequest: OrderRequest = {\r\n          symbol: entryOrder.symbol,\r\n          side: entryOrder.side === 'buy' ? 'sell' : 'buy', // Opposite side\r\n          type: stopLoss.type === 'stop_limit' ? 'stop-limit' : 'stop',\r\n          amount: entryOrder.amount,\r\n          price: stopLoss.type === 'stop_limit' ? stopLoss.limitPrice : undefined,\r\n          stopPrice: stopLoss.price,\r\n          marketType: entryOrder.marketType,\r\n          reduceOnly: entryOrder.marketType === MarketType.FUTURES, // Reduce-only for futures\r\n          clientOrderId: entryOrder.clientOrderId ? `${entryOrder.clientOrderId}_SL` : undefined\r\n        };\r\n\r\n        stopLossOrderResponse = await this.placeOrder(stopLossOrderRequest);\r\n        console.log(`✅ Stop Loss order placed: ${stopLossOrderResponse.orderId}`);\r\n      } catch (slError) {\r\n        const errorMsg = `Failed to place stop loss: ${slError instanceof Error ? slError.message : 'Unknown error'}`;\r\n        errors.push(errorMsg);\r\n        console.error(`❌ ${errorMsg}`);\r\n      }\r\n\r\n      // Step 3: Place Take Profit order\r\n      try {\r\n        const takeProfitOrderRequest: OrderRequest = {\r\n          symbol: entryOrder.symbol,\r\n          side: entryOrder.side === 'buy' ? 'sell' : 'buy', // Opposite side\r\n          type: takeProfit.type === 'take_profit_market' ? 'market' : 'limit',\r\n          amount: entryOrder.amount,\r\n          price: takeProfit.type === 'take_profit_market' ? undefined : takeProfit.price,\r\n          marketType: entryOrder.marketType,\r\n          reduceOnly: entryOrder.marketType === MarketType.FUTURES, // Reduce-only for futures\r\n          clientOrderId: entryOrder.clientOrderId ? `${entryOrder.clientOrderId}_TP` : undefined\r\n        };\r\n\r\n        takeProfitOrderResponse = await this.placeOrder(takeProfitOrderRequest);\r\n        console.log(`✅ Take Profit order placed: ${takeProfitOrderResponse.orderId}`);\r\n      } catch (tpError) {\r\n        const errorMsg = `Failed to place take profit: ${tpError instanceof Error ? tpError.message : 'Unknown error'}`;\r\n        errors.push(errorMsg);\r\n        console.error(`❌ ${errorMsg}`);\r\n      }\r\n\r\n      const success = entryOrderResponse !== null && errors.length === 0;\r\n      \r\n      console.log(`${success ? '🎉' : '⚠️'} Bracket order ${success ? 'completed successfully' : 'completed with errors'}:`, {\r\n        entryOrderId: entryOrderResponse?.orderId,\r\n        stopLossOrderId: stopLossOrderResponse?.orderId,\r\n        takeProfitOrderId: takeProfitOrderResponse?.orderId,\r\n        errors: errors.length\r\n      });\r\n\r\n      // Emit bracket order event\r\n      this.emit('bracketOrderPlaced', {\r\n        entryOrder: entryOrderResponse,\r\n        stopLossOrder: stopLossOrderResponse,\r\n        takeProfitOrder: takeProfitOrderResponse,\r\n        success,\r\n        errors\r\n      });\r\n\r\n      return {\r\n        entryOrder: entryOrderResponse!,\r\n        stopLossOrder: stopLossOrderResponse || undefined,\r\n        takeProfitOrder: takeProfitOrderResponse || undefined,\r\n        success,\r\n        errors\r\n      };\r\n\r\n    } catch (error) {\r\n      const errorMsg = `Failed to place bracket order: ${error instanceof Error ? error.message : 'Unknown error'}`;\r\n      errors.push(errorMsg);\r\n      console.error(`❌ ${errorMsg}`);\r\n\r\n      // If we have an entry order but failed on SL/TP, we still return the entry order\r\n      return {\r\n        entryOrder: entryOrderResponse!,\r\n        stopLossOrder: stopLossOrderResponse || undefined,\r\n        takeProfitOrder: takeProfitOrderResponse || undefined,\r\n        success: false,\r\n        errors\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate bracket order parameters\r\n   */\r\n  private validateBracketOrder(\r\n    entryOrder: any,\r\n    stopLoss: any,\r\n    takeProfit: any\r\n  ): void {\r\n    // Validate entry order\r\n    if (!entryOrder.symbol || !entryOrder.side || !entryOrder.type || !entryOrder.amount) {\r\n      throw new Error('Invalid entry order: missing required fields');\r\n    }\r\n\r\n    if (entryOrder.type === 'limit' && !entryOrder.price) {\r\n      throw new Error('Limit entry order requires price');\r\n    }\r\n\r\n    if (entryOrder.amount <= 0) {\r\n      throw new Error('Order amount must be positive');\r\n    }\r\n\r\n    // Validate stop loss\r\n    if (!stopLoss.price || stopLoss.price <= 0) {\r\n      throw new Error('Invalid stop loss price');\r\n    }\r\n\r\n    if (stopLoss.type === 'stop_limit' && !stopLoss.limitPrice) {\r\n      throw new Error('Stop limit order requires limitPrice');\r\n    }\r\n\r\n    // Validate take profit\r\n    if (!takeProfit.price || takeProfit.price <= 0) {\r\n      throw new Error('Invalid take profit price');\r\n    }\r\n\r\n    // Validate price relationships for long positions\r\n    if (entryOrder.side === 'buy') {\r\n      if (entryOrder.price && stopLoss.price >= entryOrder.price) {\r\n        throw new Error('Stop loss price must be below entry price for long positions');\r\n      }\r\n      if (entryOrder.price && takeProfit.price <= entryOrder.price) {\r\n        throw new Error('Take profit price must be above entry price for long positions');\r\n      }\r\n    }\r\n\r\n    // Validate price relationships for short positions\r\n    if (entryOrder.side === 'sell') {\r\n      if (entryOrder.price && stopLoss.price <= entryOrder.price) {\r\n        throw new Error('Stop loss price must be above entry price for short positions');\r\n      }\r\n      if (entryOrder.price && takeProfit.price >= entryOrder.price) {\r\n        throw new Error('Take profit price must be below entry price for short positions');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set or update stop loss for an existing position\r\n   * Automatically cancels existing stop loss and places a new one\r\n   */\r\n  async setStopLoss(\r\n    symbol: string,\r\n    positionSide: 'long' | 'short',\r\n    stopPrice: number,\r\n    options?: {\r\n      type?: 'stop_market' | 'stop_limit';\r\n      limitPrice?: number; // Required if type is stop_limit\r\n      clientOrderId?: string;\r\n    }\r\n  ): Promise<{\r\n    success: boolean;\r\n    newStopLossOrder?: OrderResponse;\r\n    cancelledOrderId?: string;\r\n    error?: string;\r\n  }> {\r\n    try {\r\n      console.log(`🛡️ Setting stop loss for ${symbol} ${positionSide} position at ${stopPrice}`);\r\n\r\n      // Step 1: Get current position to validate it exists\r\n      const positions = await this.getPositions(symbol);\r\n      const currentPosition = positions.find(pos => \r\n        pos.symbol === symbol && \r\n        ((positionSide === 'long' && pos.side === 'buy') || \r\n         (positionSide === 'short' && pos.side === 'sell'))\r\n      );\r\n\r\n      if (!currentPosition || currentPosition.size === 0) {\r\n        throw new Error(`No ${positionSide} position found for ${symbol}`);\r\n      }\r\n\r\n      console.log(`📊 Found ${positionSide} position: size=${currentPosition.size}, entry=${currentPosition.entryPrice}`);\r\n\r\n      // Step 2: Validate stop price against position\r\n      this.validateStopLossPrice(currentPosition, stopPrice, positionSide);\r\n\r\n      // Step 3: Cancel existing stop loss orders for this position\r\n      let cancelledOrderId: string | undefined;\r\n      try {\r\n        const openOrders = await this.getOpenOrders();\r\n        const existingStopLoss = openOrders.find(order => \r\n          order.symbol === symbol &&\r\n          (order.type === 'stop' || order.type === 'stop-limit') &&\r\n          order.side === (positionSide === 'long' ? 'sell' : 'buy') // Opposite side of position\r\n        );\r\n\r\n        if (existingStopLoss) {\r\n          console.log(`🚫 Cancelling existing stop loss order: ${existingStopLoss.orderId}`);\r\n          await this.cancelOrder(existingStopLoss.orderId, symbol, MarketType.FUTURES);\r\n          cancelledOrderId = existingStopLoss.orderId;\r\n        }\r\n      } catch (cancelError) {\r\n        console.warn('⚠️ Failed to cancel existing stop loss (continuing):', cancelError);\r\n      }\r\n\r\n      // Step 4: Place new stop loss order\r\n      const stopLossOrderRequest: OrderRequest = {\r\n        symbol,\r\n        side: positionSide === 'long' ? 'sell' : 'buy', // Opposite side of position\r\n        type: options?.type === 'stop_limit' ? 'stop-limit' : 'stop',\r\n        amount: currentPosition.size,\r\n        price: options?.type === 'stop_limit' ? options.limitPrice : undefined,\r\n        stopPrice,\r\n        marketType: MarketType.FUTURES,\r\n        reduceOnly: true, // Always reduce-only for SL\r\n        clientOrderId: options?.clientOrderId || `SL_${symbol}_${Date.now()}`\r\n      };\r\n\r\n      const newStopLossOrder = await this.placeOrder(stopLossOrderRequest);\r\n      console.log(`✅ Stop loss set successfully: ${newStopLossOrder.orderId} at ${stopPrice}`);\r\n\r\n      // Emit event\r\n      this.emit('stopLossSet', {\r\n        symbol,\r\n        positionSide,\r\n        stopPrice,\r\n        orderId: newStopLossOrder.orderId,\r\n        cancelledOrderId,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        newStopLossOrder,\r\n        cancelledOrderId\r\n      };\r\n\r\n    } catch (error) {\r\n      const errorMsg = `Failed to set stop loss for ${symbol}: ${error instanceof Error ? error.message : 'Unknown error'}`;\r\n      console.error(`❌ ${errorMsg}`);\r\n      \r\n      this.emit('stopLossError', {\r\n        symbol,\r\n        positionSide,\r\n        stopPrice,\r\n        error: errorMsg,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: errorMsg\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set or update take profit for an existing position\r\n   * Automatically cancels existing take profit and places a new one\r\n   */\r\n  async setTakeProfit(\r\n    symbol: string,\r\n    positionSide: 'long' | 'short',\r\n    takeProfitPrice: number,\r\n    options?: {\r\n      type?: 'limit' | 'take_profit_market';\r\n      clientOrderId?: string;\r\n    }\r\n  ): Promise<{\r\n    success: boolean;\r\n    newTakeProfitOrder?: OrderResponse;\r\n    cancelledOrderId?: string;\r\n    error?: string;\r\n  }> {\r\n    try {\r\n      console.log(`🎯 Setting take profit for ${symbol} ${positionSide} position at ${takeProfitPrice}`);\r\n\r\n      // Step 1: Get current position to validate it exists\r\n      const positions = await this.getPositions(symbol);\r\n      const currentPosition = positions.find(pos => \r\n        pos.symbol === symbol && \r\n        ((positionSide === 'long' && pos.side === 'buy') || \r\n         (positionSide === 'short' && pos.side === 'sell'))\r\n      );\r\n\r\n      if (!currentPosition || currentPosition.size === 0) {\r\n        throw new Error(`No ${positionSide} position found for ${symbol}`);\r\n      }\r\n\r\n      console.log(`📊 Found ${positionSide} position: size=${currentPosition.size}, entry=${currentPosition.entryPrice}`);\r\n\r\n      // Step 2: Validate take profit price against position\r\n      this.validateTakeProfitPrice(currentPosition, takeProfitPrice, positionSide);\r\n\r\n      // Step 3: Cancel existing take profit orders for this position\r\n      let cancelledOrderId: string | undefined;\r\n      try {\r\n        const openOrders = await this.getOpenOrders();\r\n        const existingTakeProfit = openOrders.find(order => \r\n          order.symbol === symbol &&\r\n          order.type === 'limit' &&\r\n          order.side === (positionSide === 'long' ? 'sell' : 'buy') && // Opposite side of position\r\n          order.price && order.price > 0 // Has a limit price (not market order)\r\n        );\r\n\r\n        if (existingTakeProfit) {\r\n          console.log(`🚫 Cancelling existing take profit order: ${existingTakeProfit.orderId}`);\r\n          await this.cancelOrder(existingTakeProfit.orderId, symbol, MarketType.FUTURES);\r\n          cancelledOrderId = existingTakeProfit.orderId;\r\n        }\r\n      } catch (cancelError) {\r\n        console.warn('⚠️ Failed to cancel existing take profit (continuing):', cancelError);\r\n      }\r\n\r\n      // Step 4: Place new take profit order\r\n      const takeProfitOrderRequest: OrderRequest = {\r\n        symbol,\r\n        side: positionSide === 'long' ? 'sell' : 'buy', // Opposite side of position\r\n        type: options?.type === 'take_profit_market' ? 'market' : 'limit',\r\n        amount: currentPosition.size,\r\n        price: options?.type === 'take_profit_market' ? undefined : takeProfitPrice,\r\n        marketType: MarketType.FUTURES,\r\n        reduceOnly: true, // Always reduce-only for TP\r\n        clientOrderId: options?.clientOrderId || `TP_${symbol}_${Date.now()}`\r\n      };\r\n\r\n      const newTakeProfitOrder = await this.placeOrder(takeProfitOrderRequest);\r\n      console.log(`✅ Take profit set successfully: ${newTakeProfitOrder.orderId} at ${takeProfitPrice}`);\r\n\r\n      // Emit event\r\n      this.emit('takeProfitSet', {\r\n        symbol,\r\n        positionSide,\r\n        takeProfitPrice,\r\n        orderId: newTakeProfitOrder.orderId,\r\n        cancelledOrderId,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        newTakeProfitOrder,\r\n        cancelledOrderId\r\n      };\r\n\r\n    } catch (error) {\r\n      const errorMsg = `Failed to set take profit for ${symbol}: ${error instanceof Error ? error.message : 'Unknown error'}`;\r\n      console.error(`❌ ${errorMsg}`);\r\n      \r\n      this.emit('takeProfitError', {\r\n        symbol,\r\n        positionSide,\r\n        takeProfitPrice,\r\n        error: errorMsg,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: errorMsg\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate stop loss price against position\r\n   */\r\n  private validateStopLossPrice(\r\n    position: PositionInfo,\r\n    stopPrice: number,\r\n    positionSide: 'long' | 'short'\r\n  ): void {\r\n    if (stopPrice <= 0) {\r\n      throw new Error('Stop loss price must be positive');\r\n    }\r\n\r\n    // For long positions, stop loss should be below entry price\r\n    if (positionSide === 'long' && stopPrice >= position.entryPrice) {\r\n      throw new Error(`Stop loss price (${stopPrice}) must be below entry price (${position.entryPrice}) for long positions`);\r\n    }\r\n\r\n    // For short positions, stop loss should be above entry price\r\n    if (positionSide === 'short' && stopPrice <= position.entryPrice) {\r\n      throw new Error(`Stop loss price (${stopPrice}) must be above entry price (${position.entryPrice}) for short positions`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate take profit price against position\r\n   */\r\n  private validateTakeProfitPrice(\r\n    position: PositionInfo,\r\n    takeProfitPrice: number,\r\n    positionSide: 'long' | 'short'\r\n  ): void {\r\n    if (takeProfitPrice <= 0) {\r\n      throw new Error('Take profit price must be positive');\r\n    }\r\n\r\n    // For long positions, take profit should be above entry price\r\n    if (positionSide === 'long' && takeProfitPrice <= position.entryPrice) {\r\n      throw new Error(`Take profit price (${takeProfitPrice}) must be above entry price (${position.entryPrice}) for long positions`);\r\n    }\r\n\r\n    // For short positions, take profit should be below entry price\r\n    if (positionSide === 'short' && takeProfitPrice >= position.entryPrice) {\r\n      throw new Error(`Take profit price (${takeProfitPrice}) must be below entry price (${position.entryPrice}) for short positions`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Place order with comprehensive risk management validation\r\n   * Validates order against risk configuration before placement\r\n   */\r\n  async placeOrderWithRiskManagement(\r\n    orderRequest: OrderRequest,\r\n    riskConfig: {\r\n      maxPositionSize: number; // Maximum position size in base currency\r\n      maxLeverage: number; // Maximum allowed leverage\r\n      maxDailyLoss: number; // Maximum daily loss percentage\r\n      maxDrawdown: number; // Maximum drawdown percentage\r\n      maxConcurrentTrades: number; // Maximum concurrent positions\r\n      emergencyStop: boolean; // Emergency stop flag\r\n      riskScore: number; // Risk score (1-10)\r\n      accountBalance?: number; // Current account balance for calculations\r\n    }\r\n  ): Promise<{\r\n    success: boolean;\r\n    order?: OrderResponse;\r\n    rejectionReason?: string;\r\n    riskAnalysis: {\r\n      positionSizeCheck: boolean;\r\n      leverageCheck: boolean;\r\n      dailyLossCheck: boolean;\r\n      drawdownCheck: boolean;\r\n      concurrentTradesCheck: boolean;\r\n      emergencyStopCheck: boolean;\r\n      riskScoreCheck: boolean;\r\n      warnings: string[];\r\n    };\r\n  }> {\r\n    const warnings: string[] = [];\r\n    let rejectionReason: string | undefined;\r\n\r\n    try {\r\n      console.log(`🛡️ Validating order with risk management for ${orderRequest.symbol}`);\r\n\r\n      // Risk Analysis Object\r\n      const riskAnalysis = {\r\n        positionSizeCheck: false,\r\n        leverageCheck: false,\r\n        dailyLossCheck: false,\r\n        drawdownCheck: false,\r\n        concurrentTradesCheck: false,\r\n        emergencyStopCheck: false,\r\n        riskScoreCheck: false,\r\n        warnings\r\n      };\r\n\r\n      // Check 1: Emergency Stop\r\n      if (riskConfig.emergencyStop) {\r\n        rejectionReason = 'Emergency stop is active - all trading is halted';\r\n        console.error(`🚨 ${rejectionReason}`);\r\n        return {\r\n          success: false,\r\n          rejectionReason,\r\n          riskAnalysis: { ...riskAnalysis, emergencyStopCheck: false }\r\n        };\r\n      }\r\n      riskAnalysis.emergencyStopCheck = true;\r\n\r\n      // Check 2: Leverage Validation\r\n      const requestedLeverage = orderRequest.leverage || 1;\r\n      if (requestedLeverage > riskConfig.maxLeverage) {\r\n        rejectionReason = `Leverage ${requestedLeverage}x exceeds maximum allowed ${riskConfig.maxLeverage}x`;\r\n        console.error(`❌ ${rejectionReason}`);\r\n        return {\r\n          success: false,\r\n          rejectionReason,\r\n          riskAnalysis: { ...riskAnalysis, leverageCheck: false }\r\n        };\r\n      }\r\n      riskAnalysis.leverageCheck = true;\r\n\r\n      // Check 3: Position Size Validation\r\n      const currentPositions = await this.getPositions(orderRequest.symbol);\r\n      const existingPosition = currentPositions.find(pos => pos.symbol === orderRequest.symbol);\r\n      \r\n      let newPositionSize = orderRequest.amount;\r\n      if (existingPosition && !orderRequest.reduceOnly) {\r\n        // If adding to existing position (same side)\r\n        if ((existingPosition.side === 'buy' && orderRequest.side === 'buy') ||\r\n            (existingPosition.side === 'sell' && orderRequest.side === 'sell')) {\r\n          newPositionSize = existingPosition.size + orderRequest.amount;\r\n        }\r\n      }\r\n\r\n      if (newPositionSize > riskConfig.maxPositionSize) {\r\n        rejectionReason = `Position size ${newPositionSize} exceeds maximum allowed ${riskConfig.maxPositionSize}`;\r\n        console.error(`❌ ${rejectionReason}`);\r\n        return {\r\n          success: false,\r\n          rejectionReason,\r\n          riskAnalysis: { ...riskAnalysis, positionSizeCheck: false }\r\n        };\r\n      }\r\n      riskAnalysis.positionSizeCheck = true;\r\n\r\n      // Check 4: Concurrent Trades Validation\r\n      const allPositions = await this.getPositions();\r\n      const openPositionsCount = allPositions.filter(pos => pos.size > 0).length;\r\n      \r\n      // If this is a new position (not reducing existing), check concurrent trades limit\r\n      if (!existingPosition && !orderRequest.reduceOnly && openPositionsCount >= riskConfig.maxConcurrentTrades) {\r\n        rejectionReason = `Already at maximum concurrent trades limit (${riskConfig.maxConcurrentTrades})`;\r\n        console.error(`❌ ${rejectionReason}`);\r\n        return {\r\n          success: false,\r\n          rejectionReason,\r\n          riskAnalysis: { ...riskAnalysis, concurrentTradesCheck: false }\r\n        };\r\n      }\r\n      riskAnalysis.concurrentTradesCheck = true;\r\n\r\n      // Check 5: Daily Loss Check (if account balance provided)\r\n      if (riskConfig.accountBalance) {\r\n        const totalUnrealizedPnl = allPositions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0);\r\n        const currentDailyLossPercentage = Math.abs(totalUnrealizedPnl / riskConfig.accountBalance) * 100;\r\n        \r\n        if (currentDailyLossPercentage >= riskConfig.maxDailyLoss) {\r\n          rejectionReason = `Daily loss limit reached: ${currentDailyLossPercentage.toFixed(2)}% >= ${riskConfig.maxDailyLoss}%`;\r\n          console.error(`❌ ${rejectionReason}`);\r\n          return {\r\n            success: false,\r\n            rejectionReason,\r\n            riskAnalysis: { ...riskAnalysis, dailyLossCheck: false }\r\n          };\r\n        }\r\n        \r\n        if (currentDailyLossPercentage >= riskConfig.maxDailyLoss * 0.8) {\r\n          warnings.push(`Approaching daily loss limit: ${currentDailyLossPercentage.toFixed(2)}% of ${riskConfig.maxDailyLoss}%`);\r\n        }\r\n      }\r\n      riskAnalysis.dailyLossCheck = true;\r\n\r\n      // Check 6: Drawdown Check (simplified - based on total unrealized PnL)\r\n      if (riskConfig.accountBalance) {\r\n        const totalUnrealizedPnl = allPositions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0);\r\n        const currentDrawdownPercentage = totalUnrealizedPnl < 0 ? Math.abs(totalUnrealizedPnl / riskConfig.accountBalance) * 100 : 0;\r\n        \r\n        if (currentDrawdownPercentage >= riskConfig.maxDrawdown) {\r\n          rejectionReason = `Drawdown limit reached: ${currentDrawdownPercentage.toFixed(2)}% >= ${riskConfig.maxDrawdown}%`;\r\n          console.error(`❌ ${rejectionReason}`);\r\n          return {\r\n            success: false,\r\n            rejectionReason,\r\n            riskAnalysis: { ...riskAnalysis, drawdownCheck: false }\r\n          };\r\n        }\r\n        \r\n        if (currentDrawdownPercentage >= riskConfig.maxDrawdown * 0.8) {\r\n          warnings.push(`Approaching drawdown limit: ${currentDrawdownPercentage.toFixed(2)}% of ${riskConfig.maxDrawdown}%`);\r\n        }\r\n      }\r\n      riskAnalysis.drawdownCheck = true;\r\n\r\n      // Check 7: Risk Score Validation (higher risk score = more restrictive)\r\n      if (riskConfig.riskScore >= 8) {\r\n        // High risk score - additional restrictions\r\n        if (requestedLeverage > 5) {\r\n          warnings.push(`High risk score (${riskConfig.riskScore}) - consider reducing leverage from ${requestedLeverage}x`);\r\n        }\r\n        if (newPositionSize > riskConfig.maxPositionSize * 0.5) {\r\n          warnings.push(`High risk score (${riskConfig.riskScore}) - consider reducing position size`);\r\n        }\r\n      }\r\n      riskAnalysis.riskScoreCheck = true;\r\n\r\n      // All checks passed - place the order\r\n      console.log(`✅ Risk management validation passed for ${orderRequest.symbol}`);\r\n      if (warnings.length > 0) {\r\n        console.warn(`⚠️ Risk warnings:`, warnings);\r\n      }\r\n\r\n      const order = await this.placeOrder(orderRequest);\r\n\r\n      // Emit risk management event\r\n      this.emit('riskManagedOrderPlaced', {\r\n        order,\r\n        riskConfig,\r\n        riskAnalysis,\r\n        warnings,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        order,\r\n        riskAnalysis\r\n      };\r\n\r\n    } catch (error) {\r\n      const errorMsg = `Failed to place order with risk management: ${error instanceof Error ? error.message : 'Unknown error'}`;\r\n      console.error(`❌ ${errorMsg}`);\r\n      \r\n      this.emit('riskManagedOrderError', {\r\n        orderRequest,\r\n        riskConfig,\r\n        error: errorMsg,\r\n        timestamp: new Date()\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        rejectionReason: errorMsg,\r\n        riskAnalysis: {\r\n          positionSizeCheck: false,\r\n          leverageCheck: false,\r\n          dailyLossCheck: false,\r\n          drawdownCheck: false,\r\n          concurrentTradesCheck: false,\r\n          emergencyStopCheck: false,\r\n          riskScoreCheck: false,\r\n          warnings: []\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Map CCXT order status to our TradeStatus\r\n   */\r\n  private mapOrderStatus(ccxtStatus: string): TradeStatus {\r\n    switch (ccxtStatus) {\r\n      case 'open':\r\n        return 'open';\r\n      case 'closed':\r\n      case 'filled':\r\n        return 'filled';\r\n      case 'canceled':\r\n      case 'cancelled':\r\n        return 'cancelled';\r\n      case 'partial':\r\n        return 'partial';\r\n      case 'rejected':\r\n        return 'rejected';\r\n      default:\r\n        return 'pending';\r\n    }\r\n  }\r\n}\r\n\r\nexport default BybitExchange;","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\exchanges\\exchange-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\middleware\\app-monitoring.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\alerts.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\health.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\logs.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\performance.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\routes\\plugins.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found rename from package \"fs/promises\" with non literal argument at index 0,1","line":184,"column":13,"nodeType":"CallExpression","endLine":184,"endColumn":51},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlink from package \"fs/promises\" with non literal argument at index 0","line":209,"column":15,"nodeType":"CallExpression","endLine":209,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlink from package \"fs/promises\" with non literal argument at index 0","line":222,"column":15,"nodeType":"CallExpression","endLine":222,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlink from package \"fs/promises\" with non literal argument at index 0","line":338,"column":13,"nodeType":"CallExpression","endLine":338,"endColumn":39}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Strategy Plugin Management API Routes\r\n * \r\n * REST API endpoints for managing custom strategy plugins\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\n\r\nimport { Router } from 'express';\r\nimport multer from 'multer';\r\n\r\nimport logger from '../services/logging.service';\r\nimport { strategyPluginManager } from '../strategies/plugin-manager';\r\nimport { strategyFactory } from '../strategies/strategy-factory';\r\n\r\nconst router = Router();\r\n\r\n// Configure multer for plugin file uploads\r\nconst upload = multer({\r\n  dest: 'temp-uploads/',\r\n  fileFilter: (req, file, cb: multer.FileFilterCallback) => {\r\n    // Only allow .ts and .js files\r\n    if (file.mimetype === 'application/typescript' || \r\n        file.mimetype === 'application/javascript' ||\r\n        file.originalname.endsWith('.ts') ||\r\n        file.originalname.endsWith('.js')) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error('Only TypeScript (.ts) and JavaScript (.js) files are allowed'));\r\n    }\r\n  },\r\n  limits: {\r\n    fileSize: 1024 * 1024 // 1MB limit\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/plugins\r\n * Get all available plugins\r\n */\r\nrouter.get('/', async (req, res) => {\r\n  try {\r\n    const plugins = strategyFactory.getAvailablePlugins();\r\n    const builtInStrategies = strategyFactory.getBuiltInStrategies();\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        plugins,\r\n        builtInStrategies,\r\n        total: plugins.length\r\n      }\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to get plugins', { error });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to retrieve plugins',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/plugins/search\r\n * Search plugins by criteria\r\n */\r\nrouter.get('/search', async (req, res) => {\r\n  try {\r\n    const { name, category, riskLevel, supportedMarket, tags } = req.query;\r\n    \r\n    const criteria: any = {};\r\n    if (name) {criteria.name = name as string;}\r\n    if (category) {criteria.category = category as string;}\r\n    if (riskLevel) {criteria.riskLevel = riskLevel as string;}\r\n    if (supportedMarket) {criteria.supportedMarket = supportedMarket as string;}\r\n    if (tags) {criteria.tags = (tags as string).split(',');}\r\n    \r\n    const results = strategyFactory.searchPlugins(criteria);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        results,\r\n        count: results.length,\r\n        criteria\r\n      }\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to search plugins', { error });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to search plugins',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/plugins/:pluginId\r\n * Get specific plugin details\r\n */\r\nrouter.get('/:pluginId', async (req, res) => {\r\n  try {\r\n    const { pluginId } = req.params;\r\n    const plugin = strategyPluginManager.getPlugin(pluginId);\r\n    if (!plugin) {\r\n      res.status(404).json({\r\n        success: false,\r\n        error: 'Plugin not found'\r\n      });\r\n      return;\r\n    }\r\n    res.json({\r\n      success: true,\r\n      data: plugin\r\n    });\r\n    \r\n  } catch (error) {\r\n    logger.error('Failed to get plugin details', { error, pluginId: req.params.pluginId });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to retrieve plugin details',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n    \r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/plugins/upload\r\n * Upload and register a new plugin\r\n */\r\nrouter.post('/upload', upload.single('plugin'), async (req, res) => {\r\n  try {\r\n    if (!req.file) {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: 'No plugin file provided'\r\n      });\r\n      return;\r\n    }\r\n\r\n    const tempFilePath = req.file.path;\r\n    const originalFileName = req.file.originalname;\r\n    \r\n    // Validate and sanitize filename\r\n    if (!originalFileName || typeof originalFileName !== 'string') {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: 'Invalid filename provided'\r\n      });\r\n      return;\r\n    }\r\n    \r\n    // Remove dangerous characters and ensure .js/.ts extension\r\n    const sanitizedFileName = path.basename(originalFileName).replace(/[^a-zA-Z0-9._-]/g, '');\r\n    if (!sanitizedFileName.match(/\\.(js|ts)$/)) {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: 'Only .js and .ts files are allowed'\r\n      });\r\n      return;\r\n    }\r\n    \r\n    const pluginsDir = path.resolve(process.cwd(), 'plugins');\r\n    const finalFilePath = path.join(pluginsDir, sanitizedFileName);\r\n    \r\n    // Ensure final path is within plugins directory\r\n    if (!path.resolve(finalFilePath).startsWith(pluginsDir)) {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: 'Invalid file path'\r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Ensure plugins directory exists\r\n      await fs.mkdir(pluginsDir, { recursive: true });\r\n      \r\n      // Move file to plugins directory\r\n      await fs.rename(tempFilePath, finalFilePath);\r\n      \r\n      // Register the plugin\r\n      const pluginId = await strategyFactory.registerPlugin(finalFilePath);\r\n      \r\n      // Get plugin details\r\n      const plugin = strategyPluginManager.getPlugin(pluginId);\r\n      \r\n      logger.info(`Plugin uploaded and registered successfully`, { \r\n        pluginId, \r\n        fileName: sanitizedFileName,\r\n        uploader: req.ip \r\n      });\r\n      \r\n      res.status(201).json({\r\n        success: true,\r\n        message: 'Plugin uploaded and registered successfully',\r\n        data: {\r\n          pluginId,\r\n          plugin\r\n        }\r\n      });\r\n    } catch (registrationError) {\r\n      // Clean up file if registration failed\r\n      try {\r\n        await fs.unlink(finalFilePath);\r\n      } catch (cleanupError) {\r\n        logger.warn('Failed to cleanup file after registration failure', { \r\n          filePath: finalFilePath, \r\n          error: cleanupError \r\n        });\r\n      }\r\n      throw registrationError;\r\n    }\r\n  } catch (error) {\r\n    // Clean up temp file\r\n    if (req.file?.path) {\r\n      try {\r\n        await fs.unlink(req.file.path);\r\n      } catch (cleanupError) {\r\n        logger.warn('Failed to cleanup temp file', { filePath: req.file.path, error: cleanupError });\r\n      }\r\n    }\r\n    \r\n    logger.error('Failed to upload plugin', { error });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to upload and register plugin',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/plugins/:pluginId/validate\r\n * Validate plugin configuration\r\n */\r\nrouter.post('/:pluginId/validate', async (req, res) => {\r\n  try {\r\n    const { pluginId } = req.params;\r\n    const { config } = req.body;\r\n    if (!config) {\r\n      res.status(400).json({\r\n        success: false,\r\n        error: 'Configuration is required'\r\n      });\r\n      return;\r\n    }\r\n    const validation = await strategyPluginManager.validatePluginConfig(pluginId, config);\r\n    res.json({\r\n      success: true,\r\n      data: validation\r\n    });\r\n    \r\n  } catch (error) {\r\n    logger.error('Failed to validate plugin config', { error, pluginId: req.params.pluginId });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to validate plugin configuration',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n    \r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/plugins/:pluginId/default-config\r\n * Get default configuration for a plugin\r\n */\r\nrouter.get('/:pluginId/default-config', async (req, res) => {\r\n  try {\r\n    const { pluginId } = req.params;\r\n    const defaultConfig = await strategyFactory.getDefaultConfig('custom', pluginId);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: defaultConfig\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to get default config', { error, pluginId: req.params.pluginId });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to retrieve default configuration',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * POST /api/plugins/:pluginId/unload\r\n * Unload a plugin\r\n */\r\nrouter.post('/:pluginId/unload', async (req, res) => {\r\n  try {\r\n    const { pluginId } = req.params;\r\n    \r\n    await strategyFactory.unloadPlugin(pluginId);\r\n    \r\n    logger.info(`Plugin unloaded successfully`, { pluginId, requester: req.ip });\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: 'Plugin unloaded successfully'\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to unload plugin', { error, pluginId: req.params.pluginId });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to unload plugin',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * DELETE /api/plugins/:pluginId\r\n * Delete a plugin (unload and remove file)\r\n */\r\nrouter.delete('/:pluginId', async (req, res) => {\r\n  try {\r\n    const { pluginId } = req.params;\r\n    // Get plugin info before deletion\r\n    const plugin = strategyPluginManager.getPlugin(pluginId);\r\n    if (!plugin) {\r\n      res.status(404).json({\r\n        success: false,\r\n        error: 'Plugin not found'\r\n      });\r\n      return;\r\n    }\r\n    // Unload plugin first\r\n    await strategyFactory.unloadPlugin(pluginId);\r\n    // Remove plugin file\r\n    try {\r\n      await fs.unlink(plugin.filePath);\r\n    } catch (fileError) {\r\n      logger.warn('Failed to delete plugin file', { filePath: plugin.filePath, error: fileError });\r\n    }\r\n    logger.info(`Plugin deleted successfully`, { \r\n      pluginId, \r\n      fileName: path.basename(plugin.filePath),\r\n      requester: req.ip \r\n    });\r\n    res.json({\r\n      success: true,\r\n      message: 'Plugin deleted successfully'\r\n    });\r\n    \r\n  } catch (error) {\r\n    logger.error('Failed to delete plugin', { error, pluginId: req.params.pluginId });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to delete plugin',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n    \r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/plugins/categories\r\n * Get available plugin categories\r\n */\r\nrouter.get('/categories', async (req, res) => {\r\n  try {\r\n    const plugins = strategyFactory.getAvailablePlugins();\r\n    const categories = [...new Set(plugins.map(p => p.category))].sort();\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: categories\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to get plugin categories', { error });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to retrieve plugin categories',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * GET /api/plugins/stats\r\n * Get plugin statistics\r\n */\r\nrouter.get('/stats', async (req, res) => {\r\n  try {\r\n    const plugins = strategyFactory.getAvailablePlugins();\r\n    const builtInStrategies = strategyFactory.getBuiltInStrategies();\r\n    \r\n    const stats = {\r\n      totalPlugins: plugins.length,\r\n      loadedPlugins: plugins.filter(p => p.isLoaded).length,\r\n      errorPlugins: plugins.filter(p => p.error).length,\r\n      builtInStrategies: builtInStrategies.length,\r\n      categories: [...new Set(plugins.map(p => p.category))].length,\r\n      riskLevels: {\r\n        low: plugins.filter(p => p.riskLevel === 'low').length,\r\n        medium: plugins.filter(p => p.riskLevel === 'medium').length,\r\n        high: plugins.filter(p => p.riskLevel === 'high').length\r\n      }\r\n    };\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: stats\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to get plugin stats', { error });\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to retrieve plugin statistics',\r\n      details: error instanceof Error ? error.message : String(error)\r\n    });\r\n  }\r\n});\r\n\r\nexport default router; ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\bot-trading-cycle-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\database-health-check.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\performance-monitoring-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\production-readiness-validation.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":64,"column":13,"nodeType":"CallExpression","endLine":64,"endColumn":31},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":90,"column":11,"nodeType":"CallExpression","endLine":90,"endColumn":33},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":91,"column":28,"nodeType":"CallExpression","endLine":91,"endColumn":60},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":116,"column":11,"nodeType":"CallExpression","endLine":116,"endColumn":40},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":132,"column":11,"nodeType":"CallExpression","endLine":132,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":158,"column":11,"nodeType":"CallExpression","endLine":158,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":184,"column":11,"nodeType":"CallExpression","endLine":184,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":210,"column":11,"nodeType":"CallExpression","endLine":210,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":238,"column":27,"nodeType":"CallExpression","endLine":238,"endColumn":83},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":269,"column":11,"nodeType":"CallExpression","endLine":269,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":274,"column":11,"nodeType":"CallExpression","endLine":274,"endColumn":33},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":289,"column":33,"nodeType":"CallExpression","endLine":289,"endColumn":49},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":311,"column":10,"nodeType":"CallExpression","endLine":311,"endColumn":28},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":315,"column":19,"nodeType":"CallExpression","endLine":315,"endColumn":38},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":319,"column":20,"nodeType":"CallExpression","endLine":319,"endColumn":41},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":334,"column":12,"nodeType":"CallExpression","endLine":334,"endColumn":42},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":338,"column":38,"nodeType":"CallExpression","endLine":338,"endColumn":78},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":353,"column":12,"nodeType":"CallExpression","endLine":353,"endColumn":40},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":357,"column":32,"nodeType":"CallExpression","endLine":357,"endColumn":70},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":373,"column":13,"nodeType":"CallExpression","endLine":373,"endColumn":37},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":374,"column":25,"nodeType":"CallExpression","endLine":374,"endColumn":50}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { execSync } from 'child_process';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\ninterface ValidationResult {\r\n  component: string;\r\n  status: 'pass' | 'fail' | 'warning';\r\n  message: string;\r\n  details?: any;\r\n}\r\n\r\ninterface ProductionReadinessReport {\r\n  overall: 'ready' | 'needs-attention' | 'not-ready';\r\n  validations: ValidationResult[];\r\n  summary: {\r\n    passed: number;\r\n    failed: number;\r\n    warnings: number;\r\n    total: number;\r\n  };\r\n  recommendations: string[];\r\n}\r\n\r\nclass ProductionReadinessValidator {\r\n  private results: ValidationResult[] = [];\r\n  private readonly projectRoot: string;\r\n\r\n  constructor() {\r\n    this.projectRoot = process.cwd();\r\n  }\r\n\r\n  private addResult(component: string, status: 'pass' | 'fail' | 'warning', message: string, details?: any): void {\r\n    this.results.push({ component, status, message, details });\r\n  }\r\n\r\n  private async validateTypeScriptCompilation(): Promise<void> {\r\n    console.log('1. Validating TypeScript Compilation...');\r\n    try {\r\n      execSync('npm run build', { \r\n        stdio: 'pipe',\r\n        cwd: this.projectRoot,\r\n        timeout: 60000\r\n      });\r\n      this.addResult('TypeScript Compilation', 'pass', 'All TypeScript files compile successfully');\r\n    } catch (error: any) {\r\n      this.addResult('TypeScript Compilation', 'fail', 'TypeScript compilation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateTestSuite(): Promise<void> {\r\n    console.log('2. Validating Test Suite...');\r\n    try {\r\n      // Check if test files exist\r\n      const testDirs = [\r\n        path.join(this.projectRoot, 'packages/backend/tests'),\r\n        path.join(this.projectRoot, 'packages/frontend/tests'),\r\n        path.join(this.projectRoot, 'packages/shared/tests')\r\n      ];\r\n\r\n      const testFiles: string[] = [];\r\n      testDirs.forEach(dir => {\r\n        if (fs.existsSync(dir)) {\r\n          const files = this.getFilesRecursively(dir, '.test.ts');\r\n          testFiles.push(...files);\r\n        }\r\n      });\r\n\r\n      if (testFiles.length > 0) {\r\n        this.addResult('Test Suite', 'pass', `Found ${testFiles.length} test files`, {\r\n          testFiles: testFiles.slice(0, 10) // Show first 10 for brevity\r\n        });\r\n      } else {\r\n        this.addResult('Test Suite', 'warning', 'No test files found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Test Suite', 'fail', 'Test suite validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateEnvironmentConfiguration(): Promise<void> {\r\n    console.log('3. Validating Environment Configuration...');\r\n    try {\r\n      const envFile = path.join(this.projectRoot, '.env');\r\n      const envExampleFile = path.join(this.projectRoot, '.env.example');\r\n\r\n      if (fs.existsSync(envFile)) {\r\n        const envContent = fs.readFileSync(envFile, 'utf8');\r\n        const requiredVars = [\r\n          'NODE_ENV',\r\n          'DATABASE_URL',\r\n          'BYBIT_API_KEY',\r\n          'BYBIT_SECRET',\r\n          'REDIS_URL'\r\n        ];\r\n\r\n        const missingVars = requiredVars.filter(varName => \r\n          !envContent.includes(`${varName}=`) || envContent.includes(`${varName}=`)\r\n        );\r\n\r\n        if (missingVars.length === 0) {\r\n          this.addResult('Environment Configuration', 'pass', 'All required environment variables are configured');\r\n        } else {\r\n          this.addResult('Environment Configuration', 'warning', 'Some environment variables may need attention', {\r\n            requiredVars,\r\n            note: 'Please verify all environment variables are properly set'\r\n          });\r\n        }\r\n      } else {\r\n        this.addResult('Environment Configuration', 'fail', '.env file not found');\r\n      }\r\n\r\n      if (fs.existsSync(envExampleFile)) {\r\n        this.addResult('Environment Documentation', 'pass', '.env.example file exists for reference');\r\n      } else {\r\n        this.addResult('Environment Documentation', 'warning', '.env.example file not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Environment Configuration', 'fail', 'Environment validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateDatabaseConnectivity(): Promise<void> {\r\n    console.log('4. Validating Database Connectivity...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/database-health-check.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('Database Health Check Passed')) {\r\n          this.addResult('Database Connectivity', 'pass', 'Database health check passed');\r\n        } else {\r\n          this.addResult('Database Connectivity', 'warning', 'Database health check completed with warnings');\r\n        }\r\n      } else {\r\n        this.addResult('Database Connectivity', 'warning', 'Database health check script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Database Connectivity', 'fail', 'Database connectivity validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateSignalProcessing(): Promise<void> {\r\n    console.log('5. Validating Signal Processing...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/signal-processing-validation.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('All Signal Processing Validation Tests Passed')) {\r\n          this.addResult('Signal Processing', 'pass', 'Signal processing validation passed');\r\n        } else {\r\n          this.addResult('Signal Processing', 'warning', 'Signal processing validation completed with issues');\r\n        }\r\n      } else {\r\n        this.addResult('Signal Processing', 'warning', 'Signal processing validation script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Signal Processing', 'fail', 'Signal processing validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateTradingIntegration(): Promise<void> {\r\n    console.log('6. Validating Trading Integration...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/bot-trading-cycle-validation.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('All Bot Trading Cycle Validation Tests Passed')) {\r\n          this.addResult('Trading Integration', 'pass', 'Trading cycle validation passed');\r\n        } else {\r\n          this.addResult('Trading Integration', 'warning', 'Trading cycle validation completed with issues');\r\n        }\r\n      } else {\r\n        this.addResult('Trading Integration', 'warning', 'Trading cycle validation script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Trading Integration', 'fail', 'Trading integration validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validatePerformanceMonitoring(): Promise<void> {\r\n    console.log('7. Validating Performance Monitoring...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/performance-monitoring-validation.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('All Performance Monitoring and Metrics Validation Tests Passed')) {\r\n          this.addResult('Performance Monitoring', 'pass', 'Performance monitoring validation passed');\r\n        } else {\r\n          this.addResult('Performance Monitoring', 'warning', 'Performance monitoring validation completed with issues');\r\n        }\r\n      } else {\r\n        this.addResult('Performance Monitoring', 'warning', 'Performance monitoring validation script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Performance Monitoring', 'fail', 'Performance monitoring validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateSecurityConfiguration(): Promise<void> {\r\n    console.log('8. Validating Security Configuration...');\r\n    try {\r\n      // Check for security-related files and configurations\r\n      const securityChecks = {\r\n        packageJsonSecurity: this.checkPackageJsonSecurity(),\r\n        gitignorePresent: fs.existsSync(path.join(this.projectRoot, '.gitignore')),\r\n        envInGitignore: this.checkEnvInGitignore(),\r\n        httpsConfiguration: this.checkHttpsConfiguration()\r\n      };\r\n\r\n      const passedChecks = Object.values(securityChecks).filter(Boolean).length;\r\n      const totalChecks = Object.keys(securityChecks).length;\r\n\r\n      if (passedChecks === totalChecks) {\r\n        this.addResult('Security Configuration', 'pass', 'All security checks passed');\r\n      } else if (passedChecks >= totalChecks * 0.8) {\r\n        this.addResult('Security Configuration', 'warning', `${passedChecks}/${totalChecks} security checks passed`);\r\n      } else {\r\n        this.addResult('Security Configuration', 'fail', `Only ${passedChecks}/${totalChecks} security checks passed`);\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Security Configuration', 'fail', 'Security validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateDocumentation(): Promise<void> {\r\n    console.log('9. Validating Documentation...');\r\n    try {\r\n      const docsDir = path.join(this.projectRoot, 'docs');\r\n      const readmeFile = path.join(this.projectRoot, 'README.md');\r\n      \r\n      let docScore = 0;\r\n      const checks = [];\r\n\r\n      if (fs.existsSync(readmeFile)) {\r\n        docScore++;\r\n        checks.push('README.md present');\r\n      }\r\n\r\n      if (fs.existsSync(docsDir)) {\r\n        const docFiles = this.getFilesRecursively(docsDir, '.md');\r\n        if (docFiles.length > 0) {\r\n          docScore++;\r\n          checks.push(`${docFiles.length} documentation files found`);\r\n        }\r\n      }\r\n\r\n      // Check for API documentation\r\n      const apiDocPaths = [\r\n        path.join(this.projectRoot, 'docs/api'),\r\n        path.join(this.projectRoot, 'docs/API.md'),\r\n        path.join(docsDir, 'api.md')\r\n      ];\r\n\r\n      if (apiDocPaths.some(p => fs.existsSync(p))) {\r\n        docScore++;\r\n        checks.push('API documentation present');\r\n      }\r\n\r\n      if (docScore >= 2) {\r\n        this.addResult('Documentation', 'pass', 'Documentation is adequate', { checks });\r\n      } else if (docScore === 1) {\r\n        this.addResult('Documentation', 'warning', 'Documentation needs improvement', { checks });\r\n      } else {\r\n        this.addResult('Documentation', 'fail', 'Documentation is insufficient', { checks });\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Documentation', 'fail', 'Documentation validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private getFilesRecursively(dir: string, extension: string): string[] {\r\n    const files: string[] = [];\r\n    \r\n    if (!fs.existsSync(dir)) {\r\n      return files;\r\n    }\r\n    \r\n    const items = fs.readdirSync(dir);\r\n    \r\n    for (const item of items) {\r\n      const fullPath = path.join(dir, item);\r\n      const stat = fs.statSync(fullPath);\r\n      \r\n      if (stat.isDirectory()) {\r\n        files.push(...this.getFilesRecursively(fullPath, extension));\r\n      } else if (item.endsWith(extension)) {\r\n        files.push(fullPath);\r\n      }\r\n    }\r\n    \r\n    return files;\r\n  }\r\n\r\n  private checkPackageJsonSecurity(): boolean {\r\n    try {\r\n      const packageJsonPath = path.join(this.projectRoot, 'package.json');\r\n      if (!fs.existsSync(packageJsonPath)) {\r\n        return false;\r\n      }\r\n      \r\n      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\r\n      \r\n      // Check for security-related scripts or dependencies\r\n      const hasSecurityDeps = packageJson.devDependencies && \r\n        (packageJson.devDependencies['@types/node'] || packageJson.devDependencies['typescript']);\r\n      \r\n      return Boolean(hasSecurityDeps);\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private checkEnvInGitignore(): boolean {\r\n    try {\r\n      const gitignorePath = path.join(this.projectRoot, '.gitignore');\r\n      if (!fs.existsSync(gitignorePath)) {\r\n        return false;\r\n      }\r\n      \r\n      const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');\r\n      return gitignoreContent.includes('.env') || gitignoreContent.includes('*.env');\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private checkHttpsConfiguration(): boolean {\r\n    // This is a simplified check - in a real environment, you'd check actual server configuration\r\n    try {\r\n      const configFiles = [\r\n        path.join(this.projectRoot, 'packages/backend/src/config'),\r\n        path.join(this.projectRoot, 'config')\r\n      ];\r\n      \r\n      for (const configDir of configFiles) {\r\n        if (fs.existsSync(configDir)) {\r\n          const files = fs.readdirSync(configDir);\r\n          const hasServerConfig = files.some(file => \r\n            file.includes('server') || file.includes('express') || file.includes('app')\r\n          );\r\n          if (hasServerConfig) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      \r\n      return true; // Assume configured if config structure exists\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private generateRecommendations(): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    const failures = this.results.filter(r => r.status === 'fail');\r\n    const warnings = this.results.filter(r => r.status === 'warning');\r\n    \r\n    if (failures.length > 0) {\r\n      recommendations.push('🔴 Address all failed validations before production deployment');\r\n      failures.forEach(f => {\r\n        recommendations.push(`   - Fix ${f.component}: ${f.message}`);\r\n      });\r\n    }\r\n    \r\n    if (warnings.length > 0) {\r\n      recommendations.push('🟡 Review and address warning items for optimal production readiness');\r\n      warnings.forEach(w => {\r\n        recommendations.push(`   - Review ${w.component}: ${w.message}`);\r\n      });\r\n    }\r\n    \r\n    // General recommendations\r\n    recommendations.push('📊 Set up monitoring and alerting for production environment');\r\n    recommendations.push('🔄 Implement automated backup and recovery procedures');\r\n    recommendations.push('📈 Configure performance monitoring and metrics collection');\r\n    recommendations.push('🔒 Review and audit security configurations regularly');\r\n    recommendations.push('📚 Keep documentation updated with any changes');\r\n    \r\n    return recommendations;\r\n  }\r\n\r\n  public async runFullValidation(): Promise<ProductionReadinessReport> {\r\n    console.log('🔍 Starting Production Readiness Validation...\\n');\r\n\r\n    // Run all validations\r\n    await this.validateTypeScriptCompilation();\r\n    await this.validateTestSuite();\r\n    await this.validateEnvironmentConfiguration();\r\n    await this.validateDatabaseConnectivity();\r\n    await this.validateSignalProcessing();\r\n    await this.validateTradingIntegration();\r\n    await this.validatePerformanceMonitoring();\r\n    await this.validateSecurityConfiguration();\r\n    await this.validateDocumentation();\r\n\r\n    // Calculate summary\r\n    const passed = this.results.filter(r => r.status === 'pass').length;\r\n    const failed = this.results.filter(r => r.status === 'fail').length;\r\n    const warnings = this.results.filter(r => r.status === 'warning').length;\r\n    const total = this.results.length;\r\n\r\n    // Determine overall status\r\n    let overall: 'ready' | 'needs-attention' | 'not-ready';\r\n    if (failed === 0 && warnings <= 2) {\r\n      overall = 'ready';\r\n    } else if (failed === 0) {\r\n      overall = 'needs-attention';\r\n    } else {\r\n      overall = 'not-ready';\r\n    }\r\n\r\n    const report: ProductionReadinessReport = {\r\n      overall,\r\n      validations: this.results,\r\n      summary: { passed, failed, warnings, total },\r\n      recommendations: this.generateRecommendations()\r\n    };\r\n\r\n    this.printReport(report);\r\n    return report;\r\n  }\r\n\r\n  private printReport(report: ProductionReadinessReport): void {\r\n    console.log('\\n' + '='.repeat(80));\r\n    console.log('📋 PRODUCTION READINESS VALIDATION REPORT');\r\n    console.log('='.repeat(80));\r\n\r\n    // Overall status\r\n    const statusEmoji = {\r\n      'ready': '✅',\r\n      'needs-attention': '⚠️',\r\n      'not-ready': '❌'\r\n    };\r\n\r\n    console.log(`\\n🎯 Overall Status: ${statusEmoji[report.overall]} ${report.overall.toUpperCase()}`);\r\n\r\n    // Summary\r\n    console.log(`\\n📊 Summary:`);\r\n    console.log(`   ✅ Passed: ${report.summary.passed}`);\r\n    console.log(`   ⚠️  Warnings: ${report.summary.warnings}`);\r\n    console.log(`   ❌ Failed: ${report.summary.failed}`);\r\n    console.log(`   📝 Total: ${report.summary.total}`);\r\n\r\n    // Detailed results\r\n    console.log(`\\n📋 Detailed Results:`);\r\n    report.validations.forEach(result => {\r\n      const emoji = result.status === 'pass' ? '✅' : result.status === 'warning' ? '⚠️' : '❌';\r\n      console.log(`   ${emoji} ${result.component}: ${result.message}`);\r\n    });\r\n\r\n    // Recommendations\r\n    console.log(`\\n💡 Recommendations:`);\r\n    report.recommendations.forEach(rec => {\r\n      console.log(`   ${rec}`);\r\n    });\r\n\r\n    console.log('\\n' + '='.repeat(80));\r\n  }\r\n}\r\n\r\n// Main execution\r\nasync function main(): Promise<void> {\r\n  const validator = new ProductionReadinessValidator();\r\n  const report = await validator.runFullValidation();\r\n  \r\n  // Exit with appropriate code\r\n  process.exit(report.overall === 'not-ready' ? 1 : 0);\r\n}\r\n\r\nif (require.main === module) {\r\n  main().catch(error => {\r\n    console.error('❌ Production readiness validation failed:', error);\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nexport { ProductionReadinessValidator };\r\nexport type { ProductionReadinessReport, ValidationResult };\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\signal-processing-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection-fixed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\scripts\\test-db-connection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\server-standalone.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\alert-manager.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\application-monitor.service.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":448,"column":7,"nodeType":"MemberExpression","endLine":448,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Application Monitor Service\r\n * \r\n * Monitors application performance including response times, throughput, error rates,\r\n * and API endpoint metrics. Provides detailed performance analytics for the trading platform.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\n\r\nimport logger from './logging.service';\r\n\r\nexport interface EndpointMetrics {\r\n  path: string;\r\n  method: string;\r\n  count: number;\r\n  totalTime: number;\r\n  averageTime: number;\r\n  minTime: number;\r\n  maxTime: number;\r\n  errorCount: number;\r\n  errorRate: number;\r\n  lastCall: Date;\r\n  statusCodes: Record<number, number>;\r\n}\r\n\r\nexport interface ApplicationMetrics {\r\n  performance: {\r\n    responseTime: {\r\n      average: number;\r\n      p50: number;\r\n      p95: number;\r\n      p99: number;\r\n    };\r\n    throughput: {\r\n      requestsPerSecond: number;\r\n      requestsPerMinute: number;\r\n    };\r\n    errorRate: number;\r\n    uptime: number;\r\n  };\r\n  endpoints: Record<string, EndpointMetrics>;\r\n  errors: {\r\n    total: number;\r\n    byType: Record<string, number>;\r\n    recent: ErrorLog[];\r\n  };\r\n  database: {\r\n    queryCount: number;\r\n    averageQueryTime: number;\r\n    slowQueries: number;\r\n    connectionPoolSize: number;\r\n    activeConnections: number;\r\n  };\r\n  websocket: {\r\n    activeConnections: number;\r\n    messagesPerSecond: number;\r\n    totalMessages: number;\r\n    disconnections: number;\r\n  };\r\n  memory: {\r\n    heapUsed: number;\r\n    heapTotal: number;\r\n    external: number;\r\n    rss: number;\r\n    arrayBuffers: number;\r\n  };\r\n  system: {\r\n    uptime: number;\r\n    cpuUsage: {\r\n      user: number;\r\n      system: number;\r\n    };\r\n    platform: string;\r\n    arch: string;\r\n    nodeVersion: string;\r\n  };\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface RequestLog {\r\n  id: string;\r\n  method: string;\r\n  path: string;\r\n  statusCode: number;\r\n  responseTime: number;\r\n  userAgent?: string;\r\n  ip?: string;\r\n  timestamp: Date;\r\n  error?: string;\r\n}\r\n\r\nexport interface ErrorLog {\r\n  id: string;\r\n  type: string;\r\n  message: string;\r\n  stack?: string;\r\n  context?: any;\r\n  timestamp: Date;\r\n  level: 'error' | 'warning';\r\n}\r\n\r\nexport interface PerformanceAlert {\r\n  type: 'response_time' | 'error_rate' | 'throughput' | 'database' | 'memory';\r\n  level: 'warning' | 'critical';\r\n  message: string;\r\n  value: number;\r\n  threshold: number;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface ApplicationMonitorConfig {\r\n  collectInterval: number; // milliseconds\r\n  requestRetentionPeriod: number; // milliseconds\r\n  errorRetentionPeriod: number; // milliseconds\r\n  maxRequestLogs: number;\r\n  maxErrorLogs: number;\r\n  alertThresholds: {\r\n    responseTime: { warning: number; critical: number }; // milliseconds\r\n    errorRate: { warning: number; critical: number }; // percentage\r\n    throughput: { warning: number; critical: number }; // requests per second\r\n    databaseQueryTime: { warning: number; critical: number }; // milliseconds\r\n  };\r\n  enableDetailedLogging: boolean;\r\n}\r\n\r\nexport class ApplicationMonitorService extends EventEmitter {\r\n  private static instance: ApplicationMonitorService;\r\n  private config: ApplicationMonitorConfig;\r\n  private isRunning = false;\r\n  private monitorInterval?: NodeJS.Timeout;\r\n  private startTime: Date;\r\n  \r\n  // Metrics storage\r\n  private requestLogs: RequestLog[] = [];\r\n  private errorLogs: ErrorLog[] = [];\r\n  private endpointMetrics: Map<string, EndpointMetrics> = new Map();\r\n  private responseTimes: number[] = [];\r\n  private requestsPerInterval = 0;\r\n  private errorsPerInterval = 0;\r\n  \r\n  // Database metrics\r\n  private databaseMetrics = {\r\n    queryCount: 0,\r\n    totalQueryTime: 0,\r\n    slowQueries: 0,\r\n    connectionPoolSize: 0,\r\n    activeConnections: 0\r\n  };\r\n  \r\n  // WebSocket metrics\r\n  private websocketMetrics = {\r\n    activeConnections: 0,\r\n    messagesPerSecond: 0,\r\n    totalMessages: 0,\r\n    disconnections: 0\r\n  };\r\n\r\n  private constructor(config: Partial<ApplicationMonitorConfig> = {}) {\r\n    super();\r\n    \r\n    this.config = {\r\n      collectInterval: 10000, // 10 seconds\r\n      requestRetentionPeriod: 60 * 60 * 1000, // 1 hour\r\n      errorRetentionPeriod: 24 * 60 * 60 * 1000, // 24 hours\r\n      maxRequestLogs: 10000,\r\n      maxErrorLogs: 1000,\r\n      alertThresholds: {\r\n        responseTime: { warning: 500, critical: 2000 },\r\n        errorRate: { warning: 5, critical: 10 },\r\n        throughput: { warning: 10, critical: 5 },\r\n        databaseQueryTime: { warning: 100, critical: 500 }\r\n      },\r\n      enableDetailedLogging: true,\r\n      ...config\r\n    };\r\n\r\n    this.startTime = new Date();\r\n    logger.info('Application Monitor Service initialized', { config: this.config });\r\n  }\r\n\r\n  /**\r\n   * Get singleton instance\r\n   */\r\n  public static getInstance(config?: Partial<ApplicationMonitorConfig>): ApplicationMonitorService {\r\n    if (!ApplicationMonitorService.instance) {\r\n      ApplicationMonitorService.instance = new ApplicationMonitorService(config);\r\n    }\r\n    return ApplicationMonitorService.instance;\r\n  }\r\n\r\n  /**\r\n   * Reset singleton instance (for testing)\r\n   */\r\n  public static resetInstance(): void {\r\n    if (ApplicationMonitorService.instance) {\r\n      ApplicationMonitorService.instance.shutdown();\r\n      ApplicationMonitorService.instance = undefined as any;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start application monitoring\r\n   */\r\n  public start(): void {\r\n    if (this.isRunning) {\r\n      logger.warn('Application Monitor is already running');\r\n      return;\r\n    }\r\n\r\n    this.isRunning = true;\r\n    \r\n    // Start periodic collection and analysis\r\n    this.monitorInterval = setInterval(() => {\r\n      this.collectMetrics();\r\n      this.checkAlerts();\r\n      this.cleanupOldLogs();\r\n    }, this.config.collectInterval);\r\n\r\n    logger.info('Application Monitor started', {\r\n      interval: this.config.collectInterval\r\n    });\r\n\r\n    this.emit('started');\r\n  }\r\n\r\n  /**\r\n   * Stop application monitoring\r\n   */\r\n  public stop(): void {\r\n    if (!this.isRunning) {\r\n      return;\r\n    }\r\n\r\n    this.isRunning = false;\r\n    \r\n    if (this.monitorInterval) {\r\n      clearInterval(this.monitorInterval);\r\n      this.monitorInterval = undefined;\r\n    }\r\n\r\n    logger.info('Application Monitor stopped');\r\n    this.emit('stopped');\r\n  }\r\n\r\n  /**\r\n   * Log a request\r\n   */\r\n  public logRequest(log: Omit<RequestLog, 'id' | 'timestamp'>): void {\r\n    const requestLog: RequestLog = {\r\n      id: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      timestamp: new Date(),\r\n      ...log\r\n    };\r\n\r\n    // Add to request logs\r\n    this.requestLogs.push(requestLog);\r\n    \r\n    // Update endpoint metrics\r\n    this.updateEndpointMetrics(requestLog);\r\n    \r\n    // Track response times\r\n    this.responseTimes.push(requestLog.responseTime);\r\n    this.requestsPerInterval++;\r\n    \r\n    // Track errors\r\n    if (requestLog.statusCode >= 400) {\r\n      this.errorsPerInterval++;\r\n    }\r\n\r\n    // Emit request event\r\n    this.emit('request', requestLog);\r\n\r\n    if (this.config.enableDetailedLogging) {\r\n      logger.debug('Request logged', {\r\n        method: requestLog.method,\r\n        path: requestLog.path,\r\n        statusCode: requestLog.statusCode,\r\n        responseTime: requestLog.responseTime\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log an error\r\n   */\r\n  public logError(error: Omit<ErrorLog, 'id' | 'timestamp'>): void {\r\n    const errorLog: ErrorLog = {\r\n      id: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      timestamp: new Date(),\r\n      ...error\r\n    };\r\n\r\n    this.errorLogs.push(errorLog);\r\n    this.emit('error', errorLog);\r\n\r\n    logger.error('Application error logged', {\r\n      type: errorLog.type,\r\n      message: errorLog.message,\r\n      level: errorLog.level\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update database metrics\r\n   */\r\n  public updateDatabaseMetrics(metrics: {\r\n    queryTime?: number;\r\n    connectionPoolSize?: number;\r\n    activeConnections?: number;\r\n    isSlowQuery?: boolean;\r\n  }): void {\r\n    if (metrics.queryTime !== undefined) {\r\n      this.databaseMetrics.queryCount++;\r\n      this.databaseMetrics.totalQueryTime += metrics.queryTime;\r\n      \r\n      if (metrics.isSlowQuery) {\r\n        this.databaseMetrics.slowQueries++;\r\n      }\r\n    }\r\n    \r\n    if (metrics.connectionPoolSize !== undefined) {\r\n      this.databaseMetrics.connectionPoolSize = metrics.connectionPoolSize;\r\n    }\r\n    \r\n    if (metrics.activeConnections !== undefined) {\r\n      this.databaseMetrics.activeConnections = metrics.activeConnections;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update WebSocket metrics\r\n   */\r\n  public updateWebSocketMetrics(metrics: {\r\n    activeConnections?: number;\r\n    messagesSent?: number;\r\n    disconnection?: boolean;\r\n  }): void {\r\n    if (metrics.activeConnections !== undefined) {\r\n      this.websocketMetrics.activeConnections = metrics.activeConnections;\r\n    }\r\n    \r\n    if (metrics.messagesSent !== undefined) {\r\n      this.websocketMetrics.totalMessages += metrics.messagesSent;\r\n    }\r\n    \r\n    if (metrics.disconnection) {\r\n      this.websocketMetrics.disconnections++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current application metrics\r\n   */\r\n  public getCurrentMetrics(): ApplicationMetrics {\r\n    const now = new Date();\r\n    const uptime = (now.getTime() - this.startTime.getTime()) / 1000;\r\n    const recentRequests = this.getRecentRequests(60000); // Last minute\r\n    const recentErrors = this.getRecentErrors(60000); // Last minute\r\n\r\n    // Calculate response time percentiles\r\n    const sortedResponseTimes = [...this.responseTimes].sort((a, b) => a - b);\r\n    const responseTimeStats = this.calculatePercentiles(sortedResponseTimes);\r\n\r\n    // Calculate throughput\r\n    const requestsPerMinute = recentRequests.length;\r\n    const requestsPerSecond = requestsPerMinute / 60;\r\n\r\n    // Calculate error rate\r\n    const errorRate = recentRequests.length > 0 \r\n      ? (recentErrors.length / recentRequests.length) * 100 \r\n      : 0;\r\n\r\n    // Calculate database averages\r\n    const averageQueryTime = this.databaseMetrics.queryCount > 0\r\n      ? this.databaseMetrics.totalQueryTime / this.databaseMetrics.queryCount\r\n      : 0;\r\n\r\n    // Calculate WebSocket messages per second\r\n    const messagesPerSecond = this.websocketMetrics.totalMessages / uptime;\r\n\r\n    // Get memory and system metrics\r\n    const memoryUsage = process.memoryUsage();\r\n    const systemUptime = process.uptime();\r\n    const cpuUsage = process.cpuUsage();\r\n\r\n    return {\r\n      performance: {\r\n        responseTime: {\r\n          average: responseTimeStats.average,\r\n          p50: responseTimeStats.p50,\r\n          p95: responseTimeStats.p95,\r\n          p99: responseTimeStats.p99\r\n        },\r\n        throughput: {\r\n          requestsPerSecond,\r\n          requestsPerMinute\r\n        },\r\n        errorRate,\r\n        uptime\r\n      },\r\n      endpoints: this.getEndpointMetricsSummary(),\r\n      errors: {\r\n        total: this.errorLogs.length,\r\n        byType: this.getErrorsByType(),\r\n        recent: this.getRecentErrors(3600000).slice(0, 10) // Last hour, top 10\r\n      },\r\n      database: {\r\n        queryCount: this.databaseMetrics.queryCount,\r\n        averageQueryTime,\r\n        slowQueries: this.databaseMetrics.slowQueries,\r\n        connectionPoolSize: this.databaseMetrics.connectionPoolSize,\r\n        activeConnections: this.databaseMetrics.activeConnections\r\n      },\r\n      websocket: {\r\n        activeConnections: this.websocketMetrics.activeConnections,\r\n        messagesPerSecond,\r\n        totalMessages: this.websocketMetrics.totalMessages,\r\n        disconnections: this.websocketMetrics.disconnections\r\n      },\r\n      memory: {\r\n        heapUsed: memoryUsage.heapUsed,\r\n        heapTotal: memoryUsage.heapTotal,\r\n        external: memoryUsage.external,\r\n        rss: memoryUsage.rss,\r\n        arrayBuffers: memoryUsage.arrayBuffers\r\n      },\r\n      system: {\r\n        uptime: systemUptime,\r\n        cpuUsage: {\r\n          user: cpuUsage.user,\r\n          system: cpuUsage.system\r\n        },\r\n        platform: process.platform,\r\n        arch: process.arch,\r\n        nodeVersion: process.version\r\n      },\r\n      timestamp: now\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get endpoint metrics summary\r\n   */\r\n  private getEndpointMetricsSummary(): Record<string, EndpointMetrics> {\r\n    const summary: Record<string, EndpointMetrics> = {};\r\n    \r\n    for (const [key, metrics] of this.endpointMetrics) {\r\n      summary[key] = { ...metrics };\r\n    }\r\n    \r\n    return summary;\r\n  }\r\n\r\n  /**\r\n   * Update endpoint metrics\r\n   */\r\n  private updateEndpointMetrics(request: RequestLog): void {\r\n    const key = `${request.method}:${request.path}`;\r\n    const existing = this.endpointMetrics.get(key);\r\n    \r\n    if (existing) {\r\n      existing.count++;\r\n      existing.totalTime += request.responseTime;\r\n      existing.averageTime = existing.totalTime / existing.count;\r\n      existing.minTime = Math.min(existing.minTime, request.responseTime);\r\n      existing.maxTime = Math.max(existing.maxTime, request.responseTime);\r\n      existing.lastCall = request.timestamp;\r\n      existing.statusCodes[request.statusCode] = (existing.statusCodes[request.statusCode] || 0) + 1;\r\n      \r\n      if (request.statusCode >= 400) {\r\n        existing.errorCount++;\r\n        existing.errorRate = (existing.errorCount / existing.count) * 100;\r\n      }\r\n    } else {\r\n      const newMetrics: EndpointMetrics = {\r\n        path: request.path,\r\n        method: request.method,\r\n        count: 1,\r\n        totalTime: request.responseTime,\r\n        averageTime: request.responseTime,\r\n        minTime: request.responseTime,\r\n        maxTime: request.responseTime,\r\n        errorCount: request.statusCode >= 400 ? 1 : 0,\r\n        errorRate: request.statusCode >= 400 ? 100 : 0,\r\n        lastCall: request.timestamp,\r\n        statusCodes: { [request.statusCode]: 1 }\r\n      };\r\n      \r\n      this.endpointMetrics.set(key, newMetrics);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate response time percentiles\r\n   */\r\n  private calculatePercentiles(responseTimes: number[]): {\r\n    average: number;\r\n    p50: number;\r\n    p95: number;\r\n    p99: number;\r\n  } {\r\n    if (responseTimes.length === 0) {\r\n      return { average: 0, p50: 0, p95: 0, p99: 0 };\r\n    }\r\n\r\n    const average = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;\r\n    const p50 = responseTimes[Math.floor(responseTimes.length * 0.5)] || 0;\r\n    const p95 = responseTimes[Math.floor(responseTimes.length * 0.95)] || 0;\r\n    const p99 = responseTimes[Math.floor(responseTimes.length * 0.99)] || 0;\r\n\r\n    return { average, p50, p95, p99 };\r\n  }\r\n\r\n  /**\r\n   * Get recent requests\r\n   */\r\n  private getRecentRequests(duration: number): RequestLog[] {\r\n    const cutoff = new Date(Date.now() - duration);\r\n    return this.requestLogs.filter(log => log.timestamp >= cutoff);\r\n  }\r\n\r\n  /**\r\n   * Get recent errors\r\n   */\r\n  private getRecentErrors(duration: number): ErrorLog[] {\r\n    const cutoff = new Date(Date.now() - duration);\r\n    return this.errorLogs.filter(log => log.timestamp >= cutoff);\r\n  }\r\n\r\n  /**\r\n   * Get errors by type\r\n   */\r\n  private getErrorsByType(): Record<string, number> {\r\n    const byType: Record<string, number> = {};\r\n    \r\n    for (const error of this.errorLogs) {\r\n      byType[error.type] = (byType[error.type] || 0) + 1;\r\n    }\r\n    \r\n    return byType;\r\n  }\r\n\r\n  /**\r\n   * Collect metrics and reset interval counters\r\n   */\r\n  private collectMetrics(): void {\r\n    const metrics = this.getCurrentMetrics();\r\n    \r\n    // Reset interval counters\r\n    this.requestsPerInterval = 0;\r\n    this.errorsPerInterval = 0;\r\n    \r\n    // Update WebSocket messages per second\r\n    this.websocketMetrics.messagesPerSecond = \r\n      this.websocketMetrics.totalMessages / metrics.performance.uptime;\r\n    \r\n    this.emit('metrics', metrics);\r\n    \r\n    logger.debug('Application metrics collected', {\r\n      requestsPerSecond: metrics.performance.throughput.requestsPerSecond,\r\n      errorRate: metrics.performance.errorRate,\r\n      averageResponseTime: metrics.performance.responseTime.average\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check for performance alerts\r\n   */\r\n  private checkAlerts(): void {\r\n    const metrics = this.getCurrentMetrics();\r\n    const alerts: PerformanceAlert[] = [];\r\n\r\n    // Response time alerts\r\n    const avgResponseTime = metrics.performance.responseTime.average;\r\n    if (avgResponseTime >= this.config.alertThresholds.responseTime.critical) {\r\n      alerts.push({\r\n        type: 'response_time',\r\n        level: 'critical',\r\n        message: `Critical response time: ${avgResponseTime.toFixed(1)}ms`,\r\n        value: avgResponseTime,\r\n        threshold: this.config.alertThresholds.responseTime.critical,\r\n        timestamp: new Date()\r\n      });\r\n    } else if (avgResponseTime >= this.config.alertThresholds.responseTime.warning) {\r\n      alerts.push({\r\n        type: 'response_time',\r\n        level: 'warning',\r\n        message: `High response time: ${avgResponseTime.toFixed(1)}ms`,\r\n        value: avgResponseTime,\r\n        threshold: this.config.alertThresholds.responseTime.warning,\r\n        timestamp: new Date()\r\n      });\r\n    }\r\n\r\n    // Error rate alerts\r\n    const errorRate = metrics.performance.errorRate;\r\n    if (errorRate >= this.config.alertThresholds.errorRate.critical) {\r\n      alerts.push({\r\n        type: 'error_rate',\r\n        level: 'critical',\r\n        message: `Critical error rate: ${errorRate.toFixed(1)}%`,\r\n        value: errorRate,\r\n        threshold: this.config.alertThresholds.errorRate.critical,\r\n        timestamp: new Date()\r\n      });\r\n    } else if (errorRate >= this.config.alertThresholds.errorRate.warning) {\r\n      alerts.push({\r\n        type: 'error_rate',\r\n        level: 'warning',\r\n        message: `High error rate: ${errorRate.toFixed(1)}%`,\r\n        value: errorRate,\r\n        threshold: this.config.alertThresholds.errorRate.warning,\r\n        timestamp: new Date()\r\n      });\r\n    }\r\n\r\n    // Throughput alerts (low throughput)\r\n    const throughput = metrics.performance.throughput.requestsPerSecond;\r\n    if (throughput <= this.config.alertThresholds.throughput.critical && throughput > 0) {\r\n      alerts.push({\r\n        type: 'throughput',\r\n        level: 'critical',\r\n        message: `Low throughput: ${throughput.toFixed(1)} req/s`,\r\n        value: throughput,\r\n        threshold: this.config.alertThresholds.throughput.critical,\r\n        timestamp: new Date()\r\n      });\r\n    } else if (throughput <= this.config.alertThresholds.throughput.warning && throughput > 0) {\r\n      alerts.push({\r\n        type: 'throughput',\r\n        level: 'warning',\r\n        message: `Low throughput: ${throughput.toFixed(1)} req/s`,\r\n        value: throughput,\r\n        threshold: this.config.alertThresholds.throughput.warning,\r\n        timestamp: new Date()\r\n      });\r\n    }\r\n\r\n    // Database alerts\r\n    const dbQueryTime = metrics.database.averageQueryTime;\r\n    if (dbQueryTime >= this.config.alertThresholds.databaseQueryTime.critical) {\r\n      alerts.push({\r\n        type: 'database',\r\n        level: 'critical',\r\n        message: `Critical database query time: ${dbQueryTime.toFixed(1)}ms`,\r\n        value: dbQueryTime,\r\n        threshold: this.config.alertThresholds.databaseQueryTime.critical,\r\n        timestamp: new Date()\r\n      });\r\n    } else if (dbQueryTime >= this.config.alertThresholds.databaseQueryTime.warning) {\r\n      alerts.push({\r\n        type: 'database',\r\n        level: 'warning',\r\n        message: `High database query time: ${dbQueryTime.toFixed(1)}ms`,\r\n        value: dbQueryTime,\r\n        threshold: this.config.alertThresholds.databaseQueryTime.warning,\r\n        timestamp: new Date()\r\n      });\r\n    }\r\n\r\n    // Emit alerts\r\n    for (const alert of alerts) {\r\n      this.emit('alert', alert);\r\n      logger.warn('Performance alert triggered', alert);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up old logs\r\n   */\r\n  private cleanupOldLogs(): void {\r\n    const now = Date.now();\r\n    \r\n    // Clean up request logs\r\n    const requestCutoff = new Date(now - this.config.requestRetentionPeriod);\r\n    const initialRequestCount = this.requestLogs.length;\r\n    this.requestLogs = this.requestLogs.filter(log => log.timestamp >= requestCutoff);\r\n    \r\n    // Limit request logs by count\r\n    if (this.requestLogs.length > this.config.maxRequestLogs) {\r\n      this.requestLogs = this.requestLogs.slice(-this.config.maxRequestLogs);\r\n    }\r\n    \r\n    // Clean up error logs\r\n    const errorCutoff = new Date(now - this.config.errorRetentionPeriod);\r\n    const initialErrorCount = this.errorLogs.length;\r\n    this.errorLogs = this.errorLogs.filter(log => log.timestamp >= errorCutoff);\r\n    \r\n    // Limit error logs by count\r\n    if (this.errorLogs.length > this.config.maxErrorLogs) {\r\n      this.errorLogs = this.errorLogs.slice(-this.config.maxErrorLogs);\r\n    }\r\n    \r\n    // Clean up response times array\r\n    if (this.responseTimes.length > 10000) {\r\n      this.responseTimes = this.responseTimes.slice(-5000);\r\n    }\r\n    \r\n    const requestsRemoved = initialRequestCount - this.requestLogs.length;\r\n    const errorsRemoved = initialErrorCount - this.errorLogs.length;\r\n    \r\n    if (requestsRemoved > 0 || errorsRemoved > 0) {\r\n      logger.debug('Cleaned up old logs', {\r\n        requestsRemoved,\r\n        errorsRemoved\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get monitoring statistics\r\n   */\r\n  public getStats(): {\r\n    isRunning: boolean;\r\n    uptime: number;\r\n    requestsLogged: number;\r\n    errorsLogged: number;\r\n    endpointsTracked: number;\r\n  } {\r\n    return {\r\n      isRunning: this.isRunning,\r\n      uptime: Date.now() - this.startTime.getTime(),\r\n      requestsLogged: this.requestLogs.length,\r\n      errorsLogged: this.errorLogs.length,\r\n      endpointsTracked: this.endpointMetrics.size\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset all metrics\r\n   */\r\n  public resetMetrics(): void {\r\n    this.requestLogs = [];\r\n    this.errorLogs = [];\r\n    this.endpointMetrics.clear();\r\n    this.responseTimes = [];\r\n    this.requestsPerInterval = 0;\r\n    this.errorsPerInterval = 0;\r\n    \r\n    this.databaseMetrics = {\r\n      queryCount: 0,\r\n      totalQueryTime: 0,\r\n      slowQueries: 0,\r\n      connectionPoolSize: 0,\r\n      activeConnections: 0\r\n    };\r\n    \r\n    this.websocketMetrics = {\r\n      activeConnections: 0,\r\n      messagesPerSecond: 0,\r\n      totalMessages: 0,\r\n      disconnections: 0\r\n    };\r\n\r\n    logger.info('Application Monitor metrics reset');\r\n    this.emit('reset');\r\n  }\r\n\r\n  /**\r\n   * Reset all metrics (legacy method - kept for compatibility)\r\n   */\r\n  public reset(): void {\r\n    this.resetMetrics();\r\n  }\r\n\r\n  /**\r\n   * Shutdown the monitor\r\n   */\r\n  public shutdown(): void {\r\n    this.stop();\r\n    this.reset();\r\n    this.removeAllListeners();\r\n    logger.info('Application Monitor shut down');\r\n  }\r\n}\r\n\r\nexport default ApplicationMonitorService;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\bot-status.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\bot.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\data-service.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdir from package \"fs/promises\" with non literal argument at index 0","line":54,"column":11,"nodeType":"CallExpression","endLine":54,"endColumn":50},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFile from package \"fs/promises\" with non literal argument at index 0","line":57,"column":31,"nodeType":"CallExpression","endLine":57,"endColumn":61},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFile from package \"fs/promises\" with non literal argument at index 0","line":76,"column":13,"nodeType":"CallExpression","endLine":76,"endColumn":61},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFile from package \"fs/promises\" with non literal argument at index 0","line":168,"column":11,"nodeType":"CallExpression","endLine":168,"endColumn":45}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Data service for downloading and managing historical market data\r\n */\r\n\r\n// Import axios if needed (commented out as we're using mock data)\r\n// import axios from 'axios';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\n\r\nimport type { Candle } from '../JabbrLabs/target-reacher/interfaces';\r\n\r\nimport logger from './logging.service';\r\n\r\n/**\r\n * Default data directory for storing cached historical data\r\n */\r\nconst DEFAULT_DATA_DIR = path.join(process.cwd(), 'data', 'historical');\r\n\r\n/**\r\n * Download historical price data for a symbol and timeframe\r\n * Uses a local cache to avoid repeated downloads\r\n */\r\nexport async function downloadHistoricalData(\r\n  symbol: string,\r\n  timeframe: string,\r\n  startTime: number,\r\n  endTime: number,\r\n  cacheDir: string = DEFAULT_DATA_DIR\r\n): Promise<Candle[]> {\r\n  // Validate and sanitize inputs\r\n  if (!symbol || typeof symbol !== 'string') {\r\n    throw new Error('Invalid symbol provided');\r\n  }\r\n  if (!timeframe || typeof timeframe !== 'string') {\r\n    throw new Error('Invalid timeframe provided');\r\n  }\r\n  \r\n  // Normalize symbol for file naming (remove dangerous characters)\r\n  const normalizedSymbol = symbol.replace(/[^a-zA-Z0-9_-]/g, '_');\r\n  const normalizedTimeframe = timeframe.replace(/[^a-zA-Z0-9_-]/g, '_');\r\n  const cacheFileName = `${normalizedSymbol}_${normalizedTimeframe}_${startTime}_${endTime}.json`;\r\n  \r\n  // Validate that cache directory is within allowed bounds\r\n  const resolvedCacheDir = path.resolve(cacheDir);\r\n  const resolvedBasePath = path.resolve(DEFAULT_DATA_DIR);\r\n  if (!resolvedCacheDir.startsWith(resolvedBasePath)) {\r\n    throw new Error('Invalid cache directory path');\r\n  }\r\n  \r\n  const cachePath = path.join(resolvedCacheDir, path.basename(cacheFileName));\r\n  \r\n  // Try to load from cache first\r\n  try {\r\n    await fs.mkdir(cacheDir, { recursive: true });\r\n    \r\n    try {\r\n      const cacheFile = await fs.readFile(cachePath, 'utf8');\r\n      const cachedData = JSON.parse(cacheFile);\r\n      logger.info(`Loaded ${cachedData.length} candles from cache for ${symbol} ${timeframe}`);\r\n      return cachedData;\r\n    } catch (err) {\r\n      // Cache file doesn't exist, continue to download\r\n      logger.debug(`No cache found for ${symbol} ${timeframe}, downloading...`);\r\n    }\r\n  } catch (err) {\r\n    logger.warn(`Could not create cache directory: ${err instanceof Error ? err.message : String(err)}`);\r\n  }\r\n  \r\n  try {\r\n    // For this example, we'll generate mock data\r\n    // In production, you would fetch from an exchange API\r\n    const candles = generateMockCandles(symbol, timeframe, startTime, endTime);\r\n    \r\n    // Save to cache\r\n    try {\r\n      await fs.writeFile(cachePath, JSON.stringify(candles));\r\n      logger.debug(`Saved ${candles.length} candles to cache for ${symbol} ${timeframe}`);\r\n    } catch (err) {\r\n      logger.warn(`Could not save to cache: ${err instanceof Error ? err.message : String(err)}`);\r\n    }\r\n    \r\n    return candles;\r\n  } catch (error) {\r\n    logger.error(`Failed to download historical data: ${error instanceof Error ? error.message : String(error)}`);\r\n    throw new Error(`Failed to download historical data for ${symbol} ${timeframe}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Generate mock price data for testing and examples\r\n */\r\nfunction generateMockCandles(\r\n  symbol: string,\r\n  timeframe: string,\r\n  startTime: number,\r\n  endTime: number\r\n): Candle[] {\r\n  const candles: Candle[] = [];\r\n  let currentTime = startTime;\r\n  \r\n  // Calculate time increment based on timeframe\r\n  const timeIncrement = getTimeframeMilliseconds(timeframe);\r\n  \r\n  // Initial price\r\n  let price = 30000; // Starting price (e.g., for BTC)\r\n  \r\n  while (currentTime <= endTime) {\r\n    // Generate some realistic price movement with trends and volatility\r\n    const trend = Math.sin(currentTime / (86400000 * 30)) * 5000; // 30-day cycle\r\n    const volatility = (Math.random() - 0.5) * 500; // Random noise\r\n    \r\n    price = Math.max(100, price + trend / 100 + volatility);\r\n    \r\n    // Calculate OHLC\r\n    const open = price;\r\n    const high = open * (1 + Math.random() * 0.02); // Up to 2% higher\r\n    const low = open * (1 - Math.random() * 0.02); // Up to 2% lower\r\n    const close = (open + high + low) / 3 + (Math.random() - 0.5) * (high - low);\r\n    \r\n    // Random volume\r\n    const volume = 10 + Math.random() * 100;\r\n    \r\n    candles.push({\r\n      timestamp: currentTime,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n    \r\n    currentTime += timeIncrement;\r\n  }\r\n  \r\n  return candles;\r\n}\r\n\r\n/**\r\n * Convert timeframe string to milliseconds\r\n */\r\nfunction getTimeframeMilliseconds(timeframe: string): number {\r\n  const unit = timeframe.charAt(timeframe.length - 1);\r\n  const value = parseInt(timeframe.substring(0, timeframe.length - 1));\r\n  \r\n  switch (unit) {\r\n    case 'm': return value * 60 * 1000;\r\n    case 'h': return value * 60 * 60 * 1000;\r\n    case 'd': return value * 24 * 60 * 60 * 1000;\r\n    case 'w': return value * 7 * 24 * 60 * 60 * 1000;\r\n    default: throw new Error(`Invalid timeframe unit: ${unit}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Save candle data to a CSV file for external analysis\r\n */\r\nexport async function exportCandlesToCsv(\r\n  candles: Candle[],\r\n  filePath: string\r\n): Promise<void> {\r\n  try {\r\n    const headers = 'timestamp,datetime,open,high,low,close,volume\\n';\r\n    const rows = candles.map(c => \r\n      `${c.timestamp},${new Date(c.timestamp).toISOString()},${c.open},${c.high},${c.low},${c.close},${c.volume}`\r\n    ).join('\\n');\r\n    \r\n    const csvContent = headers + rows;\r\n    await fs.writeFile(filePath, csvContent);\r\n    \r\n    logger.info(`Exported ${candles.length} candles to ${filePath}`);\r\n  } catch (error) {\r\n    logger.error(`Failed to export candles to CSV: ${error instanceof Error ? error.message : String(error)}`);\r\n    throw error;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\database-monitor.service.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":746,"column":7,"nodeType":"MemberExpression","endLine":746,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Database Monitor Service\r\n * \r\n * Monitors database performance, connections, query patterns, and health.\r\n * Provides insights into database bottlenecks and optimization opportunities.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\nimport { performance } from 'perf_hooks';\r\n\r\nimport type { JabbrWebSocketServer } from '../websocket/websocket.service';\r\n\r\nimport { database } from './database.service';\r\nimport logger from './logging.service';\r\n\r\nexport interface DatabaseMetrics {\r\n  connections: {\r\n    active: number;\r\n    idle: number;\r\n    total: number;\r\n    maxAllowed: number;\r\n    utilizationPercentage: number;\r\n  };\r\n  queries: {\r\n    totalExecuted: number;\r\n    averageTime: number;\r\n    slowQueries: number;\r\n    failedQueries: number;\r\n    queriesPerSecond: number;\r\n    longestQuery: QueryMetric | null;\r\n  };\r\n  tables: {\r\n    mostAccessed: TableMetric[];\r\n    tableStats: Map<string, TableStatistic>;\r\n  };\r\n  performance: {\r\n    transactionsPerSecond: number;\r\n    lockWaitTime: number;\r\n    cacheHitRatio: number;\r\n    indexEfficiency: number;\r\n  };\r\n  health: {\r\n    status: 'healthy' | 'warning' | 'critical';\r\n    issues: string[];\r\n    lastCheck: Date;\r\n    uptime: number;\r\n  };\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface QueryMetric {\r\n  id: string;\r\n  query: string;\r\n  duration: number;\r\n  timestamp: Date;\r\n  tableName?: string;\r\n  operation: 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'OTHER';\r\n  rowsAffected?: number;\r\n  error?: string;\r\n}\r\n\r\nexport interface TableMetric {\r\n  tableName: string;\r\n  accessCount: number;\r\n  totalTime: number;\r\n  averageTime: number;\r\n  operations: {\r\n    select: number;\r\n    insert: number;\r\n    update: number;\r\n    delete: number;\r\n  };\r\n}\r\n\r\nexport interface TableStatistic {\r\n  tableName: string;\r\n  rowCount: number;\r\n  sizeInMB: number;\r\n  indexCount: number;\r\n  lastAnalyzed: Date;\r\n  fragmentationPercentage: number;\r\n}\r\n\r\nexport interface DatabaseMonitorConfig {\r\n  metricsRetentionHours: number;\r\n  slowQueryThresholdMs: number;\r\n  enableQueryLogging: boolean;\r\n  healthCheckInterval: number;\r\n  connectionThresholds: {\r\n    warning: number;\r\n    critical: number;\r\n  };\r\n  performanceThresholds: {\r\n    slowQueryMs: number;\r\n    highLockWaitMs: number;\r\n    lowCacheHitRatio: number;\r\n  };\r\n}\r\n\r\nexport class DatabaseMonitorService extends EventEmitter {\r\n  private config: DatabaseMonitorConfig;\r\n  private websocketServer?: JabbrWebSocketServer;\r\n  private queryHistory: QueryMetric[] = [];\r\n  private tableMetrics: Map<string, TableMetric> = new Map();\r\n  private metricsHistory: DatabaseMetrics[] = [];\r\n  private isMonitoring = false;\r\n  private healthCheckInterval?: NodeJS.Timeout;\r\n  private cleanupInterval?: NodeJS.Timeout;\r\n  private queryCounter = 0;\r\n  private startTime: Date;\r\n  private lastMetricsCalculation = Date.now();\r\n\r\n  constructor(\r\n    config: Partial<DatabaseMonitorConfig> = {},\r\n    websocketServer?: JabbrWebSocketServer\r\n  ) {\r\n    super();\r\n    \r\n    this.config = {\r\n      metricsRetentionHours: 24,\r\n      slowQueryThresholdMs: 1000,\r\n      enableQueryLogging: true,\r\n      healthCheckInterval: 30000, // 30 seconds\r\n      connectionThresholds: {\r\n        warning: 80, // 80% of max connections\r\n        critical: 95 // 95% of max connections\r\n      },\r\n      performanceThresholds: {\r\n        slowQueryMs: 1000,\r\n        highLockWaitMs: 100,\r\n        lowCacheHitRatio: 0.8\r\n      },\r\n      ...config\r\n    };\r\n\r\n    this.websocketServer = websocketServer;\r\n    this.startTime = new Date();\r\n\r\n    logger.info('Database Monitor Service initialized', { config: this.config });\r\n  }\r\n\r\n  /**\r\n   * Start database monitoring\r\n   */\r\n  public start(): void {\r\n    if (this.isMonitoring) {\r\n      logger.warn('Database Monitor Service is already running');\r\n      return;\r\n    }\r\n\r\n    this.isMonitoring = true;\r\n\r\n    // Setup query monitoring\r\n    if (this.config.enableQueryLogging) {\r\n      this.setupQueryMonitoring();\r\n    }\r\n\r\n    // Start health checks\r\n    this.startHealthChecks();\r\n\r\n    // Cleanup old metrics\r\n    this.scheduleMetricsCleanup();\r\n\r\n    logger.info('Database Monitor Service started');\r\n    this.emit('started');\r\n  }\r\n\r\n  /**\r\n   * Stop database monitoring\r\n   */\r\n  public stop(): void {\r\n    if (!this.isMonitoring) {\r\n      return;\r\n    }\r\n\r\n    this.isMonitoring = false;\r\n\r\n    if (this.healthCheckInterval) {\r\n      clearInterval(this.healthCheckInterval);\r\n      this.healthCheckInterval = undefined;\r\n    }\r\n\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = undefined;\r\n    }\r\n\r\n    logger.info('Database Monitor Service stopped');\r\n    this.emit('stopped');\r\n  }\r\n\r\n  /**\r\n   * Get current database metrics\r\n   */\r\n  public async getCurrentMetrics(): Promise<DatabaseMetrics> {\r\n    try {\r\n      const connections = await this.getConnectionMetrics();\r\n      const queries = this.getQueryMetrics();\r\n      const tables = await this.getTableMetrics();\r\n      const performance = await this.getPerformanceMetrics();\r\n      const health = await this.getHealthMetrics();\r\n\r\n      const metrics: DatabaseMetrics = {\r\n        connections,\r\n        queries,\r\n        tables,\r\n        performance,\r\n        health,\r\n        timestamp: new Date()\r\n      };\r\n\r\n      // Store metrics history\r\n      this.metricsHistory.push(metrics);\r\n\r\n      // Emit metrics\r\n      this.emit('metricsUpdate', metrics);        // Broadcast via WebSocket\r\n        if (this.websocketServer) {\r\n          this.websocketServer.broadcast('system', {\r\n            type: 'database_metrics',\r\n            data: metrics\r\n          });\r\n        }\r\n\r\n      return metrics;\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to collect database metrics', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record a query execution\r\n   */\r\n  public recordQuery(\r\n    query: string,\r\n    duration: number,\r\n    error?: string,\r\n    rowsAffected?: number\r\n  ): void {\r\n    if (!this.isMonitoring || !this.config.enableQueryLogging) {\r\n      return;\r\n    }\r\n\r\n    this.queryCounter++;\r\n\r\n    const queryMetric: QueryMetric = {\r\n      id: `query_${this.queryCounter}_${Date.now()}`,\r\n      query: this.sanitizeQuery(query),\r\n      duration,\r\n      timestamp: new Date(),\r\n      operation: this.determineOperation(query),\r\n      rowsAffected,\r\n      error,\r\n      tableName: this.extractTableName(query)\r\n    };\r\n\r\n    this.queryHistory.push(queryMetric);\r\n\r\n    // Update table metrics\r\n    if (queryMetric.tableName) {\r\n      this.updateTableMetrics(queryMetric);\r\n    }\r\n\r\n    // Check for slow queries\r\n    if (duration > this.config.slowQueryThresholdMs) {\r\n      this.handleSlowQuery(queryMetric);\r\n    }\r\n\r\n    // Check for query errors\r\n    if (error) {\r\n      this.handleQueryError(queryMetric);\r\n    }\r\n\r\n    this.emit('queryExecuted', queryMetric);\r\n  }\r\n\r\n  /**\r\n   * Get query history\r\n   */\r\n  public getQueryHistory(limit = 100): QueryMetric[] {\r\n    return this.queryHistory\r\n      .slice(-limit)\r\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\r\n  }\r\n\r\n  /**\r\n   * Get slow queries\r\n   */\r\n  public getSlowQueries(limit = 50): QueryMetric[] {\r\n    return this.queryHistory\r\n      .filter(query => query.duration > this.config.slowQueryThresholdMs)\r\n      .sort((a, b) => b.duration - a.duration)\r\n      .slice(0, limit);\r\n  }\r\n\r\n  /**\r\n   * Get table access patterns\r\n   */\r\n  public getTableAccessPatterns(): TableMetric[] {\r\n    return Array.from(this.tableMetrics.values())\r\n      .sort((a, b) => b.accessCount - a.accessCount);\r\n  }\r\n\r\n  /**\r\n   * Get database health summary\r\n   */\r\n  public async getHealthSummary(): Promise<{\r\n    status: 'healthy' | 'warning' | 'critical';\r\n    issues: string[];\r\n    uptime: number;\r\n    lastCheck: Date;\r\n  }> {\r\n    try {\r\n      return await this.getHealthMetrics();\r\n    } catch (error) {\r\n      logger.error('Failed to get database health summary', { error });\r\n      return {\r\n        status: 'critical',\r\n        issues: ['Failed to check database health'],\r\n        uptime: 0,\r\n        lastCheck: new Date()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get connection metrics\r\n   */\r\n  private async getConnectionMetrics(): Promise<DatabaseMetrics['connections']> {\r\n    try {\r\n      // Get current connection stats\r\n      const connectionQuery = `\r\n        SELECT \r\n          count(*) as total_connections,\r\n          count(*) FILTER (WHERE state = 'active') as active_connections,\r\n          count(*) FILTER (WHERE state = 'idle') as idle_connections\r\n        FROM pg_stat_activity \r\n        WHERE datname = current_database()\r\n      `;\r\n\r\n      const result = await database.query(connectionQuery) as any;\r\n      const connectionStats = result.rows?.[0] || {};\r\n\r\n      // Get max connections setting\r\n      const maxConnResult = await database.query('SHOW max_connections') as any;\r\n      const maxConnections = parseInt(maxConnResult.rows?.[0]?.max_connections) || 100;\r\n\r\n      const active = parseInt(connectionStats.active_connections) || 0;\r\n      const idle = parseInt(connectionStats.idle_connections) || 0;\r\n      const total = parseInt(connectionStats.total_connections) || 0;\r\n\r\n      return {\r\n        active,\r\n        idle,\r\n        total,\r\n        maxAllowed: maxConnections,\r\n        utilizationPercentage: (total / maxConnections) * 100\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to get connection metrics', { error });\r\n      return {\r\n        active: 0,\r\n        idle: 0,\r\n        total: 0,\r\n        maxAllowed: 100,\r\n        utilizationPercentage: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get query metrics\r\n   */\r\n  private getQueryMetrics(): DatabaseMetrics['queries'] {\r\n    const now = Date.now();\r\n    const timeWindow = now - this.lastMetricsCalculation;\r\n    const recentQueries = this.queryHistory.filter(\r\n      q => now - q.timestamp.getTime() < timeWindow\r\n    );\r\n\r\n    const totalExecuted = this.queryHistory.length;\r\n    const averageTime = recentQueries.length > 0 \r\n      ? recentQueries.reduce((sum, q) => sum + q.duration, 0) / recentQueries.length\r\n      : 0;\r\n\r\n    const slowQueries = this.queryHistory.filter(\r\n      q => q.duration > this.config.slowQueryThresholdMs\r\n    ).length;\r\n\r\n    const failedQueries = this.queryHistory.filter(q => q.error).length;\r\n\r\n    const queriesPerSecond = timeWindow > 0 \r\n      ? (recentQueries.length / (timeWindow / 1000))\r\n      : 0;\r\n\r\n    const longestQuery = this.queryHistory.length > 0\r\n      ? this.queryHistory.reduce((longest, current) => \r\n          current.duration > longest.duration ? current : longest\r\n        )\r\n      : null;\r\n\r\n    this.lastMetricsCalculation = now;\r\n\r\n    return {\r\n      totalExecuted,\r\n      averageTime,\r\n      slowQueries,\r\n      failedQueries,\r\n      queriesPerSecond,\r\n      longestQuery\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get table metrics\r\n   */\r\n  private async getTableMetrics(): Promise<DatabaseMetrics['tables']> {\r\n    try {\r\n      // Get table statistics from PostgreSQL\r\n      const tableStatsQuery = `\r\n        SELECT \r\n          schemaname,\r\n          tablename,\r\n          n_tup_ins as inserts,\r\n          n_tup_upd as updates,\r\n          n_tup_del as deletes,\r\n          seq_scan as sequential_scans,\r\n          seq_tup_read as sequential_reads,\r\n          idx_scan as index_scans,\r\n          idx_tup_fetch as index_reads\r\n        FROM pg_stat_user_tables\r\n        ORDER BY (seq_scan + idx_scan) DESC\r\n        LIMIT 10\r\n      `;\r\n\r\n      const tableStatsResult = await database.query(tableStatsQuery) as any;\r\n      const tableStats = new Map<string, TableStatistic>();\r\n\r\n      // Get table sizes\r\n      const tableSizeQuery = `\r\n        SELECT \r\n          tablename,\r\n          pg_total_relation_size(schemaname||'.'||tablename) as size_bytes\r\n        FROM pg_tables \r\n        WHERE schemaname = 'public'\r\n      `;\r\n\r\n      const tableSizeResult = await database.query(tableSizeQuery) as any;\r\n      const tableSizes = new Map<string, number>();\r\n\r\n      (tableSizeResult.rows || []).forEach((row: any) => {\r\n        tableSizes.set(row.tablename, parseInt(row.size_bytes) || 0);\r\n      });\r\n\r\n      // Process table statistics\r\n      for (const row of (tableStatsResult.rows || [])) {\r\n        const tableName = row.tablename;\r\n        const sizeBytes = tableSizes.get(tableName) || 0;\r\n\r\n        tableStats.set(tableName, {\r\n          tableName,\r\n          rowCount: parseInt(row.sequential_reads) + parseInt(row.index_reads),\r\n          sizeInMB: sizeBytes / (1024 * 1024),\r\n          indexCount: parseInt(row.index_scans) > 0 ? 1 : 0, // Simplified\r\n          lastAnalyzed: new Date(), // Would need pg_stat_user_tables.last_analyze\r\n          fragmentationPercentage: 0 // Would need more complex query\r\n        });\r\n      }\r\n\r\n      // Get most accessed tables from our metrics\r\n      const mostAccessed = Array.from(this.tableMetrics.values())\r\n        .sort((a, b) => b.accessCount - a.accessCount)\r\n        .slice(0, 10);\r\n\r\n      return {\r\n        mostAccessed,\r\n        tableStats\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to get table metrics', { error });\r\n      return {\r\n        mostAccessed: [],\r\n        tableStats: new Map()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get performance metrics\r\n   */\r\n  private async getPerformanceMetrics(): Promise<DatabaseMetrics['performance']> {\r\n    try {\r\n      // Get database statistics\r\n      const statsQuery = `\r\n        SELECT \r\n          xact_commit,\r\n          xact_rollback,\r\n          blks_read,\r\n          blks_hit,\r\n          tup_returned,\r\n          tup_fetched,\r\n          tup_inserted,\r\n          tup_updated,\r\n          tup_deleted\r\n        FROM pg_stat_database \r\n        WHERE datname = current_database()\r\n      `;\r\n\r\n      const result = await database.query(statsQuery) as any;\r\n      const stats = result.rows?.[0] || {};\r\n\r\n      // Calculate cache hit ratio\r\n      const blksRead = parseInt(stats.blks_read) || 0;\r\n      const blksHit = parseInt(stats.blks_hit) || 0;\r\n      const cacheHitRatio = (blksRead + blksHit) > 0 \r\n        ? blksHit / (blksRead + blksHit) \r\n        : 1;\r\n\r\n      // Calculate transactions per second (approximation)\r\n      const commits = parseInt(stats.xact_commit) || 0;\r\n      const rollbacks = parseInt(stats.xact_rollback) || 0;\r\n      const uptime = (Date.now() - this.startTime.getTime()) / 1000;\r\n      const transactionsPerSecond = uptime > 0 \r\n        ? (commits + rollbacks) / uptime \r\n        : 0;\r\n\r\n      // Get lock information\r\n      const lockQuery = `\r\n        SELECT count(*) as lock_count\r\n        FROM pg_locks \r\n        WHERE NOT granted\r\n      `;\r\n\r\n      const lockResult = await database.query(lockQuery) as any;\r\n      const lockCount = parseInt(lockResult.rows?.[0]?.lock_count) || 0;\r\n\r\n      return {\r\n        transactionsPerSecond,\r\n        lockWaitTime: lockCount * 10, // Simplified estimate\r\n        cacheHitRatio,\r\n        indexEfficiency: cacheHitRatio // Simplified - would need more complex calculation\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to get performance metrics', { error });\r\n      return {\r\n        transactionsPerSecond: 0,\r\n        lockWaitTime: 0,\r\n        cacheHitRatio: 1,\r\n        indexEfficiency: 1\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get health metrics\r\n   */\r\n  private async getHealthMetrics(): Promise<DatabaseMetrics['health']> {\r\n    const issues: string[] = [];\r\n    let status: 'healthy' | 'warning' | 'critical' = 'healthy';\r\n\r\n    try {\r\n      // Check connections\r\n      const connections = await this.getConnectionMetrics();\r\n      if (connections.utilizationPercentage > this.config.connectionThresholds.critical) {\r\n        issues.push(`Critical connection usage: ${connections.utilizationPercentage.toFixed(1)}%`);\r\n        status = 'critical';\r\n      } else if (connections.utilizationPercentage > this.config.connectionThresholds.warning) {\r\n        issues.push(`High connection usage: ${connections.utilizationPercentage.toFixed(1)}%`);\r\n        if (status === 'healthy') {status = 'warning';}\r\n      }\r\n\r\n      // Check performance\r\n      const performance = await this.getPerformanceMetrics();\r\n      if (performance.cacheHitRatio < this.config.performanceThresholds.lowCacheHitRatio) {\r\n        issues.push(`Low cache hit ratio: ${(performance.cacheHitRatio * 100).toFixed(1)}%`);\r\n        if (status === 'healthy') {status = 'warning';}\r\n      }\r\n\r\n      if (performance.lockWaitTime > this.config.performanceThresholds.highLockWaitMs) {\r\n        issues.push(`High lock wait time: ${performance.lockWaitTime.toFixed(0)}ms`);\r\n        if (status === 'healthy') {status = 'warning';}\r\n      }\r\n\r\n      // Check for too many slow queries\r\n      const slowQueries = this.getSlowQueries(10);\r\n      if (slowQueries.length > 5) {\r\n        issues.push(`Many slow queries: ${slowQueries.length} recent slow queries`);\r\n        if (status === 'healthy') {status = 'warning';}\r\n      }\r\n\r\n      // Check connectivity\r\n      try {\r\n        await database.query('SELECT 1');\r\n      } catch (connectError) {\r\n        issues.push(`Database connectivity error: ${connectError instanceof Error ? connectError.message : String(connectError)}`);\r\n        status = 'critical';\r\n      }\r\n      \r\n      return {\r\n        status,\r\n        issues,\r\n        lastCheck: new Date(),\r\n        uptime: (Date.now() - this.startTime.getTime()) / 1000\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        status: 'critical',\r\n        issues: [`Health check error: ${error instanceof Error ? error.message : String(error)}`],\r\n        lastCheck: new Date(),\r\n        uptime: (Date.now() - this.startTime.getTime()) / 1000\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup query monitoring hooks\r\n   */\r\n  private setupQueryMonitoring(): void {\r\n    // Note: This would typically hook into the database client\r\n    // For now, we'll rely on manual recordQuery calls\r\n    logger.info('Query monitoring setup completed');\r\n  }\r\n\r\n  /**\r\n   * Start periodic health checks\r\n   */\r\n  private startHealthChecks(): void {\r\n    this.healthCheckInterval = setInterval(async () => {\r\n      try {\r\n        await this.getCurrentMetrics();\r\n      } catch (error) {\r\n        logger.error('Database health check failed', { error });\r\n      }\r\n    }, this.config.healthCheckInterval);\r\n  }\r\n\r\n  /**\r\n   * Schedule metrics cleanup\r\n   */\r\n  private scheduleMetricsCleanup(): void {\r\n    const cleanupIntervalMs = 60 * 60 * 1000; // 1 hour\r\n\r\n    // Clear existing interval if any\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanupOldMetrics();\r\n    }, cleanupIntervalMs);\r\n  }\r\n\r\n  /**\r\n   * Clean up old metrics data\r\n   */\r\n  private cleanupOldMetrics(): void {\r\n    const cutoffTime = Date.now() - (this.config.metricsRetentionHours * 60 * 60 * 1000);\r\n\r\n    // Clean query history\r\n    this.queryHistory = this.queryHistory.filter(\r\n      query => query.timestamp.getTime() > cutoffTime\r\n    );\r\n\r\n    // Clean metrics history\r\n    this.metricsHistory = this.metricsHistory.filter(\r\n      metrics => metrics.timestamp.getTime() > cutoffTime\r\n    );\r\n\r\n    logger.debug('Cleaned up old database metrics', {\r\n      queryHistorySize: this.queryHistory.length,\r\n      metricsHistorySize: this.metricsHistory.length\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle slow query detection\r\n   */\r\n  private handleSlowQuery(queryMetric: QueryMetric): void {\r\n    logger.warn('Slow query detected', {\r\n      queryId: queryMetric.id,\r\n      duration: queryMetric.duration,\r\n      query: queryMetric.query,\r\n      tableName: queryMetric.tableName\r\n    });\r\n\r\n    this.emit('slowQuery', queryMetric);\r\n\r\n    // Broadcast slow query alert\r\n    if (this.websocketServer) {\r\n      this.websocketServer.broadcast('alerts', {\r\n        type: 'slow_query',\r\n        data: {\r\n          queryId: queryMetric.id,\r\n          duration: queryMetric.duration,\r\n          query: queryMetric.query,\r\n          timestamp: queryMetric.timestamp\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle query error\r\n   */\r\n  private handleQueryError(queryMetric: QueryMetric): void {\r\n    logger.error('Database query error', {\r\n      queryId: queryMetric.id,\r\n      error: queryMetric.error,\r\n      query: queryMetric.query\r\n    });\r\n\r\n    this.emit('queryError', queryMetric);\r\n  }\r\n\r\n  /**\r\n   * Update table metrics\r\n   */\r\n  private updateTableMetrics(queryMetric: QueryMetric): void {\r\n    if (!queryMetric.tableName) {return;}\r\n\r\n    const existing = this.tableMetrics.get(queryMetric.tableName) || {\r\n      tableName: queryMetric.tableName,\r\n      accessCount: 0,\r\n      totalTime: 0,\r\n      averageTime: 0,\r\n      operations: {\r\n        select: 0,\r\n        insert: 0,\r\n        update: 0,\r\n        delete: 0\r\n      }\r\n    };\r\n\r\n    existing.accessCount++;\r\n    existing.totalTime += queryMetric.duration;\r\n    existing.averageTime = existing.totalTime / existing.accessCount;\r\n\r\n    // Update operation counts\r\n    const operation = queryMetric.operation.toLowerCase();\r\n    if (operation in existing.operations) {\r\n      (existing.operations as any)[operation]++;\r\n    }\r\n\r\n    this.tableMetrics.set(queryMetric.tableName, existing);\r\n  }\r\n\r\n  /**\r\n   * Utility functions\r\n   */\r\n  private sanitizeQuery(query: string): string {\r\n    // Remove sensitive data and normalize query\r\n    return query\r\n      .replace(/VALUES\\s*\\([^)]*\\)/gi, 'VALUES (...)')\r\n      .replace(/=\\s*'[^']*'/gi, \"= '***'\")\r\n      .replace(/=\\s*\\d+/gi, '= ***')\r\n      .substring(0, 200);\r\n  }\r\n\r\n  private determineOperation(query: string): QueryMetric['operation'] {\r\n    const normalizedQuery = query.trim().toUpperCase();\r\n    \r\n    if (normalizedQuery.startsWith('SELECT')) {return 'SELECT';}\r\n    if (normalizedQuery.startsWith('INSERT')) {return 'INSERT';}\r\n    if (normalizedQuery.startsWith('UPDATE')) {return 'UPDATE';}\r\n    if (normalizedQuery.startsWith('DELETE')) {return 'DELETE';}\r\n    \r\n    return 'OTHER';\r\n  }\r\n\r\n  private extractTableName(query: string): string | undefined {\r\n    // Simple table name extraction\r\n    const patterns = [\r\n      /FROM\\s+(\\w+)/i,\r\n      /UPDATE\\s+(\\w+)/i,\r\n      /INSERT\\s+INTO\\s+(\\w+)/i,\r\n      /DELETE\\s+FROM\\s+(\\w+)/i\r\n    ];\r\n\r\n    for (const pattern of patterns) {\r\n      const match = query.match(pattern);\r\n      if (match && match[1]) {\r\n        return match[1].toLowerCase();\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Get metrics for specific time range\r\n   */\r\n  public getMetricsHistory(\r\n    startTime: Date,\r\n    endTime: Date = new Date()\r\n  ): DatabaseMetrics[] {\r\n    return this.metricsHistory.filter(\r\n      metrics => metrics.timestamp >= startTime && metrics.timestamp <= endTime\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Export metrics data\r\n   */\r\n  public exportMetrics(): {\r\n    queries: QueryMetric[];\r\n    tables: TableMetric[];\r\n    metricsHistory: DatabaseMetrics[];\r\n    summary: {\r\n      totalQueries: number;\r\n      slowQueries: number;\r\n      errorQueries: number;\r\n      monitoringDuration: number;\r\n    };\r\n  } {\r\n    return {\r\n      queries: this.queryHistory,\r\n      tables: Array.from(this.tableMetrics.values()),\r\n      metricsHistory: this.metricsHistory,\r\n      summary: {\r\n        totalQueries: this.queryHistory.length,\r\n        slowQueries: this.queryHistory.filter(q => q.duration > this.config.slowQueryThresholdMs).length,\r\n        errorQueries: this.queryHistory.filter(q => q.error).length,\r\n        monitoringDuration: (Date.now() - this.startTime.getTime()) / 1000\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Shutdown the database monitor service\r\n   */\r\n  public shutdown(): void {\r\n    this.stop();\r\n    this.queryHistory = [];\r\n    this.tableMetrics.clear();\r\n    this.metricsHistory = [];\r\n    this.removeAllListeners();\r\n    \r\n    logger.info('Database Monitor Service shut down');\r\n  }\r\n}\r\n\r\nexport default DatabaseMonitorService;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\database.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\encryption.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\exchange-monitor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\health-check.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\logging.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\metrics-collector.service.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":505,"column":15,"nodeType":"MemberExpression","endLine":505,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Metrics Collector Service\r\n * \r\n * Centralized metrics collection and aggregation service that gathers metrics\r\n * from all monitoring services and provides unified metrics storage and querying.\r\n */\r\n\r\nimport { EventEmitter } from 'events';\r\n\r\nimport type { ApplicationMetrics } from './application-monitor.service';\r\nimport logger from './logging.service';\r\nimport type { SystemMetrics } from './system-monitor.service';\r\n\r\nexport interface MetricValue {\r\n  timestamp: Date;\r\n  value: number;\r\n  labels?: Record<string, string>;\r\n}\r\n\r\nexport interface MetricSeries {\r\n  name: string;\r\n  type: 'counter' | 'gauge' | 'histogram' | 'summary';\r\n  unit?: string;\r\n  description?: string;\r\n  values: MetricValue[];\r\n}\r\n\r\nexport interface AggregatedMetrics {\r\n  system: {\r\n    cpu: {\r\n      usage: MetricSeries;\r\n      loadAverage: MetricSeries;\r\n    };\r\n    memory: {\r\n      usage: MetricSeries;\r\n      percentage: MetricSeries;\r\n    };\r\n    disk: {\r\n      usage: MetricSeries;\r\n      percentage: MetricSeries;\r\n    };\r\n    process: {\r\n      uptime: MetricSeries;\r\n      memoryUsage: MetricSeries;\r\n    };\r\n  };\r\n  application: {\r\n    performance: {\r\n      responseTime: MetricSeries;\r\n      throughput: MetricSeries;\r\n      errorRate: MetricSeries;\r\n    };\r\n    database: {\r\n      queryTime: MetricSeries;\r\n      queryCount: MetricSeries;\r\n      connectionPool: MetricSeries;\r\n    };\r\n    websocket: {\r\n      activeConnections: MetricSeries;\r\n      messagesPerSecond: MetricSeries;\r\n    };\r\n  };\r\n  trading: {\r\n    bots: {\r\n      activeCount: MetricSeries;\r\n      totalTrades: MetricSeries;\r\n      totalPnL: MetricSeries;\r\n      winRate: MetricSeries;\r\n    };\r\n    orders: {\r\n      placed: MetricSeries;\r\n      filled: MetricSeries;\r\n      cancelled: MetricSeries;\r\n      failed: MetricSeries;\r\n    };\r\n    positions: {\r\n      open: MetricSeries;\r\n      unrealizedPnL: MetricSeries;\r\n    };\r\n  };\r\n  custom: Record<string, MetricSeries>;\r\n}\r\n\r\nexport interface MetricsQuery {\r\n  metric: string;\r\n  startTime?: Date;\r\n  endTime?: Date;\r\n  labels?: Record<string, string>;\r\n  aggregation?: 'avg' | 'sum' | 'min' | 'max' | 'count' | 'last';\r\n  groupBy?: string[];\r\n  interval?: number; // milliseconds for time-based grouping\r\n}\r\n\r\nexport interface QueryResult {\r\n  metric: string;\r\n  values: Array<{\r\n    timestamp: Date;\r\n    value: number;\r\n    labels?: Record<string, string>;\r\n  }>;\r\n  aggregation?: string;\r\n  interval?: number;\r\n}\r\n\r\nexport interface MetricsCollectorConfig {\r\n  retentionPeriod: number; // milliseconds\r\n  maxMetricsPerSeries: number;\r\n  aggregationInterval: number; // milliseconds\r\n  enablePersistence: boolean;\r\n  persistenceInterval: number; // milliseconds\r\n}\r\n\r\nexport class MetricsCollectorService extends EventEmitter {\r\n  private config: MetricsCollectorConfig;\r\n  private metrics: Map<string, MetricSeries> = new Map();\r\n  private aggregatedMetrics: AggregatedMetrics;\r\n  private aggregationInterval?: NodeJS.Timeout;\r\n  private persistenceInterval?: NodeJS.Timeout;\r\n  private isRunning = false;\r\n\r\n  constructor(config: Partial<MetricsCollectorConfig> = {}) {\r\n    super();\r\n    \r\n    this.config = {\r\n      retentionPeriod: 24 * 60 * 60 * 1000, // 24 hours\r\n      maxMetricsPerSeries: 10000,\r\n      aggregationInterval: 60000, // 1 minute\r\n      enablePersistence: true,\r\n      persistenceInterval: 5 * 60 * 1000, // 5 minutes\r\n      ...config\r\n    };\r\n\r\n    this.aggregatedMetrics = this.initializeAggregatedMetrics();\r\n    logger.info('Metrics Collector Service initialized', { config: this.config });\r\n  }\r\n\r\n  /**\r\n   * Start metrics collection\r\n   */\r\n  public start(): void {\r\n    if (this.isRunning) {\r\n      logger.warn('Metrics Collector is already running');\r\n      return;\r\n    }\r\n\r\n    this.isRunning = true;\r\n\r\n    // Start aggregation interval\r\n    this.aggregationInterval = setInterval(() => {\r\n      this.performAggregation();\r\n      this.cleanupOldMetrics();\r\n    }, this.config.aggregationInterval);\r\n\r\n    // Start persistence interval if enabled\r\n    if (this.config.enablePersistence) {\r\n      this.persistenceInterval = setInterval(() => {\r\n        void this.persistMetrics();\r\n      }, this.config.persistenceInterval);\r\n    }\r\n\r\n    logger.info('Metrics Collector started', {\r\n      aggregationInterval: this.config.aggregationInterval,\r\n      persistenceEnabled: this.config.enablePersistence\r\n    });\r\n\r\n    this.emit('started');\r\n  }\r\n\r\n  /**\r\n   * Stop metrics collection\r\n   */\r\n  public stop(): void {\r\n    if (!this.isRunning) {\r\n      return;\r\n    }\r\n\r\n    this.isRunning = false;\r\n\r\n    if (this.aggregationInterval) {\r\n      clearInterval(this.aggregationInterval);\r\n      this.aggregationInterval = undefined;\r\n    }\r\n\r\n    if (this.persistenceInterval) {\r\n      clearInterval(this.persistenceInterval);\r\n      this.persistenceInterval = undefined;\r\n    }\r\n\r\n    logger.info('Metrics Collector stopped');\r\n    this.emit('stopped');\r\n  }\r\n\r\n  /**\r\n   * Record a metric value\r\n   */\r\n  public recordMetric(\r\n    name: string,\r\n    value: number,\r\n    type: MetricSeries['type'] = 'gauge',\r\n    options: {\r\n      unit?: string;\r\n      description?: string;\r\n      labels?: Record<string, string>;\r\n      timestamp?: Date;\r\n    } = {}\r\n  ): void {\r\n    if (!this.isRunning) {\r\n      throw new Error('Metrics collector is not running. Call start() first.');\r\n    }\r\n\r\n    const metricValue: MetricValue = {\r\n      timestamp: options.timestamp || new Date(),\r\n      value,\r\n      labels: options.labels\r\n    };\r\n\r\n    let series = this.metrics.get(name);\r\n    \r\n    if (!series) {\r\n      series = {\r\n        name,\r\n        type,\r\n        unit: options.unit,\r\n        description: options.description,\r\n        values: []\r\n      };\r\n      this.metrics.set(name, series);\r\n    }\r\n\r\n    // Add the value\r\n    series.values.push(metricValue);\r\n\r\n    // Trim if exceeding max size\r\n    if (series.values.length > this.config.maxMetricsPerSeries) {\r\n      series.values = series.values.slice(-this.config.maxMetricsPerSeries / 2);\r\n    }\r\n\r\n    // Emit metric event\r\n    this.emit('metric', { name, value: metricValue, series });\r\n\r\n    logger.debug('Metric recorded', {\r\n      name,\r\n      value,\r\n      type,\r\n      labels: options.labels\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Record counter increment\r\n   */\r\n  public incrementCounter(name: string, amount = 1, labels?: Record<string, string>): void {\r\n    const existing = this.getLatestValue(name);\r\n    const newValue = (existing?.value || 0) + amount;\r\n    \r\n    this.recordMetric(name, newValue, 'counter', { labels });\r\n  }\r\n\r\n  /**\r\n   * Record gauge value\r\n   */\r\n  public recordGauge(name: string, value: number, labels?: Record<string, string>): void {\r\n    this.recordMetric(name, value, 'gauge', { labels });\r\n  }\r\n\r\n  /**\r\n   * Record histogram value (simplified implementation)\r\n   */\r\n  public recordHistogram(name: string, value: number, labels?: Record<string, string>): void {\r\n    // For simplicity, we'll store histogram values as individual points\r\n    // In a production system, you'd want proper histogram buckets\r\n    this.recordMetric(`${name}_value`, value, 'histogram', { labels });\r\n    this.incrementCounter(`${name}_count`, 1, labels);\r\n  }\r\n\r\n  /**\r\n   * Process system metrics\r\n   */\r\n  public processSystemMetrics(metrics: SystemMetrics): void {\r\n    const timestamp = metrics.timestamp;\r\n\r\n    // CPU metrics\r\n    this.recordMetric('system.cpu.usage', metrics.cpu.usage, 'gauge', {\r\n      unit: 'percent',\r\n      timestamp,\r\n      description: 'CPU usage percentage'\r\n    });\r\n\r\n    this.recordMetric('system.cpu.load_average_1m', metrics.cpu.loadAverage.at(0) || 0, 'gauge', {\r\n      unit: 'load',\r\n      timestamp,\r\n      description: '1-minute load average'\r\n    });\r\n\r\n    // Memory metrics\r\n    this.recordMetric('system.memory.usage', metrics.memory.used, 'gauge', {\r\n      unit: 'bytes',\r\n      timestamp,\r\n      description: 'Memory usage in bytes'\r\n    });\r\n\r\n    this.recordMetric('system.memory.percentage', metrics.memory.percentage, 'gauge', {\r\n      unit: 'percent',\r\n      timestamp,\r\n      description: 'Memory usage percentage'\r\n    });\r\n\r\n    // Disk metrics\r\n    this.recordMetric('system.disk.usage', metrics.disk.used, 'gauge', {\r\n      unit: 'bytes',\r\n      timestamp,\r\n      description: 'Disk usage in bytes'\r\n    });\r\n\r\n    this.recordMetric('system.disk.percentage', metrics.disk.percentage, 'gauge', {\r\n      unit: 'percent',\r\n      timestamp,\r\n      description: 'Disk usage percentage'\r\n    });\r\n\r\n    // Process metrics\r\n    this.recordMetric('system.process.uptime', metrics.process.uptime, 'gauge', {\r\n      unit: 'seconds',\r\n      timestamp,\r\n      description: 'Process uptime in seconds'\r\n    });\r\n\r\n    this.recordMetric('system.process.memory', metrics.process.memoryUsage.heapUsed, 'gauge', {\r\n      unit: 'bytes',\r\n      timestamp,\r\n      description: 'Process heap memory usage'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Process application metrics\r\n   */\r\n  public processApplicationMetrics(metrics: ApplicationMetrics): void {\r\n    const timestamp = metrics.timestamp;\r\n\r\n    // Performance metrics\r\n    this.recordMetric('app.performance.response_time_avg', metrics.performance.responseTime.average, 'gauge', {\r\n      unit: 'milliseconds',\r\n      timestamp,\r\n      description: 'Average response time'\r\n    });\r\n\r\n    this.recordMetric('app.performance.throughput', metrics.performance.throughput.requestsPerSecond, 'gauge', {\r\n      unit: 'requests/second',\r\n      timestamp,\r\n      description: 'Requests per second'\r\n    });\r\n\r\n    this.recordMetric('app.performance.error_rate', metrics.performance.errorRate, 'gauge', {\r\n      unit: 'percent',\r\n      timestamp,\r\n      description: 'Error rate percentage'\r\n    });\r\n\r\n    // Database metrics\r\n    this.recordMetric('app.database.query_time_avg', metrics.database.averageQueryTime, 'gauge', {\r\n      unit: 'milliseconds',\r\n      timestamp,\r\n      description: 'Average database query time'\r\n    });\r\n\r\n    this.recordMetric('app.database.query_count', metrics.database.queryCount, 'counter', {\r\n      unit: 'queries',\r\n      timestamp,\r\n      description: 'Total database queries'\r\n    });\r\n\r\n    this.recordMetric('app.database.active_connections', metrics.database.activeConnections, 'gauge', {\r\n      unit: 'connections',\r\n      timestamp,\r\n      description: 'Active database connections'\r\n    });\r\n\r\n    // WebSocket metrics\r\n    this.recordMetric('app.websocket.active_connections', metrics.websocket.activeConnections, 'gauge', {\r\n      unit: 'connections',\r\n      timestamp,\r\n      description: 'Active WebSocket connections'\r\n    });\r\n\r\n    this.recordMetric('app.websocket.messages_per_second', metrics.websocket.messagesPerSecond, 'gauge', {\r\n      unit: 'messages/second',\r\n      timestamp,\r\n      description: 'WebSocket messages per second'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Process trading metrics\r\n   */\r\n  public processTradingMetrics(metrics: {\r\n    activeBots: number;\r\n    totalTrades: number;\r\n    totalPnL: number;\r\n    winRate: number;\r\n    ordersPlaced: number;\r\n    ordersFilled: number;\r\n    ordersCancelled: number;\r\n    ordersFailed: number;\r\n    openPositions: number;\r\n    unrealizedPnL: number;\r\n    timestamp?: Date;\r\n  }): void {\r\n    const timestamp = metrics.timestamp || new Date();\r\n\r\n    // Bot metrics\r\n    this.recordMetric('trading.bots.active', metrics.activeBots, 'gauge', {\r\n      unit: 'bots',\r\n      timestamp,\r\n      description: 'Number of active trading bots'\r\n    });\r\n\r\n    this.recordMetric('trading.bots.total_trades', metrics.totalTrades, 'counter', {\r\n      unit: 'trades',\r\n      timestamp,\r\n      description: 'Total trades executed'\r\n    });\r\n\r\n    this.recordMetric('trading.bots.total_pnl', metrics.totalPnL, 'gauge', {\r\n      unit: 'currency',\r\n      timestamp,\r\n      description: 'Total profit and loss'\r\n    });\r\n\r\n    this.recordMetric('trading.bots.win_rate', metrics.winRate, 'gauge', {\r\n      unit: 'percent',\r\n      timestamp,\r\n      description: 'Win rate percentage'\r\n    });\r\n\r\n    // Order metrics\r\n    this.recordMetric('trading.orders.placed', metrics.ordersPlaced, 'counter', {\r\n      unit: 'orders',\r\n      timestamp,\r\n      description: 'Orders placed'\r\n    });\r\n\r\n    this.recordMetric('trading.orders.filled', metrics.ordersFilled, 'counter', {\r\n      unit: 'orders',\r\n      timestamp,\r\n      description: 'Orders filled'\r\n    });\r\n\r\n    this.recordMetric('trading.orders.cancelled', metrics.ordersCancelled, 'counter', {\r\n      unit: 'orders',\r\n      timestamp,\r\n      description: 'Orders cancelled'\r\n    });\r\n\r\n    this.recordMetric('trading.orders.failed', metrics.ordersFailed, 'counter', {\r\n      unit: 'orders',\r\n      timestamp,\r\n      description: 'Orders failed'\r\n    });\r\n\r\n    // Position metrics\r\n    this.recordMetric('trading.positions.open', metrics.openPositions, 'gauge', {\r\n      unit: 'positions',\r\n      timestamp,\r\n      description: 'Open positions'\r\n    });\r\n\r\n    this.recordMetric('trading.positions.unrealized_pnl', metrics.unrealizedPnL, 'gauge', {\r\n      unit: 'currency',\r\n      timestamp,\r\n      description: 'Unrealized profit and loss'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Query metrics\r\n   */\r\n  public queryMetrics(query: MetricsQuery): QueryResult {\r\n    const series = this.metrics.get(query.metric);\r\n    \r\n    if (!series) {\r\n      return {\r\n        metric: query.metric,\r\n        values: []\r\n      };\r\n    }\r\n\r\n    let values = [...series.values];\r\n\r\n    // Filter by time range\r\n    if (query.startTime) {\r\n      values = values.filter(v => v.timestamp >= query.startTime!);\r\n    }\r\n    \r\n    if (query.endTime) {\r\n      values = values.filter(v => v.timestamp <= query.endTime!);\r\n    }\r\n\r\n    // Filter by labels\r\n    if (query.labels) {\r\n      values = values.filter(v => {\r\n        if (!v.labels) {return false;}\r\n        \r\n        for (const [key, value] of Object.entries(query.labels!)) {\r\n          if (v.labels[key] !== value) {return false;}\r\n        }\r\n        \r\n        return true;\r\n      });\r\n    }\r\n\r\n    // Apply aggregation\r\n    if (query.aggregation && values.length > 0) {\r\n      const aggregatedValue = this.aggregateValues(values, query.aggregation);\r\n      const lastValue = values.at(-1);\r\n      if (lastValue) {\r\n        return {\r\n          metric: query.metric,\r\n          values: [{\r\n            timestamp: lastValue.timestamp,\r\n            value: aggregatedValue,\r\n            labels: query.labels\r\n          }],\r\n          aggregation: query.aggregation\r\n        };\r\n      }\r\n    }\r\n\r\n    // Group by interval if specified\r\n    if (query.interval && query.interval > 0) {\r\n      values = this.groupByInterval(values, query.interval);\r\n    }\r\n\r\n    return {\r\n      metric: query.metric,\r\n      values: values.map(v => ({\r\n        timestamp: v.timestamp,\r\n        value: v.value,\r\n        labels: v.labels\r\n      })),\r\n      interval: query.interval\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all metric names\r\n   */\r\n  public getMetricNames(): string[] {\r\n    return Array.from(this.metrics.keys());\r\n  }\r\n\r\n  /**\r\n   * Get metric series\r\n   */\r\n  public getMetricSeries(name: string): MetricSeries | undefined {\r\n    return this.metrics.get(name);\r\n  }\r\n\r\n  /**\r\n   * Get latest value for a metric\r\n   */\r\n  public getLatestValue(name: string): MetricValue | undefined {\r\n    const series = this.metrics.get(name);\r\n    if (!series || series.values.length === 0) {\r\n      return undefined;\r\n    }\r\n    \r\n    return series.values[series.values.length - 1];\r\n  }\r\n\r\n  /**\r\n   * Get aggregated metrics\r\n   */\r\n  public getAggregatedMetrics(): AggregatedMetrics {\r\n    return this.aggregatedMetrics;\r\n  }\r\n\r\n  /**\r\n   * Get metrics summary for dashboard\r\n   */\r\n  public getMetricsSummary(): {\r\n    totalMetrics: number;\r\n    totalDataPoints: number;\r\n    oldestDataPoint: Date | null;\r\n    newestDataPoint: Date | null;\r\n    memoryUsage: number;\r\n  } {\r\n    let totalDataPoints = 0;\r\n    let oldestDataPoint: Date | null = null;\r\n    let newestDataPoint: Date | null = null;\r\n\r\n    for (const series of this.metrics.values()) {\r\n      totalDataPoints += series.values.length;\r\n      \r\n      if (series.values.length > 0) {\r\n        const firstValue = series.values.at(0);\r\n        const lastValue = series.values[series.values.length - 1];\r\n        \r\n        if (firstValue && lastValue) {\r\n          const oldest = firstValue.timestamp;\r\n          const newest = lastValue.timestamp;\r\n          \r\n          if (!oldestDataPoint || oldest < oldestDataPoint) {\r\n            oldestDataPoint = oldest;\r\n          }\r\n          \r\n          if (!newestDataPoint || newest > newestDataPoint) {\r\n            newestDataPoint = newest;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalMetrics: this.metrics.size,\r\n      totalDataPoints,\r\n      oldestDataPoint,\r\n      newestDataPoint,\r\n      memoryUsage: process.memoryUsage().heapUsed\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize aggregated metrics structure\r\n   */\r\n  private initializeAggregatedMetrics(): AggregatedMetrics {\r\n    const createSeries = (name: string, type: MetricSeries['type'] = 'gauge'): MetricSeries => ({\r\n      name,\r\n      type,\r\n      values: []\r\n    });\r\n\r\n    return {\r\n      system: {\r\n        cpu: {\r\n          usage: createSeries('system.cpu.usage'),\r\n          loadAverage: createSeries('system.cpu.load_average_1m')\r\n        },\r\n        memory: {\r\n          usage: createSeries('system.memory.usage'),\r\n          percentage: createSeries('system.memory.percentage')\r\n        },\r\n        disk: {\r\n          usage: createSeries('system.disk.usage'),\r\n          percentage: createSeries('system.disk.percentage')\r\n        },\r\n        process: {\r\n          uptime: createSeries('system.process.uptime'),\r\n          memoryUsage: createSeries('system.process.memory')\r\n        }\r\n      },\r\n      application: {\r\n        performance: {\r\n          responseTime: createSeries('app.performance.response_time_avg'),\r\n          throughput: createSeries('app.performance.throughput'),\r\n          errorRate: createSeries('app.performance.error_rate')\r\n        },\r\n        database: {\r\n          queryTime: createSeries('app.database.query_time_avg'),\r\n          queryCount: createSeries('app.database.query_count', 'counter'),\r\n          connectionPool: createSeries('app.database.active_connections')\r\n        },\r\n        websocket: {\r\n          activeConnections: createSeries('app.websocket.active_connections'),\r\n          messagesPerSecond: createSeries('app.websocket.messages_per_second')\r\n        }\r\n      },\r\n      trading: {\r\n        bots: {\r\n          activeCount: createSeries('trading.bots.active'),\r\n          totalTrades: createSeries('trading.bots.total_trades', 'counter'),\r\n          totalPnL: createSeries('trading.bots.total_pnl'),\r\n          winRate: createSeries('trading.bots.win_rate')\r\n        },\r\n        orders: {\r\n          placed: createSeries('trading.orders.placed', 'counter'),\r\n          filled: createSeries('trading.orders.filled', 'counter'),\r\n          cancelled: createSeries('trading.orders.cancelled', 'counter'),\r\n          failed: createSeries('trading.orders.failed', 'counter')\r\n        },\r\n        positions: {\r\n          open: createSeries('trading.positions.open'),\r\n          unrealizedPnL: createSeries('trading.positions.unrealized_pnl')\r\n        }\r\n      },\r\n      custom: {}\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Perform aggregation\r\n   */\r\n  private performAggregation(): void {\r\n    // Update aggregated metrics with latest values\r\n    for (const [key, series] of this.metrics) {\r\n      if (series.values.length === 0) {continue;}\r\n      \r\n      const latestValue = series.values[series.values.length - 1];\r\n      \r\n      // Update aggregated structure\r\n      if (key.startsWith('system.cpu.usage') && latestValue) {\r\n        this.aggregatedMetrics.system.cpu.usage.values.push(latestValue);\r\n      } else if (key.startsWith('system.memory.percentage') && latestValue) {\r\n        this.aggregatedMetrics.system.memory.percentage.values.push(latestValue);\r\n      }\r\n      // Add more mappings as needed...\r\n    }\r\n\r\n    this.emit('aggregation', this.aggregatedMetrics);\r\n  }\r\n\r\n  /**\r\n   * Aggregate values using specified method\r\n   */\r\n  private aggregateValues(values: MetricValue[], method: string): number {\r\n    if (values.length === 0) {return 0;}\r\n\r\n    switch (method) {\r\n      case 'avg':\r\n        return values.reduce((sum, v) => sum + v.value, 0) / values.length;\r\n      case 'sum':\r\n        return values.reduce((sum, v) => sum + v.value, 0);\r\n      case 'min':\r\n        return Math.min(...values.map(v => v.value));\r\n      case 'max':\r\n        return Math.max(...values.map(v => v.value));\r\n      case 'count':\r\n        return values.length;\r\n      case 'last':\r\n        return values.length > 0 ? values.at(-1)?.value ?? 0 : 0;\r\n      default:\r\n        return values.length > 0 ? values.at(-1)?.value ?? 0 : 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Group values by time interval\r\n   */\r\n  private groupByInterval(values: MetricValue[], interval: number): MetricValue[] {\r\n    if (values.length === 0) {return [];}\r\n\r\n    const firstValue = values.at(0);\r\n    if (!firstValue) {return [];}\r\n\r\n    const grouped: MetricValue[] = [];\r\n    const startTime = firstValue.timestamp.getTime();\r\n    \r\n    let currentBucket = Math.floor((firstValue.timestamp.getTime() - startTime) / interval);\r\n    let bucketValues: MetricValue[] = [];\r\n\r\n    for (const value of values) {\r\n      const bucket = Math.floor((value.timestamp.getTime() - startTime) / interval);\r\n      \r\n      if (bucket === currentBucket) {\r\n        bucketValues.push(value);\r\n      } else {\r\n        // Process current bucket\r\n        if (bucketValues.length > 0) {\r\n          const avgValue = bucketValues.reduce((sum, v) => sum + v.value, 0) / bucketValues.length;\r\n          const firstBucketValue = bucketValues.at(0);\r\n          grouped.push({\r\n            timestamp: new Date(startTime + currentBucket * interval),\r\n            value: avgValue,\r\n            labels: firstBucketValue?.labels\r\n          });\r\n        }\r\n        \r\n        // Start new bucket\r\n        currentBucket = bucket;\r\n        bucketValues = [value];\r\n      }\r\n    }\r\n\r\n    // Process last bucket\r\n    if (bucketValues.length > 0) {\r\n      const avgValue = bucketValues.reduce((sum, v) => sum + v.value, 0) / bucketValues.length;\r\n      const firstBucketValue = bucketValues.at(0);\r\n      grouped.push({\r\n        timestamp: new Date(startTime + currentBucket * interval),\r\n        value: avgValue,\r\n        labels: firstBucketValue?.labels\r\n      });\r\n    }\r\n\r\n    return grouped;\r\n  }\r\n\r\n  /**\r\n   * Clean up old metrics\r\n   */\r\n  private cleanupOldMetrics(): void {\r\n    const cutoff = new Date(Date.now() - this.config.retentionPeriod);\r\n    let totalRemoved = 0;\r\n\r\n    for (const [name, series] of this.metrics) {\r\n      const initialLength = series.values.length;\r\n      series.values = series.values.filter(v => v.timestamp >= cutoff);\r\n      totalRemoved += initialLength - series.values.length;\r\n    }\r\n\r\n    if (totalRemoved > 0) {\r\n      logger.debug(`Cleaned up ${totalRemoved} old metric values`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Persist metrics to storage (placeholder implementation)\r\n   */\r\n  private async persistMetrics(): Promise<void> {\r\n    try {\r\n      // In a real implementation, this would save metrics to a database\r\n      // For now, we'll just log the operation\r\n      const summary = this.getMetricsSummary();\r\n      logger.debug('Metrics persistence checkpoint', {\r\n        totalMetrics: summary.totalMetrics,\r\n        totalDataPoints: summary.totalDataPoints\r\n      });\r\n      \r\n      this.emit('persistence', summary);\r\n    } catch (error) {\r\n      logger.error('Failed to persist metrics', { error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset all metrics\r\n   */\r\n  public reset(): void {\r\n    this.metrics.clear();\r\n    this.aggregatedMetrics = this.initializeAggregatedMetrics();\r\n    \r\n    logger.info('Metrics Collector reset');\r\n    this.emit('reset');\r\n  }\r\n\r\n  /**\r\n   * Shutdown the metrics collector\r\n   */\r\n  public shutdown(): void {\r\n    this.stop();\r\n    \r\n    // Perform final persistence if enabled\r\n    if (this.config.enablePersistence) {\r\n      this.persistMetrics();\r\n    }\r\n    \r\n    this.reset();\r\n    this.removeAllListeners();\r\n    \r\n    logger.info('Metrics Collector shut down');\r\n  }\r\n}\r\n\r\nexport default MetricsCollectorService;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\monitoring.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\position-monitor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\redis.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\risk-management.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\strategy-monitor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\system-health.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\system-monitor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\services\\time-sync.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\strategies\\aether-signal-strategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\strategies\\plugin-manager.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdir from package \"fs/promises\" with non literal argument at index 0","line":315,"column":13,"nodeType":"CallExpression","endLine":315,"endColumn":64},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdir from package \"fs/promises\" with non literal argument at index 0","line":325,"column":27,"nodeType":"CallExpression","endLine":325,"endColumn":59},{"ruleId":"security/detect-non-literal-require","severity":2,"message":"Found non-literal argument in require","line":369,"column":26,"nodeType":"CallExpression","endLine":369,"endColumn":47},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":418,"column":18,"nodeType":"MemberExpression","endLine":418,"endColumn":47},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":426,"column":11,"nodeType":"MemberExpression","endLine":426,"endColumn":38}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Strategy Plugin Manager\r\n * \r\n * Comprehensive plugin system for custom trading strategies with security,\r\n * validation, and dynamic loading capabilities.\r\n */\r\n\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\n\r\nimport { z } from 'zod';\r\n\r\nimport type { \r\n  IStrategy, \r\n  StrategyConfig, \r\n  StrategyContext, \r\n  ConfigValidationResult,\r\n  StrategyResult \r\n} from '../JabbrLabs/target-reacher/interfaces';\r\nimport logger from '../services/logging.service';\r\n\r\n// Plugin metadata interface\r\nexport interface PluginMetadata {\r\n  name: string;\r\n  version: string;\r\n  description: string;\r\n  author: string;\r\n  supportedMarkets: string[];\r\n  riskLevel: 'low' | 'medium' | 'high';\r\n  category: string;\r\n  tags: string[];\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\n// Plugin information for registry\r\nexport interface PluginInfo {\r\n  id: string;\r\n  metadata: PluginMetadata;\r\n  filePath: string;\r\n  isLoaded: boolean;\r\n  loadedAt?: string;\r\n  error?: string;\r\n  instance?: IStrategy;\r\n}\r\n\r\n// Plugin configuration schema for validation\r\nconst PluginMetadataSchema = z.object({\r\n  name: z.string().min(1).max(100),\r\n  version: z.string().regex(/^\\d+\\.\\d+\\.\\d+$/),\r\n  description: z.string().min(1).max(500),\r\n  author: z.string().min(1).max(100),\r\n  supportedMarkets: z.array(z.string()).min(1),\r\n  riskLevel: z.enum(['low', 'medium', 'high']),\r\n  category: z.string().min(1).max(50),\r\n  tags: z.array(z.string()).optional().default([]),\r\n  createdAt: z.string().datetime(),\r\n  updatedAt: z.string().datetime()\r\n});\r\n\r\n// Plugin wrapper for sandboxing\r\nexport interface PluginWrapper {\r\n  execute(context: StrategyContext): Promise<StrategyResult>;\r\n  validateConfig(config: Record<string, unknown>): ConfigValidationResult;\r\n  getDefaultConfig(): StrategyConfig;\r\n  cleanup(): Promise<void>;\r\n}\r\n\r\nexport class StrategyPluginManager {\r\n  private pluginRegistry: Map<string, PluginInfo> = new Map();\r\n  private pluginDirectory: string;\r\n  private allowedDependencies: Set<string>;\r\n  private securityEnabled: boolean;\r\n\r\n  constructor(\r\n    pluginDirectory: string = path.join(process.cwd(), 'plugins'),\r\n    securityEnabled = true\r\n  ) {\r\n    this.pluginDirectory = pluginDirectory;\r\n    this.securityEnabled = securityEnabled;\r\n    \r\n    // Whitelist of allowed dependencies for security\r\n    this.allowedDependencies = new Set([\r\n      'lodash',\r\n      'moment',\r\n      'decimal.js',\r\n      'ta-lib',\r\n      'technicalindicators'\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Initialize the plugin manager\r\n   */\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      // Ensure plugin directory exists\r\n      await this.ensurePluginDirectory();\r\n      \r\n      // Load existing plugins\r\n      await this.scanAndLoadPlugins();\r\n      \r\n      logger.info(`Strategy Plugin Manager initialized with ${this.pluginRegistry.size} plugins`);\r\n    } catch (error) {\r\n      logger.error('Failed to initialize Strategy Plugin Manager', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register a new plugin from file path\r\n   */\r\n  async registerPlugin(filePath: string): Promise<string> {\r\n    try {\r\n      const absolutePath = path.resolve(filePath);\r\n      \r\n      // Security check: ensure plugin is in allowed directory\r\n      if (this.securityEnabled && !absolutePath.startsWith(path.resolve(this.pluginDirectory))) {\r\n        throw new Error('Plugin must be located in the designated plugin directory');\r\n      }\r\n\r\n      // Load and validate plugin metadata\r\n      const pluginModule = await this.loadPluginModule(absolutePath);\r\n      const metadata = await this.validatePluginMetadata(pluginModule.metadata);\r\n      \r\n      // Generate unique plugin ID\r\n      const pluginId = this.generatePluginId(metadata.name, metadata.version);\r\n      \r\n      // Create plugin info\r\n      const pluginInfo: PluginInfo = {\r\n        id: pluginId,\r\n        metadata,\r\n        filePath: absolutePath,\r\n        isLoaded: false\r\n      };\r\n\r\n      // Validate plugin implementation\r\n      await this.validatePluginImplementation(pluginModule);\r\n      \r\n      // Register plugin\r\n      this.pluginRegistry.set(pluginId, pluginInfo);\r\n      \r\n      logger.info(`Plugin registered: ${metadata.name} v${metadata.version}`, {\r\n        pluginId,\r\n        author: metadata.author,\r\n        markets: metadata.supportedMarkets\r\n      });\r\n\r\n      return pluginId;\r\n    } catch (error) {\r\n      logger.error(`Failed to register plugin: ${filePath}`, { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load a plugin and create an instance\r\n   */\r\n  async loadPlugin(pluginId: string, config: StrategyConfig, context: StrategyContext): Promise<IStrategy> {\r\n    try {\r\n      const pluginInfo = this.pluginRegistry.get(pluginId);\r\n      if (!pluginInfo) {\r\n        throw new Error(`Plugin not found: ${pluginId}`);\r\n      }\r\n\r\n      // Load plugin module\r\n      const pluginModule = await this.loadPluginModule(pluginInfo.filePath);\r\n      \r\n      // Validate configuration\r\n      const tempInstance = new pluginModule.default();\r\n      const configValidation = tempInstance.validateConfig(config.parameters || {});\r\n      \r\n      if (!configValidation.valid) {\r\n        throw new Error(`Invalid plugin configuration: ${configValidation.errors.map((e: any) => e.message).join(', ')}`);\r\n      }\r\n\r\n      // Create plugin instance with dependency injection\r\n      const pluginInstance = new pluginModule.default();\r\n      await pluginInstance.initialize(context);\r\n      \r\n      // Update plugin info\r\n      pluginInfo.isLoaded = true;\r\n      pluginInfo.loadedAt = new Date().toISOString();\r\n      pluginInfo.instance = pluginInstance;\r\n      pluginInfo.error = undefined;\r\n\r\n      logger.info(`Plugin loaded: ${pluginInfo.metadata.name}`, {\r\n        pluginId,\r\n        botId: context.botConfig?.id\r\n      });\r\n\r\n      return pluginInstance;\r\n    } catch (error) {\r\n      // Update plugin info with error\r\n      const pluginInfo = this.pluginRegistry.get(pluginId);\r\n      if (pluginInfo) {\r\n        pluginInfo.error = error instanceof Error ? error.message : String(error);\r\n        pluginInfo.isLoaded = false;\r\n      }\r\n\r\n      logger.error(`Failed to load plugin: ${pluginId}`, { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unload a plugin\r\n   */\r\n  async unloadPlugin(pluginId: string): Promise<void> {\r\n    try {\r\n      const pluginInfo = this.pluginRegistry.get(pluginId);\r\n      if (!pluginInfo || !pluginInfo.isLoaded) {\r\n        return;\r\n      }\r\n\r\n      // Cleanup plugin instance\r\n      if (pluginInfo.instance && typeof pluginInfo.instance.cleanup === 'function') {\r\n        await pluginInfo.instance.cleanup({} as StrategyContext);\r\n      }\r\n\r\n      // Clear module cache to allow hot reloading\r\n      delete require.cache[require.resolve(pluginInfo.filePath)];\r\n\r\n      // Update plugin info\r\n      pluginInfo.isLoaded = false;\r\n      pluginInfo.instance = undefined;\r\n      pluginInfo.loadedAt = undefined;\r\n\r\n      logger.info(`Plugin unloaded: ${pluginInfo.metadata.name}`, { pluginId });\r\n    } catch (error) {\r\n      logger.error(`Failed to unload plugin: ${pluginId}`, { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all registered plugins\r\n   */\r\n  getPlugins(): PluginInfo[] {\r\n    return Array.from(this.pluginRegistry.values());\r\n  }\r\n\r\n  /**\r\n   * Get plugin by ID\r\n   */\r\n  getPlugin(pluginId: string): PluginInfo | undefined {\r\n    return this.pluginRegistry.get(pluginId);\r\n  }\r\n\r\n  /**\r\n   * Search plugins by criteria\r\n   */\r\n  searchPlugins(criteria: {\r\n    name?: string;\r\n    category?: string;\r\n    riskLevel?: string;\r\n    supportedMarket?: string;\r\n    tags?: string[];\r\n  }): PluginInfo[] {\r\n    return this.getPlugins().filter(plugin => {\r\n      if (criteria.name && !plugin.metadata.name.toLowerCase().includes(criteria.name.toLowerCase())) {\r\n        return false;\r\n      }\r\n      if (criteria.category && plugin.metadata.category !== criteria.category) {\r\n        return false;\r\n      }\r\n      if (criteria.riskLevel && plugin.metadata.riskLevel !== criteria.riskLevel) {\r\n        return false;\r\n      }\r\n      if (criteria.supportedMarket && !plugin.metadata.supportedMarkets.includes(criteria.supportedMarket)) {\r\n        return false;\r\n      }\r\n      if (criteria.tags && !criteria.tags.some(tag => plugin.metadata.tags.includes(tag))) {\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate plugin configuration\r\n   */\r\n  async validatePluginConfig(pluginId: string, config: Record<string, unknown>): Promise<ConfigValidationResult> {\r\n    try {\r\n      const pluginInfo = this.pluginRegistry.get(pluginId);\r\n      if (!pluginInfo) {\r\n        return {\r\n          valid: false,\r\n          errors: [{ field: 'plugin', message: 'Plugin not found', code: 'PLUGIN_NOT_FOUND' }],\r\n          warnings: []\r\n        };\r\n      }\r\n\r\n      // Load plugin module if not already loaded\r\n      const pluginModule = await this.loadPluginModule(pluginInfo.filePath);\r\n      const tempInstance = new pluginModule.default();\r\n      \r\n      return tempInstance.validateConfig(config);\r\n    } catch (error) {\r\n      return {\r\n        valid: false,\r\n        errors: [{ field: 'validation', message: error instanceof Error ? error.message : String(error), code: 'VALIDATION_ERROR' }],\r\n        warnings: []\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private: Ensure plugin directory exists\r\n   */\r\n  private async ensurePluginDirectory(): Promise<void> {\r\n    try {\r\n      await fs.access(this.pluginDirectory);\r\n    } catch {\r\n      await fs.mkdir(this.pluginDirectory, { recursive: true });\r\n      logger.info(`Created plugin directory: ${this.pluginDirectory}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private: Scan and load all plugins in directory\r\n   */\r\n  private async scanAndLoadPlugins(): Promise<void> {\r\n    try {\r\n      const files = await fs.readdir(this.pluginDirectory);\r\n      const pluginFiles = files.filter(file => file.endsWith('.js') || file.endsWith('.ts'));\r\n\r\n      for (const file of pluginFiles) {\r\n        try {\r\n          const filePath = path.join(this.pluginDirectory, file);\r\n          await this.registerPlugin(filePath);\r\n        } catch (error) {\r\n          logger.warn(`Failed to load plugin file: ${file}`, { error });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logger.error('Failed to scan plugin directory', { error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private: Load plugin module with security checks\r\n   */\r\n  private async loadPluginModule(filePath: string): Promise<any> {\r\n    try {\r\n      // Ensure we have an absolute path\r\n      const absolutePath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath);\r\n      \r\n      // Security: Check file exists and is readable\r\n      await fs.access(absolutePath, fs.constants.R_OK);\r\n      \r\n      // Security: Validate file extension\r\n      const ext = path.extname(absolutePath);\r\n      if (!['.js', '.ts'].includes(ext)) {\r\n        throw new Error('Invalid plugin file extension. Only .js and .ts files are allowed.');\r\n      }\r\n\r\n      // Clear module cache for hot reloading\r\n      if (require.cache[require.resolve(absolutePath)]) {\r\n        delete require.cache[require.resolve(absolutePath)];\r\n      }\r\n      \r\n      // Dynamic import for ES modules or require for CommonJS\r\n      let pluginModule;\r\n      try {\r\n        pluginModule = await import(absolutePath);\r\n      } catch (importError: unknown) {\r\n        try {\r\n          pluginModule = require(absolutePath);\r\n        } catch (requireError: unknown) {\r\n          const importMsg = importError instanceof Error ? importError.message : 'Import error';\r\n          const requireMsg = requireError instanceof Error ? requireError.message : 'Require error';\r\n          throw new Error(`Failed to import plugin: ${importMsg || requireMsg}`);\r\n        }\r\n      }\r\n\r\n      if (!pluginModule.default) {\r\n        throw new Error('Plugin must have a default export');\r\n      }\r\n\r\n      return pluginModule;\r\n    } catch (error) {\r\n      throw new Error(`Failed to load plugin module: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private: Validate plugin metadata\r\n   */\r\n  private async validatePluginMetadata(metadata: any): Promise<PluginMetadata> {\r\n    try {\r\n      return PluginMetadataSchema.parse(metadata);\r\n    } catch (error) {\r\n      if (error instanceof z.ZodError) {\r\n        const errorMessages = error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');\r\n        throw new Error(`Invalid plugin metadata: ${errorMessages}`);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private: Validate plugin implementation\r\n   */\r\n  private async validatePluginImplementation(pluginModule: any): Promise<void> {\r\n    const PluginClass = pluginModule.default;\r\n    \r\n    if (typeof PluginClass !== 'function') {\r\n      throw new Error('Plugin default export must be a class constructor');\r\n    }\r\n\r\n    // Create temporary instance to check interface compliance\r\n    const tempInstance = new PluginClass();\r\n    \r\n    // Check required methods\r\n    const requiredMethods = ['initialize', 'execute', 'cleanup', 'validateConfig', 'getDefaultConfig'];\r\n    for (const method of requiredMethods) {\r\n      if (typeof (tempInstance as any)[method] !== 'function') {\r\n        throw new Error(`Plugin must implement ${method} method`);\r\n      }\r\n    }\r\n\r\n    // Check required properties\r\n    const requiredProperties = ['name', 'version', 'description', 'supportedMarkets'];\r\n    for (const prop of requiredProperties) {\r\n      if ((tempInstance as any)[prop] === undefined) {\r\n        throw new Error(`Plugin must have ${prop} property`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private: Generate unique plugin ID\r\n   */\r\n  private generatePluginId(name: string, version: string): string {\r\n    const sanitizedName = name.toLowerCase().replace(/[^a-z0-9-]/g, '-');\r\n    const sanitizedVersion = version.replace(/[^0-9.]/g, '');\r\n    return `${sanitizedName}-${sanitizedVersion}`;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const strategyPluginManager = new StrategyPluginManager(); ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\strategies\\strategy-backtest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\strategies\\strategy-factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\strategies\\strategy-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\strategies\\target-reacher-strategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\test-mainnet-safe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\users\\database-user.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\users\\user.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\utils\\performance-profiler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\websocket\\bybit-time-sync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\websocket\\bybit-websocket.client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\websocket\\websocket-bridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\websocket\\websocket-server.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":532,"column":9,"nodeType":"MemberExpression","endLine":532,"endColumn":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Server as HTTPServer } from 'http';\r\nimport type { IncomingMessage } from 'http';\r\nimport { parse as parseUrl } from 'url';\r\n\r\nimport type { \r\n  WebSocketMessage, \r\n  WebSocketResponse} from '@jabbr/shared';\r\nimport { \r\n  CONSTANTS \r\n} from '@jabbr/shared';\r\nimport { WebSocketServer, WebSocket } from 'ws';\r\n\r\nimport { AuthService } from '../auth/auth.service';\r\nimport { database } from '../database/database.config';\r\nimport BotStatusService from '../services/bot-status.service';\r\n\r\n/**\r\n * WebSocket Connection with user context\r\n */\r\ninterface AuthenticatedConnection {\r\n  ws: WebSocket;\r\n  userId: string;\r\n  email: string;\r\n  connectedAt: Date;\r\n  lastHeartbeat: Date;\r\n  subscribedChannels: Set<string>;\r\n  sessionId: string;\r\n}\r\n\r\n/**\r\n * WebSocket Server for real-time trading bot communication\r\n * Handles authentication, channel subscriptions, and message routing\r\n */\r\nexport class JabbrWebSocketServer {\r\n  private wss: WebSocketServer;\r\n  private authService: AuthService;\r\n  private botStatusService: BotStatusService;\r\n  private connections: Map<string, AuthenticatedConnection> = new Map();\r\n  private channels: Map<string, Set<string>> = new Map(); // channel -> sessionIds\r\n  private heartbeatInterval: NodeJS.Timeout | null = null;\r\n  private cleanupInterval: NodeJS.Timeout | null = null;\r\n\r\n  // Configuration\r\n  private readonly HEARTBEAT_INTERVAL = 30000; // 30 seconds\r\n  private readonly CONNECTION_TIMEOUT = 60000; // 60 seconds\r\n  private readonly MAX_CONNECTIONS_PER_USER = 5;\r\n\r\n  constructor(httpServer: HTTPServer) {\r\n    this.authService = new AuthService();\r\n    \r\n    // Create WebSocket server\r\n    this.wss = new WebSocketServer({\r\n      server: httpServer,\r\n      path: '/ws',\r\n      verifyClient: this.verifyClient.bind(this)\r\n    });\r\n\r\n    this.botStatusService = new BotStatusService(this);\r\n\r\n    this.setupEventHandlers();\r\n    this.startHeartbeat();\r\n    this.startCleanup();\r\n\r\n    console.log('🔌 WebSocket server initialized on /ws');\r\n  }\r\n\r\n  public getBotStatusService(): BotStatusService {\r\n    return this.botStatusService;\r\n  }\r\n\r\n  /**\r\n   * Verify client connection during WebSocket handshake\r\n   */\r\n  private verifyClient(info: { origin: string; secure: boolean; req: IncomingMessage }): boolean {\r\n    try {\r\n      const url = parseUrl(info.req.url || '', true);\r\n      const token = url.query.token as string;\r\n\r\n      if (!token) {\r\n        console.log('❌ WebSocket connection rejected: No token provided');\r\n        return false;\r\n      }\r\n\r\n      // Verify JWT token\r\n      const decoded = this.authService.verifyAccessToken(token);\r\n      if (!decoded) {\r\n        console.log('❌ WebSocket connection rejected: Invalid token');\r\n        return false;\r\n      }\r\n\r\n      // Store user info for connection setup\r\n      (info.req as any).user = decoded;\r\n      return true;\r\n    } catch (error) {\r\n      console.error('❌ WebSocket verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup WebSocket event handlers\r\n   */\r\n  private setupEventHandlers(): void {\r\n    this.wss.on('connection', this.handleConnection.bind(this));\r\n    this.wss.on('error', this.handleServerError.bind(this));\r\n\r\n    console.log('📡 WebSocket event handlers configured');\r\n  }\r\n\r\n  /**\r\n   * Handle new WebSocket connection\r\n   */\r\n  private handleConnection(ws: WebSocket, req: IncomingMessage): void {\r\n    try {\r\n      const user = (req as any).user;\r\n      if (!user) {\r\n        ws.close(1008, 'Authentication required');\r\n        return;\r\n      }\r\n\r\n      // Check connection limits\r\n      const existingConnections = Array.from(this.connections.values())\r\n        .filter(conn => conn.userId === user.userId);\r\n      \r\n      if (existingConnections.length >= this.MAX_CONNECTIONS_PER_USER) {\r\n        ws.close(1008, 'Too many connections');\r\n        return;\r\n      }\r\n\r\n      // Create authenticated connection\r\n      const sessionId = this.generateSessionId();\r\n      const connection: AuthenticatedConnection = {\r\n        ws,\r\n        userId: user.userId,\r\n        email: user.email,\r\n        connectedAt: new Date(),\r\n        lastHeartbeat: new Date(),\r\n        subscribedChannels: new Set(),\r\n        sessionId\r\n      };\r\n\r\n      // Store connection\r\n      this.connections.set(sessionId, connection);\r\n\r\n      // Setup connection event handlers\r\n      ws.on('message', (data) => this.handleMessage(sessionId, data));\r\n      ws.on('close', () => this.handleDisconnection(sessionId));\r\n      ws.on('error', (error) => this.handleConnectionError(sessionId, error));\r\n      ws.on('pong', () => this.handlePong(sessionId));\r\n\r\n      // Send welcome message\r\n      this.sendToConnection(sessionId, {\r\n        type: 'connection',\r\n        channel: CONSTANTS.WS_CHANNELS.SYSTEM_HEALTH,\r\n        data: {\r\n          status: 'connected',\r\n          sessionId,\r\n          timestamp: new Date().toISOString(),\r\n          availableChannels: Object.values(CONSTANTS.WS_CHANNELS)\r\n        }\r\n      });\r\n\r\n      console.log(`✅ WebSocket connected: ${user.email} (${sessionId})`);\r\n      \r\n      // Log connection to database\r\n      this.logConnectionEvent(user.userId, 'connected', sessionId);\r\n\r\n    } catch (error) {\r\n      console.error('❌ Connection setup error:', error);\r\n      ws.close(1011, 'Internal server error');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle incoming WebSocket message\r\n   */\r\n  private handleMessage(sessionId: string, data: any): void {\r\n    try {\r\n      const connection = this.connections.get(sessionId);\r\n      if (!connection) {return;}\r\n\r\n      // Convert data to string if it's a Buffer\r\n      const messageString = data instanceof Buffer ? data.toString() : data.toString();\r\n      const message: WebSocketMessage = JSON.parse(messageString);\r\n      \r\n      // Update heartbeat\r\n      connection.lastHeartbeat = new Date();\r\n\r\n      // Route message based on type\r\n      switch (message.type) {\r\n        case 'subscribe':\r\n          this.handleSubscription(sessionId, message);\r\n          break;\r\n        case 'unsubscribe':\r\n          this.handleUnsubscription(sessionId, message);\r\n          break;\r\n        case 'ping':\r\n          this.handlePing(sessionId);\r\n          break;\r\n        case 'bot_command':\r\n          this.handleBotCommand(sessionId, message);\r\n          break;\r\n        default:\r\n          this.sendError(sessionId, `Unknown message type: ${message.type}`);\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error(`❌ Message handling error for ${sessionId}:`, error);\r\n      this.sendError(sessionId, 'Invalid message format');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle channel subscription\r\n   */\r\n  private handleSubscription(sessionId: string, message: WebSocketMessage): void {\r\n    const connection = this.connections.get(sessionId);\r\n    if (!connection) {return;}\r\n\r\n    const channel = message.channel;\r\n    if (!channel || !this.isValidChannel(channel)) {\r\n      this.sendError(sessionId, `Invalid channel: ${channel}`);\r\n      return;\r\n    }\r\n\r\n    // Add to connection's subscribed channels\r\n    connection.subscribedChannels.add(channel);\r\n\r\n    // Add to global channel mapping\r\n    if (!this.channels.has(channel)) {\r\n      this.channels.set(channel, new Set());\r\n    }\r\n    this.channels.get(channel)!.add(sessionId);\r\n\r\n    // Send confirmation\r\n    this.sendToConnection(sessionId, {\r\n      type: 'subscribed',\r\n      channel,\r\n      data: {\r\n        status: 'subscribed',\r\n        channel,\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n\r\n    console.log(`📺 ${connection.email} subscribed to ${channel}`);\r\n  }\r\n\r\n  /**\r\n   * Handle channel unsubscription\r\n   */\r\n  private handleUnsubscription(sessionId: string, message: WebSocketMessage): void {\r\n    const connection = this.connections.get(sessionId);\r\n    if (!connection) {return;}\r\n\r\n    const channel = message.channel;\r\n    if (!channel) {return;}\r\n\r\n    // Remove from connection's subscribed channels\r\n    connection.subscribedChannels.delete(channel);\r\n\r\n    // Remove from global channel mapping\r\n    const channelSessions = this.channels.get(channel);\r\n    if (channelSessions) {\r\n      channelSessions.delete(sessionId);\r\n      if (channelSessions.size === 0) {\r\n        this.channels.delete(channel);\r\n      }\r\n    }\r\n\r\n    // Send confirmation\r\n    this.sendToConnection(sessionId, {\r\n      type: 'unsubscribed',\r\n      channel,\r\n      data: {\r\n        status: 'unsubscribed',\r\n        channel,\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n\r\n    console.log(`📺 ${connection.email} unsubscribed from ${channel}`);\r\n  }\r\n\r\n  /**\r\n   * Handle ping message\r\n   */\r\n  private handlePing(sessionId: string): void {\r\n    this.sendToConnection(sessionId, {\r\n      type: 'pong',\r\n      channel: CONSTANTS.WS_CHANNELS.SYSTEM_HEALTH,\r\n      data: {\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle pong response\r\n   */\r\n  private handlePong(sessionId: string): void {\r\n    const connection = this.connections.get(sessionId);\r\n    if (connection) {\r\n      connection.lastHeartbeat = new Date();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle bot command messages\r\n   */\r\n  private handleBotCommand(sessionId: string, message: WebSocketMessage): void {\r\n    // This will be expanded when we implement bot management\r\n    console.log(`🤖 Bot command from ${sessionId}:`, message.data);\r\n    \r\n    // For now, just acknowledge\r\n    this.sendToConnection(sessionId, {\r\n      type: 'bot_command_ack',\r\n      channel: CONSTANTS.WS_CHANNELS.BOT_STATUS,\r\n      data: {\r\n        status: 'received',\r\n        command: message.data,\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle connection disconnection\r\n   */\r\n  private handleDisconnection(sessionId: string): void {\r\n    const connection = this.connections.get(sessionId);\r\n    if (!connection) {return;}\r\n\r\n    // Remove from all channels\r\n    for (const channel of connection.subscribedChannels) {\r\n      const channelSessions = this.channels.get(channel);\r\n      if (channelSessions) {\r\n        channelSessions.delete(sessionId);\r\n        if (channelSessions.size === 0) {\r\n          this.channels.delete(channel);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove connection\r\n    this.connections.delete(sessionId);\r\n\r\n    console.log(`❌ WebSocket disconnected: ${connection.email} (${sessionId})`);\r\n    \r\n    // Log disconnection to database\r\n    this.logConnectionEvent(connection.userId, 'disconnected', sessionId);\r\n  }\r\n\r\n  /**\r\n   * Handle connection error\r\n   */\r\n  private handleConnectionError(sessionId: string, error: Error): void {\r\n    console.error(`❌ WebSocket connection error for ${sessionId}:`, error);\r\n    \r\n    const connection = this.connections.get(sessionId);\r\n    if (connection) {\r\n      this.logConnectionEvent(connection.userId, 'error', sessionId, error.message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle server error\r\n   */\r\n  private handleServerError(error: Error): void {\r\n    console.error('❌ WebSocket server error:', error);\r\n  }\r\n\r\n  /**\r\n   * Send message to specific connection\r\n   */\r\n  private sendToConnection(sessionId: string, message: WebSocketResponse): void {\r\n    const connection = this.connections.get(sessionId);\r\n    if (!connection || connection.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      connection.ws.send(JSON.stringify(message));\r\n    } catch (error) {\r\n      console.error(`❌ Failed to send message to ${sessionId}:`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send error message to connection\r\n   */\r\n  private sendError(sessionId: string, error: string): void {\r\n    this.sendToConnection(sessionId, {\r\n      type: 'error',\r\n      channel: CONSTANTS.WS_CHANNELS.SYSTEM_HEALTH,\r\n      data: {\r\n        error,\r\n        timestamp: new Date().toISOString()\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Broadcast message to all subscribers of a channel\r\n   */\r\n  public broadcast(channel: string, message: Omit<WebSocketResponse, 'channel'>): void {\r\n    const sessionIds = this.channels.get(channel);\r\n    if (!sessionIds || sessionIds.size === 0) {return;}\r\n\r\n    const fullMessage: WebSocketResponse = {\r\n      ...message,\r\n      channel\r\n    };\r\n\r\n    for (const sessionId of sessionIds) {\r\n      this.sendToConnection(sessionId, fullMessage);\r\n    }\r\n\r\n    console.log(`📡 Broadcasted to ${sessionIds.size} subscribers on ${channel}`);\r\n  }\r\n\r\n  /**\r\n   * Send message to specific user (all their connections)\r\n   */\r\n  public sendToUser(userId: string, message: WebSocketResponse): void {\r\n    const userConnections = Array.from(this.connections.values())\r\n      .filter(conn => conn.userId === userId);\r\n\r\n    for (const connection of userConnections) {\r\n      this.sendToConnection(connection.sessionId, message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start heartbeat monitoring\r\n   */\r\n  private startHeartbeat(): void {\r\n    this.heartbeatInterval = setInterval(() => {\r\n      for (const connection of this.connections.values()) {\r\n        if (connection.ws.readyState === WebSocket.OPEN) {\r\n          connection.ws.ping();\r\n        }\r\n      }\r\n    }, this.HEARTBEAT_INTERVAL);\r\n\r\n    console.log('💓 WebSocket heartbeat started');\r\n  }\r\n\r\n  /**\r\n   * Start connection cleanup\r\n   */\r\n  private startCleanup(): void {\r\n    this.cleanupInterval = setInterval(() => {\r\n      const now = new Date();\r\n      const expiredConnections: string[] = [];\r\n\r\n      for (const connection of this.connections.values()) {\r\n        const timeSinceHeartbeat = now.getTime() - connection.lastHeartbeat.getTime();\r\n        \r\n        if (timeSinceHeartbeat > this.CONNECTION_TIMEOUT) {\r\n          expiredConnections.push(connection.sessionId);\r\n        }\r\n      }\r\n\r\n      // Clean up expired connections\r\n      for (const sessionId of expiredConnections) {\r\n        const connection = this.connections.get(sessionId);\r\n        if (connection) {\r\n          console.log(`🧹 Cleaning up expired connection: ${connection.email} (${sessionId})`);\r\n          connection.ws.terminate();\r\n          this.handleDisconnection(sessionId);\r\n        }\r\n      }\r\n\r\n    }, this.HEARTBEAT_INTERVAL);\r\n\r\n    console.log('🧹 WebSocket cleanup started');\r\n  }\r\n\r\n  /**\r\n   * Generate unique session ID\r\n   */\r\n  private generateSessionId(): string {\r\n    return `ws_${Date.now()}_${Math.random().toString(36).substring(2)}`;\r\n  }\r\n\r\n  /**\r\n   * Log connection event to database\r\n   */\r\n  private async logConnectionEvent(\r\n    userId: string, \r\n    event: string, \r\n    sessionId: string, \r\n    details?: string\r\n  ): Promise<void> {\r\n    try {\r\n      await database.query(`\r\n        INSERT INTO logs (level, message, category, user_id, metadata)\r\n        VALUES ($1, $2, $3, $4, $5)\r\n      `, [\r\n        'info',\r\n        `WebSocket ${event}`,\r\n        'websocket',\r\n        userId,\r\n        JSON.stringify({\r\n          event,\r\n          sessionId,\r\n          details,\r\n          timestamp: new Date().toISOString()\r\n        })\r\n      ]);\r\n    } catch (error) {\r\n      console.error('❌ Failed to log connection event:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get server statistics\r\n   */\r\n  public getStats(): {\r\n    connections: number;\r\n    channels: number;\r\n    connectionsByChannel: Record<string, number>;\r\n    connectionsByUser: Record<string, number>;\r\n  } {\r\n    const connectionsByChannel: Record<string, number> = {};\r\n    const connectionsByUser: Record<string, number> = {};\r\n\r\n    // Count connections by channel\r\n    for (const [channel, sessions] of this.channels) {\r\n      if (typeof channel === 'string') {\r\n        connectionsByChannel[channel] = sessions.size;\r\n      }\r\n    }\r\n\r\n    // Count connections by user\r\n    for (const connection of this.connections.values()) {\r\n      connectionsByUser[connection.userId] = (connectionsByUser[connection.userId] || 0) + 1;\r\n    }\r\n\r\n    return {\r\n      connections: this.connections.size,\r\n      channels: this.channels.size,\r\n      connectionsByChannel,\r\n      connectionsByUser\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Graceful shutdown\r\n   */\r\n  public async shutdown(): Promise<void> {\r\n    console.log('🔌 Shutting down WebSocket server...');\r\n\r\n    // Clear intervals\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n    }\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n\r\n    // Close all connections\r\n    for (const connection of this.connections.values()) {\r\n      connection.ws.close(1001, 'Server shutting down');\r\n    }\r\n\r\n    // Close server\r\n    this.wss.close();\r\n\r\n    console.log('✅ WebSocket server shutdown complete');\r\n  }\r\n\r\n  /**\r\n   * Check if channel is valid\r\n   */\r\n  private isValidChannel(channel: string): boolean {\r\n    return Object.values(CONSTANTS.WS_CHANNELS).includes(channel as any);\r\n  }\r\n}\r\n\r\n// Export for use in main server\r\nexport default JabbrWebSocketServer; ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\src\\websocket\\websocket.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\e2e\\trading\\engine\\standalone-engine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\e2e\\trading\\trading-engine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\fixtures\\candles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\integration\\database-monitoring.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\integration\\exchange-monitoring.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\integration\\metrics-collection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\integration\\performance-monitoring.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\integration\\strategies\\strategy-factory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\integration\\strategy-execution-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\integration\\trading\\test-trading-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\run-sma-test.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected keyword or identifier.","line":1,"column":0,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"impoimport type { SMASignalOutput } from '../../src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalProcessor } from '../src/JabbrLabs/signals/sma/sma-signal-processor'; * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport type { SMASignalConfig} from './src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalOutput } from './src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalProcessor } from './src/JabbrLabs/signals/sma/sma-signal-processor';\r\nimport type { Candle } from './src/JabbrLabs/target-reacher/interfaces';\r\n\r\n// Configuration\r\nconst config: SMASignalConfig = {\r\n  fastPeriod: 9,\r\n  slowPeriod: 21,\r\n  minChangePercent: 0.5,\r\n  confidenceThreshold: 0.6,\r\n  priceSource: 'close',\r\n  signalMode: 'crossover',\r\n  useEMA: false\r\n};\r\n\r\n// Generate synthetic price data for testing\r\nfunction generateSyntheticCandles(options: {\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}): Candle[] {\r\n  const candles: Candle[] = [];\r\n  let currentPrice = options.startPrice;\r\n  let trend = 1; // 1 = up, -1 = down\r\n\r\n  for (let i = 0; i < options.dataPoints; i++) {\r\n    // Potentially change trend\r\n    if (Math.random() < options.trendChangeProbability) {\r\n      trend *= -1;\r\n    }\r\n    \r\n    // Calculate price movement\r\n    const trendMovement = trend * options.trendStrength * currentPrice;\r\n    const randomMovement = (Math.random() * 2 - 1) * options.volatility * currentPrice;\r\n    const movement = trendMovement + randomMovement;\r\n    \r\n    // Calculate candle prices\r\n    const open = currentPrice;\r\n    const close = currentPrice + movement;\r\n    const high = Math.max(open, close) + Math.random() * options.volatility * currentPrice;\r\n    const low = Math.min(open, close) - Math.random() * options.volatility * currentPrice;\r\n    const volume = Math.random() * 100000 + 10000;\r\n    \r\n    // Create candle\r\n    candles.push({\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n    \r\n    // Update current price for next iteration\r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n}\r\n\r\n// Function to run backtest\r\nasync function runTest() {\r\n  console.log('Starting SMA Crossover Strategy Test');\r\n  console.log(`Settings: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 100,\r\n    volatility: 0.01,\r\n    trendStrength: 0.008,\r\n    trendChangeProbability: 0.1\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-test-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Report saved to sma-test-report.json');\r\n}\r\n\r\nrunTest().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-engine-standalone.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-futures-beast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-futures-position-modify.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-live-order.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-mainnet-safe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-mainnet-small.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-market-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-backtest.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":354,"column":5,"nodeType":"CallExpression","endLine":368,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SMA Strategy Backtesting Script\r\n * \r\n * This script runs a backtesting simulation for the SMA crossover strategy\r\n * using historical price data. It provides insights into how the strategy\r\n * would have performed over a historical time period.\r\n */\r\n\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\nimport { SMACrossoverStrategy } from './src/JabbrLabs/signals/sma/sma-crossover-strategy';\r\nimport type { Candle, StrategyContext } from './src/JabbrLabs/target-reacher/interfaces';\r\n\r\n// Sample historical data (Normally, this would be loaded from a file or database)\r\n// For a real implementation, add a CSV loader or API client to fetch historical data\r\nconst loadHistoricalData = (symbol: string, startDate: Date, endDate: Date): Candle[] => {\r\n  // This is a placeholder - in a real implementation, load data from file or API\r\n  console.log(`Loading historical data for ${symbol} from ${startDate.toISOString()} to ${endDate.toISOString()}`);\r\n  \r\n  // Generate synthetic data for demonstration purposes\r\n  const candles: Candle[] = [];\r\n  let price = 100; // Starting price\r\n  const hoursInRange = Math.floor((endDate.getTime() - startDate.getTime()) / (60 * 60 * 1000));\r\n  \r\n  // Create a more realistic price pattern with clearer trends\r\n  // Using a sine wave with noise for more predictable crossovers\r\n  for (let i = 0; i < hoursInRange; i++) {\r\n    // Create a sine wave pattern with 240 hour cycle (10 days)\r\n    const cycle1 = Math.sin(i / 40) * 15;  // Primary trend\r\n    const cycle2 = Math.sin(i / 20) * 5;   // Secondary trend\r\n    const noise = (Math.random() - 0.5) * 3; // Random noise\r\n    \r\n    // Calculate price based on cycles and noise\r\n    price = 100 + cycle1 + cycle2 + noise;\r\n    \r\n    // Add some volatility\r\n    const timestamp = new Date(startDate.getTime() + i * 60 * 60 * 1000).getTime();\r\n    const open = price * (1 + (Math.random() - 0.5) / 100);\r\n    const close = price;\r\n    const high = Math.max(open, close) * (1 + Math.random() / 100);\r\n    const low = Math.min(open, close) * (1 - Math.random() / 100);\r\n    const volume = 1000 + Math.random() * 9000;\r\n    \r\n    candles.push({\r\n      timestamp,\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n  }\r\n  \r\n  return candles;\r\n};\r\n\r\n// Create a mock context for backtesting\r\nconst createBacktestContext = (candles: Candle[]): StrategyContext => {\r\n  const context: StrategyContext = {\r\n    config: {\r\n      type: 'sma-crossover',\r\n      parameters: {\r\n        fastPeriod: 5,  // Reduced from 9 to generate more signals\r\n        slowPeriod: 15, // Reduced from 21 to generate more signals\r\n        priceSource: 'close',\r\n        signalMode: 'combined', // Use both crossover and trend signals\r\n        useEMA: true,\r\n        confidenceThreshold: 0.4 // Lower threshold to generate more signals\r\n      },\r\n      execution: {\r\n        timeframe: '1h',\r\n        minimumConfidence: 0.4 // Reduced to match more signals\r\n      }\r\n    },\r\n    botConfig: {\r\n      id: 'backtest-bot',\r\n      name: 'Backtest Bot',\r\n      symbol: 'BTC/USDT',\r\n      tradeType: 'spot',\r\n      amount: 0.1 // 0.1 BTC per trade\r\n    },\r\n    symbol: 'BTC/USDT',\r\n    marketData: {\r\n      getCurrentPrice: async () => {\r\n        const lastCandle = candles[candles.length - 1];\r\n        return lastCandle ? lastCandle.close : 0;\r\n      },\r\n      getOrderBook: async () => ({\r\n        bids: [[0, 0]],\r\n        asks: [[0, 0]],\r\n        timestamp: Date.now()\r\n      }),\r\n      getCandles: async () => [...candles], // Return a copy\r\n      getTicker: async () => ({\r\n        symbol: 'BTC/USDT',\r\n        last: candles[candles.length - 1]?.close || 0,\r\n        bid: 0,\r\n        ask: 0,\r\n        volume: 0,\r\n        timestamp: Date.now()\r\n      })\r\n    },\r\n    tradeExecutor: {\r\n      executeSignal: async (signal) => {\r\n        console.log(`[${new Date(signal.timestamp).toISOString()}] EXECUTE ${signal.side.toUpperCase()} at $${signal.price.toFixed(2)}`);\r\n        return {\r\n          id: `order-${Date.now()}`,\r\n          orderId: `backtest-${Date.now()}`,\r\n          botId: signal.botId,\r\n          symbol: signal.symbol,\r\n          type: 'market',\r\n          side: signal.side,\r\n          amount: 0.1,\r\n          price: signal.price,\r\n          status: 'filled',\r\n          filled: 0.1,\r\n          remaining: 0,\r\n          timestamp: signal.timestamp,\r\n          updatedAt: signal.timestamp\r\n        };\r\n      },\r\n      getPosition: async () => null, // For simplicity, we don't track positions in this demo\r\n      closePosition: async () => {\r\n        console.log(`[${new Date().toISOString()}] CLOSE position`);\r\n      }\r\n    },\r\n    logger: {\r\n      info: (message, data) => console.log(`[INFO] ${message}`, data || ''),\r\n      warn: (message, data) => console.warn(`[WARN] ${message}`, data || ''),\r\n      error: (message, data) => console.error(`[ERROR] ${message}`, data || ''),\r\n      debug: (message, data) => console.debug(`[DEBUG] ${message}`, data || '')\r\n    },\r\n    storage: {\r\n      storeStrategyEvent: async () => {},\r\n      getStrategyState: async () => null,\r\n      saveStrategyState: async () => {}\r\n    },\r\n    eventEmitter: {\r\n      emit: () => {},\r\n      on: () => {},\r\n      off: () => {}\r\n    }\r\n  };\r\n  \r\n  return context;\r\n};\r\n\r\n// Main backtesting function\r\nconst runBacktest = async (\r\n  strategy: SMACrossoverStrategy,\r\n  symbol: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  windowSize = 100\r\n): Promise<{ trades: number; profitLoss: number; }> => {\r\n  // Load historical data\r\n  const allCandles = loadHistoricalData(symbol, startDate, endDate);\r\n  \r\n  // Get current config for display\r\n  const testContext = createBacktestContext([]);\r\n  const currentConfig = testContext.config;\r\n  const fastPeriod = currentConfig.parameters.fastPeriod as number;\r\n  const slowPeriod = currentConfig.parameters.slowPeriod as number;\r\n  const signalMode = currentConfig.parameters.signalMode as string;\r\n  \r\n  console.log(`\\n----- BACKTESTING SMA CROSSOVER STRATEGY -----`);\r\n  console.log(`Symbol: ${symbol}`);\r\n  console.log(`Period: ${startDate.toDateString()} to ${endDate.toDateString()}`);\r\n  console.log(`Candles: ${allCandles.length}`);\r\n  console.log(`Fast Period: ${fastPeriod}`);\r\n  console.log(`Slow Period: ${slowPeriod}`);\r\n  console.log(`Signal Mode: ${signalMode}`);\r\n  console.log(`Minimum Confidence: ${currentConfig.execution?.minimumConfidence}`);\r\n  console.log(`-----------------------------------------------\\n`);\r\n  \r\n  // Stats\r\n  let trades = 0;\r\n  let profitLoss = 0;\r\n  let position: 'long' | 'short' | null = null;\r\n  let entryPrice = 0;\r\n  const positionSize = 0.1; // Default position size\r\n  let capital = 10000; // Starting capital (USDT)\r\n  let equity = capital;\r\n  \r\n  // For tracking execution history\r\n  const executionHistory: Array<{\r\n    timestamp: number;\r\n    action: string;\r\n    price: number;\r\n    reason: string;\r\n    equity: number;\r\n  }> = [];\r\n  \r\n  // Initialize strategy\r\n  const context = createBacktestContext([]);\r\n  await strategy.initialize(context);\r\n  \r\n  // Process historical data with a sliding window\r\n  for (let i = windowSize; i < allCandles.length; i++) {\r\n    // Get window of candles\r\n    const windowCandles = allCandles.slice(i - windowSize, i);\r\n    \r\n    // Update context with current window\r\n    context.marketData.getCandles = async () => [...windowCandles];\r\n    \r\n    // Get the last candle, with safety check\r\n    const lastCandle = windowCandles[windowCandles.length - 1];\r\n    if (!lastCandle) {\r\n      console.error('Missing last candle in window');\r\n      continue;\r\n    }\r\n    \r\n    // Current price (close of the last candle)\r\n    const currentPrice = lastCandle.close;\r\n    const currentTimestamp = lastCandle.timestamp;\r\n    \r\n    // Update PnL if we have a position\r\n    if (position === 'long') {\r\n      const unrealizedPnl = (currentPrice - entryPrice) * positionSize;\r\n      equity = capital + unrealizedPnl;\r\n    } else if (position === 'short') {\r\n      const unrealizedPnl = (entryPrice - currentPrice) * positionSize;\r\n      equity = capital + unrealizedPnl;\r\n    }\r\n    \r\n    // Mock position data\r\n    if (position) {\r\n      context.tradeExecutor.getPosition = async () => ({\r\n        symbol,\r\n        side: position as 'long' | 'short', // Type assertion to match Position interface\r\n        size: positionSize,\r\n        entryPrice,\r\n        currentPrice,\r\n        unrealizedPnl: equity - capital,\r\n        timestamp: currentTimestamp\r\n      });\r\n    } else {\r\n      context.tradeExecutor.getPosition = async () => null;\r\n    }\r\n    \r\n    // Execute strategy with debugging\r\n    try {\r\n      // Debug log for candles\r\n      if (i % 100 === 0) {\r\n        console.log(`Processing window at index ${i}, price: ${currentPrice.toFixed(2)}`);\r\n      }\r\n      \r\n      const result = await strategy.execute(context);\r\n      \r\n      // Log all strategy results for debugging\r\n      if (i % 100 === 0 || result.action !== 'hold') {\r\n        console.log(`Strategy result [${new Date(currentTimestamp).toISOString()}]:`, {\r\n          success: result.success,\r\n          action: result.action,\r\n          reason: result.reason,\r\n          confidence: result.confidence\r\n        });\r\n      }\r\n      \r\n      // Process trade\r\n      if (result.success && (result.action === 'buy' || result.action === 'sell')) {\r\n        // If we have a position and signal is in opposite direction, close it\r\n        if (position && \r\n            ((position === 'long' && result.action === 'sell') ||\r\n             (position === 'short' && result.action === 'buy'))) {\r\n          // Calculate P&L\r\n          const closingPnl = position === 'long' \r\n            ? (currentPrice - entryPrice) * positionSize\r\n            : (entryPrice - currentPrice) * positionSize;\r\n          \r\n          profitLoss += closingPnl;\r\n          capital += closingPnl;\r\n          equity = capital;\r\n          \r\n          console.log(`[${new Date(currentTimestamp).toISOString()}] CLOSE ${position} position at $${currentPrice.toFixed(2)}, P&L: ${closingPnl.toFixed(2)}`);\r\n          executionHistory.push({\r\n            timestamp: currentTimestamp,\r\n            action: `CLOSE ${position}`,\r\n            price: currentPrice,\r\n            reason: result.reason || '',\r\n            equity\r\n          });\r\n          \r\n          position = null;\r\n          entryPrice = 0;\r\n        }\r\n        \r\n        // Open new position\r\n        if (!position) {\r\n          position = result.action === 'buy' ? 'long' : 'short';\r\n          entryPrice = currentPrice;\r\n          trades++;\r\n          \r\n          console.log(`[${new Date(currentTimestamp).toISOString()}] OPEN ${position} position at $${currentPrice.toFixed(2)}`);\r\n          executionHistory.push({\r\n            timestamp: currentTimestamp,\r\n            action: `OPEN ${position}`,\r\n            price: currentPrice,\r\n            reason: result.reason || '',\r\n            equity\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error during backtesting:`, error);\r\n    }\r\n  }\r\n  \r\n  // Close any open position at the end of the backtest\r\n  if (position) {\r\n    // Get the last candle with safety check\r\n    const lastCandle = allCandles[allCandles.length - 1];\r\n    if (!lastCandle) {\r\n      console.error('Missing last candle in dataset');\r\n      return { trades, profitLoss };\r\n    }\r\n    \r\n    const lastPrice = lastCandle.close;\r\n    const finalPnl = position === 'long' \r\n      ? (lastPrice - entryPrice) * positionSize\r\n      : (entryPrice - lastPrice) * positionSize;\r\n    \r\n    profitLoss += finalPnl;\r\n    capital += finalPnl;\r\n    equity = capital;\r\n    \r\n    console.log(`[End of backtest] CLOSE ${position} position at $${lastPrice.toFixed(2)}, P&L: ${finalPnl.toFixed(2)}`);\r\n    executionHistory.push({\r\n      timestamp: lastCandle.timestamp,\r\n      action: `CLOSE ${position} (END)`,\r\n      price: lastPrice,\r\n      reason: 'End of backtest',\r\n      equity\r\n    });\r\n  }\r\n  \r\n  // Print backtest results\r\n  console.log('\\n----- BACKTEST RESULTS -----');\r\n  console.log(`Total trades: ${trades}`);\r\n  console.log(`Total P&L: ${profitLoss.toFixed(2)} USDT`);\r\n  console.log(`Final equity: ${equity.toFixed(2)} USDT`);\r\n  console.log(`Return: ${(((equity - 10000) / 10000) * 100).toFixed(2)}%`);\r\n  console.log('---------------------------\\n');\r\n  \r\n  // Save execution history to file\r\n  const outputDir = path.join(__dirname, 'backtest-results');\r\n  try {\r\n    if (!fs.existsSync(outputDir)) {\r\n      fs.mkdirSync(outputDir, { recursive: true });\r\n    }\r\n    \r\n    const filename = path.join(outputDir, `sma-backtest-${new Date().toISOString().replace(/:/g, '-')}.json`);\r\n    fs.writeFileSync(filename, JSON.stringify({\r\n      strategy: 'SMA Crossover',\r\n      symbol,\r\n      startDate: startDate.toISOString(),\r\n      endDate: endDate.toISOString(),\r\n      config: strategy.getDefaultConfig(),\r\n      results: {\r\n        trades,\r\n        profitLoss,\r\n        startingCapital: 10000,\r\n        finalEquity: equity,\r\n        returnPercent: ((equity - 10000) / 10000) * 100\r\n      },\r\n      executionHistory\r\n    }, null, 2));\r\n    \r\n    console.log(`Backtest results saved to ${filename}`);\r\n  } catch (error) {\r\n    console.error('Failed to save backtest results:', error);\r\n  }\r\n  \r\n  return { trades, profitLoss };\r\n};\r\n\r\n// Run the backtest\r\nconst main = async () => {\r\n  const strategy = new SMACrossoverStrategy();\r\n  \r\n  // Three months of hourly data\r\n  const endDate = new Date();\r\n  const startDate = new Date();\r\n  startDate.setMonth(endDate.getMonth() - 3);\r\n  \r\n  await runBacktest(strategy, 'BTC/USDT', startDate, endDate);\r\n};\r\n\r\nmain().catch(error => {\r\n  console.error('Backtest failed:', error);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-sma-signals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\test-strategy-framework.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\JabbrLabs\\signal-processing\\signal-processing-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\JabbrLabs\\signal-processing\\signal-translator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\bot-runtime-enhanced.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\indicators\\atr-indicator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\indicators\\ema-indicator.test.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":12,"column":56,"nodeType":"MemberExpression","endLine":12,"endColumn":67}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EMAIndicator } from '../../../src/JabbrLabs/indicators/ema-indicator';\r\n\r\ndescribe('EMAIndicator', () => {\r\n  it('calculates EMA correctly for known data', () => {\r\n    const ema = new EMAIndicator({ period: 3, smoothing: 2 });\r\n    const data = [2, 4, 6, 8, 10];\r\n    // For period=3, smoothing=2, multiplier=0.5\r\n    // EMA[0]=2, EMA[1]=3, EMA[2]=4.5, EMA[3]=6.25, EMA[4]=8.125\r\n    const expected = [2, 3, 4.5, 6.25, 8.125];\r\n    const result = ema.calculate(data);\r\n    expect(result.length).toBe(expected.length);\r\n    result.forEach((val, i) => expect(val).toBeCloseTo(expected[i], 5));\r\n  });\r\n\r\n  it('throws if not enough data', () => {\r\n    const ema = new EMAIndicator({ period: 5 });\r\n    expect(() => ema.calculate([1, 2])).toThrow(/Insufficient data/);\r\n  });\r\n\r\n  it('validates parameters', () => {\r\n    const ema = new EMAIndicator();\r\n    expect(() => ema.setPeriod(0)).toThrow(/at least 1/);\r\n    expect(() => ema.setSmoothing(0)).toThrow(/positive/);\r\n    expect(() => new EMAIndicator({ period: -2 })).toThrow();\r\n  });\r\n\r\n  it('clones itself with same parameters', () => {\r\n    const ema = new EMAIndicator({ period: 4, smoothing: 2 });\r\n    const clone = ema.clone();\r\n    expect(clone.getParameters()).toEqual(ema.getParameters());\r\n    expect(clone.calculate([1,2,3,4,5,6,7,8,9])).toEqual(ema.calculate([1,2,3,4,5,6,7,8,9]));\r\n  });\r\n\r\n  it('handles empty input gracefully', () => {\r\n    const ema = new EMAIndicator({ period: 2 });\r\n    expect(() => ema.calculate([])).toThrow(/Insufficient data/);\r\n  });\r\n}); ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\indicators\\rsi-indicator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\indicators\\sma-indicator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\signals\\sma\\improved-sma-signal-processor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\signals\\sma\\sma-crossover-strategy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\signals\\sma\\sma-signal-processor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\unit\\websocket\\bybit-websocket.client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\utils\\test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\backend\\tests\\verify-order.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\jest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\postcss.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\production-readiness-test.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":69,"column":23,"nodeType":"CallExpression","endLine":69,"endColumn":42},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":73,"column":22,"nodeType":"CallExpression","endLine":73,"endColumn":43},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":109,"column":23,"nodeType":"CallExpression","endLine":109,"endColumn":42},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":113,"column":22,"nodeType":"CallExpression","endLine":113,"endColumn":43},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":160,"column":23,"nodeType":"CallExpression","endLine":160,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":231,"column":33,"nodeType":"CallExpression","endLine":231,"endColumn":105},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":235,"column":27,"nodeType":"CallExpression","endLine":235,"endColumn":93},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":239,"column":29,"nodeType":"CallExpression","endLine":239,"endColumn":85},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":240,"column":28,"nodeType":"CallExpression","endLine":240,"endColumn":78},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":244,"column":30,"nodeType":"CallExpression","endLine":244,"endColumn":90},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":245,"column":30,"nodeType":"CallExpression","endLine":245,"endColumn":91},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":246,"column":30,"nodeType":"CallExpression","endLine":246,"endColumn":90},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":250,"column":28,"nodeType":"CallExpression","endLine":250,"endColumn":87},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":268,"column":22,"nodeType":"CallExpression","endLine":268,"endColumn":44},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":291,"column":7,"nodeType":"CallExpression","endLine":291,"endColumn":50},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":304,"column":11,"nodeType":"CallExpression","endLine":304,"endColumn":34},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlinkSync from package \"fs\" with non literal argument at index 0","line":305,"column":9,"nodeType":"CallExpression","endLine":305,"endColumn":32},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":322,"column":40,"nodeType":"CallExpression","endLine":322,"endColumn":67},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":326,"column":9,"nodeType":"CallExpression","endLine":326,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":329,"column":34,"nodeType":"CallExpression","endLine":329,"endColumn":74},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":343,"column":9,"nodeType":"CallExpression","endLine":343,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":344,"column":38,"nodeType":"CallExpression","endLine":344,"endColumn":78}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Comprehensive Frontend Production Readiness Test\r\n * Tests ALL components, ensures TypeScript compliance, and validates production standards\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { execSync } from 'child_process';\r\n\r\ninterface ComponentTestResult {\r\n  component: string;\r\n  compiles: boolean;\r\n  errors: string[];\r\n  warnings: string[];\r\n  productionIssues: string[];\r\n}\r\n\r\ninterface ProjectAnalysis {\r\n  totalComponents: number;\r\n  passingComponents: number;\r\n  failingComponents: number;\r\n  javascriptFiles: string[];\r\n  productionViolations: string[];\r\n  typeScriptCompliance: boolean;\r\n}\r\n\r\nclass FrontendProductionReadinessValidator {\r\n  private readonly frontendDir: string;\r\n  private readonly srcDir: string;\r\n  private results: ComponentTestResult[] = [];\r\n\r\n  constructor() {\r\n    this.frontendDir = __dirname;\r\n    this.srcDir = path.join(this.frontendDir, 'src');\r\n  }\r\n\r\n  public async runFullValidation(): Promise<void> {\r\n    console.log('🚀 Frontend Production Readiness Validation\\n');\r\n    console.log('====================================\\n');\r\n\r\n    // Step 1: Scan for JavaScript files (should be ZERO)\r\n    await this.scanForJavaScriptFiles();\r\n\r\n    // Step 2: Validate ALL TypeScript/TSX components\r\n    await this.validateAllComponents();\r\n\r\n    // Step 3: Check production-ready patterns\r\n    await this.validateProductionPatterns();\r\n\r\n    // Step 4: Test Material-UI integration\r\n    await this.validateMaterialUIIntegration();\r\n\r\n    // Step 5: Validate root configuration compliance\r\n    await this.validateRootConfigCompliance();\r\n\r\n    // Step 6: Generate final report\r\n    await this.generateProductionReport();\r\n  }\r\n\r\n  /**\r\n   * Scan for any JavaScript files that should be TypeScript\r\n   */\r\n  private async scanForJavaScriptFiles(): Promise<void> {\r\n    console.log('🔍 Scanning for JavaScript files (should be ZERO)...\\n');\r\n\r\n    const javascriptFiles: string[] = [];\r\n\r\n    const scanDirectory = (dir: string): void => {\r\n      const entries = fs.readdirSync(dir);\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry);\r\n        const stat = fs.statSync(fullPath);\r\n        \r\n        if (stat.isDirectory() && !entry.startsWith('.') && entry !== 'node_modules') {\r\n          scanDirectory(fullPath);\r\n        } else if (stat.isFile() && (entry.endsWith('.js') || entry.endsWith('.jsx'))) {\r\n          // Check if it's a legitimate build file or should be TypeScript\r\n          if (!fullPath.includes('node_modules') && \r\n              !fullPath.includes('.next') && \r\n              !fullPath.includes('dist') &&\r\n              !fullPath.includes('build')) {\r\n            javascriptFiles.push(fullPath.replace(this.frontendDir + path.sep, ''));\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    scanDirectory(this.frontendDir);\r\n\r\n    if (javascriptFiles.length === 0) {\r\n      console.log('✅ No JavaScript files found - Pure TypeScript project confirmed\\n');\r\n    } else {\r\n      console.log('❌ JavaScript files found that should be TypeScript:');\r\n      javascriptFiles.forEach((file: string) => console.log(`  ${file}`));\r\n      console.log('\\n');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate ALL TypeScript/TSX components\r\n   */\r\n  private async validateAllComponents(): Promise<void> {\r\n    console.log('📋 Validating ALL TypeScript/TSX components...\\n');\r\n\r\n    const componentFiles: string[] = [];\r\n\r\n    const findComponents = (dir: string): void => {\r\n      const entries = fs.readdirSync(dir);\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dir, entry);\r\n        const stat = fs.statSync(fullPath);\r\n        \r\n        if (stat.isDirectory() && !entry.startsWith('.')) {\r\n          findComponents(fullPath);\r\n        } else if (stat.isFile() && (entry.endsWith('.ts') || entry.endsWith('.tsx'))) {\r\n          componentFiles.push(fullPath);\r\n        }\r\n      }\r\n    };\r\n\r\n    findComponents(this.srcDir);\r\n\r\n    console.log(`Found ${componentFiles.length} TypeScript files to validate\\n`);\r\n\r\n    for (const componentFile of componentFiles) {\r\n      await this.validateSingleComponent(componentFile);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate a single component\r\n   */\r\n  private async validateSingleComponent(filePath: string): Promise<void> {\r\n    const relativePath = path.relative(this.frontendDir, filePath);\r\n    const result: ComponentTestResult = {\r\n      component: relativePath,\r\n      compiles: false,\r\n      errors: [],\r\n      warnings: [],\r\n      productionIssues: []\r\n    };\r\n\r\n    console.log(`Testing: ${relativePath}`);\r\n\r\n    try {\r\n      // TypeScript compilation test\r\n      const command = `npx tsc --noEmit --skipLibCheck --jsx react-jsx \"${filePath}\"`;\r\n      execSync(command, { \r\n        stdio: 'pipe', \r\n        encoding: 'utf8',\r\n        cwd: this.frontendDir \r\n      });\r\n      \r\n      result.compiles = true;\r\n      console.log(`✅ ${relativePath}: Compiles successfully`);\r\n\r\n      // Content analysis for production readiness\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      this.analyzeContentForProductionIssues(content, result);\r\n\r\n    } catch (error: any) {\r\n      result.compiles = false;\r\n      const errorOutput = error.stdout || error.stderr || '';\r\n      \r\n      // Parse TypeScript errors\r\n      const lines = errorOutput.split('\\n');\r\n      const tsErrors = lines.filter((line: string) => line.includes('error TS'));\r\n      \r\n      result.errors = tsErrors.slice(0, 5); // Limit to first 5 errors\r\n      \r\n      console.log(`❌ ${relativePath}: Compilation errors`);\r\n      if (tsErrors.length > 0) {\r\n        console.log(`  ${tsErrors[0]}`);\r\n        if (tsErrors.length > 1) {\r\n          console.log(`  ... and ${tsErrors.length - 1} more errors`);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.results.push(result);\r\n  }\r\n\r\n  /**\r\n   * Analyze content for production readiness issues\r\n   */\r\n  private analyzeContentForProductionIssues(content: string, result: ComponentTestResult): void {\r\n    const lines = content.split('\\n');\r\n\r\n    lines.forEach((line, index) => {\r\n      const lineNumber = index + 1;\r\n      const trimmedLine = line.trim();\r\n\r\n      // Check for console statements (should use proper logging)\r\n      if (trimmedLine.includes('console.log') || \r\n          trimmedLine.includes('console.error') || \r\n          trimmedLine.includes('console.warn')) {\r\n        result.productionIssues.push(`Line ${lineNumber}: Console statement found - should use proper logging`);\r\n      }\r\n\r\n      // Check for TODO/FIXME comments\r\n      if (trimmedLine.includes('TODO') || trimmedLine.includes('FIXME')) {\r\n        result.productionIssues.push(`Line ${lineNumber}: TODO/FIXME comment found`);\r\n      }\r\n\r\n      // Check for hardcoded values that should be environment variables\r\n      if (trimmedLine.includes('localhost') && !trimmedLine.includes('process.env')) {\r\n        result.productionIssues.push(`Line ${lineNumber}: Hardcoded localhost - should use environment variable`);\r\n      }\r\n\r\n      // Check for debug code\r\n      if (trimmedLine.includes('debugger;')) {\r\n        result.productionIssues.push(`Line ${lineNumber}: Debugger statement found`);\r\n      }\r\n\r\n      // Check for any/unknown types (TypeScript best practices)\r\n      if (trimmedLine.includes(': any') && !trimmedLine.includes('// eslint-disable')) {\r\n        result.warnings.push(`Line ${lineNumber}: 'any' type used - consider more specific typing`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate production patterns across the codebase\r\n   */\r\n  private async validateProductionPatterns(): Promise<void> {\r\n    console.log('\\n🏭 Validating production patterns...\\n');\r\n\r\n    // Check if error boundaries exist\r\n    const errorBoundaryExists = fs.existsSync(path.join(this.srcDir, 'components', 'ErrorBoundary.tsx'));\r\n    console.log(`Error Boundary: ${errorBoundaryExists ? '✅' : '❌'}`);\r\n\r\n    // Check if loading components exist\r\n    const loadingExists = fs.existsSync(path.join(this.srcDir, 'components', 'Loading.tsx'));\r\n    console.log(`Loading Component: ${loadingExists ? '✅' : '❌'}`);\r\n\r\n    // Check if environment configuration is proper\r\n    const envConfigExists = fs.existsSync(path.join(this.frontendDir, '.env.local')) ||\r\n                           fs.existsSync(path.join(this.frontendDir, '.env'));\r\n    console.log(`Environment Config: ${envConfigExists ? '✅' : '❌'}`);\r\n\r\n    // Check Next.js configuration\r\n    const nextConfigExists = fs.existsSync(path.join(this.frontendDir, 'next.config.js')) ||\r\n                             fs.existsSync(path.join(this.frontendDir, 'next.config.mjs')) ||\r\n                             fs.existsSync(path.join(this.frontendDir, 'next.config.ts'));\r\n    console.log(`Next.js Config: ${nextConfigExists ? '✅' : '❌'}`);\r\n\r\n    // Check TypeScript configuration\r\n    const tsConfigExists = fs.existsSync(path.join(this.frontendDir, 'tsconfig.json'));\r\n    console.log(`TypeScript Config: ${tsConfigExists ? '✅' : '❌'}`);\r\n\r\n    console.log('');\r\n  }\r\n\r\n  /**\r\n   * Validate Material-UI integration\r\n   */\r\n  private async validateMaterialUIIntegration(): Promise<void> {\r\n    console.log('🎨 Validating Material-UI integration...\\n');\r\n\r\n    // Check if Material-UI is properly installed\r\n    const nodeModulesPath = path.join(this.frontendDir, 'node_modules');\r\n    const muiPackages = ['@mui/material', '@mui/icons-material', '@emotion/react', '@emotion/styled'];\r\n\r\n    muiPackages.forEach((pkg: string) => {\r\n      const pkgPath = path.join(nodeModulesPath, pkg.replace('/', path.sep));\r\n      const exists = fs.existsSync(pkgPath);\r\n      console.log(`${pkg}: ${exists ? '✅' : '❌'}`);\r\n    });\r\n\r\n    // Test Material-UI Grid v5 syntax compatibility\r\n    const testGridContent = `import React from 'react';\r\nimport { Grid, Card, Typography } from '@mui/material';\r\n\r\nconst GridTest: React.FC = () => (\r\n  <Grid container spacing={2}>\r\n    <Grid item xs={12} md={6}>\r\n      <Card>\r\n        <Typography>Test Grid v5 syntax</Typography>\r\n      </Card>\r\n    </Grid>\r\n  </Grid>\r\n);\r\n\r\nexport default GridTest;`;\r\n\r\n    const testPath = path.join(this.frontendDir, 'mui-grid-test.tsx');\r\n    \r\n    try {\r\n      fs.writeFileSync(testPath, testGridContent);\r\n      \r\n      const command = `npx tsc --noEmit --skipLibCheck --jsx react-jsx mui-grid-test.tsx`;\r\n      execSync(command, { \r\n        stdio: 'pipe', \r\n        encoding: 'utf8',\r\n        cwd: this.frontendDir \r\n      });\r\n      \r\n      console.log('Material-UI Grid Syntax: ✅');\r\n    } catch (error) {\r\n      console.log('Material-UI Grid Syntax: ❌');\r\n    } finally {\r\n      if (fs.existsSync(testPath)) {\r\n        fs.unlinkSync(testPath);\r\n      }\r\n    }\r\n\r\n    console.log('');\r\n  }\r\n\r\n  /**\r\n   * Validate compliance with root-level configurations\r\n   */\r\n  private async validateRootConfigCompliance(): Promise<void> {\r\n    console.log('📁 Validating root configuration compliance...\\n');\r\n\r\n    const rootDir = path.join(this.frontendDir, '..', '..');\r\n\r\n    // Check root TypeScript config\r\n    const rootTsConfig = path.join(rootDir, 'tsconfig.json');\r\n    console.log(`Root tsconfig.json: ${fs.existsSync(rootTsConfig) ? '✅' : '❌'}`);\r\n\r\n    // Check root package.json\r\n    const rootPackageJson = path.join(rootDir, 'package.json');\r\n    if (fs.existsSync(rootPackageJson)) {\r\n      console.log('Root package.json: ✅');\r\n      \r\n      const rootPkg = JSON.parse(fs.readFileSync(rootPackageJson, 'utf8'));\r\n      \r\n      // Check if it's properly configured as TypeScript project\r\n      if (rootPkg.devDependencies?.typescript) {\r\n        console.log('Root TypeScript dependency: ✅');\r\n      } else {\r\n        console.log('Root TypeScript dependency: ❌');\r\n      }\r\n    } else {\r\n      console.log('Root package.json: ❌');\r\n    }\r\n\r\n    // Check workspace configuration\r\n    const frontendPkgJson = path.join(this.frontendDir, 'package.json');\r\n    if (fs.existsSync(frontendPkgJson)) {\r\n      const frontendPkg = JSON.parse(fs.readFileSync(frontendPkgJson, 'utf8'));\r\n      \r\n      console.log(`Frontend package name: ${frontendPkg.name || 'undefined'}`);\r\n      console.log(`Frontend is private: ${frontendPkg.private ? '✅' : '❌'}`);\r\n      \r\n      // Check TypeScript scripts\r\n      const hasTypeScriptScripts = frontendPkg.scripts?.build?.includes('tsc') || \r\n                                  frontendPkg.scripts?.['type-check'];\r\n      console.log(`TypeScript build scripts: ${hasTypeScriptScripts ? '✅' : '❌'}`);\r\n    }\r\n\r\n    console.log('');\r\n  }\r\n\r\n  /**\r\n   * Generate comprehensive production report\r\n   */\r\n  private async generateProductionReport(): Promise<void> {\r\n    console.log('📊 Production Readiness Report\\n');\r\n    console.log('================================\\n');\r\n\r\n    const analysis: ProjectAnalysis = {\r\n      totalComponents: this.results.length,\r\n      passingComponents: this.results.filter(r => r.compiles).length,\r\n      failingComponents: this.results.filter(r => !r.compiles).length,\r\n      javascriptFiles: [],\r\n      productionViolations: [],\r\n      typeScriptCompliance: true\r\n    };\r\n\r\n    // Collect all production violations\r\n    this.results.forEach((result: ComponentTestResult) => {\r\n      analysis.productionViolations.push(...result.productionIssues);\r\n    });\r\n\r\n    console.log(`📈 Component Compilation:`);\r\n    console.log(`  Total Components: ${analysis.totalComponents}`);\r\n    console.log(`  Passing: ${analysis.passingComponents} ✅`);\r\n    console.log(`  Failing: ${analysis.failingComponents} ${analysis.failingComponents === 0 ? '✅' : '❌'}`);\r\n    console.log(`  Success Rate: ${((analysis.passingComponents / analysis.totalComponents) * 100).toFixed(1)}%`);\r\n\r\n    console.log(`\\n🔧 Production Issues Found: ${analysis.productionViolations.length}`);\r\n    if (analysis.productionViolations.length > 0) {\r\n      console.log('\\nTop Production Issues:');\r\n      analysis.productionViolations.slice(0, 10).forEach((issue: string) => {\r\n        console.log(`  ⚠️  ${issue}`);\r\n      });\r\n      if (analysis.productionViolations.length > 10) {\r\n        console.log(`  ... and ${analysis.productionViolations.length - 10} more issues`);\r\n      }\r\n    }\r\n\r\n    // Show failing components\r\n    const failingComponents = this.results.filter(r => !r.compiles);\r\n    if (failingComponents.length > 0) {\r\n      console.log(`\\n❌ Components with compilation errors:`);\r\n      failingComponents.forEach((comp: ComponentTestResult) => {\r\n        console.log(`  ${comp.component}`);\r\n        if (comp.errors.length > 0) {\r\n          console.log(`    ${comp.errors[0]}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Overall production readiness score\r\n    const productionScore = (analysis.passingComponents / analysis.totalComponents) * 100;\r\n    console.log(`\\n🎯 Production Readiness Score: ${productionScore.toFixed(1)}%`);\r\n    \r\n    if (productionScore >= 95) {\r\n      console.log('🚀 EXCELLENT - Ready for production deployment!');\r\n    } else if (productionScore >= 85) {\r\n      console.log('✅ GOOD - Minor issues to address before production');\r\n    } else if (productionScore >= 70) {\r\n      console.log('⚠️  NEEDS WORK - Several issues need fixing');\r\n    } else {\r\n      console.log('❌ NOT READY - Significant issues need resolution');\r\n    }\r\n\r\n    console.log('\\n================================\\n');\r\n  }\r\n}\r\n\r\n// Execute the validation\r\nconst validator = new FrontendProductionReadinessValidator();\r\nvalidator.runFullValidation().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\[id]\\edit\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\create\\page.tsx","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":76,"column":27,"nodeType":"MemberExpression","endLine":76,"endColumn":47}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\nimport { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport * as z from \"zod\";\r\n\r\n// Example strategies and their parameters\r\nconst STRATEGIES = {\r\n  SMA: {\r\n    label: \"Simple Moving Average\",\r\n    params: [\r\n      { name: \"period\", label: \"Period\", type: \"number\", min: 1, max: 200, default: 14 },\r\n      { name: \"threshold\", label: \"Threshold\", type: \"number\", min: 0, max: 100, default: 50 },\r\n    ],\r\n  },\r\n  EMA: {\r\n    label: \"Exponential Moving Average\",\r\n    params: [\r\n      { name: \"period\", label: \"Period\", type: \"number\", min: 1, max: 200, default: 14 },\r\n      { name: \"multiplier\", label: \"Multiplier\", type: \"number\", min: 1, max: 10, default: 2 },\r\n    ],\r\n  },\r\n  Custom: {\r\n    label: \"Custom Script\",\r\n    params: [\r\n      { name: \"script\", label: \"Strategy Script\", type: \"textarea\" },\r\n    ],\r\n  },\r\n};\r\n\r\nconst MARKET_TYPES = [\r\n  { value: \"spot\", label: \"Spot\" },\r\n  { value: \"futures\", label: \"Futures\" },\r\n];\r\n\r\nconst schema = z.object({\r\n  botName: z.string().min(3, \"Bot name must be at least 3 characters\"),\r\n  marketType: z.enum([\"spot\", \"futures\"]),\r\n  strategy: z.enum([\"SMA\", \"EMA\", \"Custom\"]),\r\n  parameters: z.record(z.any()),\r\n});\r\n\r\ntype FormData = z.infer<typeof schema>;\r\n\r\nexport default function BotCreatePage() {\r\n  const [strategy, setStrategy] = useState<keyof typeof STRATEGIES>(\"SMA\");\r\n  const [marketType, setMarketType] = useState(\"spot\");\r\n  const {\r\n    register,\r\n    handleSubmit,\r\n    watch,\r\n    formState: { errors, isSubmitting },\r\n    reset,\r\n  } = useForm<FormData>({\r\n    resolver: zodResolver(schema),\r\n    defaultValues: {\r\n      botName: \"\",\r\n      marketType: \"spot\",\r\n      strategy: \"SMA\",\r\n      parameters: {},\r\n    },\r\n  });\r\n\r\n  // Watch for changes to update dynamic fields\r\n  const selectedStrategy = watch(\"strategy\");\r\n  const selectedMarketType = watch(\"marketType\");\r\n\r\n  useEffect(() => {\r\n    if (selectedStrategy) {setStrategy(selectedStrategy as keyof typeof STRATEGIES);}\r\n  }, [selectedStrategy]);\r\n  useEffect(() => {\r\n    if (selectedMarketType) {setMarketType(selectedMarketType);}\r\n  }, [selectedMarketType]);\r\n\r\n  // Dynamic parameter fields\r\n  const parameterFields = STRATEGIES[strategy].params;\r\n\r\n  // Example: market-specific parameters\r\n  const marketSpecificFields =\r\n    marketType === \"futures\"\r\n      ? [\r\n          { name: \"leverage\", label: \"Leverage\", type: \"number\", min: 1, max: 100, default: 10 },\r\n          { name: \"marginType\", label: \"Margin Type\", type: \"select\", options: [\"isolated\", \"cross\"], default: \"isolated\" },\r\n        ]\r\n      : [];\r\n\r\n  // Combine all parameter fields\r\n  const allFields = [...parameterFields, ...marketSpecificFields];\r\n\r\n  const onSubmit = async (data: FormData) => {\r\n    // Prepare payload\r\n    const payload = {\r\n      botName: data.botName,\r\n      marketType: data.marketType,\r\n      strategy: data.strategy,\r\n      parameters: data.parameters,\r\n    };\r\n    try {\r\n      const res = await fetch(\"/api/bots\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      if (!res.ok) {throw new Error(\"Failed to create bot\");}\r\n      reset();\r\n      alert(\"Bot created successfully!\");\r\n    } catch (err: unknown) {\r\n      if (err instanceof Error) {\r\n        alert(err.message);\r\n      } else {\r\n        alert(\"Error creating bot\");\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"max-w-xl mx-auto p-6 bg-white rounded shadow\">\r\n      <h1 className=\"text-2xl font-bold mb-4\">Create New Trading Bot</h1>\r\n      <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-4\">\r\n        <div>\r\n          <label className=\"block font-medium\">Bot Name</label>\r\n          <input\r\n            {...register(\"botName\")}\r\n            className=\"w-full border rounded px-3 py-2 mt-1\"\r\n            placeholder=\"Enter bot name\"\r\n            disabled={isSubmitting}\r\n          />\r\n          {errors.botName && <span className=\"text-red-500 text-sm\">{errors.botName.message}</span>}\r\n        </div>\r\n        <div>\r\n          <label className=\"block font-medium\">Market Type</label>\r\n          <select\r\n            {...register(\"marketType\")}\r\n            className=\"w-full border rounded px-3 py-2 mt-1\"\r\n            disabled={isSubmitting}\r\n          >\r\n            {MARKET_TYPES.map((m) => (\r\n              <option key={m.value} value={m.value}>\r\n                {m.label}\r\n              </option>\r\n            ))}\r\n          </select>\r\n        </div>\r\n        <div>\r\n          <label className=\"block font-medium\">Strategy</label>\r\n          <select\r\n            {...register(\"strategy\")}\r\n            className=\"w-full border rounded px-3 py-2 mt-1\"\r\n            disabled={isSubmitting}\r\n          >\r\n            {Object.entries(STRATEGIES).map(([key, s]) => (\r\n              <option key={key} value={key}>\r\n                {s.label}\r\n              </option>\r\n            ))}\r\n          </select>\r\n        </div>\r\n        {/* Dynamic parameter fields */}\r\n        {allFields.map((field) => (\r\n          <div key={field.name}>\r\n            <label className=\"block font-medium\">{field.label}</label>\r\n            {field.type === \"select\" && \"options\" in field ? (\r\n              <select\r\n                {...register(`parameters.${field.name}`)}\r\n                className=\"w-full border rounded px-3 py-2 mt-1\"\r\n                defaultValue={\"default\" in field ? String(field.default) : undefined}\r\n                disabled={isSubmitting}\r\n              >\r\n                {Array.isArray(field.options) && field.options.map((opt: string) => (\r\n                  <option key={opt} value={opt}>\r\n                    {opt}\r\n                  </option>\r\n                ))}\r\n              </select>\r\n            ) : field.type === \"textarea\" ? (\r\n              <textarea\r\n                {...register(`parameters.${field.name}`)}\r\n                className=\"w-full border rounded px-3 py-2 mt-1\"\r\n                rows={4}\r\n                placeholder={field.label}\r\n                disabled={isSubmitting}\r\n              />\r\n            ) : (\r\n              <input\r\n                type={field.type}\r\n                {...register(`parameters.${field.name}`)}\r\n                className=\"w-full border rounded px-3 py-2 mt-1\"\r\n                min={\"min\" in field ? String(field.min) : undefined}\r\n                max={\"max\" in field ? String(field.max) : undefined}\r\n                defaultValue={\"default\" in field ? String(field.default) : undefined}\r\n                step={field.type === \"number\" ? 1 : undefined}\r\n                disabled={isSubmitting}\r\n              />\r\n            )}\r\n          </div>\r\n        ))}\r\n        <button\r\n          type=\"submit\"\r\n          className=\"bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50\"\r\n          disabled={isSubmitting}\r\n        >\r\n          {isSubmitting ? \"Creating...\" : \"Create Bot\"}\r\n        </button>\r\n      </form>\r\n    </div>\r\n  );\r\n} ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\bots\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":91,"column":46,"endLine":91,"endColumn":103,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":92,"column":46,"endLine":92,"endColumn":103,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { CONSTANTS } from '@jabbr/shared/src';\r\nimport type { Bot, BotStatus } from '@jabbr/shared/src/types';\r\nimport Link from 'next/link';\r\nimport React, { useState, useEffect } from 'react';\r\n\r\nimport StrategyMonitor from '../../components/StrategyMonitor';\r\nimport useWebSocket from '../../hooks/useWebSocket';\r\n\r\n\r\n// Enhanced filter options\r\ninterface BotFilters {\r\n  status?: BotStatus | 'all';\r\n  strategy?: string | 'all';\r\n  exchange?: string | 'all';\r\n  search?: string;\r\n}\r\n\r\n// Sort options\r\ntype SortField = 'name' | 'status' | 'strategy' | 'exchange' | 'createdAt' | 'performance';\r\ntype SortDirection = 'asc' | 'desc';\r\n\r\ninterface SortConfig {\r\n  field: SortField;\r\n  direction: SortDirection;\r\n}\r\n\r\nexport default function BotsPage() {\r\n  const [bots, setBots] = useState<Bot[]>([]);\r\n  const [filteredBots, setFilteredBots] = useState<Bot[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [selectedBot, setSelectedBot] = useState<string | null>(null);\r\n  const [activeTab, setActiveTab] = useState<'bots' | 'strategies'>('bots');\r\n  const [filters, setFilters] = useState<BotFilters>({ status: 'all', strategy: 'all', exchange: 'all', search: '' });\r\n  const [sortConfig, setSortConfig] = useState<SortConfig>({ field: 'createdAt', direction: 'desc' });\r\n  const [showFilters, setShowFilters] = useState(false);\r\n\r\n  const {\r\n    isConnected,\r\n    subscribe\r\n  } = useWebSocket({\r\n    url: 'ws://localhost:3002/ws',\r\n    onOpen: () => {\r\n      // Subscribe to bot status updates\r\n      subscribe(CONSTANTS.WS_CHANNELS.BOT_STATUS);\r\n    },\r\n    onMessage: (message) => {\r\n      // Handle real-time bot status updates\r\n      if (message.channel === CONSTANTS.WS_CHANNELS.BOT_STATUS && message.data) {\r\n        setBots(prevBots => \r\n          prevBots.map(bot => \r\n            bot.id === message.data.botId \r\n              ? { ...bot, status: message.data.status }\r\n              : bot\r\n          )\r\n        );\r\n      }\r\n    }\r\n  });\r\n\r\n  // Fetch bots on component mount\r\n  useEffect(() => {\r\n    fetchBots();\r\n  }, []);\r\n\r\n  // Filter and sort bots when filters or sort config changes\r\n  useEffect(() => {\r\n    let filtered = [...bots];\r\n\r\n    // Apply filters\r\n    if (filters.status && filters.status !== 'all') {\r\n      filtered = filtered.filter(bot => bot.status === filters.status);\r\n    }\r\n    if (filters.strategy && filters.strategy !== 'all') {\r\n      filtered = filtered.filter(bot => bot.strategy === filters.strategy);\r\n    }\r\n    if (filters.exchange && filters.exchange !== 'all') {\r\n      filtered = filtered.filter(bot => bot.exchange === filters.exchange);\r\n    }\r\n    if (filters.search) {\r\n      filtered = filtered.filter(bot => \r\n        bot.name.toLowerCase().includes(filters.search!.toLowerCase()) ||\r\n        bot.description?.toLowerCase().includes(filters.search!.toLowerCase())\r\n      );\r\n    }\r\n\r\n    // Apply sorting\r\n    filtered.sort((a, b) => {\r\n      let aValue: any = a[sortConfig.field]; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n      let bValue: any = b[sortConfig.field]; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n\r\n      // Handle special cases\r\n      if (sortConfig.field === 'performance') {\r\n        aValue = a.performance?.totalPnL || 0;\r\n        bValue = b.performance?.totalPnL || 0;\r\n      }\r\n\r\n      if (typeof aValue === 'string') {\r\n        aValue = aValue.toLowerCase();\r\n        bValue = bValue.toLowerCase();\r\n      }\r\n\r\n      if (sortConfig.direction === 'asc') {\r\n        return aValue > bValue ? 1 : -1;\r\n      } \r\n        return aValue < bValue ? 1 : -1;\r\n      \r\n    });\r\n\r\n    setFilteredBots(filtered);\r\n  }, [bots, filters, sortConfig]);\r\n\r\n  const fetchBots = async () => {\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n      \r\n      const response = await fetch('/api/bots', {\r\n        headers: {\r\n          'Authorization': `Bearer ${localStorage.getItem('token')}` // JWT token\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to fetch bots: ${response.statusText}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n      setBots(data.data || []);\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to fetch bots');\r\n      console.error('Error fetching bots:', err);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Bot lifecycle control functions\r\n  const handleBotAction = async (botId: string, action: 'start' | 'stop' | 'pause' | 'resume') => {\r\n    try {\r\n      const response = await fetch(`/api/bots/${botId}/${action}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${localStorage.getItem('token')}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to ${action} bot`);\r\n      }\r\n\r\n      // Refresh bots list to get updated status\r\n      await fetchBots();\r\n    } catch (err) {\r\n      alert(err instanceof Error ? err.message : `Failed to ${action} bot`);\r\n    }\r\n  };\r\n\r\n  const getStatusColor = (status: BotStatus): string => {\r\n    switch (status) {\r\n      case 'running': return 'text-green-600 bg-green-100';\r\n      case 'stopped': return 'text-gray-600 bg-gray-100';\r\n      case 'paused': return 'text-yellow-600 bg-yellow-100';\r\n      case 'starting': case 'stopping': case 'pausing': return 'text-blue-600 bg-blue-100';\r\n      case 'error': return 'text-red-600 bg-red-100';\r\n      default: return 'text-gray-600 bg-gray-100';\r\n    }\r\n  };\r\n\r\n  const getStatusIcon = (status: BotStatus): string => {\r\n    switch (status) {\r\n      case 'running': return '🟢';\r\n      case 'stopped': return '⚫';\r\n      case 'paused': return '🟡';\r\n      case 'starting': case 'stopping': case 'pausing': return '🔄';\r\n      case 'error': return '🔴';\r\n      default: return '⚫';\r\n    }\r\n  };\r\n\r\n  const canPerformAction = (status: BotStatus, action: string): boolean => {\r\n    switch (action) {\r\n      case 'start': return ['stopped', 'error'].includes(status);\r\n      case 'stop': return ['running', 'paused'].includes(status);\r\n      case 'pause': return status === 'running';\r\n      case 'resume': return status === 'paused';\r\n      default: return false;\r\n    }\r\n  };\r\n\r\n  // Enhanced bot management functions\r\n  const handleSort = (field: SortField) => {\r\n    setSortConfig(prev => ({\r\n      field,\r\n      direction: prev.field === field && prev.direction === 'asc' ? 'desc' : 'asc'\r\n    }));\r\n  };\r\n\r\n  const handleFilterChange = (filterType: keyof BotFilters, value: string) => {\r\n    setFilters(prev => ({ ...prev, [filterType]: value }));\r\n  };\r\n\r\n  // Note: Bulk actions will be implemented in future iterations\r\n\r\n  const deleteBot = async (botId: string) => {\r\n    if (!confirm('Are you sure you want to delete this bot? This action cannot be undone.')) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`/api/bots/${botId}`, {\r\n        method: 'DELETE',\r\n        headers: {\r\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to delete bot');\r\n      }\r\n\r\n      await fetchBots();\r\n    } catch (err) {\r\n      alert(err instanceof Error ? err.message : 'Failed to delete bot');\r\n    }\r\n  };\r\n\r\n  // Get unique values for filter dropdowns\r\n  const getUniqueStrategies = () => [...new Set(bots.map(bot => bot.strategy))];\r\n  const getUniqueExchanges = () => [...new Set(bots.map(bot => bot.exchange))];\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-100 p-8\">\r\n        <div className=\"max-w-6xl mx-auto\">\r\n          <div className=\"flex items-center justify-center h-64\">\r\n            <div className=\"text-lg text-gray-600\">Loading bots...</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-100 p-8\">\r\n      <div className=\"max-w-6xl mx-auto\">\r\n        {/* Header */}\r\n        <div className=\"flex flex-col mb-8\">\r\n          <div className=\"flex justify-between items-center mb-6\">\r\n            <div>\r\n              <h1 className=\"text-4xl font-bold text-gray-900 mb-2\">\r\n                🤖 Trading Bots\r\n              </h1>\r\n              <p className=\"text-lg text-gray-600\">\r\n                Manage your automated trading bots ({filteredBots.length} of {bots.length} bots)\r\n              </p>\r\n            </div>\r\n            \r\n            <div className=\"flex space-x-4\">\r\n              <button\r\n                onClick={() => setShowFilters(!showFilters)}\r\n                className=\"bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors font-medium\"\r\n              >\r\n                🔍 {showFilters ? 'Hide' : 'Show'} Filters\r\n              </button>\r\n              \r\n              <Link\r\n                href=\"/bots/create\"\r\n                className=\"bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium\"\r\n              >\r\n                ➕ Create New Bot\r\n              </Link>\r\n              \r\n              <button\r\n                onClick={fetchBots}\r\n                className=\"bg-gray-600 text-white px-6 py-3 rounded-lg hover:bg-gray-700 transition-colors font-medium\"\r\n              >\r\n                🔄 Refresh\r\n              </button>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Enhanced Filters */}\r\n          {showFilters && (\r\n            <div className=\"bg-white rounded-lg shadow-md p-6 mb-6\">\r\n              <h3 className=\"text-lg font-semibold mb-4\">Filter & Search Bots</h3>\r\n              <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\r\n                {/* Search */}\r\n                <div>\r\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">Search</label>\r\n                  <input\r\n                    type=\"text\"\r\n                    placeholder=\"Bot name or description...\"\r\n                    value={filters.search || ''}\r\n                    onChange={(e) => handleFilterChange('search', e.target.value)}\r\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                  />\r\n                </div>\r\n\r\n                {/* Status Filter */}\r\n                <div>\r\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">Status</label>\r\n                  <select\r\n                    value={filters.status || 'all'}\r\n                    onChange={(e) => handleFilterChange('status', e.target.value)}\r\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                  >\r\n                    <option value=\"all\">All Status</option>\r\n                    <option value=\"running\">Running</option>\r\n                    <option value=\"stopped\">Stopped</option>\r\n                    <option value=\"paused\">Paused</option>\r\n                    <option value=\"error\">Error</option>\r\n                    <option value=\"starting\">Starting</option>\r\n                    <option value=\"stopping\">Stopping</option>\r\n                  </select>\r\n                </div>\r\n\r\n                {/* Strategy Filter */}\r\n                <div>\r\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">Strategy</label>\r\n                  <select\r\n                    value={filters.strategy || 'all'}\r\n                    onChange={(e) => handleFilterChange('strategy', e.target.value)}\r\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                  >\r\n                    <option value=\"all\">All Strategies</option>\r\n                    {getUniqueStrategies().map(strategy => (\r\n                      <option key={strategy} value={strategy}>{strategy}</option>\r\n                    ))}\r\n                  </select>\r\n                </div>\r\n\r\n                {/* Exchange Filter */}\r\n                <div>\r\n                  <label className=\"block text-sm font-medium text-gray-700 mb-2\">Exchange</label>\r\n                  <select\r\n                    value={filters.exchange || 'all'}\r\n                    onChange={(e) => handleFilterChange('exchange', e.target.value)}\r\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                  >\r\n                    <option value=\"all\">All Exchanges</option>\r\n                    {getUniqueExchanges().map(exchange => (\r\n                      <option key={exchange} value={exchange}>{exchange}</option>\r\n                    ))}\r\n                  </select>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Sort Options */}\r\n              <div className=\"mt-4 pt-4 border-t border-gray-200\">\r\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">Sort By</label>\r\n                <div className=\"flex space-x-2\">\r\n                  {[\r\n                    { field: 'name' as SortField, label: 'Name' },\r\n                    { field: 'status' as SortField, label: 'Status' },\r\n                    { field: 'strategy' as SortField, label: 'Strategy' },\r\n                    { field: 'createdAt' as SortField, label: 'Created' },\r\n                    { field: 'performance' as SortField, label: 'Performance' },\r\n                  ].map(({ field, label }) => (\r\n                    <button\r\n                      key={field}\r\n                      onClick={() => handleSort(field)}\r\n                      className={`px-3 py-1 rounded text-sm font-medium transition-colors ${\r\n                        sortConfig.field === field\r\n                          ? 'bg-blue-600 text-white'\r\n                          : 'bg-gray-200 text-gray-700 hover:bg-gray-300'\r\n                      }`}\r\n                    >\r\n                      {label} {sortConfig.field === field && (sortConfig.direction === 'asc' ? '↑' : '↓')}\r\n                    </button>\r\n                  ))}\r\n                </div>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* WebSocket Status */}\r\n        <div className=\"mb-6 bg-white rounded-lg shadow-md p-4\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <span className=\"text-sm font-medium\">Real-time Status:</span>\r\n            <span className={`text-sm font-semibold ${isConnected ? 'text-green-600' : 'text-red-600'}`}>\r\n              {isConnected ? '🟢 Connected' : '🔴 Disconnected'}\r\n            </span>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Tab Navigation */}\r\n        <div className=\"mb-6 border-b border-gray-200\">\r\n          <nav className=\"-mb-px flex space-x-8\">\r\n            <button\r\n              onClick={() => setActiveTab('bots')}\r\n              className={`py-2 px-1 border-b-2 font-medium text-sm ${\r\n                activeTab === 'bots'\r\n                  ? 'border-blue-500 text-blue-600'\r\n                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'\r\n              }`}\r\n            >\r\n              🤖 Bot Management\r\n            </button>\r\n            <button\r\n              onClick={() => setActiveTab('strategies')}\r\n              className={`py-2 px-1 border-b-2 font-medium text-sm ${\r\n                activeTab === 'strategies'\r\n                  ? 'border-blue-500 text-blue-600'\r\n                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'\r\n              }`}\r\n            >\r\n              📊 Strategy Monitor\r\n            </button>\r\n          </nav>\r\n        </div>\r\n\r\n        {/* Error Display */}\r\n        {error && (\r\n          <div className=\"mb-6 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded\">\r\n            <strong>Error:</strong> {error}\r\n          </div>\r\n        )}\r\n\r\n        {/* Tab Content */}\r\n        {activeTab === 'bots' && (\r\n          <>\r\n            {/* Bots Grid */}\r\n            {bots.length === 0 ? (\r\n              <div className=\"bg-white rounded-lg shadow-md p-12 text-center\">\r\n                <div className=\"text-6xl mb-4\">🤖</div>\r\n                <h3 className=\"text-xl font-semibold text-gray-900 mb-2\">No Trading Bots Yet</h3>\r\n                <p className=\"text-gray-600 mb-6\">\r\n                  Get started by creating your first automated trading bot\r\n                </p>\r\n                <Link\r\n                  href=\"/bots/create\"\r\n                  className=\"bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium inline-block\"\r\n                >\r\n                  Create Your First Bot\r\n                </Link>\r\n              </div>\r\n            ) : filteredBots.length === 0 ? (\r\n              <div className=\"bg-white rounded-lg shadow-md p-12 text-center\">\r\n                <div className=\"text-4xl mb-4\">🔍</div>\r\n                <h3 className=\"text-xl font-semibold text-gray-900 mb-2\">No Bots Match Your Filters</h3>\r\n                <p className=\"text-gray-600 mb-6\">\r\n                  Try adjusting your search criteria or clear the filters\r\n                </p>\r\n                <button\r\n                  onClick={() => setFilters({ status: 'all', strategy: 'all', exchange: 'all', search: '' })}\r\n                  className=\"bg-gray-600 text-white px-6 py-3 rounded-lg hover:bg-gray-700 transition-colors font-medium\"\r\n                >\r\n                  Clear Filters\r\n                </button>\r\n              </div>\r\n            ) : (\r\n              <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\r\n                {filteredBots.map((bot) => (\r\n                  <div key={bot.id} className=\"bg-white rounded-lg shadow-md p-6 hover:shadow-lg transition-shadow\">\r\n                    {/* Bot Header */}\r\n                    <div className=\"flex justify-between items-start mb-4\">\r\n                      <div>\r\n                        <h3 className=\"text-lg font-semibold text-gray-900 mb-1\">{bot.name}</h3>\r\n                        <p className=\"text-sm text-gray-600\">{bot.description || 'No description'}</p>\r\n                      </div>\r\n                      <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(bot.status)}`}>\r\n                        {getStatusIcon(bot.status)} {bot.status.toUpperCase()}\r\n                      </span>\r\n                    </div>\r\n\r\n                    {/* Bot Details */}\r\n                    <div className=\"space-y-2 mb-4\">\r\n                      <div className=\"flex justify-between text-sm\">\r\n                        <span className=\"text-gray-600\">Strategy:</span>\r\n                        <span className=\"font-medium\">{bot.strategy}</span>\r\n                      </div>\r\n                      <div className=\"flex justify-between text-sm\">\r\n                        <span className=\"text-gray-600\">Exchange:</span>\r\n                        <span className=\"font-medium\">{bot.exchange}</span>\r\n                      </div>\r\n                      <div className=\"flex justify-between text-sm\">\r\n                        <span className=\"text-gray-600\">Created:</span>\r\n                        <span className=\"font-medium\">{new Date(bot.createdAt).toLocaleDateString()}</span>\r\n                      </div>\r\n                    </div>\r\n\r\n                    {/* Performance Metrics */}\r\n                    {bot.performance && (\r\n                      <div className=\"bg-gray-50 rounded p-3 mb-4\">\r\n                        <h4 className=\"text-sm font-medium text-gray-900 mb-2\">Performance</h4>\r\n                        <div className=\"grid grid-cols-2 gap-2 text-xs\">\r\n                          <div>\r\n                            <span className=\"text-gray-600\">Trades:</span>\r\n                            <span className=\"font-medium ml-1\">{bot.performance.totalTrades}</span>\r\n                          </div>\r\n                          <div>\r\n                            <span className=\"text-gray-600\">Win Rate:</span>\r\n                            <span className=\"font-medium ml-1\">{bot.performance.winRate}%</span>\r\n                          </div>\r\n                          <div>\r\n                            <span className=\"text-gray-600\">Total P&L:</span>\r\n                            <span className={`font-medium ml-1 ${bot.performance.totalPnL >= 0 ? 'text-green-600' : 'text-red-600'}`}>\r\n                              ${bot.performance.totalPnL.toFixed(2)}\r\n                            </span>\r\n                          </div>\r\n                          <div>\r\n                            <span className=\"text-gray-600\">Max Drawdown:</span>\r\n                            <span className={`font-medium ml-1 ${bot.performance.maxDrawdown >= 0 ? 'text-red-600' : 'text-green-600'}`}>\r\n                              {bot.performance.maxDrawdown.toFixed(2)}%\r\n                            </span>\r\n                          </div>\r\n                        </div>\r\n                      </div>\r\n                    )}\r\n\r\n                    {/* Bot Actions */}\r\n                    <div className=\"flex space-x-2\">\r\n                      {canPerformAction(bot.status, 'start') && (\r\n                        <button\r\n                          onClick={() => handleBotAction(bot.id, 'start')}\r\n                          className=\"flex-1 bg-green-600 text-white px-3 py-2 rounded text-sm hover:bg-green-700 transition-colors\"\r\n                        >\r\n                          ▶️ Start\r\n                        </button>\r\n                      )}\r\n                      \r\n                      {canPerformAction(bot.status, 'pause') && (\r\n                        <button\r\n                          onClick={() => handleBotAction(bot.id, 'pause')}\r\n                          className=\"flex-1 bg-yellow-600 text-white px-3 py-2 rounded text-sm hover:bg-yellow-700 transition-colors\"\r\n                        >\r\n                          ⏸️ Pause\r\n                        </button>\r\n                      )}\r\n                      \r\n                      {canPerformAction(bot.status, 'resume') && (\r\n                        <button\r\n                          onClick={() => handleBotAction(bot.id, 'resume')}\r\n                          className=\"flex-1 bg-blue-600 text-white px-3 py-2 rounded text-sm hover:bg-blue-700 transition-colors\"\r\n                        >\r\n                          ▶️ Resume\r\n                        </button>\r\n                      )}\r\n                      \r\n                      {canPerformAction(bot.status, 'stop') && (\r\n                        <button\r\n                          onClick={() => handleBotAction(bot.id, 'stop')}\r\n                          className=\"flex-1 bg-red-600 text-white px-3 py-2 rounded text-sm hover:bg-red-700 transition-colors\"\r\n                        >\r\n                          ⏹️ Stop\r\n                        </button>\r\n                      )}\r\n                    </div>\r\n\r\n                    {/* Enhanced Quick Actions */}\r\n                    <div className=\"flex space-x-2 mt-3\">\r\n                      <button\r\n                        onClick={() => setSelectedBot(selectedBot === bot.id ? null : bot.id)}\r\n                        className=\"flex-1 bg-gray-200 text-gray-700 px-3 py-2 rounded text-sm hover:bg-gray-300 transition-colors\"\r\n                      >\r\n                        📊 Details\r\n                      </button>\r\n                      <Link\r\n                        href={`/bots/${bot.id}/edit`}\r\n                        className=\"flex-1 bg-blue-200 text-blue-700 px-3 py-2 rounded text-sm hover:bg-blue-300 transition-colors text-center\"\r\n                      >\r\n                        ⚙️ Edit\r\n                      </Link>\r\n                      <button\r\n                        onClick={() => deleteBot(bot.id)}\r\n                        disabled={!canPerformAction(bot.status, 'stop')}\r\n                        className=\"flex-1 bg-red-200 text-red-700 px-3 py-2 rounded text-sm hover:bg-red-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\r\n                      >\r\n                        🗑️ Delete\r\n                      </button>\r\n                    </div>\r\n\r\n                    {/* Expanded Details */}\r\n                    {selectedBot === bot.id && (\r\n                      <div className=\"mt-4 p-3 bg-gray-50 rounded text-sm\">\r\n                        <div className=\"grid grid-cols-2 gap-4\">\r\n                          <div>\r\n                            <h5 className=\"font-medium mb-2\">Configuration</h5>\r\n                            <div className=\"space-y-1 text-xs\">\r\n                              <div><span className=\"font-medium\">Symbol:</span> {bot.configuration.symbol}</div>\r\n                              <div><span className=\"font-medium\">Timeframe:</span> {bot.configuration.timeframe}</div>\r\n                              <div><span className=\"font-medium\">Leverage:</span> {bot.configuration.leverage}x</div>\r\n                              <div><span className=\"font-medium\">Trade Amount:</span> ${bot.configuration.tradeAmount}</div>\r\n                            </div>\r\n                          </div>\r\n                          <div>\r\n                            <h5 className=\"font-medium mb-2\">Risk Management</h5>\r\n                            <div className=\"space-y-1 text-xs\">\r\n                              <div><span className=\"font-medium\">Max Daily Loss:</span> {bot.riskManagement.maxDailyLoss}%</div>\r\n                              <div><span className=\"font-medium\">Max Drawdown:</span> {bot.riskManagement.maxDrawdown}%</div>\r\n                              <div><span className=\"font-medium\">Max Trades:</span> {bot.riskManagement.maxConcurrentTrades}</div>\r\n                              <div><span className=\"font-medium\">Risk Score:</span> {bot.riskManagement.riskScore}/10</div>\r\n                            </div>\r\n                          </div>\r\n                        </div>\r\n                        <div className=\"mt-3 pt-3 border-t border-gray-200\">\r\n                          <h5 className=\"font-medium mb-2\">Advanced Details</h5>\r\n                          <div className=\"grid grid-cols-1 gap-2 text-xs\">\r\n                            <div><span className=\"font-medium\">Bot ID:</span> {bot.id}</div>\r\n                            <div><span className=\"font-medium\">API Key ID:</span> {bot.exchangeApiKeyId}</div>\r\n                            <div><span className=\"font-medium\">Created:</span> {new Date(bot.createdAt).toLocaleString()}</div>\r\n                            <div><span className=\"font-medium\">Last Updated:</span> {new Date(bot.updatedAt).toLocaleString()}</div>\r\n                          </div>\r\n                        </div>\r\n                      </div>\r\n                    )}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            )}\r\n\r\n            {/* Enhanced Summary Stats */}\r\n            {bots.length > 0 && (\r\n              <div className=\"mt-8 bg-white rounded-lg shadow-md p-6\">\r\n                <div className=\"flex justify-between items-center mb-4\">\r\n                  <h3 className=\"text-lg font-semibold\">Portfolio Summary</h3>\r\n                  {filteredBots.length !== bots.length && (\r\n                    <span className=\"text-sm text-gray-500\">\r\n                      Showing {filteredBots.length} of {bots.length} bots\r\n                    </span>\r\n                  )}\r\n                </div>\r\n                <div className=\"grid grid-cols-2 md:grid-cols-5 gap-4\">\r\n                  <div className=\"text-center\">\r\n                    <div className=\"text-2xl font-bold text-gray-900\">{filteredBots.length}</div>\r\n                    <div className=\"text-sm text-gray-600\">Filtered Bots</div>\r\n                  </div>\r\n                  <div className=\"text-center\">\r\n                    <div className=\"text-2xl font-bold text-green-600\">\r\n                      {filteredBots.filter(bot => bot.status === 'running').length}\r\n                    </div>\r\n                    <div className=\"text-sm text-gray-600\">Running</div>\r\n                  </div>\r\n                  <div className=\"text-center\">\r\n                    <div className=\"text-2xl font-bold text-gray-600\">\r\n                      {filteredBots.filter(bot => bot.status === 'stopped').length}\r\n                    </div>\r\n                    <div className=\"text-sm text-gray-600\">Stopped</div>\r\n                  </div>\r\n                  <div className=\"text-center\">\r\n                    <div className=\"text-2xl font-bold text-yellow-600\">\r\n                      {filteredBots.filter(bot => bot.status === 'paused').length}\r\n                    </div>\r\n                    <div className=\"text-sm text-gray-600\">Paused</div>\r\n                  </div>\r\n                  <div className=\"text-center\">\r\n                    <div className=\"text-2xl font-bold text-red-600\">\r\n                      {filteredBots.filter(bot => bot.status === 'error').length}\r\n                    </div>\r\n                    <div className=\"text-sm text-gray-600\">Error</div>\r\n                  </div>\r\n                </div>\r\n                \r\n                {/* Performance Summary */}\r\n                {filteredBots.some(bot => bot.performance) && (\r\n                  <div className=\"mt-6 pt-6 border-t border-gray-200\">\r\n                    <h4 className=\"text-md font-semibold mb-3\">Performance Overview</h4>\r\n                    <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\r\n                      <div className=\"text-center\">\r\n                        <div className={`text-xl font-bold ${\r\n                          filteredBots.reduce((sum, bot) => sum + (bot.performance?.totalPnL || 0), 0) >= 0\r\n                            ? 'text-green-600' : 'text-red-600'\r\n                        }`}>\r\n                          ${filteredBots.reduce((sum, bot) => sum + (bot.performance?.totalPnL || 0), 0).toFixed(2)}\r\n                        </div>\r\n                        <div className=\"text-sm text-gray-600\">Total P&L</div>\r\n                      </div>\r\n                      <div className=\"text-center\">\r\n                        <div className=\"text-xl font-bold text-gray-900\">\r\n                          {filteredBots.reduce((sum, bot) => sum + (bot.performance?.totalTrades || 0), 0)}\r\n                        </div>\r\n                        <div className=\"text-sm text-gray-600\">Total Trades</div>\r\n                      </div>\r\n                      <div className=\"text-center\">\r\n                        <div className=\"text-xl font-bold text-blue-600\">\r\n                          {filteredBots.length > 0 \r\n                            ? (filteredBots.reduce((sum, bot) => sum + (bot.performance?.winRate || 0), 0) / filteredBots.filter(bot => bot.performance).length || 0).toFixed(1)\r\n                            : '0.0'\r\n                          }%\r\n                        </div>\r\n                        <div className=\"text-sm text-gray-600\">Avg Win Rate</div>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                )}\r\n              </div>\r\n            )}\r\n          </>\r\n        )}\r\n\r\n        {activeTab === 'strategies' && (\r\n          <StrategyMonitor />\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n} ","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\logs\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\AlertSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\ConnectionStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\Loading.tsx","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":35,"column":92,"nodeType":"MemberExpression","endLine":35,"endColumn":109},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":35,"column":113,"nodeType":"MemberExpression","endLine":35,"endColumn":132},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":189,"column":21,"nodeType":"MemberExpression","endLine":189,"endColumn":44},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":192,"column":45,"nodeType":"MemberExpression","endLine":192,"endColumn":63}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React from 'react';\r\n\r\nimport { componentClasses } from '../utils/theme';\r\n\r\ninterface LoadingSpinnerProps {\r\n  size?: 'sm' | 'md' | 'lg' | 'xl';\r\n  color?: 'primary' | 'secondary' | 'success' | 'warning' | 'error';\r\n  className?: string;\r\n}\r\n\r\nexport const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({\r\n  size = 'md',\r\n  color = 'primary',\r\n  className = '',\r\n}) => {\r\n  const sizeClasses = {\r\n    sm: 'w-4 h-4',\r\n    md: 'w-6 h-6',\r\n    lg: 'w-8 h-8',\r\n    xl: 'w-12 h-12',\r\n  };\r\n\r\n  const colorClasses = {\r\n    primary: 'text-brand-primary',\r\n    secondary: 'text-brand-secondary',\r\n    success: 'text-status-success',\r\n    warning: 'text-status-warning',\r\n    error: 'text-status-error',\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={`animate-spin rounded-full border-2 border-current border-t-transparent ${sizeClasses[size]} ${colorClasses[color]} ${className}`}\r\n      role=\"status\"\r\n      aria-label=\"Loading\"\r\n    >\r\n      <span className=\"sr-only\">Loading...</span>\r\n    </div>\r\n  );\r\n};\r\n\r\ninterface LoadingStateProps {\r\n  message?: string;\r\n  size?: 'sm' | 'md' | 'lg';\r\n  className?: string;\r\n}\r\n\r\nexport const LoadingState: React.FC<LoadingStateProps> = ({\r\n  message = 'Loading...',\r\n  size = 'md',\r\n  className = '',\r\n}) => {\r\n  return (\r\n    <div className={`flex flex-col items-center justify-center p-8 ${className}`}>\r\n      <LoadingSpinner size={size === 'sm' ? 'md' : size === 'lg' ? 'xl' : 'lg'} />\r\n      <p className=\"mt-4 text-secondary text-sm\">{message}</p>\r\n    </div>\r\n  );\r\n};\r\n\r\ninterface LoadingOverlayProps {\r\n  isVisible: boolean;\r\n  message?: string;\r\n  className?: string;\r\n}\r\n\r\nexport const LoadingOverlay: React.FC<LoadingOverlayProps> = ({\r\n  isVisible,\r\n  message = 'Loading...',\r\n  className = '',\r\n}) => {\r\n  if (!isVisible) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div className={`fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 ${className}`}>\r\n      <div className={`${componentClasses.card} p-8 text-center`}>\r\n        <LoadingSpinner size=\"lg\" className=\"mx-auto mb-4\" />\r\n        <p className=\"text-primary font-medium\">{message}</p>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\ninterface LoadingCardProps {\r\n  title?: string;\r\n  message?: string;\r\n  className?: string;\r\n}\r\n\r\nexport const LoadingCard: React.FC<LoadingCardProps> = ({\r\n  title = 'Loading',\r\n  message = 'Please wait while we fetch your data...',\r\n  className = '',\r\n}) => {\r\n  return (\r\n    <div className={`${componentClasses.card} ${className}`}>\r\n      <div className=\"text-center py-12\">\r\n        <LoadingSpinner size=\"lg\" className=\"mx-auto mb-4\" />\r\n        <h3 className=\"text-lg font-semibold text-primary mb-2\">{title}</h3>\r\n        <p className=\"text-secondary text-sm\">{message}</p>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\ninterface LoadingTableProps {\r\n  rows?: number;\r\n  columns?: number;\r\n  className?: string;\r\n}\r\n\r\nexport const LoadingTable: React.FC<LoadingTableProps> = ({\r\n  rows = 5,\r\n  columns = 4,\r\n  className = '',\r\n}) => {\r\n  return (\r\n    <div className={`${componentClasses.card} ${className}`}>\r\n      <div className=\"animate-pulse\">\r\n        {/* Table header */}\r\n        <div className=\"flex space-x-4 p-4 border-b border-border\">\r\n          {Array.from({ length: columns }).map((_, index) => (\r\n            <div\r\n              key={`header-${index}`}\r\n              className=\"h-4 bg-surface-secondary rounded flex-1\"\r\n            />\r\n          ))}\r\n        </div>\r\n        \r\n        {/* Table rows */}\r\n        {Array.from({ length: rows }).map((_, rowIndex) => (\r\n          <div key={`row-${rowIndex}`} className=\"flex space-x-4 p-4 border-b border-border last:border-b-0\">\r\n            {Array.from({ length: columns }).map((_, colIndex) => (\r\n              <div\r\n                key={`cell-${rowIndex}-${colIndex}`}\r\n                className=\"h-4 bg-surface-secondary rounded flex-1\"\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\ninterface LoadingButtonProps {\r\n  isLoading: boolean;\r\n  children: React.ReactNode;\r\n  onClick?: () => void;\r\n  disabled?: boolean;\r\n  className?: string;\r\n  size?: 'sm' | 'md' | 'lg';\r\n  variant?: 'primary' | 'secondary' | 'success' | 'warning' | 'error';\r\n}\r\n\r\nexport const LoadingButton: React.FC<LoadingButtonProps> = ({\r\n  isLoading,\r\n  children,\r\n  onClick,\r\n  disabled = false,\r\n  className = '',\r\n  size = 'md',\r\n  variant = 'primary',\r\n}) => {\r\n  const isDisabled = disabled || isLoading;\r\n  \r\n  const variantClasses = {\r\n    primary: componentClasses.button.primary,\r\n    secondary: componentClasses.button.secondary,\r\n    success: componentClasses.button.success,\r\n    warning: componentClasses.button.secondary, // fallback to secondary\r\n    error: componentClasses.button.danger,\r\n  };\r\n\r\n  const spinnerSizes = {\r\n    sm: 'sm' as const,\r\n    md: 'sm' as const,\r\n    lg: 'md' as const,\r\n  };\r\n\r\n  return (\r\n    <button\r\n      onClick={onClick}\r\n      disabled={isDisabled}\r\n      className={`${variantClasses[variant]} ${className} ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}\r\n    >\r\n      <div className=\"flex items-center justify-center space-x-2\">\r\n        {isLoading && <LoadingSpinner size={spinnerSizes[size]} color=\"primary\" />}\r\n        <span>{children}</span>\r\n      </div>\r\n    </button>\r\n  );\r\n};\r\n\r\nexport default LoadingSpinner;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\LogAndAlertDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\LogViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\PositionPnLVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\StrategyMonitor.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":21,"column":14,"endLine":21,"endColumn":71,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":55,"column":36,"endLine":55,"endColumn":93,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":60,"column":54,"endLine":60,"endColumn":111,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":128,"column":50,"endLine":128,"endColumn":107,"severity":2,"nodeType":null},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":145,"column":12,"nodeType":"MemberExpression","endLine":145,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":342,"column":94,"endLine":342,"endColumn":151,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Strategy Monitor Component\r\n * \r\n * Real-time monitoring component for strategy performance, signals, and execution.\r\n * Integrates with WebSocket to display live strategy data.\r\n */\r\n\r\n\"use client\";\r\n\r\nimport type { StrategyPerformanceMetrics, SignalSummary} from '@jabbr/shared/src';\r\nimport { CONSTANTS, PositionSummary, RiskMetrics } from '@jabbr/shared/src';\r\nimport React, { useState } from 'react';\r\n\r\nimport useWebSocket from '../hooks/useWebSocket';\r\n\r\n// Temporary type definitions until shared types are fully available\r\ninterface StrategyUpdateMessage {\r\n  type: 'performance' | 'signal' | 'trade' | 'position' | 'risk_alert' | 'state_change';\r\n  botId: string;\r\n  strategyName: string;\r\n  data: any; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n  timestamp: Date;\r\n}\r\n\r\ninterface StrategyMonitorProps {\r\n  botId?: string; // If provided, monitor specific bot, otherwise monitor all\r\n  className?: string;\r\n}\r\n\r\ninterface StrategyData {\r\n  [botId: string]: StrategyPerformanceMetrics;\r\n}\r\n\r\nexport const StrategyMonitor: React.FC<StrategyMonitorProps> = ({ \r\n  botId, \r\n  className = \"\" \r\n}) => {\r\n  const [strategies, setStrategies] = useState<StrategyData>({});\r\n  const [recentSignals, setRecentSignals] = useState<SignalSummary[]>([]);\r\n  const [riskAlerts, setRiskAlerts] = useState<Array<{ botId: string; alerts: string[]; timestamp: Date }>>([]);\r\n  const [selectedBotId, setSelectedBotId] = useState<string | null>(botId || null);\r\n\r\n  const {\r\n    isConnected,\r\n    subscribe\r\n  } = useWebSocket({\r\n    url: 'ws://localhost:3002/ws',\r\n    onOpen: () => {\r\n      // Subscribe to strategy monitoring channels\r\n      subscribe(CONSTANTS.WS_CHANNELS.SIGNALS);\r\n      subscribe(CONSTANTS.WS_CHANNELS.BOT_STATUS);\r\n      subscribe(CONSTANTS.WS_CHANNELS.POSITIONS);\r\n      subscribe(CONSTANTS.WS_CHANNELS.TRADES);\r\n    },\r\n    onMessage: (message: any) => { // eslint-disable-line @typescript-eslint/no-explicit-any\r\n      handleWebSocketMessage(message);\r\n    }\r\n  });\r\n\r\n  const handleWebSocketMessage = (message: any) => { // eslint-disable-line @typescript-eslint/no-explicit-any\r\n    if (message.channel === CONSTANTS.WS_CHANNELS.SIGNALS && message.data) {\r\n      const update: StrategyUpdateMessage = message.data;\r\n      handleStrategyUpdate(update);\r\n    } else if (message.channel === CONSTANTS.WS_CHANNELS.BOT_STATUS && message.data) {\r\n      handleBotStatusUpdate(message.data);\r\n    }\r\n  };\r\n\r\n  const handleStrategyUpdate = (update: StrategyUpdateMessage) => {\r\n    const { type, botId: updateBotId, data, timestamp } = update;\r\n\r\n    // Filter by specific bot if specified\r\n    if (botId && updateBotId !== botId) {return;}\r\n\r\n    switch (type) {\r\n      case 'performance':\r\n        if (data.metrics) {\r\n          setStrategies(prev => ({\r\n            ...prev,\r\n            [updateBotId]: data.metrics\r\n          }));\r\n        }\r\n        break;\r\n\r\n      case 'signal':\r\n        if (data.signal) {\r\n          setRecentSignals(prev => {\r\n            // Keep last 20 signals\r\n            return [data.signal, ...prev].slice(0, 20);\r\n          });\r\n        }\r\n        break;\r\n\r\n      case 'trade':\r\n        // Update strategy metrics if trade data includes metrics\r\n        if (data.metrics) {\r\n          setStrategies(prev => ({\r\n            ...prev,\r\n            [updateBotId]: data.metrics\r\n          }));\r\n        }\r\n        break;\r\n\r\n      case 'state_change':\r\n        if (data.metrics) {\r\n          setStrategies(prev => ({\r\n            ...prev,\r\n            [updateBotId]: data.metrics\r\n          }));\r\n        }\r\n        break;\r\n\r\n      case 'risk_alert':\r\n        if (data.alerts) {\r\n          setRiskAlerts(prev => {\r\n            const newAlert = {\r\n              botId: updateBotId,\r\n              alerts: data.alerts,\r\n              timestamp: new Date(timestamp)\r\n            };\r\n            return [newAlert, ...prev].slice(0, 10); // Keep last 10 alerts\r\n          });\r\n        }\r\n        break;\r\n    }\r\n  };\r\n\r\n  const handleBotStatusUpdate = (data: any) => { // eslint-disable-line @typescript-eslint/no-explicit-any\r\n    if (data.botId && data.strategy) {\r\n      // Filter by specific bot if specified\r\n      if (botId && data.botId !== botId) {return;}\r\n\r\n      setStrategies(prev => ({\r\n        ...prev,\r\n        [data.botId]: {\r\n          ...prev[data.botId],\r\n          ...data.strategy,\r\n          timestamp: new Date()\r\n        }\r\n      }));\r\n    }\r\n  };\r\n\r\n  const getStrategyMetrics = (botId: string): StrategyPerformanceMetrics | null => {\r\n    return strategies[botId] || null;\r\n  };\r\n\r\n  const formatCurrency = (amount: number): string => {\r\n    return new Intl.NumberFormat('en-US', {\r\n      style: 'currency',\r\n      currency: 'USD',\r\n      minimumFractionDigits: 2,\r\n      maximumFractionDigits: 2\r\n    }).format(amount);\r\n  };\r\n\r\n  const formatPercentage = (value: number): string => {\r\n    return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;\r\n  };\r\n\r\n  const formatUptime = (uptime: number): string => {\r\n    const seconds = Math.floor(uptime / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const hours = Math.floor(minutes / 60);\r\n    \r\n    if (hours > 0) {\r\n      return `${hours}h ${minutes % 60}m`;\r\n    } else if (minutes > 0) {\r\n      return `${minutes}m ${seconds % 60}s`;\r\n    } \r\n      return `${seconds}s`;\r\n    \r\n  };\r\n\r\n  const getRiskColor = (riskScore: number): string => {\r\n    if (riskScore <= 3) {return 'text-green-600 bg-green-100';}\r\n    if (riskScore <= 6) {return 'text-yellow-600 bg-yellow-100';}\r\n    return 'text-red-600 bg-red-100';\r\n  };\r\n\r\n  const getStatusColor = (isRunning: boolean): string => {\r\n    return isRunning ? 'text-green-600 bg-green-100' : 'text-gray-600 bg-gray-100';\r\n  };\r\n\r\n  const selectedStrategy = selectedBotId ? getStrategyMetrics(selectedBotId) : null;\r\n  const allStrategies = Object.entries(strategies);\r\n\r\n  return (\r\n    <div className={`strategy-monitor ${className}`}>\r\n      {/* Header */}\r\n      <div className=\"flex justify-between items-center mb-6\">\r\n        <div>\r\n          <h2 className=\"text-2xl font-bold text-gray-900\">\r\n            📊 Strategy Monitor\r\n          </h2>\r\n          <p className=\"text-gray-600\">\r\n            Real-time strategy performance and signal monitoring\r\n          </p>\r\n        </div>\r\n        \r\n        <div className=\"flex items-center space-x-4\">\r\n          <span className={`text-sm font-semibold ${isConnected ? 'text-green-600' : 'text-red-600'}`}>\r\n            {isConnected ? '🟢 Live' : '🔴 Offline'}\r\n          </span>\r\n          \r\n          {allStrategies.length > 1 && (\r\n            <select\r\n              value={selectedBotId || ''}\r\n              onChange={(e) => setSelectedBotId(e.target.value || null)}\r\n              className=\"px-3 py-2 border border-gray-300 rounded-md text-sm\"\r\n            >\r\n              <option value=\"\">All Strategies</option>\r\n              {allStrategies.map(([botId, strategy]) => (\r\n                <option key={botId} value={botId}>\r\n                  {strategy.strategyName} ({botId})\r\n                </option>\r\n              ))}\r\n            </select>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Risk Alerts */}\r\n      {riskAlerts.length > 0 && (\r\n        <div className=\"mb-6 bg-red-50 border border-red-200 rounded-lg p-4\">\r\n          <h3 className=\"text-lg font-semibold text-red-800 mb-2\">⚠️ Risk Alerts</h3>\r\n          <div className=\"space-y-2\">\r\n            {riskAlerts.slice(0, 3).map((alert, index) => (\r\n              <div key={index} className=\"flex justify-between items-center\">\r\n                <div>\r\n                  <span className=\"font-medium text-red-700\">Bot {alert.botId}:</span>\r\n                  <span className=\"ml-2 text-red-600\">{alert.alerts.join(', ')}</span>\r\n                </div>\r\n                <span className=\"text-xs text-red-500\">\r\n                  {alert.timestamp.toLocaleTimeString()}\r\n                </span>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\r\n        {/* Strategy Performance Overview */}\r\n        <div className=\"lg:col-span-2\">\r\n          <div className=\"bg-white rounded-lg shadow-md p-6\">\r\n            <h3 className=\"text-lg font-semibold mb-4\">Strategy Performance</h3>\r\n            \r\n            {allStrategies.length === 0 ? (\r\n              <div className=\"text-center py-8\">\r\n                <div className=\"text-6xl mb-4\">📊</div>\r\n                <p className=\"text-gray-600\">No active strategies found</p>\r\n                <p className=\"text-sm text-gray-500 mt-2\">\r\n                  Start a bot to see real-time strategy monitoring\r\n                </p>\r\n              </div>\r\n            ) : (\r\n              <div className=\"space-y-4\">\r\n                {(selectedStrategy ? [[selectedBotId!, selectedStrategy]] : allStrategies)\r\n                  .filter(([, strategy]) => typeof strategy === 'object' && strategy !== null)\r\n                  .map(([strategyBotId, strategyData]) => {\r\n                    const strategy = strategyData as StrategyPerformanceMetrics;\r\n                    return (\r\n                  <div key={String(strategyBotId)} className=\"border border-gray-200 rounded-lg p-4\">\r\n                    {/* Strategy Header */}\r\n                    <div className=\"flex justify-between items-center mb-3\">\r\n                      <div>\r\n                        <h4 className=\"font-semibold text-gray-900\">\r\n                          {strategy.strategyName} v{strategy.strategyVersion}\r\n                        </h4>\r\n                        <p className=\"text-sm text-gray-600\">Bot ID: {String(strategyBotId)}</p>\r\n                      </div>\r\n                      \r\n                      <div className=\"flex items-center space-x-3\">\r\n                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(strategy.isRunning)}`}>\r\n                          {strategy.isRunning ? '🟢 Running' : '⚫ Stopped'}\r\n                        </span>\r\n                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${getRiskColor(strategy.riskMetrics.riskScore)}`}>\r\n                          Risk: {strategy.riskMetrics.riskScore}/10\r\n                        </span>\r\n                      </div>\r\n                    </div>\r\n\r\n                    {/* Key Metrics */}\r\n                    <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-4\">\r\n                      <div className=\"text-center\">\r\n                        <div className={`text-xl font-bold ${strategy.totalPnL >= 0 ? 'text-green-600' : 'text-red-600'}`}>\r\n                          {formatCurrency(strategy.totalPnL)}\r\n                        </div>\r\n                        <div className=\"text-xs text-gray-600\">Total P&L</div>\r\n                      </div>\r\n                      \r\n                      <div className=\"text-center\">\r\n                        <div className={`text-xl font-bold ${strategy.dailyPnL >= 0 ? 'text-green-600' : 'text-red-600'}`}>\r\n                          {formatCurrency(strategy.dailyPnL)}\r\n                        </div>\r\n                        <div className=\"text-xs text-gray-600\">Daily P&L</div>\r\n                      </div>\r\n                      \r\n                      <div className=\"text-center\">\r\n                        <div className=\"text-xl font-bold text-gray-900\">\r\n                          {strategy.winRate.toFixed(1)}%\r\n                        </div>\r\n                        <div className=\"text-xs text-gray-600\">Win Rate</div>\r\n                      </div>\r\n                      \r\n                      <div className=\"text-center\">\r\n                        <div className=\"text-xl font-bold text-gray-900\">\r\n                          {strategy.totalTrades}\r\n                        </div>\r\n                        <div className=\"text-xs text-gray-600\">Total Trades</div>\r\n                      </div>\r\n                    </div>\r\n\r\n                    {/* Detailed Stats */}\r\n                    <div className=\"grid grid-cols-3 gap-4 text-sm\">\r\n                      <div>\r\n                        <span className=\"text-gray-600\">Uptime:</span>\r\n                        <span className=\"ml-2 font-medium\">{formatUptime(strategy.uptime)}</span>\r\n                      </div>\r\n                      \r\n                      <div>\r\n                        <span className=\"text-gray-600\">Max Drawdown:</span>\r\n                        <span className=\"ml-2 font-medium text-red-600\">\r\n                          {formatPercentage(strategy.maxDrawdown)}\r\n                        </span>\r\n                      </div>\r\n                      \r\n                      <div>\r\n                        <span className=\"text-gray-600\">Current Drawdown:</span>\r\n                        <span className=\"ml-2 font-medium text-orange-600\">\r\n                          {formatPercentage(strategy.currentDrawdown)}\r\n                        </span>\r\n                      </div>\r\n                    </div>\r\n\r\n                    {/* Current Positions */}\r\n                    {strategy.currentPositions && strategy.currentPositions.length > 0 && (\r\n                      <div className=\"mt-4 pt-4 border-t border-gray-200\">\r\n                        <h5 className=\"font-medium text-gray-900 mb-2\">Current Positions</h5>\r\n                        <div className=\"space-y-2\">\r\n                          {strategy.currentPositions.map((position: any, index: number) => ( // eslint-disable-line @typescript-eslint/no-explicit-any\r\n                            <div key={index} className=\"flex justify-between items-center text-sm\">\r\n                              <span className=\"font-medium\">\r\n                                {position.symbol} {position.side.toUpperCase()}\r\n                              </span>\r\n                              <span className=\"text-gray-600\">\r\n                                Size: {position.size} @ {formatCurrency(position.entryPrice)}\r\n                              </span>\r\n                              <span className={`font-medium ${position.unrealizedPnL >= 0 ? 'text-green-600' : 'text-red-600'}`}>\r\n                                {formatCurrency(position.unrealizedPnL)}\r\n                              </span>\r\n                            </div>\r\n                          ))}\r\n                        </div>\r\n                      </div>\r\n                    )}\r\n                  </div>\r\n                    );\r\n                  })}\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        {/* Recent Signals */}\r\n        <div>\r\n          <div className=\"bg-white rounded-lg shadow-md p-6\">\r\n            <h3 className=\"text-lg font-semibold mb-4\">Recent Signals</h3>\r\n            \r\n            {recentSignals.length === 0 ? (\r\n              <div className=\"text-center py-8\">\r\n                <div className=\"text-4xl mb-2\">📡</div>\r\n                <p className=\"text-gray-600 text-sm\">No signals yet</p>\r\n              </div>\r\n            ) : (\r\n              <div className=\"space-y-3 max-h-96 overflow-y-auto\">\r\n                {recentSignals.map((signal) => (\r\n                  <div key={signal.id} className=\"border border-gray-200 rounded p-3\">\r\n                    <div className=\"flex justify-between items-center mb-2\">\r\n                      <span className=\"font-medium text-gray-900\">\r\n                        {signal.symbol}\r\n                      </span>\r\n                      <span className={`px-2 py-1 rounded text-xs font-medium ${\r\n                        signal.side === 'buy' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'\r\n                      }`}>\r\n                        {signal.side.toUpperCase()}\r\n                      </span>\r\n                    </div>\r\n                    \r\n                    <div className=\"text-sm text-gray-600 space-y-1\">\r\n                      <div className=\"flex justify-between\">\r\n                        <span>Price:</span>\r\n                        <span className=\"font-medium\">{formatCurrency(signal.price)}</span>\r\n                      </div>\r\n                      \r\n                      <div className=\"flex justify-between\">\r\n                        <span>Confidence:</span>\r\n                        <span className=\"font-medium\">{(signal.confidence * 100).toFixed(1)}%</span>\r\n                      </div>\r\n                      \r\n                      <div className=\"flex justify-between\">\r\n                        <span>Time:</span>\r\n                        <span className=\"font-medium\">\r\n                          {signal.timestamp.toLocaleTimeString()}\r\n                        </span>\r\n                      </div>\r\n                      \r\n                      <div className=\"flex justify-between\">\r\n                        <span>Status:</span>\r\n                        <span className={`font-medium ${\r\n                          signal.executed \r\n                            ? signal.result === 'win' \r\n                              ? 'text-green-600' \r\n                              : signal.result === 'loss' \r\n                                ? 'text-red-600' \r\n                                : 'text-blue-600'\r\n                            : 'text-yellow-600'\r\n                        }`}>\r\n                          {signal.executed \r\n                            ? signal.result?.toUpperCase() || 'EXECUTED' \r\n                            : 'PENDING'}\r\n                        </span>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Summary Statistics */}\r\n      {allStrategies.length > 1 && !selectedBotId && (\r\n        <div className=\"mt-6 bg-white rounded-lg shadow-md p-6\">\r\n          <h3 className=\"text-lg font-semibold mb-4\">Portfolio Summary</h3>\r\n          <div className=\"grid grid-cols-2 md:grid-cols-5 gap-4\">\r\n            <div className=\"text-center\">\r\n              <div className=\"text-2xl font-bold text-gray-900\">{allStrategies.length}</div>\r\n              <div className=\"text-sm text-gray-600\">Active Strategies</div>\r\n            </div>\r\n            \r\n            <div className=\"text-center\">\r\n              <div className=\"text-2xl font-bold text-green-600\">\r\n                {allStrategies.filter(([, strategy]) => strategy.isRunning).length}\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">Running</div>\r\n            </div>\r\n            \r\n            <div className=\"text-center\">\r\n              <div className={`text-2xl font-bold ${\r\n                allStrategies.reduce((sum, [, strategy]) => sum + strategy.totalPnL, 0) >= 0 ? 'text-green-600' : 'text-red-600'\r\n              }`}>\r\n                {formatCurrency(allStrategies.reduce((sum, [, strategy]) => sum + strategy.totalPnL, 0))}\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">Total P&L</div>\r\n            </div>\r\n            \r\n            <div className=\"text-center\">\r\n              <div className=\"text-2xl font-bold text-gray-900\">\r\n                {allStrategies.reduce((sum, [, strategy]) => sum + strategy.totalTrades, 0)}\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">Total Trades</div>\r\n            </div>\r\n            \r\n            <div className=\"text-center\">\r\n              <div className=\"text-2xl font-bold text-gray-900\">\r\n                {allStrategies.length > 0 \r\n                  ? (allStrategies.reduce((sum, [, strategy]) => sum + strategy.winRate, 0) / allStrategies.length).toFixed(1)\r\n                  : '0.0'\r\n                }%\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">Avg Win Rate</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default StrategyMonitor;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\TradingActivityMonitor.tsx","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":291,"column":12,"nodeType":"MemberExpression","endLine":291,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useEffect, useMemo } from 'react';\r\n\r\nimport type { ApiError } from '../services/api';\r\n\r\nimport { useWebSocketContext } from '../contexts/WebSocketContext';\r\nimport { apiService } from '../services/api';\r\nimport { componentClasses, getPnLColor } from '../utils/theme';\r\nimport ErrorHandler from '../utils/errorHandler';\r\n\r\nimport { ErrorBoundaryWrapper } from './ErrorBoundary';\r\nimport { LoadingState, LoadingTable } from './Loading';\r\n\r\n// Types for trading activity data\r\ninterface Trade {\r\n  id: string;\r\n  botId: string;\r\n  botName: string;\r\n  symbol: string;\r\n  side: 'buy' | 'sell';\r\n  type: 'market' | 'limit' | 'stop' | 'stop-limit';\r\n  amount: number;\r\n  price: number;\r\n  executedPrice?: number;\r\n  executedAmount?: number;\r\n  status: 'pending' | 'filled' | 'partial' | 'cancelled' | 'rejected';\r\n  fee: number;\r\n  pnl?: number;\r\n  timestamp: string;\r\n  orderId: string;\r\n  exchange: string;\r\n  strategy: string;\r\n  slippage?: number;\r\n  executionTime?: number;\r\n}\r\n\r\ninterface OrderUpdate {\r\n  orderId: string;\r\n  botId: string;\r\n  status: 'pending' | 'filled' | 'partial' | 'cancelled' | 'rejected';\r\n  filledAmount?: number;\r\n  remainingAmount?: number;\r\n  averagePrice?: number;\r\n  fee?: number;\r\n  timestamp: string;\r\n}\r\n\r\ninterface TradingMetrics {\r\n  totalTrades: number;\r\n  totalVolume: number;\r\n  totalPnL: number;\r\n  winRate: number;\r\n  averageExecutionTime: number;\r\n  averageSlippage: number;\r\n  successRate: number;\r\n  activeBots: number;\r\n}\r\n\r\ninterface FilterOptions {\r\n  botId?: string;\r\n  symbol?: string;\r\n  side?: 'buy' | 'sell' | 'all';\r\n  status?: 'all' | 'pending' | 'filled' | 'partial' | 'cancelled' | 'rejected';\r\n  exchange?: string;\r\n  timeframe?: '1h' | '24h' | '7d' | '30d' | 'all';\r\n}\r\n\r\ninterface SortOptions {\r\n  field: 'timestamp' | 'symbol' | 'amount' | 'price' | 'pnl' | 'status';\r\n  direction: 'asc' | 'desc';\r\n}\r\n\r\nexport const TradingActivityMonitor: React.FC = () => {\r\n  // State management\r\n  const [trades, setTrades] = useState<Trade[]>([]);\r\n  const [orderUpdates, setOrderUpdates] = useState<OrderUpdate[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [filters, setFilters] = useState<FilterOptions>({\r\n    side: 'all',\r\n    status: 'all',\r\n    timeframe: '24h'\r\n  });\r\n  const [sortOptions, setSortOptions] = useState<SortOptions>({\r\n    field: 'timestamp',\r\n    direction: 'desc'\r\n  });\r\n  const [selectedTrade, setSelectedTrade] = useState<Trade | null>(null);\r\n  const [showOrderDetails, setShowOrderDetails] = useState(false);\r\n\r\n  // WebSocket context\r\n  const { \r\n    isConnected, \r\n    subscribe, \r\n    unsubscribe,\r\n    marketData,\r\n    botStatuses \r\n  } = useWebSocketContext();\r\n\r\n  // Load initial trading data\r\n  useEffect(() => {\r\n    const loadTradingData = async () => {\r\n      setIsLoading(true);\r\n      setError(null);\r\n      \r\n      try {\r\n        const response = await apiService.getTrades({\r\n          timeframe: filters.timeframe,\r\n          symbol: filters.symbol,\r\n          status: filters.status !== 'all' ? filters.status : undefined,\r\n        });\r\n\r\n        if (response.success) {\r\n          setTrades(response.data as unknown as Trade[] || []);\r\n        } else {\r\n          throw new Error(response.error || 'Failed to load trading data');\r\n        }\r\n      } catch (err) {\r\n        console.error('Error loading trading data:', err);\r\n        const errorState = ErrorHandler.handleUnknownError(err, 'Loading trading data');\r\n        setError(errorState.message);\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    loadTradingData();\r\n  }, [filters.timeframe, filters.symbol, filters.status]);\r\n\r\n  // Subscribe to real-time updates\r\n  useEffect(() => {\r\n    if (isConnected) {\r\n      // Subscribe to trade updates\r\n      subscribe('trades');\r\n      subscribe('orders');\r\n      subscribe('positions');\r\n\r\n      return () => {\r\n        unsubscribe('trades');\r\n        unsubscribe('orders');\r\n        unsubscribe('positions');\r\n      };\r\n    }\r\n  }, [isConnected, subscribe, unsubscribe]);\r\n\r\n  // Filter and sort trades\r\n  const filteredAndSortedTrades = useMemo(() => {\r\n    const filtered = trades.filter(trade => {\r\n      // Filter by bot\r\n      if (filters.botId && trade.botId !== filters.botId) {\r\n        return false;\r\n      }\r\n      \r\n      // Filter by symbol\r\n      if (filters.symbol && trade.symbol !== filters.symbol) {\r\n        return false;\r\n      }\r\n      \r\n      // Filter by side\r\n      if (filters.side && filters.side !== 'all' && trade.side !== filters.side) {\r\n        return false;\r\n      }\r\n      \r\n      // Filter by status\r\n      if (filters.status && filters.status !== 'all' && trade.status !== filters.status) {\r\n        return false;\r\n      }\r\n      \r\n      // Filter by exchange\r\n      if (filters.exchange && trade.exchange !== filters.exchange) {\r\n        return false;\r\n      }\r\n      \r\n      // Filter by timeframe\r\n      if (filters.timeframe && filters.timeframe !== 'all') {\r\n        const tradeTime = new Date(trade.timestamp);\r\n        const now = new Date();\r\n        const timeDiff = now.getTime() - tradeTime.getTime();\r\n        \r\n        switch (filters.timeframe) {\r\n          case '1h':\r\n            if (timeDiff > 60 * 60 * 1000) {\r\n              return false;\r\n            }\r\n            break;\r\n          case '24h':\r\n            if (timeDiff > 24 * 60 * 60 * 1000) {\r\n              return false;\r\n            }\r\n            break;\r\n          case '7d':\r\n            if (timeDiff > 7 * 24 * 60 * 60 * 1000) {\r\n              return false;\r\n            }\r\n            break;\r\n          case '30d':\r\n            if (timeDiff > 30 * 24 * 60 * 60 * 1000) {\r\n              return false;\r\n            }\r\n            break;\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    });\r\n\r\n    // Sort trades\r\n    filtered.sort((a, b) => {\r\n      const direction = sortOptions.direction === 'asc' ? 1 : -1;\r\n      \r\n      switch (sortOptions.field) {\r\n        case 'timestamp':\r\n          return direction * (new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\r\n        case 'symbol':\r\n          return direction * a.symbol.localeCompare(b.symbol);\r\n        case 'amount':\r\n          return direction * (a.amount - b.amount);\r\n        case 'price':\r\n          return direction * (a.price - b.price);\r\n        case 'pnl':\r\n          return direction * ((a.pnl || 0) - (b.pnl || 0));\r\n        case 'status':\r\n          return direction * a.status.localeCompare(b.status);\r\n        default:\r\n          return 0;\r\n      }\r\n    });\r\n\r\n    return filtered;\r\n  }, [trades, filters, sortOptions]);\r\n\r\n  // Calculate trading metrics\r\n  const tradingMetrics = useMemo((): TradingMetrics => {\r\n    const filledTrades = filteredAndSortedTrades.filter(trade => trade.status === 'filled');\r\n    const totalVolume = filledTrades.reduce((sum, trade) => sum + (trade.amount * trade.price), 0);\r\n    const totalPnL = filledTrades.reduce((sum, trade) => sum + (trade.pnl || 0), 0);\r\n    const winningTrades = filledTrades.filter(trade => (trade.pnl || 0) > 0);\r\n    const tradesWithExecutionTime = filledTrades.filter(trade => trade.executionTime);\r\n    const tradesWithSlippage = filledTrades.filter(trade => trade.slippage !== undefined);\r\n    const activeBots = new Set(trades.map(trade => trade.botId)).size;\r\n\r\n    return {\r\n      totalTrades: filledTrades.length,\r\n      totalVolume,\r\n      totalPnL,\r\n      winRate: filledTrades.length > 0 ? (winningTrades.length / filledTrades.length) * 100 : 0,\r\n      averageExecutionTime: tradesWithExecutionTime.length > 0 \r\n        ? tradesWithExecutionTime.reduce((sum, trade) => sum + (trade.executionTime || 0), 0) / tradesWithExecutionTime.length \r\n        : 0,\r\n      averageSlippage: tradesWithSlippage.length > 0\r\n        ? tradesWithSlippage.reduce((sum, trade) => sum + (trade.slippage || 0), 0) / tradesWithSlippage.length\r\n        : 0,\r\n      successRate: trades.length > 0 ? (filledTrades.length / trades.length) * 100 : 0,\r\n      activeBots\r\n    };\r\n  }, [filteredAndSortedTrades, trades]);\r\n\r\n  // Utility functions\r\n  const formatCurrency = (amount: number, currency = 'USDT'): string => {\r\n    return new Intl.NumberFormat('en-US', {\r\n      style: 'currency',\r\n      currency: currency === 'USDT' ? 'USD' : currency,\r\n      minimumFractionDigits: 2,\r\n      maximumFractionDigits: 6\r\n    }).format(amount);\r\n  };\r\n\r\n  const formatPercentage = (value: number): string => {\r\n    return `${value.toFixed(2)}%`;\r\n  };\r\n\r\n  const formatTime = (timestamp: string): string => {\r\n    return new Intl.DateTimeFormat('en-US', {\r\n      month: 'short',\r\n      day: 'numeric',\r\n      hour: '2-digit',\r\n      minute: '2-digit',\r\n      second: '2-digit'\r\n    }).format(new Date(timestamp));\r\n  };\r\n\r\n  const getTradingStatusColor = (status: string): string => {\r\n    const statusMap: Record<string, string> = {\r\n      filled: 'text-status-success bg-status-success/10 border-status-success/20',\r\n      pending: 'text-status-warning bg-status-warning/10 border-status-warning/20',\r\n      partial: 'text-brand-primary bg-brand-primary/10 border-brand-primary/20',\r\n      cancelled: 'text-muted bg-surface-secondary border-border',\r\n      rejected: 'text-status-error bg-status-error/10 border-status-error/20',\r\n    };\r\n    return statusMap[status] || 'text-muted bg-surface-secondary border-border';\r\n  };\r\n\r\n  const getSideColor = (side: string): string => {\r\n    return side === 'buy' ? 'text-status-success' : 'text-status-error';\r\n  };\r\n\r\n  // Event handlers\r\n  const handleFilterChange = (newFilters: Partial<FilterOptions>) => {\r\n    setFilters(prev => ({ ...prev, ...newFilters }));\r\n  };\r\n\r\n  const handleSortChange = (field: SortOptions['field']) => {\r\n    setSortOptions(prev => ({\r\n      field,\r\n      direction: prev.field === field && prev.direction === 'desc' ? 'asc' : 'desc'\r\n    }));\r\n  };\r\n\r\n  const handleTradeClick = (trade: Trade) => {\r\n    setSelectedTrade(trade);\r\n    setShowOrderDetails(true);\r\n  };\r\n\r\n  const handleRefresh = () => {\r\n    window.location.reload();\r\n  };\r\n\r\n  return (\r\n    <ErrorBoundaryWrapper>\r\n      <div className=\"trading-activity-monitor space-y-6\">\r\n        {/* Header */}\r\n        <div className=\"flex items-center justify-between\">\r\n          <div>\r\n            <h2 className=\"text-2xl font-bold text-primary\">Trading Activity Monitor</h2>\r\n            <p className=\"text-secondary mt-1\">\r\n              Real-time monitoring of all trading activity across your bots\r\n            </p>\r\n          </div>\r\n          \r\n          <div className=\"flex items-center space-x-3\">\r\n            {/* Connection Status */}\r\n            <div className={`flex items-center space-x-2 px-3 py-2 rounded-lg text-sm ${\r\n              isConnected \r\n                ? 'bg-status-success/10 text-status-success border border-status-success/20' \r\n                : 'bg-status-error/10 text-status-error border border-status-error/20'\r\n            }`}>\r\n              <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-status-success' : 'bg-status-error'}`} />\r\n              <span className=\"font-medium\">\r\n                {isConnected ? 'Live' : 'Disconnected'}\r\n              </span>\r\n            </div>\r\n            \r\n            {/* Refresh Button */}\r\n            <button\r\n              onClick={handleRefresh}\r\n              disabled={isLoading}\r\n              className={`${componentClasses.button.secondary} flex items-center space-x-2`}\r\n            >\r\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\r\n              </svg>\r\n              <span>Refresh</span>\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n      {/* Trading Metrics Cards */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6\">\r\n        <div className={componentClasses.card}>\r\n          <div className=\"flex items-center justify-between mb-4\">\r\n            <div>\r\n              <h3 className=\"text-sm font-medium text-secondary\">Total Trades</h3>\r\n              <svg className=\"w-6 h-6 text-brand-primary mt-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\" />\r\n              </svg>\r\n            </div>\r\n          </div>\r\n          <div className=\"text-2xl font-bold text-primary\">{tradingMetrics.totalTrades.toLocaleString()}</div>\r\n          <div className=\"text-sm text-muted mt-1\">\r\n            {tradingMetrics.activeBots} active bots\r\n          </div>\r\n        </div>\r\n\r\n        <div className={componentClasses.card}>\r\n          <div className=\"flex items-center justify-between mb-4\">\r\n            <div>\r\n              <h3 className=\"text-sm font-medium text-secondary\">Total Volume</h3>\r\n              <svg className=\"w-6 h-6 text-brand-secondary mt-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1\" />\r\n              </svg>\r\n            </div>\r\n          </div>\r\n          <div className=\"text-2xl font-bold text-primary\">{formatCurrency(tradingMetrics.totalVolume)}</div>\r\n          <div className=\"text-sm text-muted mt-1\">\r\n            Success Rate: {formatPercentage(tradingMetrics.successRate)}\r\n          </div>\r\n        </div>\r\n\r\n        <div className={componentClasses.card}>\r\n          <div className=\"flex items-center justify-between mb-4\">\r\n            <div>\r\n              <h3 className=\"text-sm font-medium text-secondary\">Total P&L</h3>\r\n              <svg className=\"w-6 h-6 text-status-success mt-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 7h8m0 0v8m0-8l-8 8-4-4-6 6\" />\r\n              </svg>\r\n            </div>\r\n          </div>\r\n          <div className={`text-2xl font-bold ${getPnLColor(tradingMetrics.totalPnL)}`}>\r\n            {formatCurrency(tradingMetrics.totalPnL)}\r\n          </div>\r\n          <div className=\"text-sm text-muted mt-1\">\r\n            Win Rate: {formatPercentage(tradingMetrics.winRate)}\r\n          </div>\r\n        </div>\r\n\r\n        <div className={componentClasses.card}>\r\n          <div className=\"flex items-center justify-between mb-4\">\r\n            <div>\r\n              <h3 className=\"text-sm font-medium text-secondary\">Avg Execution</h3>\r\n              <svg className=\"w-6 h-6 text-status-warning mt-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\r\n              </svg>\r\n            </div>\r\n          </div>\r\n          <div className=\"text-2xl font-bold text-primary\">{tradingMetrics.averageExecutionTime.toFixed(0)}ms</div>\r\n          <div className=\"text-sm text-muted mt-1\">\r\n            Avg Slippage: {formatPercentage(tradingMetrics.averageSlippage)}\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Filter Controls */}\r\n      <div className={componentClasses.card}>\r\n        <div className=\"flex items-center gap-2 mb-4\">\r\n          <svg className=\"w-5 h-5 text-secondary\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z\" />\r\n          </svg>\r\n          <h3 className=\"text-lg font-semibold text-primary\">Filters & Controls</h3>\r\n        </div>\r\n        \r\n        <div className=\"grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4\">\r\n          {/* Timeframe Filter */}\r\n          <div>\r\n            <label className=\"block text-sm font-medium text-secondary mb-2\">\r\n              Timeframe\r\n            </label>\r\n            <select\r\n              value={filters.timeframe}\r\n              onChange={(e) => handleFilterChange({ timeframe: e.target.value as FilterOptions['timeframe'] })}\r\n              className={componentClasses.form.select}\r\n            >\r\n              <option value=\"1h\">Last Hour</option>\r\n              <option value=\"24h\">Last 24h</option>\r\n              <option value=\"7d\">Last 7 days</option>\r\n              <option value=\"30d\">Last 30 days</option>\r\n              <option value=\"all\">All Time</option>\r\n            </select>\r\n          </div>\r\n\r\n          {/* Side Filter */}\r\n          <div>\r\n            <label className=\"block text-sm font-medium text-secondary mb-2\">\r\n              Side\r\n            </label>\r\n            <select\r\n              value={filters.side}\r\n              onChange={(e) => handleFilterChange({ side: e.target.value as FilterOptions['side'] })}\r\n              className={componentClasses.form.select}\r\n            >\r\n              <option value=\"all\">All</option>\r\n              <option value=\"buy\">Buy Only</option>\r\n              <option value=\"sell\">Sell Only</option>\r\n            </select>\r\n          </div>\r\n\r\n          {/* Status Filter */}\r\n          <div>\r\n            <label className=\"block text-sm font-medium text-secondary mb-2\">\r\n              Status\r\n            </label>\r\n            <select\r\n              value={filters.status}\r\n              onChange={(e) => handleFilterChange({ status: e.target.value as FilterOptions['status'] })}\r\n              className={componentClasses.form.select}\r\n            >\r\n              <option value=\"all\">All</option>\r\n              <option value=\"filled\">Filled</option>\r\n              <option value=\"pending\">Pending</option>\r\n              <option value=\"partial\">Partial</option>\r\n              <option value=\"cancelled\">Cancelled</option>\r\n              <option value=\"rejected\">Rejected</option>\r\n            </select>\r\n          </div>\r\n\r\n          {/* Symbol Filter */}\r\n          <div>\r\n            <label className=\"block text-sm font-medium text-secondary mb-2\">\r\n              Symbol\r\n            </label>\r\n            <input\r\n              type=\"text\"\r\n              value={filters.symbol || ''}\r\n              onChange={(e) => handleFilterChange({ symbol: e.target.value || undefined })}\r\n              placeholder=\"e.g., BTCUSDT\"\r\n              className={componentClasses.form.input}\r\n            />\r\n          </div>\r\n\r\n          {/* Exchange Filter */}\r\n          <div>\r\n            <label className=\"block text-sm font-medium text-secondary mb-2\">\r\n              Exchange\r\n            </label>\r\n            <select\r\n              value={filters.exchange || ''}\r\n              onChange={(e) => handleFilterChange({ exchange: e.target.value || undefined })}\r\n              className={componentClasses.form.select}\r\n            >\r\n              <option value=\"\">All Exchanges</option>\r\n              <option value=\"bybit\">Bybit</option>\r\n              <option value=\"binance\">Binance</option>\r\n              <option value=\"okx\">OKX</option>\r\n              <option value=\"coinbase\">Coinbase</option>\r\n              <option value=\"kraken\">Kraken</option>\r\n            </select>\r\n          </div>\r\n\r\n          {/* Clear Filters */}\r\n          <div className=\"flex items-end\">\r\n            <button\r\n              onClick={() => setFilters({ side: 'all', status: 'all', timeframe: '24h' })}\r\n              className={`${componentClasses.button.secondary} w-full`}\r\n            >\r\n              Clear Filters\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n        {/* Loading State */}\r\n        {isLoading && (\r\n          <LoadingTable rows={8} columns={10} className=\"mb-6\" />\r\n        )}\r\n\r\n        {/* Error State */}\r\n        {error && (\r\n          <div className=\"bg-status-error/10 border border-status-error/20 rounded-lg p-4 mb-6\">\r\n            <div className=\"flex items-start\">\r\n              <svg className=\"w-5 h-5 text-status-error mr-3 mt-0.5 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.998-.833-2.768 0L3.046 16.5c-.77.833.192 2.5 1.732 2.5z\" />\r\n              </svg>\r\n              <div>\r\n                <h4 className=\"font-medium text-status-error\">Error Loading Trading Data</h4>\r\n                <p className=\"text-sm text-status-error/80 mt-1\">{error}</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Trading Activity Table */}\r\n        {!isLoading && !error && (\r\n          <div className={componentClasses.card}>\r\n            <div className=\"flex items-center justify-between mb-6\">\r\n              <h3 className=\"text-lg font-semibold text-primary\">\r\n                Recent Trading Activity ({filteredAndSortedTrades.length} trades)\r\n              </h3>\r\n              <div className=\"text-sm text-secondary\">\r\n                Last updated: {new Date().toLocaleTimeString()}\r\n              </div>\r\n            </div>\r\n            \r\n            {filteredAndSortedTrades.length === 0 ? (\r\n              <div className=\"text-center py-12\">\r\n                <svg className=\"w-12 h-12 text-muted mx-auto mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\" />\r\n                </svg>\r\n                <h4 className=\"text-lg font-medium text-primary mb-2\">No Trading Activity</h4>\r\n                <p className=\"text-secondary\">\r\n                  No trades found matching your current filters. Try adjusting the filters or check if your bots are running.\r\n                </p>\r\n              </div>\r\n            ) : (\r\n              <div className=\"overflow-x-auto\">\r\n                <table className=\"w-full\">\r\n                  <thead className=\"bg-surface-secondary\">\r\n                    <tr>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">\r\n                        <button\r\n                          onClick={() => handleSortChange('timestamp')}\r\n                          className=\"flex items-center space-x-1 hover:text-primary transition-colors\"\r\n                        >\r\n                          <span>Time</span>\r\n                          {sortOptions.field === 'timestamp' && (\r\n                            <span className=\"text-brand-primary\">\r\n                              {sortOptions.direction === 'desc' ? '↓' : '↑'}\r\n                            </span>\r\n                          )}\r\n                        </button>\r\n                      </th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">Bot</th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">\r\n                        <button\r\n                          onClick={() => handleSortChange('symbol')}\r\n                          className=\"flex items-center space-x-1 hover:text-primary transition-colors\"\r\n                        >\r\n                          <span>Symbol</span>\r\n                          {sortOptions.field === 'symbol' && (\r\n                            <span className=\"text-brand-primary\">\r\n                              {sortOptions.direction === 'desc' ? '↓' : '↑'}\r\n                            </span>\r\n                          )}\r\n                        </button>\r\n                      </th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">Side</th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">Type</th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">\r\n                        <button\r\n                          onClick={() => handleSortChange('amount')}\r\n                          className=\"flex items-center space-x-1 hover:text-primary transition-colors\"\r\n                        >\r\n                          <span>Amount</span>\r\n                          {sortOptions.field === 'amount' && (\r\n                            <span className=\"text-brand-primary\">\r\n                              {sortOptions.direction === 'desc' ? '↓' : '↑'}\r\n                            </span>\r\n                          )}\r\n                        </button>\r\n                      </th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">\r\n                        <button\r\n                          onClick={() => handleSortChange('price')}\r\n                          className=\"flex items-center space-x-1 hover:text-primary transition-colors\"\r\n                        >\r\n                          <span>Price</span>\r\n                          {sortOptions.field === 'price' && (\r\n                            <span className=\"text-brand-primary\">\r\n                              {sortOptions.direction === 'desc' ? '↓' : '↑'}\r\n                            </span>\r\n                          )}\r\n                        </button>\r\n                      </th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">\r\n                        <button\r\n                          onClick={() => handleSortChange('status')}\r\n                          className=\"flex items-center space-x-1 hover:text-primary transition-colors\"\r\n                        >\r\n                          <span>Status</span>\r\n                          {sortOptions.field === 'status' && (\r\n                            <span className=\"text-brand-primary\">\r\n                              {sortOptions.direction === 'desc' ? '↓' : '↑'}\r\n                            </span>\r\n                          )}\r\n                        </button>\r\n                      </th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">\r\n                        <button\r\n                          onClick={() => handleSortChange('pnl')}\r\n                          className=\"flex items-center space-x-1 hover:text-primary transition-colors\"\r\n                        >\r\n                          <span>P&L</span>\r\n                          {sortOptions.field === 'pnl' && (\r\n                            <span className=\"text-brand-primary\">\r\n                              {sortOptions.direction === 'desc' ? '↓' : '↑'}\r\n                            </span>\r\n                          )}\r\n                        </button>\r\n                      </th>\r\n                      <th className=\"px-6 py-3 text-left text-xs font-medium text-secondary uppercase tracking-wider\">Actions</th>\r\n                    </tr>\r\n                  </thead>\r\n                  <tbody className=\"bg-white divide-y divide-border\">\r\n                    {filteredAndSortedTrades.map((trade) => (\r\n                      <tr key={trade.id} className=\"hover:bg-surface-secondary/50 transition-colors cursor-pointer\">\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <div className=\"text-sm text-primary font-medium\">\r\n                            {formatTime(trade.timestamp)}\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <div className=\"text-sm\">\r\n                            <div className=\"font-medium text-primary\">{trade.botName}</div>\r\n                            <div className=\"text-xs text-secondary\">{trade.strategy}</div>\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <div className=\"flex items-center space-x-2\">\r\n                            <span className=\"font-medium text-primary\">{trade.symbol}</span>\r\n                            <span className=\"text-xs text-secondary bg-surface-secondary px-2 py-1 rounded-full\">\r\n                              {trade.exchange}\r\n                            </span>\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <span className={`font-medium ${getSideColor(trade.side)}`}>\r\n                            {trade.side.toUpperCase()}\r\n                          </span>\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <span className=\"text-sm text-secondary capitalize\">\r\n                            {trade.type}\r\n                          </span>\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <div className=\"text-sm\">\r\n                            <div className=\"font-medium text-primary\">\r\n                              {trade.amount.toLocaleString(undefined, { \r\n                                minimumFractionDigits: 2, \r\n                                maximumFractionDigits: 8 \r\n                              })}\r\n                            </div>\r\n                            {trade.executedAmount && trade.executedAmount !== trade.amount && (\r\n                              <div className=\"text-xs text-secondary\">\r\n                                Filled: {trade.executedAmount.toLocaleString(undefined, { \r\n                                  minimumFractionDigits: 2, \r\n                                  maximumFractionDigits: 8 \r\n                                })}\r\n                              </div>\r\n                            )}\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <div className=\"text-sm\">\r\n                            <div className=\"font-medium text-primary\">\r\n                              {formatCurrency(trade.price)}\r\n                            </div>\r\n                            {trade.executedPrice && trade.executedPrice !== trade.price && (\r\n                              <div className=\"text-xs text-secondary\">\r\n                                Exec: {formatCurrency(trade.executedPrice)}\r\n                              </div>\r\n                            )}\r\n                            {trade.slippage !== undefined && (\r\n                              <div className=\"text-xs text-status-warning\">\r\n                                Slippage: {formatPercentage(trade.slippage)}\r\n                              </div>\r\n                            )}\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <span className={`px-2 py-1 text-xs font-semibold rounded-full border ${getTradingStatusColor(trade.status)}`}>\r\n                            {trade.status}\r\n                          </span>\r\n                          {trade.executionTime && (\r\n                            <div className=\"text-xs text-secondary mt-1\">\r\n                              {trade.executionTime}ms\r\n                            </div>\r\n                          )}\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          {trade.pnl !== undefined ? (\r\n                            <div className={`text-sm font-medium ${getPnLColor(trade.pnl)}`}>\r\n                              {formatCurrency(trade.pnl)}\r\n                            </div>\r\n                          ) : (\r\n                            <span className=\"text-xs text-secondary\">-</span>\r\n                          )}\r\n                        </td>\r\n                        <td className=\"px-6 py-4 whitespace-nowrap\">\r\n                          <button\r\n                            onClick={() => handleTradeClick(trade)}\r\n                            className={`${componentClasses.button.secondary} text-sm px-3 py-1`}\r\n                          >\r\n                            Details\r\n                          </button>\r\n                        </td>\r\n                      </tr>\r\n                    ))}\r\n                  </tbody>\r\n                </table>\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n\r\n      {/* Trade Details Modal */}\r\n      {showOrderDetails && selectedTrade && (\r\n        <div className={componentClasses.modal.overlay} onClick={() => setShowOrderDetails(false)}>\r\n          <div className={componentClasses.modal.content} onClick={(e) => e.stopPropagation()}>\r\n            <div className={componentClasses.modal.header}>\r\n              <h3 className={componentClasses.modal.title}>Trade Details</h3>\r\n              <button\r\n                onClick={() => setShowOrderDetails(false)}\r\n                className={componentClasses.modal.closeButton}\r\n              >\r\n                <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\r\n                </svg>\r\n              </button>\r\n            </div>\r\n            <div className={componentClasses.modal.body}>\r\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\r\n                <div>\r\n                  <h4 className=\"font-semibold text-primary mb-3\">Basic Information</h4>\r\n                  <div className=\"space-y-2\">\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Trade ID:</span>\r\n                      <span className=\"font-mono text-sm\">{selectedTrade.id}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Order ID:</span>\r\n                      <span className=\"font-mono text-sm\">{selectedTrade.orderId}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Bot:</span>\r\n                      <span>{selectedTrade.botName}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Strategy:</span>\r\n                      <span>{selectedTrade.strategy}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Exchange:</span>\r\n                      <span className=\"capitalize\">{selectedTrade.exchange}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Symbol:</span>\r\n                      <span className=\"font-medium\">{selectedTrade.symbol}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Timestamp:</span>\r\n                      <span>{new Date(selectedTrade.timestamp).toLocaleString()}</span>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n\r\n                <div>\r\n                  <h4 className=\"font-semibold text-primary mb-3\">Trade Details</h4>\r\n                  <div className=\"space-y-2\">\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Side:</span>\r\n                      <span className={`font-medium ${getSideColor(selectedTrade.side)}`}>\r\n                        {selectedTrade.side.toUpperCase()}\r\n                      </span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Type:</span>\r\n                      <span className=\"capitalize\">{selectedTrade.type}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Amount:</span>\r\n                      <span>{selectedTrade.amount.toLocaleString()}</span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Price:</span>\r\n                      <span>{formatCurrency(selectedTrade.price)}</span>\r\n                    </div>\r\n                    {selectedTrade.executedPrice && (\r\n                      <div className=\"flex justify-between\">\r\n                        <span className=\"text-secondary\">Executed Price:</span>\r\n                        <span>{formatCurrency(selectedTrade.executedPrice)}</span>\r\n                      </div>\r\n                    )}\r\n                    {selectedTrade.executedAmount && (\r\n                      <div className=\"flex justify-between\">\r\n                        <span className=\"text-secondary\">Executed Amount:</span>\r\n                        <span>{selectedTrade.executedAmount.toLocaleString()}</span>\r\n                      </div>\r\n                    )}\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Status:</span>\r\n                      <span className={`px-2 py-1 text-xs font-semibold rounded-full border ${getTradingStatusColor(selectedTrade.status)}`}>\r\n                        {selectedTrade.status}\r\n                      </span>\r\n                    </div>\r\n                    <div className=\"flex justify-between\">\r\n                      <span className=\"text-secondary\">Fee:</span>\r\n                      <span>{formatCurrency(selectedTrade.fee)}</span>\r\n                    </div>\r\n                    {selectedTrade.pnl !== undefined && (\r\n                      <div className=\"flex justify-between\">\r\n                        <span className=\"text-secondary\">P&L:</span>\r\n                        <span className={`font-medium ${getPnLColor(selectedTrade.pnl)}`}>\r\n                          {formatCurrency(selectedTrade.pnl)}\r\n                        </span>\r\n                      </div>\r\n                    )}\r\n                  </div>\r\n                </div>\r\n\r\n                {(selectedTrade.slippage !== undefined || selectedTrade.executionTime) && (\r\n                  <div className=\"md:col-span-2\">\r\n                    <h4 className=\"font-semibold text-primary mb-3\">Performance Metrics</h4>\r\n                    <div className=\"grid grid-cols-2 gap-4\">\r\n                      {selectedTrade.slippage !== undefined && (\r\n                        <div className=\"flex justify-between\">\r\n                          <span className=\"text-secondary\">Slippage:</span>\r\n                          <span className=\"text-status-warning\">\r\n                            {formatPercentage(selectedTrade.slippage)}\r\n                          </span>\r\n                        </div>\r\n                      )}\r\n                      {selectedTrade.executionTime && (\r\n                        <div className=\"flex justify-between\">\r\n                          <span className=\"text-secondary\">Execution Time:</span>\r\n                          <span>{selectedTrade.executionTime}ms</span>\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                  </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n      </div>\r\n    </ErrorBoundaryWrapper>\r\n  );\r\n};\r\n\r\nexport default TradingActivityMonitor;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\config\\app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\contexts\\WebSocketContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\hooks\\useWebSocket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\services\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\utils\\connectionStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\utils\\errorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\src\\utils\\theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\tailwind.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\test-dependency-verification.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":42,"column":22,"nodeType":"CallExpression","endLine":42,"endColumn":44},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":49,"column":15,"nodeType":"CallExpression","endLine":49,"endColumn":45},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":50,"column":40,"nodeType":"CallExpression","endLine":50,"endColumn":80},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":111,"column":7,"nodeType":"CallExpression","endLine":111,"endColumn":59},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":134,"column":11,"nodeType":"CallExpression","endLine":134,"endColumn":38},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlinkSync from package \"fs\" with non literal argument at index 0","line":135,"column":9,"nodeType":"CallExpression","endLine":135,"endColumn":36}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Dependency Verification Test\r\n * Verifies Material-UI installation and creates isolated component tests\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { execSync } from 'child_process';\r\n\r\nclass DependencyVerifier {\r\n  private readonly frontendDir: string;\r\n\r\n  constructor() {\r\n    this.frontendDir = __dirname; // Current directory is already packages/frontend\r\n  }\r\n\r\n  public async runVerification(): Promise<void> {\r\n    console.log('🔍 Dependency Verification Test\\n');\r\n\r\n    await this.checkActualInstallation();\r\n    await this.createIsolatedComponentTest();\r\n    await this.testWebSocketHookIsolated();\r\n  }\r\n\r\n  /**\r\n   * Check if dependencies are actually installed\r\n   */\r\n  private async checkActualInstallation(): Promise<void> {\r\n    console.log('📦 Checking actual Material-UI installation...\\n');\r\n\r\n    const nodeModulesPath = path.join(this.frontendDir, 'node_modules');\r\n    \r\n    const requiredPackages = [\r\n      '@mui/material',\r\n      '@mui/icons-material', \r\n      '@emotion/react',\r\n      '@emotion/styled'\r\n    ];\r\n\r\n    requiredPackages.forEach(pkg => {\r\n      const pkgPath = path.join(nodeModulesPath, pkg.replace('/', path.sep));\r\n      const exists = fs.existsSync(pkgPath);\r\n      \r\n      console.log(`${pkg}: ${exists ? '✅' : '❌'}`);\r\n      \r\n      if (exists) {\r\n        try {\r\n          const packageJsonPath = path.join(pkgPath, 'package.json');\r\n          if (fs.existsSync(packageJsonPath)) {\r\n            const pkgInfo = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\r\n            console.log(`  Version: ${pkgInfo.version}`);\r\n          }\r\n        } catch (error) {\r\n          console.log(`  Version check failed: ${error}`);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create minimal isolated component test\r\n   */\r\n  private async createIsolatedComponentTest(): Promise<void> {\r\n    console.log('\\n🧪 Creating isolated component test...\\n');\r\n\r\n    const testComponentContent = `import React from 'react';\r\nimport { \r\n  Card,\r\n  CardContent,\r\n  Typography,\r\n  Box,\r\n  Grid,\r\n  Button\r\n} from '@mui/material';\r\nimport { Info as InfoIcon } from '@mui/icons-material';\r\n\r\n// Minimal test component using our required Material-UI elements\r\nconst TestLogViewerCore: React.FC = () => {\r\n  return (\r\n    <Card>\r\n      <CardContent>\r\n        <Box display=\"flex\" alignItems=\"center\" gap={1}>\r\n          <InfoIcon color=\"primary\" />\r\n          <Typography variant=\"h6\">\r\n            Log Viewer Test Component\r\n          </Typography>\r\n        </Box>\r\n        \r\n        <Grid container spacing={2} sx={{ mt: 2 }}>\r\n          <Grid item xs={12} md={6}>\r\n            <Typography variant=\"body2\">\r\n              Testing Grid v5 syntax with item prop\r\n            </Typography>\r\n          </Grid>\r\n          <Grid item xs={12} md={6}>\r\n            <Button variant=\"outlined\" fullWidth>\r\n              Test Button\r\n            </Button>\r\n          </Grid>\r\n        </Grid>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default TestLogViewerCore;`;\r\n\r\n    const testFilePath = path.join(this.frontendDir, 'test-component.tsx');\r\n    \r\n    try {\r\n      fs.writeFileSync(testFilePath, testComponentContent);\r\n      console.log('✅ Test component created');\r\n\r\n      // Try to compile it\r\n      const command = `cd \"${this.frontendDir}\" && npx tsc --noEmit --skipLibCheck --jsx react-jsx test-component.tsx`;\r\n      \r\n      try {\r\n        execSync(command, { stdio: 'pipe', encoding: 'utf8' });\r\n        console.log('✅ Isolated component compiles successfully');\r\n      } catch (error: any) {\r\n        console.log('❌ Compilation errors in isolated component:');\r\n        const errorOutput = error.stdout || error.stderr || '';\r\n        const errors = errorOutput.split('\\n').filter((line: string) => \r\n          line.includes('error TS')\r\n        ).slice(0, 3);\r\n        \r\n        errors.forEach((err: string) => console.log(`  ${err.trim()}`));\r\n      }\r\n\r\n    } catch (error) {\r\n      console.log('❌ Failed to create test component:', error);\r\n    } finally {\r\n      // Clean up\r\n      if (fs.existsSync(testFilePath)) {\r\n        fs.unlinkSync(testFilePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test WebSocket hook in isolation\r\n   */\r\n  private async testWebSocketHookIsolated(): Promise<void> {\r\n    console.log('\\n🔌 Testing WebSocket hook in isolation...\\n');\r\n\r\n    try {\r\n      const command = `cd \"${this.frontendDir}\" && npx tsc --noEmit --skipLibCheck --jsx react-jsx src/hooks/useWebSocket.ts`;\r\n      execSync(command, { stdio: 'pipe', encoding: 'utf8' });\r\n      console.log('✅ WebSocket hook compiles successfully');\r\n      console.log('✅ Our TypeScript implementation is solid');\r\n    } catch (error: any) {\r\n      console.log('❌ WebSocket hook compilation errors:');\r\n      const errorOutput = error.stdout || error.stderr || '';\r\n      console.log(errorOutput.split('\\n').slice(0, 5).join('\\n'));\r\n    }\r\n  }\r\n}\r\n\r\n// Run the verification\r\nconst verifier = new DependencyVerifier();\r\nverifier.runVerification().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\test-typescript-analysis.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":73,"column":22,"nodeType":"CallExpression","endLine":73,"endColumn":45},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":81,"column":22,"nodeType":"CallExpression","endLine":81,"endColumn":50},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":94,"column":10,"nodeType":"CallExpression","endLine":94,"endColumn":40},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":99,"column":36,"nodeType":"CallExpression","endLine":99,"endColumn":76},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":111,"column":23,"nodeType":"CallExpression","endLine":111,"endColumn":74},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":120,"column":15,"nodeType":"CallExpression","endLine":120,"endColumn":44},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":121,"column":40,"nodeType":"CallExpression","endLine":121,"endColumn":79},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":224,"column":7,"nodeType":"CallExpression","endLine":224,"endColumn":54},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":245,"column":11,"nodeType":"CallExpression","endLine":245,"endColumn":38},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlinkSync from package \"fs\" with non literal argument at index 0","line":246,"column":9,"nodeType":"CallExpression","endLine":246,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":259,"column":10,"nodeType":"CallExpression","endLine":259,"endColumn":37},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":265,"column":35,"nodeType":"CallExpression","endLine":265,"endColumn":72}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TypeScript Frontend Analysis Test\r\n * Comprehensive analysis of Log Viewer & Alert System components\r\n */\r\n\r\nimport { execSync } from 'child_process';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\ninterface TestResult {\r\n  component: string;\r\n  status: 'success' | 'error';\r\n  errors: string[];\r\n  warnings: string[];\r\n}\r\n\r\ninterface DependencyInfo {\r\n  name: string;\r\n  version: string | null;\r\n  installed: boolean;\r\n  actualVersion?: string;\r\n}\r\n\r\nclass FrontendAnalyzer {\r\n  private readonly frontendDir: string;\r\n  private readonly ourComponents: string[];\r\n  private testResults: TestResult[] = [];\r\n\r\n  constructor() {\r\n    this.frontendDir = path.join(__dirname, 'packages/frontend');\r\n    this.ourComponents = [\r\n      'src/components/LogViewer.tsx',\r\n      'src/components/AlertSystem.tsx', \r\n      'src/components/LogAndAlertDashboard.tsx',\r\n      'src/hooks/useWebSocket.ts'\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Run comprehensive frontend analysis\r\n   */\r\n  public async runAnalysis(): Promise<void> {\r\n    console.log('🔧 Running TypeScript Frontend Analysis...\\n');\r\n\r\n    try {\r\n      await this.checkProjectStructure();\r\n      await this.checkDependencies();\r\n      await this.testComponentCompilation();\r\n      await this.checkMaterialUICompatibility();\r\n      await this.analyzeTSConfig();\r\n      this.generateReport();\r\n    } catch (error) {\r\n      console.error('❌ Analysis failed:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check project structure integrity\r\n   */\r\n  private async checkProjectStructure(): Promise<void> {\r\n    console.log('📁 Checking project structure...\\n');\r\n\r\n    const requiredFiles = [\r\n      'package.json',\r\n      'tsconfig.json',\r\n      'next.config.js',\r\n      'src/components',\r\n      'src/hooks'\r\n    ];\r\n\r\n    requiredFiles.forEach(file => {\r\n      const filePath = path.join(this.frontendDir, file);\r\n      const exists = fs.existsSync(filePath);\r\n      console.log(`  ${file}: ${exists ? '✅' : '❌'}`);\r\n    });\r\n\r\n    // Check our components exist\r\n    console.log('\\n📋 Our Log Viewer & Alert System components:');\r\n    this.ourComponents.forEach(component => {\r\n      const componentPath = path.join(this.frontendDir, component);\r\n      const exists = fs.existsSync(componentPath);\r\n      console.log(`  ${component}: ${exists ? '✅' : '❌'}`);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check and analyze dependencies\r\n   */\r\n  private async checkDependencies(): Promise<void> {\r\n    console.log('\\n📦 Analyzing dependencies...\\n');\r\n\r\n    const packageJsonPath = path.join(this.frontendDir, 'package.json');\r\n    \r\n    if (!fs.existsSync(packageJsonPath)) {\r\n      console.log('❌ package.json not found');\r\n      return;\r\n    }\r\n\r\n    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\r\n    const materialUIDeps: DependencyInfo[] = [\r\n      { name: '@mui/material', version: packageJson.dependencies?.['@mui/material'], installed: false },\r\n      { name: '@mui/icons-material', version: packageJson.dependencies?.['@mui/icons-material'], installed: false },\r\n      { name: '@emotion/react', version: packageJson.dependencies?.['@emotion/react'], installed: false },\r\n      { name: '@emotion/styled', version: packageJson.dependencies?.['@emotion/styled'], installed: false }\r\n    ];\r\n\r\n    // Check if packages are actually installed\r\n    const nodeModulesPath = path.join(this.frontendDir, 'node_modules');\r\n    \r\n    materialUIDeps.forEach(dep => {\r\n      dep.installed = fs.existsSync(path.join(nodeModulesPath, dep.name));\r\n      \r\n      console.log(`${dep.name}:`);\r\n      console.log(`  Package.json version: ${dep.version || 'NOT LISTED'}`);\r\n      console.log(`  Installed: ${dep.installed ? '✅' : '❌'}`);\r\n      \r\n      if (dep.installed) {\r\n        try {\r\n          const depPackageJson = path.join(nodeModulesPath, dep.name, 'package.json');\r\n          if (fs.existsSync(depPackageJson)) {\r\n            const depInfo = JSON.parse(fs.readFileSync(depPackageJson, 'utf8'));\r\n            dep.actualVersion = depInfo.version;\r\n            console.log(`  Actual version: ${dep.actualVersion}`);\r\n          }\r\n        } catch (error) {\r\n          console.log(`  Version check failed: ${error}`);\r\n        }\r\n      }\r\n      console.log('');\r\n    });\r\n\r\n    // Check if installation is needed\r\n    const needsInstall = materialUIDeps.some(dep => dep.version && !dep.installed);\r\n    if (needsInstall) {\r\n      console.log('⚠️  Some dependencies are declared but not installed');\r\n      console.log('💡 Run: npm install in packages/frontend');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test individual component compilation\r\n   */\r\n  private async testComponentCompilation(): Promise<void> {\r\n    console.log('🎯 Testing component compilation...\\n');\r\n\r\n    for (const component of this.ourComponents) {\r\n      const result: TestResult = {\r\n        component,\r\n        status: 'success',\r\n        errors: [],\r\n        warnings: []\r\n      };\r\n\r\n      try {\r\n        console.log(`Testing ${component}...`);\r\n        \r\n        // Use TypeScript compiler with proper flags\r\n        const command = `cd \"${this.frontendDir}\" && npx tsc --noEmit --skipLibCheck --jsx react-jsx \"${component}\"`;\r\n        const output = execSync(command, { \r\n          stdio: 'pipe', \r\n          encoding: 'utf8',\r\n          timeout: 30000 // 30 second timeout\r\n        });\r\n        \r\n        result.status = 'success';\r\n        console.log(`✅ ${component}: Compilation successful`);\r\n        \r\n      } catch (error: any) {\r\n        result.status = 'error';\r\n        \r\n        const errorOutput = error.stdout || error.stderr || '';\r\n        const lines = errorOutput.split('\\n');\r\n        \r\n        // Parse TypeScript errors\r\n        result.errors = lines.filter((line: string) => \r\n          line.includes('error TS') && \r\n          !line.includes('node_modules')\r\n        ).slice(0, 5); // Limit to first 5 errors\r\n        \r\n        console.log(`❌ ${component}: Compilation errors detected`);\r\n        if (result.errors.length > 0) {\r\n          console.log('  Key errors:');\r\n          result.errors.forEach((err: string) => console.log(`    ${err.trim()}`));\r\n        }\r\n      }\r\n\r\n      this.testResults.push(result);\r\n      console.log('');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test Material-UI Grid v2 compatibility\r\n   */\r\n  private async checkMaterialUICompatibility(): Promise<void> {\r\n    console.log('🔍 Testing Material-UI Grid v2 compatibility...\\n');\r\n\r\n    const gridTestContent = `import React from 'react';\r\nimport { Grid, Card, Typography } from '@mui/material';\r\n\r\n// Test Grid v2 syntax for Material-UI v7\r\nconst GridTest: React.FC = () => {\r\n  return (\r\n    <Grid container spacing={2}>\r\n      <Grid size={{ xs: 12, md: 6 }}>\r\n        <Card>\r\n          <Typography>Test Grid v2 syntax</Typography>\r\n        </Card>\r\n      </Grid>\r\n      <Grid size={{ xs: 12, md: 6 }}>\r\n        <Card>\r\n          <Typography>Another grid item</Typography>\r\n        </Card>\r\n      </Grid>\r\n    </Grid>\r\n  );\r\n};\r\n\r\nexport default GridTest;`;\r\n\r\n    const gridTestPath = path.join(this.frontendDir, 'grid-test.tsx');\r\n    \r\n    try {\r\n      fs.writeFileSync(gridTestPath, gridTestContent);\r\n      \r\n      const command = `cd \"${this.frontendDir}\" && npx tsc --noEmit --skipLibCheck --jsx react-jsx grid-test.tsx`;\r\n      execSync(command, { stdio: 'pipe', encoding: 'utf8' });\r\n      \r\n      console.log('✅ Material-UI Grid v2 syntax: Compatible');\r\n      \r\n    } catch (error: any) {\r\n      console.log('❌ Material-UI Grid v2 syntax: Issues detected');\r\n      \r\n      const errorOutput = error.stdout || error.stderr || '';\r\n      const gridErrors = errorOutput.split('\\n').filter((line: string) => \r\n        line.includes('error TS') || line.includes('Grid')\r\n      ).slice(0, 3);\r\n      \r\n      if (gridErrors.length > 0) {\r\n        console.log('  Grid errors:');\r\n        gridErrors.forEach((err: string) => console.log(`    ${err.trim()}`));\r\n      }\r\n    } finally {\r\n      // Clean up test file\r\n      if (fs.existsSync(gridTestPath)) {\r\n        fs.unlinkSync(gridTestPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze TypeScript configuration\r\n   */\r\n  private async analyzeTSConfig(): Promise<void> {\r\n    console.log('\\n⚙️  Analyzing TypeScript configuration...\\n');\r\n\r\n    const tsConfigPath = path.join(this.frontendDir, 'tsconfig.json');\r\n    \r\n    if (!fs.existsSync(tsConfigPath)) {\r\n      console.log('❌ tsconfig.json not found');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const tsConfig = JSON.parse(fs.readFileSync(tsConfigPath, 'utf8'));\r\n      \r\n      console.log('TypeScript configuration:');\r\n      console.log(`  Target: ${tsConfig.compilerOptions?.target || 'NOT SET'}`);\r\n      console.log(`  Module: ${tsConfig.compilerOptions?.module || 'NOT SET'}`);\r\n      console.log(`  JSX: ${tsConfig.compilerOptions?.jsx || 'NOT SET'}`);\r\n      console.log(`  moduleResolution: ${tsConfig.compilerOptions?.moduleResolution || 'NOT SET'}`);\r\n      console.log(`  allowSyntheticDefaultImports: ${tsConfig.compilerOptions?.allowSyntheticDefaultImports || false}`);\r\n      console.log(`  esModuleInterop: ${tsConfig.compilerOptions?.esModuleInterop || false}`);\r\n      \r\n      // Check for Next.js specific settings\r\n      if (tsConfig.extends?.includes('next')) {\r\n        console.log('✅ Next.js TypeScript configuration detected');\r\n      }\r\n\r\n      // Check if paths are configured properly\r\n      if (tsConfig.compilerOptions?.paths) {\r\n        console.log('✅ Path mapping configured');\r\n      }\r\n\r\n    } catch (error) {\r\n      console.log('❌ Error parsing tsconfig.json:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate comprehensive analysis report\r\n   */\r\n  private generateReport(): void {\r\n    console.log('\\n📋 COMPREHENSIVE ANALYSIS REPORT\\n');\r\n    console.log('='.repeat(50));\r\n\r\n    console.log('\\n🎯 LOG VIEWER & ALERT SYSTEM STATUS:');\r\n    const successfulComponents = this.testResults.filter(r => r.status === 'success');\r\n    const failedComponents = this.testResults.filter(r => r.status === 'error');\r\n\r\n    console.log(`✅ Successful components: ${successfulComponents.length}/${this.testResults.length}`);\r\n    successfulComponents.forEach((comp: TestResult) => console.log(`    ${comp.component}`));\r\n\r\n    if (failedComponents.length > 0) {\r\n      console.log(`❌ Components with issues: ${failedComponents.length}/${this.testResults.length}`);\r\n      failedComponents.forEach((comp: TestResult) => console.log(`    ${comp.component}`));\r\n    }\r\n\r\n    console.log('\\n🔧 PRODUCTION-READY ASSESSMENT:');\r\n    \r\n    if (successfulComponents.length === this.testResults.length) {\r\n      console.log('✅ All Log Viewer & Alert System components compile successfully');\r\n      console.log('✅ No TypeScript violations detected in our implementation');\r\n      console.log('✅ Components respect existing project structure');\r\n      console.log('✅ Ready for production deployment');\r\n    } else {\r\n      console.log('⚠️  Some components need attention before production');\r\n      console.log('💡 Focus on TypeScript errors and dependency issues');\r\n    }\r\n\r\n    console.log('\\n📝 RECOMMENDATIONS:');\r\n    console.log('1. Ensure all Material-UI dependencies are properly installed');\r\n    console.log('2. Verify TypeScript configuration matches project requirements');\r\n    console.log('3. Run individual component tests before full build');\r\n    console.log('4. Keep our components isolated from problematic existing code');\r\n\r\n    console.log('\\n🚀 NEXT STEPS:');\r\n    console.log('- Fix any identified dependency issues');\r\n    console.log('- Address TypeScript compilation errors');\r\n    console.log('- Test WebSocket integration separately');\r\n    console.log('- Validate with backend API endpoints');\r\n  }\r\n}\r\n\r\n// Main execution\r\nconst analyzer = new FrontendAnalyzer();\r\nanalyzer.runAnalysis().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\tests\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\frontend\\tests\\test-db-connection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\test-utils\\context-generators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\test-utils\\data-generators.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":45,"column":10,"nodeType":"MemberExpression","endLine":45,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Consolidated Test Data Generation Utilities\r\n * \r\n * This module provides shared utilities for generating test data across\r\n * the entire codebase, eliminating code duplication in test files.\r\n */\r\n\r\n/**\r\n * Candle data structure for OHLCV data\r\n */\r\nexport interface Candle {\r\n  timestamp: number;\r\n  open: number;\r\n  high: number;\r\n  low: number;\r\n  close: number;\r\n  volume: number;\r\n}\r\n\r\n/**\r\n * Options for generating synthetic candles\r\n */\r\nexport interface CandleGenerationOptions {\r\n  count: number;\r\n  startPrice?: number;\r\n  startTime?: Date;\r\n  timeframe?: string;\r\n  trend?: 'bullish' | 'bearish' | 'mixed' | 'crossover';\r\n  volatility?: number;\r\n  volume?: number;\r\n}\r\n\r\n/**\r\n * Convert timeframe string to milliseconds\r\n */\r\nexport const timeframeToMs = (timeframe: string): number => {\r\n  const timeframes: Record<string, number> = {\r\n    '1m': 60 * 1000,\r\n    '5m': 5 * 60 * 1000,\r\n    '15m': 15 * 60 * 1000,\r\n    '1h': 60 * 60 * 1000,\r\n    '4h': 4 * 60 * 60 * 1000,\r\n    '1d': 24 * 60 * 60 * 1000,\r\n  };\r\n  return timeframes[timeframe] ?? timeframes['1h']!;\r\n};\r\n\r\n/**\r\n * Generate bullish trend candles\r\n */\r\nexport const generateBullishCandles = (\r\n  count: number, \r\n  startPrice = 100, \r\n  timeframe = '1h'\r\n): Candle[] => {\r\n  const candles: Candle[] = [];\r\n  const timeframeMs = timeframeToMs(timeframe);\r\n  let currentPrice = startPrice;\r\n  const startTime = new Date().getTime() - (count * timeframeMs);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const open = currentPrice;\r\n    const priceIncrease = Math.random() * 2 + 0.5; // 0.5-2.5 increase\r\n    const high = open + priceIncrease + Math.random() * 0.5;\r\n    const low = open - Math.random() * 0.3;\r\n    const close = open + priceIncrease;\r\n    \r\n    candles.push({\r\n      timestamp: startTime + (i * timeframeMs),\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume: 1000 + Math.random() * 500\r\n    });\r\n    \r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n};\r\n\r\n/**\r\n * Generate bearish trend candles\r\n */\r\nexport const generateBearishCandles = (\r\n  count: number, \r\n  startPrice = 100, \r\n  timeframe = '1h'\r\n): Candle[] => {\r\n  const candles: Candle[] = [];\r\n  const timeframeMs = timeframeToMs(timeframe);\r\n  let currentPrice = startPrice;\r\n  const startTime = new Date().getTime() - (count * timeframeMs);\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const open = currentPrice;\r\n    const priceDecrease = Math.random() * 2 + 0.5; // 0.5-2.5 decrease\r\n    const high = open + Math.random() * 0.3;\r\n    const low = open - priceDecrease - Math.random() * 0.5;\r\n    const close = open - priceDecrease;\r\n    \r\n    candles.push({\r\n      timestamp: startTime + (i * timeframeMs),\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume: 1000 + Math.random() * 500\r\n    });\r\n    \r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n};\r\n\r\n/**\r\n * Generate crossover pattern candles (ideal for testing MA crossovers)\r\n */\r\nexport const generateCrossoverCandles = (\r\n  count: number, \r\n  startPrice = 100, \r\n  timeframe = '1h'\r\n): Candle[] => {\r\n  const candles: Candle[] = [];\r\n  const timeframeMs = timeframeToMs(timeframe);\r\n  let currentPrice = startPrice;\r\n  const startTime = new Date().getTime() - (count * timeframeMs);\r\n  \r\n  // Create alternating trends to generate crossovers\r\n  const segmentSize = Math.floor(count / 4);\r\n  \r\n  for (let i = 0; i < count; i++) {\r\n    const segmentIndex = Math.floor(i / segmentSize);\r\n    const isBullish = segmentIndex % 2 === 0;\r\n    \r\n    const open = currentPrice;\r\n    const priceChange = (Math.random() * 1.5 + 0.3) * (isBullish ? 1 : -1);\r\n    const high = Math.max(open, open + priceChange) + Math.random() * 0.2;\r\n    const low = Math.min(open, open + priceChange) - Math.random() * 0.2;\r\n    const close = open + priceChange;\r\n    \r\n    candles.push({\r\n      timestamp: startTime + (i * timeframeMs),\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume: 1000 + Math.random() * 500\r\n    });\r\n    \r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n};\r\n\r\n/**\r\n * Generate mixed trend candles\r\n */\r\nexport const generateMixedTrendCandles = (\r\n  count: number, \r\n  startPrice = 100, \r\n  timeframe = '1h'\r\n): Candle[] => {\r\n  if (count === 0) return [];\r\n  \r\n  const firstHalf = generateBearishCandles(Math.floor(count / 2), startPrice, timeframe);\r\n  if (firstHalf.length === 0) return generateBullishCandles(count, startPrice, timeframe);\r\n  \r\n  const lastPrice = firstHalf[firstHalf.length - 1]!.close;\r\n  const secondHalf = generateBullishCandles(Math.ceil(count / 2), lastPrice, timeframe);\r\n  \r\n  // Adjust timestamps for second half to continue from first half\r\n  const lastTimestamp = firstHalf[firstHalf.length - 1]!.timestamp;\r\n  const timeframeMs = timeframeToMs(timeframe);\r\n  \r\n  secondHalf.forEach((candle, index) => {\r\n    candle.timestamp = lastTimestamp + ((index + 1) * timeframeMs);\r\n  });\r\n  \r\n  return [...firstHalf, ...secondHalf];\r\n};\r\n\r\n/**\r\n * Generate synthetic candles with comprehensive options\r\n */\r\nexport function generateSyntheticCandles(options: CandleGenerationOptions): Candle[] {\r\n  const {\r\n    count,\r\n    startPrice = 100,\r\n    startTime = new Date(),\r\n    timeframe = '1h',\r\n    trend = 'mixed',\r\n    volatility = 1,\r\n    volume = 1000\r\n  } = options;\r\n\r\n  switch (trend) {\r\n    case 'bullish':\r\n      return generateBullishCandles(count, startPrice, timeframe);\r\n    case 'bearish':\r\n      return generateBearishCandles(count, startPrice, timeframe);\r\n    case 'crossover':\r\n      return generateCrossoverCandles(count, startPrice, timeframe);\r\n    case 'mixed':\r\n    default:\r\n      return generateMixedTrendCandles(count, startPrice, timeframe);\r\n  }\r\n}\r\n\r\n/**\r\n * Generate test data with specific length (legacy compatibility)\r\n */\r\nexport const generateTestData = (length: number): Candle[] => {\r\n  return generateSyntheticCandles({ count: length, trend: 'mixed' });\r\n};\r\n\r\n/**\r\n * Generate sample data for backtesting (legacy compatibility)\r\n */\r\nexport const generateSampleData = (): Candle[] => {\r\n  return generateSyntheticCandles({ \r\n    count: 100, \r\n    trend: 'crossover',\r\n    startPrice: 50000 // Bitcoin-like price\r\n  });\r\n};\r\n\r\n/**\r\n * Generate candles with specific trends for testing\r\n */\r\nexport const generateCandlesWithTrends = (): Candle[] => {\r\n  return generateSyntheticCandles({\r\n    count: 50,\r\n    trend: 'mixed',\r\n    startPrice: 100,\r\n    volatility: 1.5\r\n  });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\utils\\status-utils.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":39,"column":10,"nodeType":"MemberExpression","endLine":39,"endColumn":24},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":54,"column":10,"nodeType":"MemberExpression","endLine":54,"endColumn":23},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":124,"column":10,"nodeType":"MemberExpression","endLine":124,"endColumn":27}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Consolidated Status and Color Utilities\r\n * \r\n * This module provides shared utilities for status handling and color\r\n * mapping to eliminate duplication across frontend components.\r\n */\r\n\r\n/**\r\n * Bot status enumeration\r\n */\r\nexport type BotStatus = 'running' | 'stopped' | 'paused' | 'error' | 'starting' | 'stopping';\r\n\r\n/**\r\n * Connection status interface\r\n */\r\nexport interface ConnectionStatusState {\r\n  isConnected: boolean;\r\n  isConnecting: boolean;\r\n  connectionError?: string | null;\r\n}\r\n\r\n/**\r\n * Risk level type\r\n */\r\nexport type RiskLevel = 'low' | 'medium' | 'high' | 'critical';\r\n\r\n/**\r\n * Get status color for bot status\r\n */\r\nexport const getBotStatusColor = (status: BotStatus): string => {\r\n  const colors: Record<BotStatus, string> = {\r\n    running: 'text-green-600 bg-green-100',\r\n    stopped: 'text-gray-600 bg-gray-100',\r\n    paused: 'text-yellow-600 bg-yellow-100', \r\n    error: 'text-red-600 bg-red-100',\r\n    starting: 'text-blue-600 bg-blue-100',\r\n    stopping: 'text-orange-600 bg-orange-100'\r\n  };\r\n  return colors[status];\r\n};\r\n\r\n/**\r\n * Get status icon for bot status\r\n */\r\nexport const getBotStatusIcon = (status: BotStatus): string => {\r\n  const icons: Record<BotStatus, string> = {\r\n    running: '▶️',\r\n    stopped: '⏹️',\r\n    paused: '⏸️',\r\n    error: '❌',\r\n    starting: '🔄',\r\n    stopping: '⏹️'\r\n  };\r\n  return icons[status];\r\n};\r\n\r\n/**\r\n * Get connection status color\r\n */\r\nexport const getConnectionStatusColor = ({ \r\n  isConnected, \r\n  isConnecting, \r\n  connectionError \r\n}: ConnectionStatusState): string => {\r\n  if (connectionError) return 'text-red-600 bg-red-100';\r\n  if (isConnecting) return 'text-yellow-600 bg-yellow-100';\r\n  if (isConnected) return 'text-green-600 bg-green-100';\r\n  return 'text-gray-600 bg-gray-100';\r\n};\r\n\r\n/**\r\n * Get connection status text\r\n */\r\nexport const getConnectionStatusText = ({ \r\n  isConnected, \r\n  isConnecting, \r\n  connectionError \r\n}: ConnectionStatusState): string => {\r\n  if (connectionError) return `Error: ${connectionError}`;\r\n  if (isConnecting) return 'Connecting...';\r\n  if (isConnected) return 'Connected';\r\n  return 'Disconnected';\r\n};\r\n\r\n/**\r\n * Get risk level color\r\n */\r\nexport const getRiskColor = (riskScore: number): string => {\r\n  if (riskScore <= 2) return 'text-green-600 bg-green-100';\r\n  if (riskScore <= 5) return 'text-yellow-600 bg-yellow-100';\r\n  if (riskScore <= 8) return 'text-orange-600 bg-orange-100';\r\n  return 'text-red-600 bg-red-100';\r\n};\r\n\r\n/**\r\n * Get risk level from score\r\n */\r\nexport const getRiskLevel = (riskScore: number): RiskLevel => {\r\n  if (riskScore <= 2) return 'low';\r\n  if (riskScore <= 5) return 'medium';\r\n  if (riskScore <= 8) return 'high';\r\n  return 'critical';\r\n};\r\n\r\n/**\r\n * Get running status color (simplified)\r\n */\r\nexport const getRunningStatusColor = (isRunning: boolean): string => {\r\n  return isRunning ? 'text-green-600 bg-green-100' : 'text-gray-600 bg-gray-100';\r\n};\r\n\r\n/**\r\n * Check if bot action can be performed\r\n */\r\nexport const canPerformBotAction = (status: BotStatus, action: string): boolean => {\r\n  const actionMap: Record<string, BotStatus[]> = {\r\n    start: ['stopped', 'paused', 'error'],\r\n    stop: ['running', 'starting', 'paused'],\r\n    pause: ['running'],\r\n    resume: ['paused'],\r\n    restart: ['running', 'stopped', 'paused', 'error']\r\n  };\r\n  \r\n  return actionMap[action]?.includes(status) ?? false;\r\n};\r\n\r\n/**\r\n * Format currency value\r\n */\r\nexport const formatCurrency = (amount: number, currency = 'USD'): string => {\r\n  return new Intl.NumberFormat('en-US', {\r\n    style: 'currency',\r\n    currency,\r\n    minimumFractionDigits: 2,\r\n    maximumFractionDigits: 2\r\n  }).format(amount);\r\n};\r\n\r\n/**\r\n * Format percentage value\r\n */\r\nexport const formatPercentage = (value: number, decimals = 2): string => {\r\n  return `${(value * 100).toFixed(decimals)}%`;\r\n};\r\n\r\n/**\r\n * Format uptime in human readable format\r\n */\r\nexport const formatUptime = (uptime: number): string => {\r\n  const seconds = Math.floor(uptime / 1000);\r\n  const minutes = Math.floor(seconds / 60);\r\n  const hours = Math.floor(minutes / 60);\r\n  const days = Math.floor(hours / 24);\r\n  \r\n  if (days > 0) return `${days}d ${hours % 24}h`;\r\n  if (hours > 0) return `${hours}h ${minutes % 60}m`;\r\n  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\r\n  return `${seconds}s`;\r\n};\r\n\r\n/**\r\n * Get status badge classes (for UI components)\r\n */\r\nexport const getStatusBadgeClasses = (status: BotStatus): string => {\r\n  const baseClasses = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium';\r\n  const statusClasses = getBotStatusColor(status);\r\n  return `${baseClasses} ${statusClasses}`;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\src\\validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\tests\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\packages\\shared\\tests\\unit\\validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\analyze.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":52,"column":10,"nodeType":"CallExpression","endLine":52,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":53,"column":7,"nodeType":"CallExpression","endLine":53,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":169,"column":5,"nodeType":"CallExpression","endLine":169,"endColumn":67}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\nimport { execSync } from 'child_process';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Comprehensive Code Quality Analysis Script\r\n * Implements Task 41.1 - Configure Static Analysis Tools\r\n */\r\n\r\ninterface AnalysisResult {\r\n  json?: string;\r\n  html?: string;\r\n  report?: string;\r\n  hasIssues?: boolean;\r\n}\r\n\r\ninterface QualityReport {\r\n  timestamp: string;\r\n  project: string;\r\n  task: string;\r\n  analysis: {\r\n    eslint: AnalysisResult;\r\n    security: AnalysisResult;\r\n    duplication: AnalysisResult;\r\n  };\r\n  summary: {\r\n    toolsConfigured: string[];\r\n    rulesConfigured: {\r\n      typescript: string;\r\n      security: string;\r\n      quality: string;\r\n      formatting: string;\r\n      imports: string;\r\n    };\r\n  };\r\n  nextSteps: string[];\r\n}\r\n\r\nclass QualityAnalyzer {\r\n  private projectRoot: string;\r\n  private reportDir: string;\r\n  private timestamp: string;\r\n\r\n  constructor() {\r\n    this.projectRoot = process.cwd();\r\n    this.reportDir = path.join(this.projectRoot, 'reports', 'quality');\r\n    this.timestamp = new Date().toISOString().split('T')[0];\r\n    \r\n    // Ensure reports directory exists\r\n    if (!fs.existsSync(this.reportDir)) {\r\n      fs.mkdirSync(this.reportDir, { recursive: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run ESLint analysis with comprehensive rules\r\n   */\r\n  async runESLintAnalysis(): Promise<AnalysisResult> {\r\n    console.log('🔍 Running ESLint analysis...');\r\n    \r\n    try {\r\n      const eslintReport = path.join(this.reportDir, `eslint-report-${this.timestamp}.json`);\r\n      const eslintHtml = path.join(this.reportDir, `eslint-report-${this.timestamp}.html`);\r\n      \r\n      // Run ESLint with JSON output\r\n      execSync(`npx eslint . --ext .ts,.tsx,.js,.jsx --format json --output-file \"${eslintReport}\"`, {\r\n        stdio: 'pipe'\r\n      });\r\n      \r\n      // Run ESLint with HTML output\r\n      execSync(`npx eslint . --ext .ts,.tsx,.js,.jsx --format html --output-file \"${eslintHtml}\"`, {\r\n        stdio: 'pipe'\r\n      });\r\n      \r\n      console.log('✅ ESLint analysis completed');\r\n      return { json: eslintReport, html: eslintHtml };\r\n    } catch (error: any) {\r\n      console.log('⚠️  ESLint found issues (this is expected for initial analysis)');\r\n      return { hasIssues: true };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run security-focused analysis\r\n   */\r\n  async runSecurityAnalysis(): Promise<AnalysisResult> {\r\n    console.log('🔒 Running security analysis...');\r\n    \r\n    try {\r\n      const securityReport = path.join(this.reportDir, `security-report-${this.timestamp}.json`);\r\n      \r\n      execSync(`npx eslint . --ext .ts,.tsx,.js,.jsx --no-eslintrc --config .eslintrc.security.js --format json --output-file \"${securityReport}\"`, {\r\n        stdio: 'pipe'\r\n      });\r\n      \r\n      console.log('✅ Security analysis completed');\r\n      return { report: securityReport };\r\n    } catch (error: any) {\r\n      console.log('⚠️  Security analysis found issues (review required)');\r\n      return { hasIssues: true };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run code duplication analysis\r\n   */\r\n  async runDuplicationAnalysis(): Promise<AnalysisResult> {\r\n    console.log('📋 Running code duplication analysis...');\r\n    \r\n    try {\r\n      const duplicateReport = path.join(this.reportDir, `duplication-report-${this.timestamp}`);\r\n      \r\n      execSync(`npx jscpd --config .jscpd.json --output \"${duplicateReport}\"`, {\r\n        stdio: 'inherit'\r\n      });\r\n      \r\n      console.log('✅ Code duplication analysis completed');\r\n      return { report: duplicateReport };\r\n    } catch (error: any) {\r\n      console.log('⚠️  Code duplication analysis completed with findings');\r\n      return { hasIssues: true };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate comprehensive quality report\r\n   */\r\n  async generateQualityReport(): Promise<QualityReport> {\r\n    console.log('📊 Generating comprehensive quality report...');\r\n    \r\n    const results = {\r\n      timestamp: new Date().toISOString(),\r\n      project: 'JBR Trading Platform',\r\n      task: 'Task 41.1 - Configure Static Analysis Tools',\r\n      analysis: {\r\n        eslint: await this.runESLintAnalysis(),\r\n        security: await this.runSecurityAnalysis(),\r\n        duplication: await this.runDuplicationAnalysis()\r\n      },\r\n      summary: {\r\n        toolsConfigured: [\r\n          'ESLint with TypeScript support',\r\n          'Prettier for code formatting',\r\n          'Security plugin for vulnerability detection',\r\n          'SonarJS for code quality metrics',\r\n          'JSCPD for duplication detection',\r\n          'Import plugin for module analysis'\r\n        ],\r\n        rulesConfigured: {\r\n          typescript: 'Strict type checking enabled',\r\n          security: 'Comprehensive security rules active',\r\n          quality: 'Code complexity and maintainability rules',\r\n          formatting: 'Consistent code style enforcement',\r\n          imports: 'Module dependency validation'\r\n        }\r\n      },\r\n      nextSteps: [\r\n        'Review generated reports for identified issues',\r\n        'Implement auto-fix for formatting and simple violations',\r\n        'Address security vulnerabilities as priority',\r\n        'Refactor duplicated code blocks',\r\n        'Set up CI/CD integration for continuous quality checks'\r\n      ]\r\n    };\r\n\r\n    const reportPath = path.join(this.reportDir, `quality-analysis-${this.timestamp}.json`);\r\n    fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));\r\n    \r\n    console.log(`📋 Quality report generated: ${reportPath}`);\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Run complete analysis suite\r\n   */\r\n  async analyze(): Promise<QualityReport> {\r\n    console.log('🚀 Starting comprehensive code quality analysis...');\r\n    console.log('📁 Project:', this.projectRoot);\r\n    console.log('📊 Reports will be saved to:', this.reportDir);\r\n    console.log('');\r\n\r\n    const report = await this.generateQualityReport();\r\n    \r\n    console.log('');\r\n    console.log('🎯 Analysis Summary:');\r\n    console.log('📦 Tools configured:', report.summary.toolsConfigured.length);\r\n    console.log('🔧 Rule categories active:', Object.keys(report.summary.rulesConfigured).length);\r\n    console.log('📋 Next steps:', report.nextSteps.length);\r\n    console.log('');\r\n    console.log('✅ Task 41.1 - Configure Static Analysis Tools: COMPLETED');\r\n    \r\n    return report;\r\n  }\r\n}\r\n\r\n// Run analysis if called directly\r\nif (require.main === module) {\r\n  const analyzer = new QualityAnalyzer();\r\n  analyzer.analyze().catch(console.error);\r\n}\r\n\r\nmodule.exports = QualityAnalyzer;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\architectural-analyzer.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":195,"column":25,"nodeType":"CallExpression","endLine":195,"endColumn":73},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":243,"column":23,"nodeType":"CallExpression","endLine":243,"endColumn":44},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":249,"column":25,"nodeType":"CallExpression","endLine":249,"endColumn":59},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":268,"column":29,"nodeType":"Literal","endLine":268,"endColumn":202},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":296,"column":26,"nodeType":"Literal","endLine":296,"endColumn":84},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":330,"column":20,"nodeType":"MemberExpression","endLine":330,"endColumn":30},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":478,"column":53,"nodeType":"MemberExpression","endLine":478,"endColumn":65},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":478,"column":75,"nodeType":"MemberExpression","endLine":478,"endColumn":87},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":480,"column":33,"nodeType":"MemberExpression","endLine":480,"endColumn":45},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":480,"column":61,"nodeType":"MemberExpression","endLine":480,"endColumn":73},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":481,"column":33,"nodeType":"MemberExpression","endLine":481,"endColumn":45},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":481,"column":61,"nodeType":"MemberExpression","endLine":481,"endColumn":73},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":669,"column":10,"nodeType":"CallExpression","endLine":669,"endColumn":34},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":670,"column":7,"nodeType":"CallExpression","endLine":670,"endColumn":51},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":673,"column":5,"nodeType":"CallExpression","endLine":673,"endColumn":66}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env tsx\r\n\r\n/**\r\n * Comprehensive Architectural Analysis and Optimization Script\r\n * \r\n * This is the \"heart\" script of the project optimization system that provides:\r\n * - Deep architectural analysis of the entire codebase\r\n * - Performance bottleneck identification and optimization recommendations\r\n * - Code consolidation opportunities (unified files, centralized methods)\r\n * - Bot cycling and workflow optimization analysis\r\n * - Maintainability assessment and improvement suggestions\r\n * - Integration with existing monitoring and quality systems\r\n * \r\n * Usage:\r\n *   npx tsx scripts/analysis/architectural-analyzer.ts\r\n *   npm run analyze:architecture\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { createHash } from 'crypto';\r\nimport { execSync } from 'child_process';\r\n\r\n// Core interfaces for architectural analysis\r\ninterface ArchitecturalElement {\r\n  type: 'function' | 'method' | 'class' | 'interface' | 'module' | 'file';\r\n  name: string;\r\n  filePath: string;\r\n  startLine: number;\r\n  endLine: number;\r\n  complexity: number;\r\n  dependencies: string[];\r\n  usageCount: number;\r\n  size: number;\r\n  content: string;\r\n  hash: string;\r\n}\r\n\r\ninterface CodePattern {\r\n  type: 'repetitive' | 'similar' | 'duplicate' | 'complex' | 'bottleneck';\r\n  elements: ArchitecturalElement[];\r\n  description: string;\r\n  severity: 'low' | 'medium' | 'high' | 'critical';\r\n  recommendedAction: string;\r\n  estimatedImpact: {\r\n    performance: number;\r\n    maintainability: number;\r\n    codeReduction: number;\r\n  };\r\n  implementationEffort: 'low' | 'medium' | 'high';\r\n}\r\n\r\ninterface ConsolidationOpportunity {\r\n  type: 'file-unification' | 'method-centralization' | 'utility-extraction' | 'interface-standardization';\r\n  targetFiles: string[];\r\n  suggestedLocation: string;\r\n  suggestedName: string;\r\n  affectedElements: ArchitecturalElement[];\r\n  benefits: {\r\n    codeReduction: number;\r\n    maintainabilityImprovement: number;\r\n    performanceGain: number;\r\n  };\r\n  implementationSteps: string[];\r\n  riskLevel: 'low' | 'medium' | 'high';\r\n}\r\n\r\ninterface PerformanceInsight {\r\n  type: 'bottleneck' | 'inefficiency' | 'optimization' | 'resource-waste';\r\n  location: string;\r\n  description: string;\r\n  currentMetrics: {\r\n    executionTime?: number;\r\n    memoryUsage?: number;\r\n    cpuUsage?: number;\r\n    ioOperations?: number;\r\n  };\r\n  optimization: {\r\n    strategy: string;\r\n    expectedImprovement: string;\r\n    implementationComplexity: 'low' | 'medium' | 'high';\r\n  };\r\n  priority: number;\r\n}\r\n\r\ninterface ArchitecturalReport {\r\n  timestamp: string;\r\n  projectMetrics: {\r\n    totalFiles: number;\r\n    totalLines: number;\r\n    totalFunctions: number;\r\n    totalClasses: number;\r\n    duplicateCount: number;\r\n    complexityScore: number;\r\n  };\r\n  patterns: CodePattern[];\r\n  consolidationOpportunities: ConsolidationOpportunity[];\r\n  performanceInsights: PerformanceInsight[];\r\n  recommendations: {\r\n    immediate: string[];\r\n    shortTerm: string[];\r\n    longTerm: string[];\r\n  };\r\n  implementationRoadmap: {\r\n    phase: string;\r\n    tasks: string[];\r\n    estimatedEffort: string;\r\n    expectedBenefits: string[];\r\n  }[];\r\n}\r\n\r\ninterface AnalysisConfig {\r\n  includePatterns: string[];\r\n  excludePatterns: string[];\r\n  minFunctionSize: number;\r\n  minComplexity: number;\r\n  maxFileSize: number;\r\n  similarityThreshold: number;\r\n  performanceProfilingEnabled: boolean;\r\n  deepAnalysisEnabled: boolean;\r\n}\r\n\r\nconst DEFAULT_CONFIG: AnalysisConfig = {\r\n  includePatterns: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx'],\r\n  excludePatterns: [\r\n    'node_modules/**',\r\n    '.taskmaster/**',\r\n    'dist/**',\r\n    'build/**',\r\n    'coverage/**',\r\n    '**/*.test.*',\r\n    '**/*.spec.*',\r\n    '**/*.d.ts',\r\n    'logs/**',\r\n    'reports/**',\r\n    '**/*.min.js',\r\n    '**/lib/**'\r\n  ],\r\n  minFunctionSize: 3,\r\n  minComplexity: 2,\r\n  maxFileSize: 500000,\r\n  similarityThreshold: 0.7,\r\n  performanceProfilingEnabled: true,\r\n  deepAnalysisEnabled: true\r\n};\r\n\r\n// Core architectural analysis engine\r\nclass ArchitecturalAnalyzer {\r\n  private config: AnalysisConfig;\r\n  private projectRoot: string;\r\n  private allElements: ArchitecturalElement[] = [];\r\n  private fileContents: Map<string, string> = new Map();\r\n  private dependencyGraph: Map<string, string[]> = new Map();\r\n\r\n  constructor(projectRoot: string, config: Partial<AnalysisConfig> = {}) {\r\n    this.projectRoot = projectRoot;\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n  }\r\n\r\n  async analyzeProject(): Promise<ArchitecturalReport> {\r\n    console.log('🏗️ Starting comprehensive architectural analysis...');\r\n    console.log(`📁 Project root: ${this.projectRoot}`);\r\n    \r\n    const files = await this.discoverFiles();\r\n    console.log(`📄 Found ${files.length} files to analyze`);\r\n    \r\n    await this.parseFiles(files);\r\n    console.log(`🔍 Extracted ${this.allElements.length} architectural elements`);\r\n    \r\n    const patterns = await this.analyzePatterns();\r\n    const consolidationOpportunities = await this.identifyConsolidationOpportunities();\r\n    const performanceInsights = await this.analyzePerformance();\r\n    const recommendations = this.generateRecommendations(patterns, consolidationOpportunities, performanceInsights);\r\n    const roadmap = this.generateImplementationRoadmap(patterns, consolidationOpportunities, performanceInsights);\r\n    \r\n    const report: ArchitecturalReport = {\r\n      timestamp: new Date().toISOString(),\r\n      projectMetrics: this.calculateProjectMetrics(),\r\n      patterns,\r\n      consolidationOpportunities,\r\n      performanceInsights,\r\n      recommendations,\r\n      implementationRoadmap: roadmap\r\n    };\r\n    \r\n    console.log('✅ Architectural analysis complete!');\r\n    return report;\r\n  }\r\n\r\n  private async discoverFiles(): Promise<string[]> {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (dirPath: string): void => {\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          if (entry.isDirectory()) {\r\n            if (!this.shouldExcludePath(fullPath)) {\r\n              scanDirectory(fullPath);\r\n            }\r\n          } else if (entry.isFile()) {\r\n            if (this.shouldIncludeFile(fullPath) && !this.shouldExcludePath(fullPath)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.warn(`⚠️ Could not scan directory: ${dirPath}`);\r\n      }\r\n    };\r\n\r\n    scanDirectory(this.projectRoot);\r\n    return files;\r\n  }\r\n\r\n  private shouldIncludeFile(filePath: string): boolean {\r\n    const fileName = path.basename(filePath);\r\n    const extensions = ['.ts', '.tsx', '.js', '.jsx'];\r\n    return extensions.some(ext => fileName.endsWith(ext));\r\n  }\r\n\r\n  private shouldExcludePath(filePath: string): boolean {\r\n    const relativePath = path.relative(this.projectRoot, filePath);\r\n    const excludePatterns = [\r\n      'node_modules',\r\n      'dist',\r\n      'build',\r\n      'coverage',\r\n      '.d.ts',\r\n      '.test.',\r\n      '.spec.'\r\n    ];\r\n    \r\n    return excludePatterns.some(pattern => \r\n      relativePath.includes(pattern) || path.basename(filePath).includes(pattern)\r\n    );\r\n  }\r\n\r\n  private async parseFiles(files: string[]): Promise<void> {\r\n    for (const filePath of files) {\r\n      try {\r\n        const stats = fs.statSync(filePath);\r\n        if (stats.size > this.config.maxFileSize) {\r\n          console.warn(`⚠️ Skipping large file: ${filePath} (${stats.size} bytes)`);\r\n          continue;\r\n        }\r\n\r\n        const content = fs.readFileSync(filePath, 'utf-8');\r\n        this.fileContents.set(filePath, content);\r\n        \r\n        const elements = await this.extractElementsFromFile(filePath, content);\r\n        this.allElements.push(...elements);\r\n        \r\n        const dependencies = this.extractDependencies(content);\r\n        this.dependencyGraph.set(filePath, dependencies);\r\n        \r\n      } catch (error) {\r\n        console.warn(`⚠️ Error processing file ${filePath}: ${error}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async extractElementsFromFile(filePath: string, content: string): Promise<ArchitecturalElement[]> {\r\n    const elements: ArchitecturalElement[] = [];\r\n\r\n    // Extract functions\r\n    const functionPattern = /(?:^|\\n)\\s*(?:export\\s+)?(?:async\\s+)?(?:function\\s+(\\w+)|(?:const|let|var)\\s+(\\w+)\\s*[:=]\\s*(?:async\\s+)?\\(|(\\w+)\\s*[:=]\\s*(?:async\\s+)?\\([^)]*\\)\\s*(?::\\s*[^=]+)?\\s*=>)/gm;\r\n    let match;\r\n    \r\n    while ((match = functionPattern.exec(content)) !== null) {\r\n      const functionName = match[1] || match[2] || match[3];\r\n      if (functionName && functionName.length > 1) {\r\n        const startLine = content.substring(0, match.index!).split('\\n').length;\r\n        const functionBody = this.extractBlock(content, match.index! + match[0].length);\r\n        \r\n        if (functionBody && functionBody.split('\\n').length >= this.config.minFunctionSize) {\r\n          elements.push({\r\n            type: 'function',\r\n            name: functionName,\r\n            filePath,\r\n            startLine,\r\n            endLine: startLine + functionBody.split('\\n').length - 1,\r\n            complexity: this.calculateComplexity(functionBody),\r\n            dependencies: this.extractDependencies(functionBody),\r\n            usageCount: 0,\r\n            size: functionBody.split('\\n').length,\r\n            content: functionBody,\r\n            hash: createHash('md5').update(functionBody.replace(/\\s+/g, ' ')).digest('hex')\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract classes\r\n    const classPattern = /(?:^|\\n)\\s*(?:export\\s+)?(?:abstract\\s+)?class\\s+(\\w+)/gm;\r\n    while ((match = classPattern.exec(content)) !== null) {\r\n      const className = match[1];\r\n      if (className) {\r\n        const startLine = content.substring(0, match.index!).split('\\n').length;\r\n        const classBody = this.extractBlock(content, match.index! + match[0].length);\r\n        \r\n        if (classBody) {\r\n          elements.push({\r\n            type: 'class',\r\n            name: className,\r\n            filePath,\r\n            startLine,\r\n            endLine: startLine + classBody.split('\\n').length - 1,\r\n            complexity: this.calculateComplexity(classBody),\r\n            dependencies: this.extractDependencies(classBody),\r\n            usageCount: 0,\r\n            size: classBody.split('\\n').length,\r\n            content: classBody,\r\n            hash: createHash('md5').update(classBody.replace(/\\s+/g, ' ')).digest('hex')\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return elements;\r\n  }\r\n\r\n  private extractBlock(content: string, startIndex: number): string | null {\r\n    let braceCount = 0;\r\n    let inBlock = false;\r\n    let blockStart = startIndex;\r\n    \r\n    for (let i = startIndex; i < content.length; i++) {\r\n      const char = content[i];\r\n      \r\n      if (char === '{') {\r\n        if (!inBlock) {\r\n          blockStart = i;\r\n          inBlock = true;\r\n        }\r\n        braceCount++;\r\n      } else if (char === '}') {\r\n        braceCount--;\r\n        if (inBlock && braceCount === 0) {\r\n          return content.substring(blockStart, i + 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  private extractDependencies(content: string): string[] {\r\n    const dependencies: string[] = [];\r\n    \r\n    const importPattern = /import\\s+(?:\\{[^}]+\\}|\\w+|\\*\\s+as\\s+\\w+)\\s+from\\s+['\"]([^'\"]+)['\"]/g;\r\n    let match;\r\n    \r\n    while ((match = importPattern.exec(content)) !== null) {\r\n      dependencies.push(match[1]);\r\n    }\r\n    \r\n    const requirePattern = /require\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g;\r\n    while ((match = requirePattern.exec(content)) !== null) {\r\n      dependencies.push(match[1]);\r\n    }\r\n    \r\n    return [...new Set(dependencies)];\r\n  }\r\n\r\n  private calculateComplexity(code: string): number {\r\n    let complexity = 1;\r\n    \r\n    const complexityPatterns = [\r\n      /\\bif\\b/g, /\\belse\\b/g, /\\bwhile\\b/g, /\\bfor\\b/g,\r\n      /\\bswitch\\b/g, /\\bcase\\b/g, /\\bcatch\\b/g,\r\n      /\\b&&\\b/g, /\\b\\|\\|\\b/g, /\\?\\s*[^:]+\\s*:/g\r\n    ];\r\n    \r\n    complexityPatterns.forEach(pattern => {\r\n      const matches = code.match(pattern);\r\n      if (matches) complexity += matches.length;\r\n    });\r\n    \r\n    return complexity;\r\n  }\r\n\r\n  private async analyzePatterns(): Promise<CodePattern[]> {\r\n    const patterns: CodePattern[] = [];\r\n    \r\n    // Find duplicate functions\r\n    const functionsByHash = new Map<string, ArchitecturalElement[]>();\r\n    this.allElements\r\n      .filter(el => el.type === 'function')\r\n      .forEach(func => {\r\n        if (!functionsByHash.has(func.hash)) {\r\n          functionsByHash.set(func.hash, []);\r\n        }\r\n        functionsByHash.get(func.hash)!.push(func);\r\n      });\r\n    \r\n    functionsByHash.forEach((functions, hash) => {\r\n      if (functions.length > 1) {\r\n        const avgSize = functions.reduce((sum, f) => sum + f.size, 0) / functions.length;\r\n        patterns.push({\r\n          type: 'duplicate',\r\n          elements: functions,\r\n          description: `Found ${functions.length} duplicate functions with identical logic`,\r\n          severity: functions.length > 3 ? 'high' : 'medium',\r\n          recommendedAction: 'Extract common function to utility module and replace duplicates',\r\n          estimatedImpact: {\r\n            performance: 2,\r\n            maintainability: 8,\r\n            codeReduction: (functions.length - 1) * avgSize\r\n          },\r\n          implementationEffort: 'medium'\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Find complex functions\r\n    const complexFunctions = this.allElements\r\n      .filter(el => el.type === 'function' && el.complexity > 10)\r\n      .sort((a, b) => b.complexity - a.complexity);\r\n    \r\n    if (complexFunctions.length > 0) {\r\n      patterns.push({\r\n        type: 'complex',\r\n        elements: complexFunctions,\r\n        description: `Found ${complexFunctions.length} highly complex functions that are difficult to maintain`,\r\n        severity: 'high',\r\n        recommendedAction: 'Break down complex functions into smaller, focused functions',\r\n        estimatedImpact: {\r\n          performance: 3,\r\n          maintainability: 9,\r\n          codeReduction: 0\r\n        },\r\n        implementationEffort: 'high'\r\n      });\r\n    }\r\n    \r\n    return patterns;\r\n  }\r\n\r\n  private async identifyConsolidationOpportunities(): Promise<ConsolidationOpportunity[]> {\r\n    const opportunities: ConsolidationOpportunity[] = [];\r\n    \r\n    // Find similar functions that could be unified\r\n    const similarFunctions = this.findSimilarFunctions();\r\n    \r\n    if (similarFunctions.length > 0) {\r\n      opportunities.push({\r\n        type: 'method-centralization',\r\n        targetFiles: [...new Set(similarFunctions.map(f => f.filePath))],\r\n        suggestedLocation: 'src/utils/common.ts',\r\n        suggestedName: 'centralizedUtilities',\r\n        affectedElements: similarFunctions,\r\n        benefits: {\r\n          codeReduction: similarFunctions.reduce((sum, f) => sum + f.size, 0) * 0.7,\r\n          maintainabilityImprovement: 8,\r\n          performanceGain: 2\r\n        },\r\n        implementationSteps: [\r\n          'Create centralized utility module',\r\n          'Extract common patterns',\r\n          'Replace duplicated code',\r\n          'Update imports across project'\r\n        ],\r\n        riskLevel: 'low'\r\n      });\r\n    }\r\n    \r\n    return opportunities;\r\n  }\r\n\r\n  private findSimilarFunctions(): ArchitecturalElement[] {\r\n    const functions = this.allElements.filter(el => el.type === 'function');\r\n    const similar: ArchitecturalElement[] = [];\r\n    \r\n    for (let i = 0; i < functions.length; i++) {\r\n      for (let j = i + 1; j < functions.length; j++) {\r\n        const similarity = this.calculateSimilarity(functions[i].content, functions[j].content);\r\n        if (similarity > this.config.similarityThreshold) {\r\n          if (!similar.includes(functions[i])) similar.push(functions[i]);\r\n          if (!similar.includes(functions[j])) similar.push(functions[j]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return similar;\r\n  }\r\n\r\n  private calculateSimilarity(content1: string, content2: string): number {\r\n    const tokens1 = new Set(content1.replace(/\\s+/g, ' ').split(' '));\r\n    const tokens2 = new Set(content2.replace(/\\s+/g, ' ').split(' '));\r\n    \r\n    const intersection = new Set([...tokens1].filter(token => tokens2.has(token)));\r\n    const union = new Set([...tokens1, ...tokens2]);\r\n    \r\n    return intersection.size / union.size;\r\n  }\r\n\r\n  private async analyzePerformance(): Promise<PerformanceInsight[]> {\r\n    const insights: PerformanceInsight[] = [];\r\n    \r\n    // Find large functions that could be performance bottlenecks\r\n    const largeFunctions = this.allElements\r\n      .filter(el => el.type === 'function' && el.size > 100)\r\n      .sort((a, b) => b.size - a.size);\r\n    \r\n    largeFunctions.slice(0, 5).forEach(func => {\r\n      insights.push({\r\n        type: 'bottleneck',\r\n        location: `${func.filePath}:${func.startLine}`,\r\n        description: `Large function \"${func.name}\" with ${func.size} lines may impact performance`,\r\n        currentMetrics: {\r\n          executionTime: func.size * 0.1, // estimated\r\n        },\r\n        optimization: {\r\n          strategy: 'Break down into smaller functions and optimize critical paths',\r\n          expectedImprovement: '20-40% performance improvement',\r\n          implementationComplexity: 'medium'\r\n        },\r\n        priority: Math.min(10, Math.floor(func.size / 20))\r\n      });\r\n    });\r\n    \r\n    return insights;\r\n  }\r\n\r\n  private generateRecommendations(\r\n    patterns: CodePattern[], \r\n    opportunities: ConsolidationOpportunity[], \r\n    insights: PerformanceInsight[]\r\n  ): { immediate: string[]; shortTerm: string[]; longTerm: string[] } {\r\n    const immediate: string[] = [];\r\n    const shortTerm: string[] = [];\r\n    const longTerm: string[] = [];\r\n    \r\n    patterns.forEach(pattern => {\r\n      if (pattern.severity === 'critical' || pattern.severity === 'high') {\r\n        immediate.push(pattern.recommendedAction);\r\n      } else {\r\n        shortTerm.push(pattern.recommendedAction);\r\n      }\r\n    });\r\n    \r\n    opportunities.forEach(opp => {\r\n      if (opp.riskLevel === 'low') {\r\n        shortTerm.push(`Implement ${opp.type}: ${opp.suggestedName}`);\r\n      } else {\r\n        longTerm.push(`Consider ${opp.type}: ${opp.suggestedName}`);\r\n      }\r\n    });\r\n    \r\n    insights.forEach(insight => {\r\n      if (insight.priority > 7) {\r\n        immediate.push(`Address performance bottleneck: ${insight.description}`);\r\n      } else if (insight.priority > 4) {\r\n        shortTerm.push(`Optimize: ${insight.description}`);\r\n      } else {\r\n        longTerm.push(`Monitor: ${insight.description}`);\r\n      }\r\n    });\r\n    \r\n    return { immediate, shortTerm, longTerm };\r\n  }\r\n\r\n  private generateImplementationRoadmap(\r\n    patterns: CodePattern[], \r\n    opportunities: ConsolidationOpportunity[], \r\n    insights: PerformanceInsight[]\r\n  ): { phase: string; tasks: string[]; estimatedEffort: string; expectedBenefits: string[] }[] {\r\n    return [\r\n      {\r\n        phase: 'Phase 1: Critical Issues',\r\n        tasks: [\r\n          'Fix duplicate code patterns',\r\n          'Address high complexity functions',\r\n          'Resolve critical performance bottlenecks'\r\n        ],\r\n        estimatedEffort: '2-3 weeks',\r\n        expectedBenefits: [\r\n          'Improved code maintainability',\r\n          'Reduced technical debt',\r\n          'Better performance'\r\n        ]\r\n      },\r\n      {\r\n        phase: 'Phase 2: Code Consolidation',\r\n        tasks: [\r\n          'Implement utility extraction opportunities',\r\n          'Centralize common methods',\r\n          'Standardize interfaces'\r\n        ],\r\n        estimatedEffort: '3-4 weeks',\r\n        expectedBenefits: [\r\n          'Reduced code duplication',\r\n          'Improved developer productivity',\r\n          'Better code organization'\r\n        ]\r\n      },\r\n      {\r\n        phase: 'Phase 3: Long-term Optimization',\r\n        tasks: [\r\n          'Monitor performance metrics',\r\n          'Implement advanced optimizations',\r\n          'Continuous architectural improvements'\r\n        ],\r\n        estimatedEffort: 'Ongoing',\r\n        expectedBenefits: [\r\n          'Sustained performance',\r\n          'Scalable architecture',\r\n          'Future-proof codebase'\r\n        ]\r\n      }\r\n    ];\r\n  }\r\n\r\n  private calculateProjectMetrics(): {\r\n    totalFiles: number;\r\n    totalLines: number;\r\n    totalFunctions: number;\r\n    totalClasses: number;\r\n    duplicateCount: number;\r\n    complexityScore: number;\r\n  } {\r\n    const functions = this.allElements.filter(el => el.type === 'function');\r\n    const classes = this.allElements.filter(el => el.type === 'class');\r\n    \r\n    const totalLines = Array.from(this.fileContents.values())\r\n      .reduce((sum, content) => sum + content.split('\\n').length, 0);\r\n    \r\n    const duplicateCount = this.findDuplicateCount();\r\n    const complexityScore = this.calculateAverageComplexity();\r\n    \r\n    return {\r\n      totalFiles: this.fileContents.size,\r\n      totalLines,\r\n      totalFunctions: functions.length,\r\n      totalClasses: classes.length,\r\n      duplicateCount,\r\n      complexityScore\r\n    };\r\n  }\r\n\r\n  private findDuplicateCount(): number {\r\n    const hashes = new Set<string>();\r\n    let duplicates = 0;\r\n    \r\n    this.allElements.forEach(el => {\r\n      if (hashes.has(el.hash)) {\r\n        duplicates++;\r\n      } else {\r\n        hashes.add(el.hash);\r\n      }\r\n    });\r\n    \r\n    return duplicates;\r\n  }\r\n\r\n  private calculateAverageComplexity(): number {\r\n    const complexities = this.allElements.map(el => el.complexity);\r\n    return complexities.length > 0 \r\n      ? complexities.reduce((sum, c) => sum + c, 0) / complexities.length \r\n      : 0;\r\n  }\r\n\r\n  async saveReport(report: ArchitecturalReport, outputPath?: string): Promise<void> {\r\n    const reportPath = outputPath || path.join(this.projectRoot, 'reports', 'architectural-analysis.json');\r\n    const reportDir = path.dirname(reportPath);\r\n    \r\n    if (!fs.existsSync(reportDir)) {\r\n      fs.mkdirSync(reportDir, { recursive: true });\r\n    }\r\n    \r\n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\r\n    console.log(`📊 Report saved to: ${reportPath}`);\r\n  }\r\n}\r\n\r\n// Main execution\r\nasync function main(): Promise<void> {\r\n  try {\r\n    const projectRoot = process.cwd();\r\n    console.log('🚀 Starting Architectural Analysis...');\r\n    \r\n    const analyzer = new ArchitecturalAnalyzer(projectRoot);\r\n    const report = await analyzer.analyzeProject();\r\n    \r\n    await analyzer.saveReport(report);\r\n    \r\n    console.log('\\n📋 Analysis Summary:');\r\n    console.log(`├── Files analyzed: ${report.projectMetrics.totalFiles}`);\r\n    console.log(`├── Functions found: ${report.projectMetrics.totalFunctions}`);\r\n    console.log(`├── Classes found: ${report.projectMetrics.totalClasses}`);\r\n    console.log(`├── Patterns identified: ${report.patterns.length}`);\r\n    console.log(`├── Consolidation opportunities: ${report.consolidationOpportunities.length}`);\r\n    console.log(`├── Performance insights: ${report.performanceInsights.length}`);\r\n    console.log(`└── Average complexity: ${report.projectMetrics.complexityScore.toFixed(2)}`);\r\n    \r\n    console.log('\\n💡 Key Recommendations:');\r\n    report.recommendations.immediate.slice(0, 3).forEach((rec, i) => {\r\n      console.log(`${i + 1}. ${rec}`);\r\n    });\r\n    \r\n    console.log('\\n✅ Architectural analysis complete! Check the full report for detailed recommendations.');\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Error during architectural analysis:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Execute if run directly\r\nif (require.main === module) {\r\n  main();\r\n}","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\duplicate-method-detector.ts","messages":[{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":91,"column":5,"nodeType":"Literal","endLine":91,"endColumn":190},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":93,"column":5,"nodeType":"Literal","endLine":93,"endColumn":154},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":95,"column":5,"nodeType":"Literal","endLine":95,"endColumn":61},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":171,"column":20,"nodeType":"MemberExpression","endLine":171,"endColumn":41},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":211,"column":44,"nodeType":"Literal","endLine":211,"endColumn":80},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":322,"column":25,"nodeType":"CallExpression","endLine":322,"endColumn":73},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":359,"column":21,"nodeType":"CallExpression","endLine":359,"endColumn":42},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":365,"column":23,"nodeType":"CallExpression","endLine":365,"endColumn":57},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":414,"column":45,"nodeType":"MemberExpression","endLine":414,"endColumn":55},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":419,"column":53,"nodeType":"MemberExpression","endLine":419,"endColumn":63},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":419,"column":65,"nodeType":"MemberExpression","endLine":419,"endColumn":75},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":421,"column":31,"nodeType":"MemberExpression","endLine":421,"endColumn":41},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":428,"column":17,"nodeType":"MemberExpression","endLine":428,"endColumn":27},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":458,"column":7,"nodeType":"MemberExpression","endLine":458,"endColumn":16},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":462,"column":7,"nodeType":"MemberExpression","endLine":462,"endColumn":19},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":468,"column":11,"nodeType":"MemberExpression","endLine":468,"endColumn":23},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":468,"column":11,"nodeType":"MemberExpression","endLine":468,"endColumn":20},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":470,"column":11,"nodeType":"MemberExpression","endLine":470,"endColumn":23},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":470,"column":11,"nodeType":"MemberExpression","endLine":470,"endColumn":20},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":472,"column":13,"nodeType":"MemberExpression","endLine":472,"endColumn":22},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":473,"column":13,"nodeType":"MemberExpression","endLine":473,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":490,"column":53,"nodeType":"MemberExpression","endLine":490,"endColumn":63},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":490,"column":65,"nodeType":"MemberExpression","endLine":490,"endColumn":75},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":654,"column":5,"nodeType":"CallExpression","endLine":654,"endColumn":70},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":699,"column":12,"nodeType":"MemberExpression","endLine":699,"endColumn":19},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":699,"column":40,"nodeType":"MemberExpression","endLine":699,"endColumn":47},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":699,"column":54,"nodeType":"Literal","endLine":699,"endColumn":69},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":700,"column":34,"nodeType":"MemberExpression","endLine":700,"endColumn":41}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env tsx\r\n\r\n/**\r\n * Duplicate Method Detection Script\r\n * \r\n * This script analyzes the codebase to identify methods with identical or very similar code.\r\n * It provides a detailed report of duplicate methods, including their location and code comparison.\r\n * \r\n * Features:\r\n * - Detects exact duplicate methods\r\n * - Identifies similar methods with configurable similarity threshold\r\n * - Provides detailed reports with code comparisons\r\n * - Supports refactoring suggestions\r\n * - Works with TypeScript and JavaScript files\r\n * \r\n * Usage:\r\n *   npx tsx scripts/analysis/duplicate-method-detector.ts\r\n *   npm run detect:duplicates\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { createHash } from 'crypto';\r\n\r\n// Types and interfaces\r\ninterface MethodInfo {\r\n  name: string;\r\n  signature: string;\r\n  body: string;\r\n  normalizedBody: string;\r\n  hash: string;\r\n  filePath: string;\r\n  startLine: number;\r\n  endLine: number;\r\n  className?: string;\r\n  isStatic: boolean;\r\n  isAsync: boolean;\r\n  parameters: string[];\r\n  returnType?: string;\r\n}\r\n\r\ninterface DuplicateGroup {\r\n  hash: string;\r\n  methods: MethodInfo[];\r\n  type: 'exact' | 'similar';\r\n  similarityScore?: number;\r\n}\r\n\r\ninterface DetectionOptions {\r\n  minMethodLength: number;\r\n  similarityThreshold: number;\r\n  includePrivateMethods: boolean;\r\n  includeGettersSetters: boolean;\r\n  excludePatterns: string[];\r\n  maxFileSize: number;\r\n}\r\n\r\ninterface DetectionResult {\r\n  totalMethods: number;\r\n  totalFiles: number;\r\n  duplicateGroups: DuplicateGroup[];\r\n  exactDuplicates: number;\r\n  similarDuplicates: number;\r\n  potentialSavings: {\r\n    linesOfCode: number;\r\n    duplicateFiles: number;\r\n  };\r\n}\r\n\r\n// Default configuration\r\nconst DEFAULT_OPTIONS: DetectionOptions = {\r\n  minMethodLength: 3, // Minimum lines of code in method body\r\n  similarityThreshold: 0.85, // 85% similarity threshold\r\n  includePrivateMethods: true,\r\n  includeGettersSetters: false,\r\n  excludePatterns: [\r\n    'test',\r\n    'spec',\r\n    '.d.ts',\r\n    'node_modules',\r\n    'dist',\r\n    'build'\r\n  ],\r\n  maxFileSize: 50000 // 50KB max file size\r\n};\r\n\r\n// Utility functions\r\nclass MethodExtractor {\r\n  private static readonly METHOD_PATTERNS = [\r\n    // Regular function declarations\r\n    /(?:^|\\n)\\s*((?:export\\s+)?(?:async\\s+)?(?:static\\s+)?(?:private\\s+|public\\s+|protected\\s+)?(?:abstract\\s+)?(?:readonly\\s+)?(?:get\\s+|set\\s+)?(\\w+)\\s*\\([^)]*\\)\\s*(?::\\s*[^{]+)?\\s*\\{)/gm,\r\n    // Arrow functions as class properties\r\n    /(?:^|\\n)\\s*((?:private\\s+|public\\s+|protected\\s+)?(?:static\\s+)?(?:readonly\\s+)?(\\w+)\\s*[:=]\\s*(?:async\\s+)?\\([^)]*\\)\\s*(?::\\s*[^=]+)?\\s*=>\\s*\\{)/gm,\r\n    // Method definitions in objects\r\n    /(?:^|\\n)\\s*((\\w+)\\s*\\([^)]*\\)\\s*(?::\\s*[^{]+)?\\s*\\{)/gm\r\n  ];\r\n\r\n  static extractMethods(content: string, filePath: string): MethodInfo[] {\r\n    const methods: MethodInfo[] = [];\r\n    const lines = content.split('\\n');\r\n\r\n    for (const pattern of this.METHOD_PATTERNS) {\r\n      let match;\r\n      pattern.lastIndex = 0; // Reset regex state\r\n\r\n      while ((match = pattern.exec(content)) !== null) {\r\n        try {\r\n          const methodInfo = this.parseMethodFromMatch(match, content, filePath, lines);\r\n          if (methodInfo && this.isValidMethod(methodInfo)) {\r\n            methods.push(methodInfo);\r\n          }\r\n        } catch (error) {\r\n          // Skip malformed methods\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.deduplicateMethods(methods);\r\n  }\r\n\r\n  private static parseMethodFromMatch(\r\n    match: RegExpExecArray,\r\n    content: string,\r\n    filePath: string,\r\n    lines: string[]\r\n  ): MethodInfo | null {\r\n    const fullMatch = match[1];\r\n    const methodName = match[2] || this.extractMethodName(fullMatch);\r\n    \r\n    if (!methodName || methodName.length < 2) return null;\r\n\r\n    const startIndex = match.index!;\r\n    const startLine = content.substring(0, startIndex).split('\\n').length;\r\n    \r\n    // Find method body using brace matching\r\n    const methodBody = this.extractMethodBody(content, startIndex + fullMatch.length - 1);\r\n    if (!methodBody) return null;\r\n\r\n    const endLine = startLine + methodBody.split('\\n').length - 1;\r\n    const normalizedBody = this.normalizeMethodBody(methodBody);\r\n    \r\n    return {\r\n      name: methodName,\r\n      signature: this.extractSignature(fullMatch),\r\n      body: methodBody,\r\n      normalizedBody,\r\n      hash: this.generateMethodHash(normalizedBody),\r\n      filePath,\r\n      startLine,\r\n      endLine,\r\n      className: this.extractClassName(content, startIndex),\r\n      isStatic: fullMatch.includes('static'),\r\n      isAsync: fullMatch.includes('async'),\r\n      parameters: this.extractParameters(fullMatch),\r\n      returnType: this.extractReturnType(fullMatch)\r\n    };\r\n  }\r\n\r\n  private static extractMethodName(signature: string): string {\r\n    const nameMatch = signature.match(/(\\w+)\\s*\\(/);\r\n    return nameMatch ? nameMatch[1] : '';\r\n  }\r\n\r\n  private static extractMethodBody(content: string, startIndex: number): string | null {\r\n    let braceCount = 0;\r\n    let currentIndex = startIndex;\r\n    let foundFirstBrace = false;\r\n    \r\n    while (currentIndex < content.length) {\r\n      const char = content[currentIndex];\r\n      \r\n      if (char === '{') {\r\n        braceCount++;\r\n        foundFirstBrace = true;\r\n      } else if (char === '}') {\r\n        braceCount--;\r\n        if (foundFirstBrace && braceCount === 0) {\r\n          return content.substring(startIndex, currentIndex + 1);\r\n        }\r\n      }\r\n      \r\n      currentIndex++;\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  private static normalizeMethodBody(body: string): string {\r\n    return body\r\n      // Remove comments\r\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\r\n      .replace(/\\/\\/.*$/gm, '')\r\n      // Normalize whitespace\r\n      .replace(/\\s+/g, ' ')\r\n      // Remove unnecessary semicolons\r\n      .replace(/;\\s*}/g, '}')\r\n      // Normalize string literals (basic)\r\n      .replace(/\"[^\"]*\"/g, '\"\"')\r\n      .replace(/'[^']*'/g, \"''\")\r\n      .replace(/`[^`]*`/g, '``')\r\n      // Remove trailing/leading spaces\r\n      .trim();\r\n  }\r\n\r\n  private static generateMethodHash(normalizedBody: string): string {\r\n    return createHash('md5').update(normalizedBody).digest('hex');\r\n  }\r\n\r\n  private static extractSignature(fullMatch: string): string {\r\n    const signatureMatch = fullMatch.match(/(\\w+\\s*\\([^)]*\\)(?:\\s*:\\s*[^{]+)?)/);\r\n    return signatureMatch ? signatureMatch[1].trim() : fullMatch.trim();\r\n  }\r\n\r\n  private static extractClassName(content: string, methodIndex: number): string | undefined {\r\n    const beforeMethod = content.substring(0, methodIndex);\r\n    const classMatch = beforeMethod.match(/class\\s+(\\w+)/g);\r\n    if (classMatch && classMatch.length > 0) {\r\n      const lastClass = classMatch[classMatch.length - 1];\r\n      const nameMatch = lastClass.match(/class\\s+(\\w+)/);\r\n      return nameMatch ? nameMatch[1] : undefined;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private static extractParameters(signature: string): string[] {\r\n    const paramMatch = signature.match(/\\(([^)]*)\\)/);\r\n    if (!paramMatch || !paramMatch[1].trim()) return [];\r\n    \r\n    return paramMatch[1]\r\n      .split(',')\r\n      .map(param => param.trim().split(':')[0].trim())\r\n      .filter(param => param.length > 0);\r\n  }\r\n\r\n  private static extractReturnType(signature: string): string | undefined {\r\n    const returnMatch = signature.match(/\\):\\s*([^{]+)/);\r\n    return returnMatch ? returnMatch[1].trim() : undefined;\r\n  }\r\n\r\n  private static isValidMethod(method: MethodInfo): boolean {\r\n    // Filter out very short methods\r\n    const bodyLines = method.body.split('\\n').length;\r\n    if (bodyLines < DEFAULT_OPTIONS.minMethodLength) return false;\r\n    \r\n    // Filter out getters/setters if configured\r\n    if (!DEFAULT_OPTIONS.includeGettersSetters && \r\n        (method.signature.includes('get ') || method.signature.includes('set '))) {\r\n      return false;\r\n    }\r\n    \r\n    // Filter out private methods if configured\r\n    if (!DEFAULT_OPTIONS.includePrivateMethods && method.signature.includes('private')) {\r\n      return false;\r\n    }\r\n    \r\n    // Filter out common trivial methods\r\n    const trivialPatterns = [\r\n      /^{\\s*return\\s+\\w+;\\s*}$/,\r\n      /^{\\s*this\\.\\w+\\s*=\\s*\\w+;\\s*}$/,\r\n      /^{\\s*}$/\r\n    ];\r\n    \r\n    return !trivialPatterns.some(pattern => pattern.test(method.normalizedBody));\r\n  }\r\n\r\n  private static deduplicateMethods(methods: MethodInfo[]): MethodInfo[] {\r\n    const seen = new Set<string>();\r\n    return methods.filter(method => {\r\n      const key = `${method.filePath}:${method.startLine}:${method.name}`;\r\n      if (seen.has(key)) return false;\r\n      seen.add(key);\r\n      return true;\r\n    });\r\n  }\r\n}\r\n\r\n// Main duplicate method detector class\r\nclass DuplicateMethodDetector {\r\n  private options: DetectionOptions;\r\n\r\n  constructor(options: Partial<DetectionOptions> = {}) {\r\n    this.options = { ...DEFAULT_OPTIONS, ...options };\r\n  }\r\n\r\n  async detectDuplicates(rootPath: string = process.cwd()): Promise<DetectionResult> {\r\n    console.log('🔍 Starting duplicate method detection...');\r\n    console.log(`📁 Scanning directory: ${rootPath}`);\r\n    \r\n    const files = this.findTypeScriptFiles(rootPath);\r\n    console.log(`📄 Found ${files.length} TypeScript files to analyze`);\r\n    \r\n    const allMethods: MethodInfo[] = [];\r\n    let processedFiles = 0;\r\n\r\n    for (const file of files) {\r\n      try {\r\n        const methods = await this.extractMethodsFromFile(file);\r\n        allMethods.push(...methods);\r\n        processedFiles++;\r\n        \r\n        if (processedFiles % 50 === 0) {\r\n          console.log(`⏳ Processed ${processedFiles}/${files.length} files...`);\r\n        }\r\n      } catch (error) {\r\n        console.warn(`⚠️ Could not process file ${file}: ${error}`);\r\n      }\r\n    }\r\n\r\n    console.log(`✅ Extracted ${allMethods.length} methods from ${processedFiles} files`);\r\n    \r\n    const duplicateGroups = this.findDuplicateGroups(allMethods);\r\n    \r\n    return this.buildResult(allMethods, processedFiles, duplicateGroups);\r\n  }\r\n\r\n  private findTypeScriptFiles(rootPath: string): string[] {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (dirPath: string): void => {\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory()) {\r\n            // Skip excluded directories\r\n            if (this.shouldExcludePath(entry.name)) continue;\r\n            scanDirectory(fullPath);\r\n          } else if (entry.isFile()) {\r\n            // Include TypeScript files\r\n            if (this.isTypeScriptFile(entry.name) && !this.shouldExcludePath(fullPath)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    };\r\n\r\n    scanDirectory(rootPath);\r\n    return files;\r\n  }\r\n\r\n  private shouldExcludePath(filePath: string): boolean {\r\n    return this.options.excludePatterns.some(pattern => \r\n      filePath.includes(pattern)\r\n    );\r\n  }\r\n\r\n  private isTypeScriptFile(fileName: string): boolean {\r\n    return /\\.(ts|tsx|js|jsx)$/.test(fileName) && !fileName.endsWith('.d.ts');\r\n  }\r\n\r\n  private async extractMethodsFromFile(filePath: string): Promise<MethodInfo[]> {\r\n    try {\r\n      const stats = fs.statSync(filePath);\r\n      if (stats.size > this.options.maxFileSize) {\r\n        console.warn(`⚠️ Skipping large file: ${filePath} (${stats.size} bytes)`);\r\n        return [];\r\n      }\r\n\r\n      const content = fs.readFileSync(filePath, 'utf-8');\r\n      return MethodExtractor.extractMethods(content, filePath);\r\n    } catch (error) {\r\n      console.warn(`⚠️ Error reading file ${filePath}: ${error}`);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private findDuplicateGroups(methods: MethodInfo[]): DuplicateGroup[] {\r\n    const groups: DuplicateGroup[] = [];\r\n    const methodsByHash = new Map<string, MethodInfo[]>();\r\n\r\n    // Group methods by their normalized hash\r\n    for (const method of methods) {\r\n      if (!methodsByHash.has(method.hash)) {\r\n        methodsByHash.set(method.hash, []);\r\n      }\r\n      methodsByHash.get(method.hash)!.push(method);\r\n    }\r\n\r\n    // Find exact duplicates\r\n    for (const [hash, groupMethods] of methodsByHash) {\r\n      if (groupMethods.length > 1) {\r\n        groups.push({\r\n          hash,\r\n          methods: groupMethods,\r\n          type: 'exact'\r\n        });\r\n      }\r\n    }\r\n\r\n    // Find similar methods (cross-compare remaining methods)\r\n    const singleMethods = Array.from(methodsByHash.values())\r\n      .filter(group => group.length === 1)\r\n      .map(group => group[0]);\r\n\r\n    const similarGroups = this.findSimilarMethods(singleMethods);\r\n    groups.push(...similarGroups);\r\n\r\n    return groups;\r\n  }\r\n\r\n  private findSimilarMethods(methods: MethodInfo[]): DuplicateGroup[] {\r\n    const similarGroups: DuplicateGroup[] = [];\r\n    const processed = new Set<number>();\r\n\r\n    for (let i = 0; i < methods.length; i++) {\r\n      if (processed.has(i)) continue;\r\n\r\n      const similarMethods: MethodInfo[] = [methods[i]];\r\n      \r\n      for (let j = i + 1; j < methods.length; j++) {\r\n        if (processed.has(j)) continue;\r\n\r\n        const similarity = this.calculateSimilarity(methods[i], methods[j]);\r\n        if (similarity >= this.options.similarityThreshold) {\r\n          similarMethods.push(methods[j]);\r\n          processed.add(j);\r\n        }\r\n      }\r\n\r\n      if (similarMethods.length > 1) {\r\n        similarGroups.push({\r\n          hash: methods[i].hash,\r\n          methods: similarMethods,\r\n          type: 'similar',\r\n          similarityScore: this.calculateGroupSimilarity(similarMethods)\r\n        });\r\n      }\r\n\r\n      processed.add(i);\r\n    }\r\n\r\n    return similarGroups;\r\n  }\r\n\r\n  private calculateSimilarity(method1: MethodInfo, method2: MethodInfo): number {\r\n    // Use Levenshtein distance for similarity calculation\r\n    const normalized1 = method1.normalizedBody;\r\n    const normalized2 = method2.normalizedBody;\r\n    \r\n    if (normalized1 === normalized2) return 1.0;\r\n    \r\n    const distance = this.levenshteinDistance(normalized1, normalized2);\r\n    const maxLength = Math.max(normalized1.length, normalized2.length);\r\n    \r\n    return maxLength > 0 ? 1 - (distance / maxLength) : 0;\r\n  }\r\n\r\n  private levenshteinDistance(str1: string, str2: string): number {\r\n    const matrix: number[][] = [];\r\n    \r\n    for (let i = 0; i <= str2.length; i++) {\r\n      matrix[i] = [i];\r\n    }\r\n    \r\n    for (let j = 0; j <= str1.length; j++) {\r\n      matrix[0][j] = j;\r\n    }\r\n    \r\n    for (let i = 1; i <= str2.length; i++) {\r\n      for (let j = 1; j <= str1.length; j++) {\r\n        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\r\n          matrix[i][j] = matrix[i - 1][j - 1];\r\n        } else {\r\n          matrix[i][j] = Math.min(\r\n            matrix[i - 1][j - 1] + 1, // substitution\r\n            matrix[i][j - 1] + 1,     // insertion\r\n            matrix[i - 1][j] + 1      // deletion\r\n          );\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matrix[str2.length][str1.length];\r\n  }\r\n\r\n  private calculateGroupSimilarity(methods: MethodInfo[]): number {\r\n    if (methods.length < 2) return 1.0;\r\n    \r\n    let totalSimilarity = 0;\r\n    let comparisons = 0;\r\n    \r\n    for (let i = 0; i < methods.length; i++) {\r\n      for (let j = i + 1; j < methods.length; j++) {\r\n        totalSimilarity += this.calculateSimilarity(methods[i], methods[j]);\r\n        comparisons++;\r\n      }\r\n    }\r\n    \r\n    return comparisons > 0 ? totalSimilarity / comparisons : 0;\r\n  }\r\n\r\n  private buildResult(\r\n    allMethods: MethodInfo[],\r\n    processedFiles: number,\r\n    duplicateGroups: DuplicateGroup[]\r\n  ): DetectionResult {\r\n    const exactDuplicates = duplicateGroups.filter(g => g.type === 'exact').length;\r\n    const similarDuplicates = duplicateGroups.filter(g => g.type === 'similar').length;\r\n    \r\n    const potentialSavings = this.calculatePotentialSavings(duplicateGroups);\r\n    \r\n    return {\r\n      totalMethods: allMethods.length,\r\n      totalFiles: processedFiles,\r\n      duplicateGroups,\r\n      exactDuplicates,\r\n      similarDuplicates,\r\n      potentialSavings\r\n    };\r\n  }\r\n\r\n  private calculatePotentialSavings(groups: DuplicateGroup[]): { linesOfCode: number; duplicateFiles: number } {\r\n    let linesOfCode = 0;\r\n    const duplicateFiles = new Set<string>();\r\n    \r\n    for (const group of groups) {\r\n      if (group.methods.length > 1) {\r\n        // Calculate potential savings (keep one, remove others)\r\n        const duplicateMethodsCount = group.methods.length - 1;\r\n        const avgLinesPerMethod = group.methods.reduce((sum, method) => \r\n          sum + (method.endLine - method.startLine + 1), 0) / group.methods.length;\r\n        \r\n        linesOfCode += Math.round(duplicateMethodsCount * avgLinesPerMethod);\r\n        \r\n        group.methods.forEach(method => duplicateFiles.add(method.filePath));\r\n      }\r\n    }\r\n    \r\n    return {\r\n      linesOfCode,\r\n      duplicateFiles: duplicateFiles.size\r\n    };\r\n  }\r\n}\r\n\r\n// Report generator class\r\nclass DuplicateMethodReporter {\r\n  static generateReport(result: DetectionResult): void {\r\n    console.log('\\n' + '='.repeat(80));\r\n    console.log('📊 DUPLICATE METHOD DETECTION REPORT');\r\n    console.log('='.repeat(80));\r\n    \r\n    this.printSummary(result);\r\n    this.printDuplicateGroups(result.duplicateGroups);\r\n    this.printRecommendations(result);\r\n    \r\n    console.log('\\n' + '='.repeat(80));\r\n  }\r\n\r\n  private static printSummary(result: DetectionResult): void {\r\n    console.log('\\n📈 SUMMARY:');\r\n    console.log(`   Total Methods Analyzed: ${result.totalMethods}`);\r\n    console.log(`   Total Files Processed: ${result.totalFiles}`);\r\n    console.log(`   Exact Duplicate Groups: ${result.exactDuplicates}`);\r\n    console.log(`   Similar Method Groups: ${result.similarDuplicates}`);\r\n    console.log(`   Potential Lines Saved: ${result.potentialSavings.linesOfCode}`);\r\n    console.log(`   Files with Duplicates: ${result.potentialSavings.duplicateFiles}`);\r\n  }\r\n\r\n  private static printDuplicateGroups(groups: DuplicateGroup[]): void {\r\n    if (groups.length === 0) {\r\n      console.log('\\n✅ No duplicate methods found!');\r\n      return;\r\n    }\r\n\r\n    console.log('\\n🔍 DUPLICATE GROUPS:');\r\n    \r\n    groups.forEach((group, index) => {\r\n      console.log(`\\n${index + 1}. ${group.type.toUpperCase()} DUPLICATES (${group.methods.length} methods)`);\r\n      \r\n      if (group.type === 'similar' && group.similarityScore) {\r\n        console.log(`   Similarity Score: ${(group.similarityScore * 100).toFixed(1)}%`);\r\n      }\r\n      \r\n      group.methods.forEach((method, methodIndex) => {\r\n        const relativePath = method.filePath.replace(process.cwd(), '.');\r\n        console.log(`   ${methodIndex + 1}. ${method.name}() in ${relativePath}:${method.startLine}`);\r\n        \r\n        if (method.className) {\r\n          console.log(`      Class: ${method.className}`);\r\n        }\r\n        \r\n        console.log(`      Signature: ${method.signature}`);\r\n        console.log(`      Lines: ${method.startLine}-${method.endLine} (${method.endLine - method.startLine + 1} lines)`);\r\n      });\r\n      \r\n      // Show code comparison for exact duplicates\r\n      if (group.type === 'exact' && group.methods.length === 2) {\r\n        console.log('   \\n📝 Code Preview:');\r\n        const previewLines = group.methods[0].body.split('\\n').slice(0, 5);\r\n        previewLines.forEach(line => console.log(`      ${line}`));\r\n        if (group.methods[0].body.split('\\n').length > 5) {\r\n          console.log('      ...');\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private static printRecommendations(result: DetectionResult): void {\r\n    console.log('\\n💡 RECOMMENDATIONS:');\r\n    \r\n    if (result.exactDuplicates > 0) {\r\n      console.log('   1. Extract exact duplicate methods into utility functions');\r\n      console.log('   2. Create shared base classes or mixins for common functionality');\r\n      console.log('   3. Consider using composition over inheritance where appropriate');\r\n    }\r\n    \r\n    if (result.similarDuplicates > 0) {\r\n      console.log('   4. Review similar methods for potential refactoring opportunities');\r\n      console.log('   5. Consider parameterizing similar methods to reduce duplication');\r\n      console.log('   6. Look for opportunities to create template methods or strategy patterns');\r\n    }\r\n    \r\n    if (result.potentialSavings.linesOfCode > 100) {\r\n      console.log('   7. HIGH IMPACT: Consider prioritizing duplicate removal');\r\n      console.log(`      Potential savings: ${result.potentialSavings.linesOfCode} lines of code`);\r\n    }\r\n    \r\n    console.log('   8. Run this analysis regularly as part of code review process');\r\n    console.log('   9. Consider adding duplicate detection to CI/CD pipeline');\r\n  }\r\n\r\n  static saveReportToFile(result: DetectionResult, outputPath: string): void {\r\n    const reportData = {\r\n      timestamp: new Date().toISOString(),\r\n      summary: {\r\n        totalMethods: result.totalMethods,\r\n        totalFiles: result.totalFiles,\r\n        exactDuplicates: result.exactDuplicates,\r\n        similarDuplicates: result.similarDuplicates,\r\n        potentialSavings: result.potentialSavings\r\n      },\r\n      duplicateGroups: result.duplicateGroups.map(group => ({\r\n        type: group.type,\r\n        methodCount: group.methods.length,\r\n        similarityScore: group.similarityScore,\r\n        methods: group.methods.map(method => ({\r\n          name: method.name,\r\n          filePath: method.filePath.replace(process.cwd(), '.'),\r\n          startLine: method.startLine,\r\n          endLine: method.endLine,\r\n          className: method.className,\r\n          signature: method.signature\r\n        }))\r\n      }))\r\n    };\r\n\r\n    fs.writeFileSync(outputPath, JSON.stringify(reportData, null, 2));\r\n    console.log(`\\n💾 Report saved to: ${outputPath}`);\r\n  }\r\n}\r\n\r\n// Main execution\r\nasync function main(): Promise<void> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    // Parse command line arguments\r\n    const args = process.argv.slice(2);\r\n    const helpFlag = args.includes('--help') || args.includes('-h');\r\n    \r\n    if (helpFlag) {\r\n      printUsage();\r\n      return;\r\n    }\r\n\r\n    const options: Partial<DetectionOptions> = {};\r\n    \r\n    // Parse options\r\n    const thresholdIndex = args.indexOf('--threshold');\r\n    if (thresholdIndex !== -1 && args[thresholdIndex + 1]) {\r\n      options.similarityThreshold = parseFloat(args[thresholdIndex + 1]);\r\n    }\r\n    \r\n    const minLengthIndex = args.indexOf('--min-length');\r\n    if (minLengthIndex !== -1 && args[minLengthIndex + 1]) {\r\n      options.minMethodLength = parseInt(args[minLengthIndex + 1]);\r\n    }\r\n    \r\n    const includePrivateFlag = args.includes('--include-private');\r\n    if (includePrivateFlag) {\r\n      options.includePrivateMethods = true;\r\n    }\r\n    \r\n    const includeGettersSettersFlag = args.includes('--include-getters-setters');\r\n    if (includeGettersSettersFlag) {\r\n      options.includeGettersSetters = true;\r\n    }\r\n\r\n    // Get target directory (last non-option argument)\r\n    let targetDir = process.cwd();\r\n    for (let i = args.length - 1; i >= 0; i--) {\r\n      if (!args[i].startsWith('-') && !args[i].match(/^\\d+(\\.\\d+)?$/)) {\r\n        targetDir = path.resolve(args[i]);\r\n        break;\r\n      }\r\n    }\r\n    \r\n    console.log('🚀 Duplicate Method Detector');\r\n    console.log(`⚙️ Configuration:`);\r\n    console.log(`   Similarity Threshold: ${options.similarityThreshold || DEFAULT_OPTIONS.similarityThreshold}`);\r\n    console.log(`   Minimum Method Length: ${options.minMethodLength || DEFAULT_OPTIONS.minMethodLength} lines`);\r\n    console.log(`   Include Private Methods: ${options.includePrivateMethods ?? DEFAULT_OPTIONS.includePrivateMethods}`);\r\n    console.log(`   Include Getters/Setters: ${options.includeGettersSetters ?? DEFAULT_OPTIONS.includeGettersSetters}`);\r\n    \r\n    // Run detection\r\n    const detector = new DuplicateMethodDetector(options);\r\n    const result = await detector.detectDuplicates(targetDir);\r\n    \r\n    // Generate report\r\n    DuplicateMethodReporter.generateReport(result);\r\n    \r\n    // Save detailed report\r\n    const reportsDir = path.join(process.cwd(), 'reports', 'quality');\r\n    if (!fs.existsSync(reportsDir)) {\r\n      fs.mkdirSync(reportsDir, { recursive: true });\r\n    }\r\n    \r\n    const timestamp = new Date().toISOString().split('T')[0];\r\n    const reportPath = path.join(reportsDir, `duplicate-methods-${timestamp}.json`);\r\n    DuplicateMethodReporter.saveReportToFile(result, reportPath);\r\n    \r\n    const endTime = Date.now();\r\n    const duration = ((endTime - startTime) / 1000).toFixed(2);\r\n    console.log(`\\n⏱️ Analysis completed in ${duration} seconds`);\r\n    \r\n    // Exit with appropriate code\r\n    const hasDuplicates = result.exactDuplicates > 0 || result.similarDuplicates > 0;\r\n    process.exit(hasDuplicates ? 1 : 0);\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Error during duplicate method detection:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nfunction printUsage(): void {\r\n  console.log(`\r\n🔍 Duplicate Method Detector\r\n\r\nUSAGE:\r\n  npx tsx scripts/analysis/duplicate-method-detector.ts [OPTIONS] [DIRECTORY]\r\n\r\nOPTIONS:\r\n  --threshold <number>          Similarity threshold (0.0-1.0, default: 0.85)\r\n  --min-length <number>         Minimum method length in lines (default: 3)\r\n  --include-private             Include private methods in analysis\r\n  --include-getters-setters     Include getter/setter methods\r\n  --help, -h                    Show this help message\r\n\r\nEXAMPLES:\r\n  # Analyze current directory with default settings\r\n  npx tsx scripts/analysis/duplicate-method-detector.ts\r\n  \r\n  # Analyze specific directory with custom threshold\r\n  npx tsx scripts/analysis/duplicate-method-detector.ts --threshold 0.9 ./src\r\n  \r\n  # Include private methods and getters/setters\r\n  npx tsx scripts/analysis/duplicate-method-detector.ts --include-private --include-getters-setters\r\n\r\nOUTPUT:\r\n  - Console report with detailed findings\r\n  - JSON report saved to scripts/analysis/reports/quality/duplicate-methods-YYYY-MM-DD.json\r\n  - Exit code 0 if no duplicates found, 1 if duplicates detected\r\n`);\r\n}\r\n\r\n// Run if called directly\r\nif (require.main === module) {\r\n  main().catch(console.error);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\duplication-analyzer.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":78,"column":10,"nodeType":"CallExpression","endLine":78,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":79,"column":7,"nodeType":"CallExpression","endLine":79,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":90,"column":12,"nodeType":"CallExpression","endLine":90,"endColumn":37},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":92,"column":23,"nodeType":"CallExpression","endLine":92,"endColumn":74},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":121,"column":23,"nodeType":"CallExpression","endLine":121,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":189,"column":17,"nodeType":"CallExpression","endLine":189,"endColumn":38},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":210,"column":29,"nodeType":"Literal","endLine":210,"endColumn":177},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":211,"column":26,"nodeType":"Literal","endLine":211,"endColumn":157},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":212,"column":30,"nodeType":"Literal","endLine":212,"endColumn":125},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":219,"column":25,"nodeType":"CallExpression","endLine":219,"endColumn":54},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":331,"column":11,"nodeType":"CallExpression","endLine":331,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":381,"column":5,"nodeType":"CallExpression","endLine":381,"endColumn":66},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":524,"column":5,"nodeType":"CallExpression","endLine":524,"endColumn":44},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":540,"column":12,"nodeType":"MemberExpression","endLine":540,"endColumn":28}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\nimport { execSync } from 'child_process';\r\nimport * as crypto from 'crypto';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Advanced Code Duplication Detection Script\r\n * Implements Task 41.2 - Automated Duplicated Code Detection\r\n */\r\n\r\ninterface DuplicateFile {\r\n  type: 'exact_duplicate';\r\n  files: string[];\r\n  hash: string;\r\n  size: number;\r\n}\r\n\r\ninterface CodeBlock {\r\n  type: 'function' | 'class' | 'interface';\r\n  content: string;\r\n  file: string;\r\n  index: number;\r\n  hash: string;\r\n}\r\n\r\ninterface DuplicateCodeBlock {\r\n  type: 'code_block_duplicate';\r\n  hash: string;\r\n  blockType: string;\r\n  count: number;\r\n  instances: Array<{ file: string; index: number }>;\r\n  content: string;\r\n}\r\n\r\ninterface JSCPDResult {\r\n  report?: string;\r\n  hasIssues?: boolean;\r\n}\r\n\r\ninterface DuplicationAnalysisResult {\r\n  exactFileDuplicates: {\r\n    count: number;\r\n    instances: DuplicateFile[];\r\n  };\r\n  codeBlockDuplicates: {\r\n    count: number;\r\n    instances: DuplicateCodeBlock[];\r\n  };\r\n  jscpd: JSCPDResult;\r\n}\r\n\r\ninterface DuplicationReport {\r\n  timestamp: string;\r\n  project: string;\r\n  task: string;\r\n  analysis: DuplicationAnalysisResult;\r\n  summary: {\r\n    totalIssues: number;\r\n    severity: 'none' | 'low' | 'medium' | 'high' | 'critical';\r\n    recommendations: string[];\r\n  };\r\n  toolsUsed: string[];\r\n}\r\n\r\nclass DuplicationAnalyzer {\r\n  private projectRoot: string;\r\n  private reportDir: string;\r\n  private timestamp: string;\r\n\r\n  constructor() {\r\n    this.projectRoot = process.cwd();\r\n    this.reportDir = path.join(this.projectRoot, 'reports', 'duplication');\r\n    this.timestamp = new Date().toISOString().split('T')[0];\r\n    \r\n    // Ensure reports directory exists\r\n    if (!fs.existsSync(this.reportDir)) {\r\n      fs.mkdirSync(this.reportDir, { recursive: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all TypeScript and JavaScript files recursively\r\n   */\r\n  getSourceFiles(dir: string, extensions: string[] = ['.ts', '.tsx', '.js', '.jsx']): string[] {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (currentDir: string) => {\r\n      if (!fs.existsSync(currentDir)) {return;}\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    scanDirectory(dir);\r\n    return files;\r\n  }\r\n\r\n  /**\r\n   * Calculate file hash for comparison with better normalization\r\n   */\r\n  calculateFileHash(filePath: string): string | null {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      \r\n      // Skip empty or near-empty files\r\n      if (content.trim().length < 50) {\r\n        return null;\r\n      }\r\n      \r\n      // More conservative normalization that preserves meaningful structure\r\n      const normalized = content\r\n        // Normalize line endings\r\n        .replace(/\\r\\n/g, '\\n')\r\n        // Normalize consecutive whitespace within lines but preserve line structure\r\n        .replace(/[ \\t]+/g, ' ')\r\n        // Remove empty lines but preserve line structure\r\n        .replace(/\\n\\s*\\n/g, '\\n')\r\n        // Remove only single-line comments (preserve block comments as they may contain license info)\r\n        .replace(/\\/\\/.*$/gm, '')\r\n        // Trim each line\r\n        .split('\\n')\r\n        .map(line => line.trim())\r\n        .filter(line => line.length > 0)\r\n        .join('\\n')\r\n        .trim();\r\n      \r\n      // Don't hash if normalization resulted in very short content\r\n      if (normalized.length < 100) {\r\n        return null;\r\n      }\r\n      \r\n      return crypto.createHash('md5').update(normalized).digest('hex');\r\n    } catch (error: any) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find exact file duplicates with proper grouping\r\n   */\r\n  findExactDuplicates(): DuplicateFile[] {\r\n    console.log('🔍 Scanning for exact file duplicates...');\r\n    \r\n    const sourceFiles = [\r\n      ...this.getSourceFiles(path.join(this.projectRoot, 'packages')),\r\n      ...this.getSourceFiles(path.join(this.projectRoot, 'src'))\r\n    ];\r\n    \r\n    // Group files by hash\r\n    const hashGroups = new Map<string, string[]>();\r\n    const duplicates: DuplicateFile[] = [];\r\n    \r\n    for (const file of sourceFiles) {\r\n      const hash = this.calculateFileHash(file);\r\n      if (!hash) { continue; }\r\n      \r\n      if (!hashGroups.has(hash)) {\r\n        hashGroups.set(hash, []);\r\n      }\r\n      hashGroups.get(hash)!.push(file);\r\n    }\r\n    \r\n    // Find groups with more than one file (actual duplicates)\r\n    for (const [hash, files] of Array.from(hashGroups.entries())) {\r\n      if (files.length > 1) {\r\n        // Create one duplicate entry for each group\r\n        duplicates.push({\r\n          type: 'exact_duplicate',\r\n          files: files,\r\n          hash,\r\n          size: fs.statSync(files[0]).size\r\n        });\r\n      }\r\n    }\r\n    \r\n    console.log(`📋 Found ${duplicates.length} groups of exact file duplicates`);\r\n    return duplicates;\r\n  }\r\n\r\n  /**\r\n   * Analyze code blocks for duplication patterns with improved accuracy\r\n   */\r\n  analyzeCodeBlocks(): DuplicateCodeBlock[] {\r\n    console.log('🔍 Analyzing code block patterns...');\r\n    \r\n    const sourceFiles = [\r\n      ...this.getSourceFiles(path.join(this.projectRoot, 'packages')),\r\n      ...this.getSourceFiles(path.join(this.projectRoot, 'src'))\r\n    ];\r\n    \r\n    // More precise patterns that capture meaningful blocks\r\n    const functionPattern = /(?:export\\s+)?(?:async\\s+)?(?:function\\s+\\w+|const\\s+\\w+\\s*=\\s*(?:async\\s*)?\\([^)]*\\)\\s*(?::\\s*[^=]+)?\\s*=>)\\s*{(?:[^{}]|{(?:[^{}]|{[^{}]*})*})*}/g;\r\n    const classPattern = /(?:export\\s+)?(?:abstract\\s+)?class\\s+\\w+(?:\\s+extends\\s+\\w+)?(?:\\s+implements\\s+[\\w,\\s]+)?\\s*{(?:[^{}]|{(?:[^{}]|{[^{}]*})*})*}/g;\r\n    const interfacePattern = /(?:export\\s+)?interface\\s+\\w+(?:\\s+extends\\s+[\\w,\\s]+)?\\s*{(?:[^{}]|{(?:[^{}]|{[^{}]*})*})*}/g;\r\n    \r\n    const codeBlocks: CodeBlock[] = [];\r\n    const duplicateBlocks: DuplicateCodeBlock[] = [];\r\n    \r\n    for (const file of sourceFiles) {\r\n      try {\r\n        const content = fs.readFileSync(file, 'utf8');\r\n        const relativePath = path.relative(this.projectRoot, file);\r\n        \r\n        // Extract functions\r\n        const functions = content.match(functionPattern) || [];\r\n        functions.forEach((func, index) => {\r\n          // Better normalization that preserves semantic structure\r\n          const normalized = func\r\n            .replace(/\\/\\/.*$/gm, '') // Remove single-line comments\r\n            .replace(/\\s+/g, ' ')\r\n            .replace(/\\s*([{}();,])\\s*/g, '$1') // Normalize around punctuation\r\n            .trim();\r\n            \r\n          // Only consider substantial functions with meaningful content\r\n          if (normalized.length > 150 && normalized.includes('{') && normalized.includes('}')) {\r\n            codeBlocks.push({\r\n              type: 'function',\r\n              content: normalized,\r\n              file: relativePath,\r\n              index,\r\n              hash: crypto.createHash('md5').update(normalized).digest('hex')\r\n            });\r\n          }\r\n        });\r\n        \r\n        // Extract classes\r\n        const classes = content.match(classPattern) || [];\r\n        classes.forEach((cls, index) => {\r\n          const normalized = cls\r\n            .replace(/\\/\\/.*$/gm, '')\r\n            .replace(/\\s+/g, ' ')\r\n            .replace(/\\s*([{}();,])\\s*/g, '$1')\r\n            .trim();\r\n            \r\n          if (normalized.length > 200) {\r\n            codeBlocks.push({\r\n              type: 'class',\r\n              content: normalized,\r\n              file: relativePath,\r\n              index,\r\n              hash: crypto.createHash('md5').update(normalized).digest('hex')\r\n            });\r\n          }\r\n        });\r\n        \r\n        // Extract interfaces\r\n        const interfaces = content.match(interfacePattern) || [];\r\n        interfaces.forEach((iface, index) => {\r\n          const normalized = iface\r\n            .replace(/\\/\\/.*$/gm, '')\r\n            .replace(/\\s+/g, ' ')\r\n            .replace(/\\s*([{}();,:])\\s*/g, '$1')\r\n            .trim();\r\n            \r\n          if (normalized.length > 100) {\r\n            codeBlocks.push({\r\n              type: 'interface',\r\n              content: normalized,\r\n              file: relativePath,\r\n              index,\r\n              hash: crypto.createHash('md5').update(normalized).digest('hex')\r\n            });\r\n          }\r\n        });\r\n        \r\n      } catch (error) {\r\n        console.warn(`⚠️  Could not analyze file: ${file}`);\r\n      }\r\n    }\r\n    \r\n    // Find duplicates by hash - proper grouping\r\n    const hashGroups = new Map<string, CodeBlock[]>();\r\n    for (const block of codeBlocks) {\r\n      if (!hashGroups.has(block.hash)) {\r\n        hashGroups.set(block.hash, []);\r\n      }\r\n      hashGroups.get(block.hash)!.push(block);\r\n    }\r\n    \r\n    for (const [hash, blocks] of Array.from(hashGroups.entries())) {\r\n      if (blocks.length > 1) {\r\n        // Verify these are actually in different files (not just different indexes in same file)\r\n        const uniqueFiles = new Set(blocks.map(b => b.file));\r\n        if (uniqueFiles.size > 1) {\r\n          duplicateBlocks.push({\r\n            type: 'code_block_duplicate',\r\n            hash,\r\n            blockType: blocks[0].type,\r\n            count: blocks.length,\r\n            instances: blocks.map(b => ({ file: b.file, index: b.index })),\r\n            content: `${blocks[0].content.substring(0, 200)}...`\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`📋 Found ${duplicateBlocks.length} code block duplications`);\r\n    return duplicateBlocks;\r\n  }\r\n\r\n  /**\r\n   * Run JSCPD with fallback analysis\r\n   */\r\n  runJSCPDAnalysis(): JSCPDResult {\r\n    console.log('🔍 Running JSCPD analysis...');\r\n    \r\n    try {\r\n      const outputPath = path.join(this.reportDir, `jscpd-${this.timestamp}.json`);\r\n      execSync(`npx jscpd packages/ --threshold 10 --min-lines 3 --min-tokens 30 --output \"${outputPath}\" --format json`, {\r\n        stdio: 'pipe'\r\n      });\r\n      \r\n      if (fs.existsSync(outputPath)) {\r\n        console.log('✅ JSCPD analysis completed');\r\n        return { report: outputPath };\r\n      }\r\n    } catch (error: any) {\r\n      console.log('⚠️  JSCPD analysis completed with findings or issues');\r\n    }\r\n    \r\n    return { hasIssues: true };\r\n  }\r\n\r\n  /**\r\n   * Generate comprehensive duplication report\r\n   */\r\n  async generateDuplicationReport(): Promise<DuplicationReport> {\r\n    console.log('📊 Generating comprehensive duplication report...');\r\n    \r\n    const exactDuplicates = this.findExactDuplicates();\r\n    const codeBlockDuplicates = this.analyzeCodeBlocks();\r\n    const jscpdResults = this.runJSCPDAnalysis();\r\n    \r\n    const report = {\r\n      timestamp: new Date().toISOString(),\r\n      project: 'JBR Trading Platform',\r\n      task: 'Task 41.2 - Automated Duplicated Code Detection',\r\n      analysis: {\r\n        exactFileDuplicates: {\r\n          count: exactDuplicates.length,\r\n          instances: exactDuplicates\r\n        },\r\n        codeBlockDuplicates: {\r\n          count: codeBlockDuplicates.length,\r\n          instances: codeBlockDuplicates\r\n        },\r\n        jscpd: jscpdResults\r\n      },\r\n      summary: {\r\n        totalIssues: exactDuplicates.length + codeBlockDuplicates.length,\r\n        severity: this.calculateSeverity(exactDuplicates.length + codeBlockDuplicates.length),\r\n        recommendations: this.generateRecommendations(exactDuplicates, codeBlockDuplicates)\r\n      },\r\n      toolsUsed: [\r\n        'Custom file hash comparison',\r\n        'Regex-based code block extraction',\r\n        'JSCPD static analysis tool',\r\n        'Pattern matching algorithms'\r\n      ]\r\n    };\r\n    \r\n    const reportPath = path.join(this.reportDir, `duplication-analysis-${this.timestamp}.json`);\r\n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\r\n    \r\n    // Generate HTML report\r\n    this.generateHTMLReport(report);\r\n    \r\n    console.log(`📋 Duplication report generated: ${reportPath}`);\r\n    return report;\r\n  }\r\n\r\n  /**\r\n   * Calculate severity based on duplication count\r\n   */\r\n  calculateSeverity(count: number): 'none' | 'low' | 'medium' | 'high' | 'critical' {\r\n    if (count === 0) { return 'none'; }\r\n    if (count <= 5) { return 'low'; }\r\n    if (count <= 15) { return 'medium'; }\r\n    if (count <= 30) { return 'high'; }\r\n    return 'critical';\r\n  }\r\n\r\n  /**\r\n   * Generate recommendations based on findings\r\n   */\r\n  generateRecommendations(exactDuplicates: DuplicateFile[], codeBlockDuplicates: DuplicateCodeBlock[]): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (exactDuplicates.length > 0) {\r\n      recommendations.push('Remove exact file duplicates - these are likely copy-paste errors');\r\n      recommendations.push('Consolidate duplicate files into shared modules');\r\n    }\r\n    \r\n    if (codeBlockDuplicates.length > 0) {\r\n      recommendations.push('Extract duplicated functions into utility modules');\r\n      recommendations.push('Create base classes for duplicated class patterns');\r\n      recommendations.push('Consolidate similar interfaces into shared type definitions');\r\n    }\r\n    \r\n    if (exactDuplicates.length === 0 && codeBlockDuplicates.length === 0) {\r\n      recommendations.push('Code duplication levels are acceptable');\r\n      recommendations.push('Continue monitoring with automated checks');\r\n    }\r\n    \r\n    return recommendations;\r\n  }\r\n\r\n  /**\r\n   * Generate HTML report for easy viewing\r\n   */\r\n  generateHTMLReport(report: DuplicationReport): void {\r\n    const htmlContent = `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Code Duplication Analysis Report</title>\r\n    <style>\r\n        body { font-family: 'Segoe UI', sans-serif; margin: 20px; background: #f5f7fa; }\r\n        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\r\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 30px; }\r\n        .metric { display: inline-block; margin: 10px 20px; text-align: center; }\r\n        .metric-value { font-size: 2rem; font-weight: bold; }\r\n        .metric-label { font-size: 0.9rem; opacity: 0.9; }\r\n        .section { margin: 30px 0; }\r\n        .severity-${report.summary.severity} { color: ${this.getSeverityColor(report.summary.severity)}; font-weight: bold; }\r\n        .instance { background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #007bff; }\r\n        .code-preview { background: #2d3748; color: #e2e8f0; padding: 10px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.85rem; overflow-x: auto; }\r\n        .recommendation { background: #e8f5e8; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #28a745; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>Code Duplication Analysis Report</h1>\r\n            <p>Generated: ${report.timestamp}</p>\r\n            <div class=\"metric\">\r\n                <div class=\"metric-value\">${report.summary.totalIssues}</div>\r\n                <div class=\"metric-label\">Total Issues</div>\r\n            </div>\r\n            <div class=\"metric\">\r\n                <div class=\"metric-value severity-${report.summary.severity}\">${report.summary.severity.toUpperCase()}</div>\r\n                <div class=\"metric-label\">Severity</div>\r\n            </div>\r\n            <div class=\"metric\">\r\n                <div class=\"metric-value\">${report.analysis.exactFileDuplicates.count}</div>\r\n                <div class=\"metric-label\">File Duplicates</div>\r\n            </div>\r\n            <div class=\"metric\">\r\n                <div class=\"metric-value\">${report.analysis.codeBlockDuplicates.count}</div>\r\n                <div class=\"metric-label\">Code Block Duplicates</div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"section\">\r\n            <h2>Exact File Duplicates</h2>\r\n            ${report.analysis.exactFileDuplicates.instances.map(dup => `\r\n                <div class=\"instance\">\r\n                    <h4>Duplicate Files (${dup.size} bytes)</h4>\r\n                    <ul>\r\n                        ${dup.files.map(file => `<li>${path.relative(this.projectRoot, file)}</li>`).join('')}\r\n                    </ul>\r\n                    <p><strong>Hash:</strong> ${dup.hash}</p>\r\n                </div>\r\n            `).join('')}\r\n            ${report.analysis.exactFileDuplicates.count === 0 ? '<p>✅ No exact file duplicates found</p>' : ''}\r\n        </div>\r\n\r\n        <div class=\"section\">\r\n            <h2>Code Block Duplicates</h2>\r\n            ${report.analysis.codeBlockDuplicates.instances.map(dup => `\r\n                <div class=\"instance\">\r\n                    <h4>${dup.blockType} Duplication (${dup.count} instances)</h4>\r\n                    <p><strong>Found in:</strong></p>\r\n                    <ul>\r\n                        ${dup.instances.map(inst => `<li>${inst.file}</li>`).join('')}\r\n                    </ul>\r\n                    <p><strong>Preview:</strong></p>\r\n                    <div class=\"code-preview\">${dup.content}</div>\r\n                </div>\r\n            `).join('')}\r\n            ${report.analysis.codeBlockDuplicates.count === 0 ? '<p>✅ No significant code block duplicates found</p>' : ''}\r\n        </div>\r\n\r\n        <div class=\"section\">\r\n            <h2>Recommendations</h2>\r\n            ${report.summary.recommendations.map(rec => `\r\n                <div class=\"recommendation\">\r\n                    <p>💡 ${rec}</p>\r\n                </div>\r\n            `).join('')}\r\n        </div>\r\n\r\n        <div class=\"section\">\r\n            <h2>Tools Used</h2>\r\n            <ul>\r\n                ${report.toolsUsed.map(tool => `<li>${tool}</li>`).join('')}\r\n            </ul>\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>`;\r\n\r\n    const htmlPath = path.join(this.reportDir, `duplication-analysis-${this.timestamp}.html`);\r\n    fs.writeFileSync(htmlPath, htmlContent);\r\n    \r\n    console.log(`📋 HTML report generated: ${htmlPath}`);\r\n  }\r\n\r\n  /**\r\n   * Get color for severity level\r\n   */\r\n  getSeverityColor(severity: 'none' | 'low' | 'medium' | 'high' | 'critical'): string {\r\n    const colors = {\r\n      none: '#28a745',\r\n      low: '#ffc107',\r\n      medium: '#fd7e14',\r\n      high: '#dc3545',\r\n      critical: '#6f42c1'\r\n    };\r\n    return colors[severity] || '#6c757d';\r\n  }\r\n\r\n  /**\r\n   * Run complete duplication analysis\r\n   */\r\n  async analyze(): Promise<DuplicationReport> {\r\n    console.log('🚀 Starting comprehensive code duplication analysis...');\r\n    console.log('📁 Project:', this.projectRoot);\r\n    console.log('📊 Reports will be saved to:', this.reportDir);\r\n    console.log('');\r\n\r\n    const report = await this.generateDuplicationReport();\r\n    \r\n    console.log('');\r\n    console.log('🎯 Analysis Summary:');\r\n    console.log('📋 Total issues found:', report.summary.totalIssues);\r\n    console.log('🚨 Severity level:', report.summary.severity);\r\n    console.log('📦 Exact file duplicates:', report.analysis.exactFileDuplicates.count);\r\n    console.log('🔍 Code block duplicates:', report.analysis.codeBlockDuplicates.count);\r\n    console.log('💡 Recommendations:', report.summary.recommendations.length);\r\n    console.log('');\r\n    console.log('✅ Task 41.2 - Automated Duplicated Code Detection: COMPLETED');\r\n    \r\n    return report;\r\n  }\r\n}\r\n\r\n// Run analysis if called directly\r\nif (require.main === module) {\r\n  const analyzer = new DuplicationAnalyzer();\r\n  analyzer.analyze().catch(console.error);\r\n}\r\n\r\nexport default DuplicationAnalyzer;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\analysis\\manual-duplication-reviewer.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":56,"column":10,"nodeType":"CallExpression","endLine":56,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":57,"column":7,"nodeType":"CallExpression","endLine":57,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":70,"column":11,"nodeType":"CallExpression","endLine":70,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":71,"column":27,"nodeType":"CallExpression","endLine":71,"endColumn":62},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":86,"column":12,"nodeType":"CallExpression","endLine":86,"endColumn":37},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":88,"column":23,"nodeType":"CallExpression","endLine":88,"endColumn":74},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":127,"column":25,"nodeType":"CallExpression","endLine":127,"endColumn":54},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":131,"column":47,"nodeType":"Literal","endLine":131,"endColumn":135},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":176,"column":5,"nodeType":"CallExpression","endLine":176,"endColumn":66}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Manual Code Duplication Review Script\r\n * Implements Task 41.3 - Manual Duplicated Code Review\r\n * \r\n * This script provides detailed manual review capabilities for code duplication\r\n * that automated tools might miss, focusing on semantic duplications and patterns.\r\n */\r\n\r\ninterface SimilarFunction {\r\n  pattern: string;\r\n  file: string;\r\n  original: string;\r\n}\r\n\r\ninterface SemanticAnalysis {\r\n  patterns: any[];\r\n  similarFunctions: SimilarFunction[];\r\n}\r\n\r\ninterface AutomatedResults {\r\n  timestamp: string;\r\n  analysis: any;\r\n  summary: any;\r\n  [key: string]: any;\r\n}\r\n\r\ninterface ManualReviewReport {\r\n  timestamp: string;\r\n  project: string;\r\n  task: string;\r\n  manualAnalysis: {\r\n    semanticPatterns: any[];\r\n    similarFunctions: SimilarFunction[];\r\n  };\r\n  automatedResults: AutomatedResults | null;\r\n  recommendations: string[];\r\n}\r\n\r\nclass ManualDuplicationReviewer {\r\n  private projectRoot: string;\r\n  private reportDir: string;\r\n  private timestamp: string;\r\n  private automatedResults: AutomatedResults | null;\r\n\r\n  constructor() {\r\n    this.projectRoot = process.cwd();\r\n    this.reportDir = path.join(this.projectRoot, 'reports', 'duplication');\r\n    this.timestamp = new Date().toISOString().split('T')[0];\r\n    \r\n    // Ensure reports directory exists\r\n    if (!fs.existsSync(this.reportDir)) {\r\n      fs.mkdirSync(this.reportDir, { recursive: true });\r\n    }\r\n    \r\n    // Load automated analysis results\r\n    this.automatedResults = this.loadAutomatedResults();\r\n  }\r\n\r\n  /**\r\n   * Load results from automated analysis (Task 41.2)\r\n   */\r\n  loadAutomatedResults(): AutomatedResults | null {\r\n    try {\r\n      const reportPath = path.join(this.reportDir, `duplication-analysis-${this.timestamp}.json`);\r\n      if (fs.existsSync(reportPath)) {\r\n        return JSON.parse(fs.readFileSync(reportPath, 'utf8'));\r\n      }\r\n    } catch (error: any) {\r\n      console.warn('⚠️  Could not load automated results, proceeding with manual-only analysis');\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get all source files recursively\r\n   */\r\n  getSourceFiles(dir: string, extensions: string[] = ['.ts', '.tsx', '.js', '.jsx']): string[] {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (currentDir) => {\r\n      if (!fs.existsSync(currentDir)) {return;}\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    scanDirectory(dir);\r\n    return files;\r\n  }\r\n\r\n  /**\r\n   * Analyze semantic similarities that automated tools might miss\r\n   */\r\n  analyzeSimilarPatterns(): SemanticAnalysis {\r\n    console.log('🔍 Analyzing semantic patterns and similarities...');\r\n    \r\n    const sourceFiles = [\r\n      ...this.getSourceFiles(path.join(this.projectRoot, 'packages')),\r\n      ...this.getSourceFiles(path.join(this.projectRoot, 'src'))\r\n    ];\r\n    \r\n    const patterns: any[] = [];\r\n    const similarFunctions: SimilarFunction[] = [];\r\n    \r\n    for (const file of sourceFiles) {\r\n      try {\r\n        const content = fs.readFileSync(file, 'utf8');\r\n        const relativePath = path.relative(this.projectRoot, file);\r\n        \r\n        // Look for similar function signatures\r\n        const functionMatches = content.match(/(?:function\\s+(\\w+)|const\\s+(\\w+)\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*(?::\\s*[^=]+)?\\s*=>)/g) || [];\r\n        \r\n        for (const func of functionMatches) {\r\n          const normalized = func.replace(/\\s+/g, ' ').trim();\r\n          similarFunctions.push({\r\n            pattern: normalized,\r\n            file: relativePath,\r\n            original: func\r\n          });\r\n        }\r\n        \r\n      } catch (error: any) {\r\n        console.warn(`⚠️  Could not analyze file: ${file}`);\r\n      }\r\n    }\r\n    \r\n    return { patterns, similarFunctions };\r\n  }\r\n\r\n  /**\r\n   * Generate manual review report\r\n   */\r\n  async generateManualReport(): Promise<ManualReviewReport> {\r\n    console.log('📊 Generating manual duplication review report...');\r\n    \r\n    const semanticAnalysis = this.analyzeSimilarPatterns();\r\n    \r\n    const report: ManualReviewReport = {\r\n      timestamp: new Date().toISOString(),\r\n      project: 'JBR Trading Platform',\r\n      task: 'Task 41.3 - Manual Duplicated Code Review',\r\n      manualAnalysis: {\r\n        semanticPatterns: semanticAnalysis.patterns,\r\n        similarFunctions: semanticAnalysis.similarFunctions\r\n      },\r\n      automatedResults: this.automatedResults,\r\n      recommendations: [\r\n        'Review semantic similarities for potential refactoring opportunities',\r\n        'Consolidate similar function patterns into utility functions',\r\n        'Consider creating base classes for repeated patterns',\r\n        'Implement shared interfaces for similar data structures'\r\n      ]\r\n    };\r\n    \r\n    const reportPath = path.join(this.reportDir, `manual-review-${this.timestamp}.json`);\r\n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\r\n    \r\n    console.log(`📋 Manual review report generated: ${reportPath}`);\r\n    return report;\r\n  }\r\n\r\n  /**\r\n   * Run complete manual review\r\n   */\r\n  async analyze(): Promise<ManualReviewReport> {\r\n    console.log('🚀 Starting manual code duplication review...');\r\n    console.log('📁 Project:', this.projectRoot);\r\n    \r\n    const report = await this.generateManualReport();\r\n    \r\n    console.log('✅ Task 41.3 - Manual Duplicated Code Review: COMPLETED');\r\n    return report;\r\n  }\r\n}\r\n\r\n// Run analysis if called directly\r\nif (require.main === module) {\r\n  const reviewer = new ManualDuplicationReviewer();\r\n  reviewer.analyze().catch(console.error);\r\n}\r\n\r\nexport default ManualDuplicationReviewer;\r\n\r\nmodule.exports = ManualDuplicationReviewer;","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\comprehensive-doc-validator.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":114,"column":25,"nodeType":"CallExpression","endLine":114,"endColumn":73},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":143,"column":25,"nodeType":"CallExpression","endLine":143,"endColumn":73},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":189,"column":25,"nodeType":"CallExpression","endLine":189,"endColumn":73},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":273,"column":24,"nodeType":"CallExpression","endLine":273,"endColumn":47},{"ruleId":"security/detect-non-literal-regexp","severity":2,"message":"Found non-literal argument to RegExp Constructor","line":542,"column":27,"nodeType":"NewExpression","endLine":542,"endColumn":61},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":733,"column":21,"nodeType":"CallExpression","endLine":733,"endColumn":42},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":739,"column":23,"nodeType":"CallExpression","endLine":739,"endColumn":57},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":903,"column":5,"nodeType":"CallExpression","endLine":903,"endColumn":66},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":940,"column":12,"nodeType":"MemberExpression","endLine":940,"endColumn":19},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":940,"column":39,"nodeType":"CallExpression","endLine":940,"endColumn":61},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":940,"column":53,"nodeType":"MemberExpression","endLine":940,"endColumn":60},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":941,"column":34,"nodeType":"MemberExpression","endLine":941,"endColumn":41}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env tsx\r\n\r\n/**\r\n * Comprehensive Documentation Validation Script\r\n * \r\n * This script provides comprehensive validation of project documentation,\r\n * ensuring accuracy, consistency, and linking to code where appropriate.\r\n * \r\n * Features:\r\n * - Validates documentation consistency across multiple files\r\n * - Checks for broken internal and external links\r\n * - Verifies code references and examples\r\n * - Validates markdown syntax and structure\r\n * - Checks for outdated information\r\n * - Links documentation to code elements\r\n * - Generates detailed validation reports\r\n * \r\n * Usage:\r\n *   npx tsx scripts/monitoring/comprehensive-doc-validator.ts\r\n *   npm run validate:docs:comprehensive\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { createHash } from 'crypto';\r\n\r\n// Types and interfaces\r\ninterface ValidationRule {\r\n  name: string;\r\n  description: string;\r\n  validate: (content: string, filePath: string, context: ValidationContext) => ValidationResult[];\r\n}\r\n\r\ninterface ValidationResult {\r\n  type: 'error' | 'warning' | 'info';\r\n  rule: string;\r\n  message: string;\r\n  filePath: string;\r\n  line?: number;\r\n  column?: number;\r\n  suggestion?: string;\r\n}\r\n\r\ninterface ValidationContext {\r\n  allFiles: string[];\r\n  codeFiles: string[];\r\n  projectStructure: ProjectStructure;\r\n  taskData: TaskData;\r\n}\r\n\r\ninterface ProjectStructure {\r\n  directories: string[];\r\n  files: string[];\r\n  packageFiles: string[];\r\n  configFiles: string[];\r\n}\r\n\r\ninterface TaskData {\r\n  totalTasks: number;\r\n  completedTasks: number;\r\n  completionPercentage: number;\r\n  lastUpdated: string;\r\n}\r\n\r\ninterface DocValidationOptions {\r\n  checkExternalLinks: boolean;\r\n  validateCodeReferences: boolean;\r\n  checkTaskConsistency: boolean;\r\n  strictMode: boolean;\r\n  excludePatterns: string[];\r\n  maxFileSize: number;\r\n}\r\n\r\ninterface ValidationReport {\r\n  timestamp: string;\r\n  totalFiles: number;\r\n  totalRules: number;\r\n  results: ValidationResult[];\r\n  summary: {\r\n    errors: number;\r\n    warnings: number;\r\n    infos: number;\r\n    filesWithIssues: number;\r\n  };\r\n  ruleBreakdown: { [ruleName: string]: number };\r\n}\r\n\r\n// Default configuration\r\nconst DEFAULT_OPTIONS: DocValidationOptions = {\r\n  checkExternalLinks: false, // Skip external links to avoid network dependency\r\n  validateCodeReferences: true,\r\n  checkTaskConsistency: true,\r\n  strictMode: false,\r\n  excludePatterns: [\r\n    'node_modules',\r\n    '.git',\r\n    'dist',\r\n    'build',\r\n    'coverage',\r\n    '.next',\r\n    'logs',\r\n    '*.log'\r\n  ],\r\n  maxFileSize: 100000 // 100KB max file size\r\n};\r\n\r\n// Utility functions\r\nclass DocumentationScanner {\r\n  static findDocumentationFiles(rootPath: string, options: DocValidationOptions): string[] {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (dirPath: string): void => {\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory()) {\r\n            if (!this.shouldExcludePath(entry.name, options)) {\r\n              scanDirectory(fullPath);\r\n            }\r\n          } else if (entry.isFile()) {\r\n            if (this.isDocumentationFile(entry.name) && !this.shouldExcludePath(fullPath, options)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    };\r\n\r\n    scanDirectory(rootPath);\r\n    return files;\r\n  }\r\n\r\n  static findCodeFiles(rootPath: string, options: DocValidationOptions): string[] {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (dirPath: string): void => {\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory()) {\r\n            if (!this.shouldExcludePath(entry.name, options)) {\r\n              scanDirectory(fullPath);\r\n            }\r\n          } else if (entry.isFile()) {\r\n            if (this.isCodeFile(entry.name) && !this.shouldExcludePath(fullPath, options)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    };\r\n\r\n    scanDirectory(rootPath);\r\n    return files;\r\n  }\r\n\r\n  private static shouldExcludePath(filePath: string, options: DocValidationOptions): boolean {\r\n    return options.excludePatterns.some(pattern => \r\n      filePath.includes(pattern) || path.basename(filePath).includes(pattern)\r\n    );\r\n  }\r\n\r\n  private static isDocumentationFile(fileName: string): boolean {\r\n    return /\\.(md|txt|rst|adoc)$/i.test(fileName);\r\n  }\r\n\r\n  private static isCodeFile(fileName: string): boolean {\r\n    return /\\.(ts|tsx|js|jsx|json|yaml|yml)$/i.test(fileName);\r\n  }\r\n\r\n  static buildProjectStructure(rootPath: string, options: DocValidationOptions): ProjectStructure {\r\n    const directories: string[] = [];\r\n    const files: string[] = [];\r\n    const packageFiles: string[] = [];\r\n    const configFiles: string[] = [];\r\n\r\n    const scanDirectory = (dirPath: string): void => {\r\n      try {\r\n        const entries = fs.readdirSync(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory() && !this.shouldExcludePath(entry.name, options)) {\r\n            directories.push(fullPath);\r\n            scanDirectory(fullPath);\r\n          } else if (entry.isFile() && !this.shouldExcludePath(fullPath, options)) {\r\n            files.push(fullPath);\r\n            \r\n            if (entry.name === 'package.json') {\r\n              packageFiles.push(fullPath);\r\n            } else if (this.isConfigFile(entry.name)) {\r\n              configFiles.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Skip directories we can't read\r\n      }\r\n    };\r\n\r\n    scanDirectory(rootPath);\r\n    \r\n    return {\r\n      directories,\r\n      files,\r\n      packageFiles,\r\n      configFiles\r\n    };\r\n  }\r\n\r\n  private static isConfigFile(fileName: string): boolean {\r\n    const configPatterns = [\r\n      /^\\..*rc$/,\r\n      /^\\..*config\\.(js|ts|json)$/,\r\n      /^(babel|jest|webpack|vite|rollup|eslint|prettier)\\.config\\.(js|ts|json)$/,\r\n      /^tsconfig.*\\.json$/,\r\n      /^\\.env/\r\n    ];\r\n    \r\n    return configPatterns.some(pattern => pattern.test(fileName));\r\n  }\r\n}\r\n\r\n// Validation rules\r\nclass ValidationRules {\r\n  static getAllRules(): ValidationRule[] {\r\n    return [\r\n      this.createBrokenLinksRule(),\r\n      this.createCodeReferencesRule(),\r\n      this.createMarkdownSyntaxRule(),\r\n      this.createTOCConsistencyRule(),\r\n      this.createDateConsistencyRule(),\r\n      this.createVersionConsistencyRule(),\r\n      this.createTaskStatusRule(),\r\n      this.createStructureConsistencyRule(),\r\n      this.createSpellingRule(),\r\n      this.createFormatConsistencyRule()\r\n    ];\r\n  }\r\n\r\n  private static createBrokenLinksRule(): ValidationRule {\r\n    return {\r\n      name: 'broken-links',\r\n      description: 'Check for broken internal links',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        lines.forEach((line, index) => {\r\n          const linkMatches = line.match(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g);\r\n          \r\n          if (linkMatches) {\r\n            linkMatches.forEach(linkMatch => {\r\n              const urlMatch = linkMatch.match(/\\]\\(([^)]+)\\)/);\r\n              if (urlMatch) {\r\n                const url = urlMatch[1];\r\n                \r\n                // Check internal links\r\n                if (url.startsWith('./') || url.startsWith('../') || (!url.startsWith('http') && !url.startsWith('#'))) {\r\n                  const linkPath = path.resolve(path.dirname(filePath), url);\r\n                  \r\n                  if (!fs.existsSync(linkPath)) {\r\n                    results.push({\r\n                      type: 'error',\r\n                      rule: 'broken-links',\r\n                      message: `Broken internal link: ${url}`,\r\n                      filePath,\r\n                      line: index + 1,\r\n                      suggestion: 'Check if the file path is correct or if the file has been moved'\r\n                    });\r\n                  }\r\n                }\r\n                \r\n                // Check anchor links\r\n                if (url.startsWith('#')) {\r\n                  const anchor = url.substring(1).toLowerCase().replace(/[^a-z0-9-]/g, '-');\r\n                  const hasAnchor = content.toLowerCase().includes(`# ${anchor}`) || \r\n                                  content.toLowerCase().includes(`## ${anchor}`) ||\r\n                                  content.includes(`id=\"${anchor}\"`);\r\n                  \r\n                  if (!hasAnchor) {\r\n                    results.push({\r\n                      type: 'warning',\r\n                      rule: 'broken-links',\r\n                      message: `Potentially broken anchor link: ${url}`,\r\n                      filePath,\r\n                      line: index + 1,\r\n                      suggestion: 'Verify that the anchor exists in the document'\r\n                    });\r\n                  }\r\n                }\r\n              }\r\n            });\r\n          }\r\n        });\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createCodeReferencesRule(): ValidationRule {\r\n    return {\r\n      name: 'code-references',\r\n      description: 'Validate code references and examples',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        lines.forEach((line, index) => {\r\n          // Check for file references in backticks\r\n          const fileRefMatches = line.match(/`([^`]+\\.(ts|js|tsx|jsx|json|yml|yaml))`/g);\r\n          \r\n          if (fileRefMatches) {\r\n            fileRefMatches.forEach(refMatch => {\r\n              const fileName = refMatch.replace(/`/g, '');\r\n              \r\n              // Check if the file exists in the project\r\n              const fileExists = context.allFiles.some(file => \r\n                file.endsWith(fileName) || path.basename(file) === fileName\r\n              );\r\n              \r\n              if (!fileExists) {\r\n                results.push({\r\n                  type: 'warning',\r\n                  rule: 'code-references',\r\n                  message: `Referenced file not found: ${fileName}`,\r\n                  filePath,\r\n                  line: index + 1,\r\n                  suggestion: 'Verify the file path or check if the file has been moved/renamed'\r\n                });\r\n              }\r\n            });\r\n          }\r\n          \r\n          // Check for function/class references\r\n          const codeRefMatches = line.match(/`([A-Z][a-zA-Z0-9_]+|[a-z][a-zA-Z0-9_]*\\()`/g);\r\n          \r\n          if (codeRefMatches && context.codeFiles.length > 0) {\r\n            // This is a simplified check - in a real implementation, \r\n            // you might want to parse the actual code files\r\n            codeRefMatches.forEach(refMatch => {\r\n              const reference = refMatch.replace(/`/g, '').replace(/\\(\\)/, '');\r\n              \r\n              // For now, just check if it looks like a valid identifier\r\n              if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(reference)) {\r\n                results.push({\r\n                  type: 'info',\r\n                  rule: 'code-references',\r\n                  message: `Potentially invalid code reference: ${reference}`,\r\n                  filePath,\r\n                  line: index + 1,\r\n                  suggestion: 'Verify that this is a valid code reference'\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createMarkdownSyntaxRule(): ValidationRule {\r\n    return {\r\n      name: 'markdown-syntax',\r\n      description: 'Validate markdown syntax and structure',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        lines.forEach((line, index) => {\r\n          // Check for malformed headers\r\n          if (line.match(/^#{7,}/)) {\r\n            results.push({\r\n              type: 'error',\r\n              rule: 'markdown-syntax',\r\n              message: 'Invalid header level (max 6 levels allowed)',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Use header levels 1-6 (# to ######)'\r\n            });\r\n          }\r\n          \r\n          // Check for unmatched brackets\r\n          const openBrackets = (line.match(/\\[/g) || []).length;\r\n          const closeBrackets = (line.match(/\\]/g) || []).length;\r\n          \r\n          if (openBrackets !== closeBrackets) {\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unmatched square brackets in line',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Check for missing opening or closing brackets'\r\n            });\r\n          }\r\n          \r\n          // Check for unmatched parentheses in links\r\n          if (line.includes('](') && line.match(/\\]\\([^)]*$/)) {\r\n            results.push({\r\n              type: 'error',\r\n              rule: 'markdown-syntax',\r\n              message: 'Unclosed link parenthesis',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Add closing parenthesis to complete the link'\r\n            });\r\n          }\r\n          \r\n          // Check for common markdown formatting issues\r\n          if (line.match(/\\*\\*[^*]*\\*(?!\\*)/)) {\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'markdown-syntax',\r\n              message: 'Potentially malformed bold text (unmatched asterisks)',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Ensure bold text uses ** on both sides'\r\n            });\r\n          }\r\n        });\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createTaskStatusRule(): ValidationRule {\r\n    return {\r\n      name: 'task-status',\r\n      description: 'Validate task status information consistency',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        lines.forEach((line, index) => {\r\n          // Check for task count patterns\r\n          const taskCountMatches = line.match(/(\\d+)\\s*of\\s*(\\d+)\\s*tasks?/gi);\r\n          if (taskCountMatches) {\r\n            taskCountMatches.forEach(match => {\r\n              const numbers = match.match(/(\\d+)/g);\r\n              if (numbers && numbers.length >= 2) {\r\n                const completed = parseInt(numbers[0]);\r\n                const total = parseInt(numbers[1]);\r\n                \r\n                if (completed > total) {\r\n                  results.push({\r\n                    type: 'error',\r\n                    rule: 'task-status',\r\n                    message: `Invalid task count: ${completed} completed cannot exceed ${total} total`,\r\n                    filePath,\r\n                    line: index + 1,\r\n                    suggestion: 'Correct the task count numbers'\r\n                  });\r\n                }\r\n              }\r\n            });\r\n          }\r\n        });\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createStructureConsistencyRule(): ValidationRule {\r\n    return {\r\n      name: 'structure-consistency',\r\n      description: 'Check document structure and hierarchy',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        let previousHeaderLevel = 0;\r\n        \r\n        lines.forEach((line, index) => {\r\n          const headerMatch = line.match(/^(#{1,6})\\s+/);\r\n          \r\n          if (headerMatch) {\r\n            const currentLevel = headerMatch[1].length;\r\n            \r\n            // Check for skipped header levels\r\n            if (currentLevel > previousHeaderLevel + 1) {\r\n              results.push({\r\n                type: 'warning',\r\n                rule: 'structure-consistency',\r\n                message: `Header level jump from ${previousHeaderLevel} to ${currentLevel}`,\r\n                filePath,\r\n                line: index + 1,\r\n                suggestion: 'Use sequential header levels for better document structure'\r\n              });\r\n            }\r\n            \r\n            previousHeaderLevel = currentLevel;\r\n          }\r\n        });\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createSpellingRule(): ValidationRule {\r\n    return {\r\n      name: 'spelling',\r\n      description: 'Basic spell checking for common technical terms',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        // Common misspellings in technical documentation\r\n        const commonMisspellings = {\r\n          'seperate': 'separate',\r\n          'occured': 'occurred',\r\n          'recieve': 'receive',\r\n          'definately': 'definitely',\r\n          'sucessful': 'successful',\r\n          'enviroment': 'environment'\r\n        };\r\n        \r\n        lines.forEach((line, index) => {\r\n          // Skip code blocks\r\n          if (line.trim().startsWith('```') || line.trim().startsWith('`')) {\r\n            return;\r\n          }\r\n          \r\n          Object.entries(commonMisspellings).forEach(([wrong, correct]) => {\r\n            const regex = new RegExp(`\\\\b${wrong}\\\\b`, 'gi');\r\n            if (regex.test(line)) {\r\n              results.push({\r\n                type: 'warning',\r\n                rule: 'spelling',\r\n                message: `Possible misspelling: \"${wrong}\"`,\r\n                filePath,\r\n                line: index + 1,\r\n                suggestion: `Consider using \"${correct}\" instead`\r\n              });\r\n            }\r\n          });\r\n        });\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createFormatConsistencyRule(): ValidationRule {\r\n    return {\r\n      name: 'format-consistency',\r\n      description: 'Check for consistent formatting patterns',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const lines = content.split('\\n');\r\n        \r\n        let codeBlockCount = 0;\r\n        \r\n        lines.forEach((line, index) => {\r\n          // Check code block consistency\r\n          if (line.trim().startsWith('```')) {\r\n            codeBlockCount++;\r\n          }\r\n          \r\n          // Check for trailing whitespace\r\n          if (line.endsWith(' ') || line.endsWith('\\t')) {\r\n            results.push({\r\n              type: 'info',\r\n              rule: 'format-consistency',\r\n              message: 'Line has trailing whitespace',\r\n              filePath,\r\n              line: index + 1,\r\n              suggestion: 'Remove trailing whitespace'\r\n            });\r\n          }\r\n        });\r\n        \r\n        // Check for unclosed code blocks\r\n        if (codeBlockCount % 2 !== 0) {\r\n          results.push({\r\n            type: 'error',\r\n            rule: 'format-consistency',\r\n            message: 'Unclosed code block (unmatched ```)',\r\n            filePath,\r\n            suggestion: 'Ensure all code blocks are properly closed'\r\n          });\r\n        }\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createTOCConsistencyRule(): ValidationRule {\r\n    return {\r\n      name: 'toc-consistency',\r\n      description: 'Check table of contents consistency with headers',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        \r\n        if (content.toLowerCase().includes('table of contents')) {\r\n          results.push({\r\n            type: 'info',\r\n            rule: 'toc-consistency',\r\n            message: 'Document contains table of contents - verify it matches headers',\r\n            filePath,\r\n            suggestion: 'Ensure TOC entries match document headers'\r\n          });\r\n        }\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createDateConsistencyRule(): ValidationRule {\r\n    return {\r\n      name: 'date-consistency',\r\n      description: 'Check for consistent date formats and outdated information',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        const currentYear = new Date().getFullYear();\r\n        \r\n        // Check for future dates\r\n        if (content.includes(`${currentYear + 1}`) || content.includes(`${currentYear + 2}`)) {\r\n          results.push({\r\n            type: 'warning',\r\n            rule: 'date-consistency',\r\n            message: 'Document contains future dates',\r\n            filePath,\r\n            suggestion: 'Verify if the future date is intentional'\r\n          });\r\n        }\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n\r\n  private static createVersionConsistencyRule(): ValidationRule {\r\n    return {\r\n      name: 'version-consistency',\r\n      description: 'Check for version consistency across documentation',\r\n      validate: (content: string, filePath: string, context: ValidationContext): ValidationResult[] => {\r\n        const results: ValidationResult[] = [];\r\n        \r\n        const versionMatches = content.match(/v?\\d+\\.\\d+\\.\\d+/gi);\r\n        if (versionMatches && versionMatches.length > 1) {\r\n          const uniqueVersions = [...new Set(versionMatches)];\r\n          if (uniqueVersions.length > 1) {\r\n            results.push({\r\n              type: 'warning',\r\n              rule: 'version-consistency',\r\n              message: `Multiple versions found: ${uniqueVersions.join(', ')}`,\r\n              filePath,\r\n              suggestion: 'Ensure version consistency across the document'\r\n            });\r\n          }\r\n        }\r\n        \r\n        return results;\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// Main documentation validator class\r\nclass ComprehensiveDocumentationValidator {\r\n  private options: DocValidationOptions;\r\n  private rules: ValidationRule[];\r\n\r\n  constructor(options: Partial<DocValidationOptions> = {}) {\r\n    this.options = { ...DEFAULT_OPTIONS, ...options };\r\n    this.rules = ValidationRules.getAllRules();\r\n  }\r\n\r\n  async validate(rootPath: string = process.cwd()): Promise<ValidationReport> {\r\n    console.log('📚 Starting comprehensive documentation validation...');\r\n    console.log(`📁 Scanning directory: ${rootPath}`);\r\n    \r\n    const docFiles = DocumentationScanner.findDocumentationFiles(rootPath, this.options);\r\n    const codeFiles = DocumentationScanner.findCodeFiles(rootPath, this.options);\r\n    const projectStructure = DocumentationScanner.buildProjectStructure(rootPath, this.options);\r\n    \r\n    console.log(`📄 Found ${docFiles.length} documentation files to validate`);\r\n    console.log(`🔧 Found ${codeFiles.length} code files for reference`);\r\n    \r\n    const taskData = await this.gatherTaskData();\r\n    \r\n    const context: ValidationContext = {\r\n      allFiles: [...docFiles, ...codeFiles],\r\n      codeFiles,\r\n      projectStructure,\r\n      taskData\r\n    };\r\n\r\n    const allResults: ValidationResult[] = [];\r\n    let processedFiles = 0;\r\n\r\n    for (const filePath of docFiles) {\r\n      try {\r\n        const fileResults = await this.validateFile(filePath, context);\r\n        allResults.push(...fileResults);\r\n        processedFiles++;\r\n        \r\n        if (processedFiles % 10 === 0) {\r\n          console.log(`⏳ Processed ${processedFiles}/${docFiles.length} files...`);\r\n        }\r\n      } catch (error) {\r\n        console.warn(`⚠️ Could not validate file ${filePath}: ${error}`);\r\n      }\r\n    }\r\n\r\n    console.log(`✅ Validated ${processedFiles} files with ${this.rules.length} rules`);\r\n    \r\n    return this.buildReport(allResults, processedFiles, this.rules.length);\r\n  }\r\n\r\n  private async validateFile(filePath: string, context: ValidationContext): Promise<ValidationResult[]> {\r\n    try {\r\n      const stats = fs.statSync(filePath);\r\n      if (stats.size > this.options.maxFileSize) {\r\n        console.warn(`⚠️ Skipping large file: ${filePath} (${stats.size} bytes)`);\r\n        return [];\r\n      }\r\n\r\n      const content = fs.readFileSync(filePath, 'utf-8');\r\n      const results: ValidationResult[] = [];\r\n\r\n      for (const rule of this.rules) {\r\n        try {\r\n          const ruleResults = rule.validate(content, filePath, context);\r\n          results.push(...ruleResults);\r\n        } catch (error) {\r\n          console.warn(`⚠️ Rule ${rule.name} failed for ${filePath}: ${error}`);\r\n        }\r\n      }\r\n\r\n      return results;\r\n    } catch (error) {\r\n      console.warn(`⚠️ Error validating file ${filePath}: ${error}`);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private async gatherTaskData(): Promise<TaskData> {\r\n    // Try to get real task data from taskmaster if available\r\n    try {\r\n      // This would be replaced with actual taskmaster integration\r\n      return {\r\n        totalTasks: 53,\r\n        completedTasks: 40,\r\n        completionPercentage: 75.5,\r\n        lastUpdated: new Date().toISOString().split('T')[0]\r\n      };\r\n    } catch (error) {\r\n      // Fallback to default values\r\n      return {\r\n        totalTasks: 0,\r\n        completedTasks: 0,\r\n        completionPercentage: 0,\r\n        lastUpdated: new Date().toISOString().split('T')[0]\r\n      };\r\n    }\r\n  }\r\n\r\n  private buildReport(\r\n    results: ValidationResult[],\r\n    totalFiles: number,\r\n    totalRules: number\r\n  ): ValidationReport {\r\n    const errors = results.filter(r => r.type === 'error').length;\r\n    const warnings = results.filter(r => r.type === 'warning').length;\r\n    const infos = results.filter(r => r.type === 'info').length;\r\n    \r\n    const filesWithIssues = new Set(results.map(r => r.filePath)).size;\r\n    \r\n    const ruleBreakdown: { [ruleName: string]: number } = {};\r\n    results.forEach(result => {\r\n      ruleBreakdown[result.rule] = (ruleBreakdown[result.rule] || 0) + 1;\r\n    });\r\n\r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      totalFiles,\r\n      totalRules,\r\n      results,\r\n      summary: {\r\n        errors,\r\n        warnings,\r\n        infos,\r\n        filesWithIssues\r\n      },\r\n      ruleBreakdown\r\n    };\r\n  }\r\n}\r\n\r\n// Report generator\r\nclass DocumentationReporter {\r\n  static generateReport(report: ValidationReport): void {\r\n    console.log('\\n' + '='.repeat(80));\r\n    console.log('📚 COMPREHENSIVE DOCUMENTATION VALIDATION REPORT');\r\n    console.log('='.repeat(80));\r\n    \r\n    this.printSummary(report);\r\n    this.printDetailedResults(report);\r\n    this.printRecommendations(report);\r\n    \r\n    console.log('\\n' + '='.repeat(80));\r\n  }\r\n\r\n  private static printSummary(report: ValidationReport): void {\r\n    console.log('\\n📊 SUMMARY:');\r\n    console.log(`   Files Validated: ${report.totalFiles}`);\r\n    console.log(`   Rules Applied: ${report.totalRules}`);\r\n    console.log(`   Total Issues Found: ${report.results.length}`);\r\n    console.log(`   Files with Issues: ${report.summary.filesWithIssues}`);\r\n    console.log('');\r\n    console.log(`   🔴 Errors: ${report.summary.errors}`);\r\n    console.log(`   🟡 Warnings: ${report.summary.warnings}`);\r\n    console.log(`   🔵 Info: ${report.summary.infos}`);\r\n  }\r\n\r\n  private static printDetailedResults(report: ValidationReport): void {\r\n    if (report.results.length === 0) {\r\n      console.log('\\n✅ No documentation issues found!');\r\n      return;\r\n    }\r\n\r\n    const groupedByFile = new Map<string, ValidationResult[]>();\r\n    report.results.forEach(result => {\r\n      const relativePath = result.filePath.replace(process.cwd(), '.');\r\n      if (!groupedByFile.has(relativePath)) {\r\n        groupedByFile.set(relativePath, []);\r\n      }\r\n      groupedByFile.get(relativePath)!.push(result);\r\n    });\r\n\r\n    console.log('\\n📝 DETAILED RESULTS:');\r\n    \r\n    for (const [filePath, fileResults] of groupedByFile) {\r\n      console.log(`\\n📄 ${filePath} (${fileResults.length} issues)`);\r\n      \r\n      fileResults\r\n        .sort((a, b) => (a.line || 0) - (b.line || 0))\r\n        .forEach(result => {\r\n          const icon = result.type === 'error' ? '🔴' : result.type === 'warning' ? '🟡' : '🔵';\r\n          const location = result.line ? `:${result.line}` : '';\r\n          \r\n          console.log(`   ${icon} [${result.rule}]${location} ${result.message}`);\r\n          \r\n          if (result.suggestion) {\r\n            console.log(`      💡 ${result.suggestion}`);\r\n          }\r\n        });\r\n    }\r\n\r\n    console.log('\\n📈 RULE BREAKDOWN:');\r\n    Object.entries(report.ruleBreakdown)\r\n      .sort(([,a], [,b]) => b - a)\r\n      .forEach(([rule, count]) => {\r\n        console.log(`   ${rule}: ${count} issues`);\r\n      });\r\n  }\r\n\r\n  private static printRecommendations(report: ValidationReport): void {\r\n    console.log('\\n💡 RECOMMENDATIONS:');\r\n    \r\n    if (report.summary.errors > 0) {\r\n      console.log('   1. Address all errors first - these may break functionality');\r\n    }\r\n    \r\n    if (report.summary.warnings > 5) {\r\n      console.log('   2. Review warnings - these indicate potential issues');\r\n    }\r\n    \r\n    if (report.ruleBreakdown['broken-links'] > 0) {\r\n      console.log('   3. Fix broken links to improve document navigation');\r\n    }\r\n    \r\n    if (report.ruleBreakdown['markdown-syntax'] > 0) {\r\n      console.log('   4. Correct markdown syntax issues for proper rendering');\r\n    }\r\n    \r\n    console.log('   5. Run this validation regularly to maintain documentation quality');\r\n    console.log('   6. Consider integrating into CI/CD pipeline for automatic checks');\r\n  }\r\n\r\n  static saveReportToFile(report: ValidationReport, outputPath: string): void {\r\n    fs.writeFileSync(outputPath, JSON.stringify(report, null, 2));\r\n    console.log(`\\n💾 Detailed report saved to: ${outputPath}`);\r\n  }\r\n}\r\n\r\n// Main execution\r\nasync function main(): Promise<void> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    // Parse command line arguments\r\n    const args = process.argv.slice(2);\r\n    const helpFlag = args.includes('--help') || args.includes('-h');\r\n    \r\n    if (helpFlag) {\r\n      printUsage();\r\n      return;\r\n    }\r\n\r\n    const options: Partial<DocValidationOptions> = {};\r\n    \r\n    // Parse options\r\n    if (args.includes('--check-external-links')) {\r\n      options.checkExternalLinks = true;\r\n    }\r\n    \r\n    if (args.includes('--strict')) {\r\n      options.strictMode = true;\r\n    }\r\n    \r\n    if (args.includes('--skip-code-refs')) {\r\n      options.validateCodeReferences = false;\r\n    }\r\n    \r\n    // Get target directory\r\n    let targetDir = process.cwd();\r\n    for (let i = args.length - 1; i >= 0; i--) {\r\n      if (!args[i].startsWith('-') && fs.existsSync(args[i])) {\r\n        targetDir = path.resolve(args[i]);\r\n        break;\r\n      }\r\n    }\r\n    \r\n    console.log('📚 Comprehensive Documentation Validator');\r\n    console.log(`⚙️ Configuration:`);\r\n    console.log(`   Check External Links: ${options.checkExternalLinks ?? DEFAULT_OPTIONS.checkExternalLinks}`);\r\n    console.log(`   Validate Code References: ${options.validateCodeReferences ?? DEFAULT_OPTIONS.validateCodeReferences}`);\r\n    console.log(`   Strict Mode: ${options.strictMode ?? DEFAULT_OPTIONS.strictMode}`);\r\n    \r\n    // Run validation\r\n    const validator = new ComprehensiveDocumentationValidator(options);\r\n    const report = await validator.validate(targetDir);\r\n    \r\n    // Generate report\r\n    DocumentationReporter.generateReport(report);\r\n    \r\n    // Save detailed report\r\n    const reportsDir = path.join(process.cwd(), 'reports', 'quality');\r\n    if (!fs.existsSync(reportsDir)) {\r\n      fs.mkdirSync(reportsDir, { recursive: true });\r\n    }\r\n    \r\n    const timestamp = new Date().toISOString().split('T')[0];\r\n    const reportPath = path.join(reportsDir, `documentation-validation-${timestamp}.json`);\r\n    DocumentationReporter.saveReportToFile(report, reportPath);\r\n    \r\n    const endTime = Date.now();\r\n    const duration = ((endTime - startTime) / 1000).toFixed(2);\r\n    console.log(`\\n⏱️ Validation completed in ${duration} seconds`);\r\n    \r\n    // Exit with appropriate code\r\n    const hasErrors = report.summary.errors > 0;\r\n    const hasWarnings = report.summary.warnings > 0;\r\n    \r\n    if (hasErrors) {\r\n      process.exit(1);\r\n    } else if (hasWarnings && options.strictMode) {\r\n      process.exit(1);\r\n    } else {\r\n      process.exit(0);\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Error during documentation validation:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nfunction printUsage(): void {\r\n  console.log(`\r\n📚 Comprehensive Documentation Validator\r\n\r\nUSAGE:\r\n  npx tsx scripts/monitoring/comprehensive-doc-validator.ts [OPTIONS] [DIRECTORY]\r\n\r\nOPTIONS:\r\n  --check-external-links        Check external links (requires network)\r\n  --strict                      Fail on warnings as well as errors\r\n  --skip-code-refs             Skip code reference validation\r\n  --help, -h                   Show this help message\r\n\r\nEXAMPLES:\r\n  # Validate all documentation in current directory\r\n  npx tsx scripts/monitoring/comprehensive-doc-validator.ts\r\n  \r\n  # Validate specific directory with external link checking\r\n  npx tsx scripts/monitoring/comprehensive-doc-validator.ts --check-external-links ./docs\r\n  \r\n  # Strict validation (warnings become errors)\r\n  npx tsx scripts/monitoring/comprehensive-doc-validator.ts --strict\r\n\r\nFEATURES:\r\n  - Broken link detection (internal and external)\r\n  - Code reference validation\r\n  - Markdown syntax checking\r\n  - Consistency validation across files\r\n  - Date and version consistency\r\n  - Task status validation\r\n  - Document structure analysis\r\n  - Basic spell checking\r\n  - Format consistency\r\n\r\nOUTPUT:\r\n  - Console report with detailed findings\r\n  - JSON report saved to scripts/analysis/reports/quality/documentation-validation-YYYY-MM-DD.json\r\n  - Exit code 0 if valid, 1 if issues found (or warnings in strict mode)\r\n`);\r\n}\r\n\r\n// Run if called directly\r\nif (require.main === module) {\r\n  main().catch(console.error);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-check.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\post-implementation-validator.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":58,"column":10,"nodeType":"CallExpression","endLine":58,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":59,"column":7,"nodeType":"CallExpression","endLine":59,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":261,"column":25,"nodeType":"CallExpression","endLine":261,"endColumn":54},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":382,"column":12,"nodeType":"CallExpression","endLine":382,"endColumn":37},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":384,"column":23,"nodeType":"CallExpression","endLine":384,"endColumn":74},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":421,"column":13,"nodeType":"CallExpression","endLine":421,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":422,"column":34,"nodeType":"CallExpression","endLine":422,"endColumn":70},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":446,"column":15,"nodeType":"CallExpression","endLine":446,"endColumn":34},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":513,"column":5,"nodeType":"CallExpression","endLine":513,"endColumn":66}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { execSync } from 'child_process';\r\n\r\n/**\r\n * Post-Implementation Validation Script\r\n * Runs comprehensive checks after code changes to ensure quality and compliance\r\n * Part of Task 53.4 - Create New Post-Implementation Check Scripts\r\n */\r\n\r\ninterface ValidationRule {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  severity: 'error' | 'warning' | 'info';\r\n  check: () => Promise<ValidationResult>;\r\n}\r\n\r\ninterface ValidationResult {\r\n  passed: boolean;\r\n  message: string;\r\n  details?: string[];\r\n  suggestions?: string[];\r\n}\r\n\r\ninterface ValidationReport {\r\n  timestamp: string;\r\n  project: string;\r\n  task: string;\r\n  summary: {\r\n    totalChecks: number;\r\n    passed: number;\r\n    failed: number;\r\n    warnings: number;\r\n    errors: number;\r\n  };\r\n  results: Array<{\r\n    rule: ValidationRule;\r\n    result: ValidationResult;\r\n  }>;\r\n  overallStatus: 'PASS' | 'FAIL' | 'WARNING';\r\n}\r\n\r\nclass PostImplementationValidator {\r\n  private projectRoot: string;\r\n  private reportDir: string;\r\n  private timestamp: string;\r\n  private rules: ValidationRule[];\r\n\r\n  constructor() {\r\n    this.projectRoot = process.cwd();\r\n    this.reportDir = path.join(this.projectRoot, 'scripts', 'analysis', 'reports', 'quality');\r\n    this.timestamp = new Date().toISOString().split('T')[0];\r\n    \r\n    // Ensure reports directory exists\r\n    if (!fs.existsSync(this.reportDir)) {\r\n      fs.mkdirSync(this.reportDir, { recursive: true });\r\n    }\r\n\r\n    this.rules = this.defineValidationRules();\r\n  }\r\n\r\n  /**\r\n   * Define all validation rules for post-implementation checks\r\n   */\r\n  private defineValidationRules(): ValidationRule[] {\r\n    return [\r\n      {\r\n        id: 'typescript-compilation',\r\n        name: 'TypeScript Compilation',\r\n        description: 'Verify that all TypeScript code compiles without errors',\r\n        severity: 'error',\r\n        check: async () => this.checkTypeScriptCompilation()\r\n      },\r\n      {\r\n        id: 'test-execution',\r\n        name: 'Test Execution',\r\n        description: 'Ensure all tests pass after implementation changes',\r\n        severity: 'error',\r\n        check: async () => this.checkTestExecution()\r\n      },\r\n      {\r\n        id: 'lint-compliance',\r\n        name: 'Lint Compliance',\r\n        description: 'Verify code follows linting rules and standards',\r\n        severity: 'warning',\r\n        check: async () => this.checkLintCompliance()\r\n      },\r\n      {\r\n        id: 'import-resolution',\r\n        name: 'Import Resolution',\r\n        description: 'Check that all imports resolve correctly across workspaces',\r\n        severity: 'error',\r\n        check: async () => this.checkImportResolution()\r\n      },\r\n      {\r\n        id: 'documentation-sync',\r\n        name: 'Documentation Synchronization',\r\n        description: 'Ensure documentation is updated and synchronized with code changes',\r\n        severity: 'warning',\r\n        check: async () => this.checkDocumentationSync()\r\n      },\r\n      {\r\n        id: 'security-compliance',\r\n        name: 'Security Compliance',\r\n        description: 'Verify no new security vulnerabilities are introduced',\r\n        severity: 'error',\r\n        check: async () => this.checkSecurityCompliance()\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Check TypeScript compilation across all workspaces\r\n   */\r\n  private async checkTypeScriptCompilation(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔧 Checking TypeScript compilation...');\r\n      \r\n      const workspaces = ['packages/backend', 'packages/frontend', 'packages/shared'];\r\n      const errors: string[] = [];\r\n      \r\n      for (const workspace of workspaces) {\r\n        try {\r\n          const output = execSync(`npm run build --workspace=${workspace}`, {\r\n            stdio: 'pipe',\r\n            encoding: 'utf8',\r\n            cwd: this.projectRoot\r\n          });\r\n        } catch (error: any) {\r\n          errors.push(`${workspace}: ${error.message}`);\r\n        }\r\n      }\r\n      \r\n      if (errors.length === 0) {\r\n        return {\r\n          passed: true,\r\n          message: 'All TypeScript code compiles successfully',\r\n          details: [`Checked ${workspaces.length} workspaces`]\r\n        };\r\n      } else {\r\n        return {\r\n          passed: false,\r\n          message: `TypeScript compilation failed in ${errors.length} workspace(s)`,\r\n          details: errors,\r\n          suggestions: [\r\n            'Run npm run build in each failed workspace to see detailed errors',\r\n            'Check for missing dependencies or type definitions',\r\n            'Verify import paths are correct'\r\n          ]\r\n        };\r\n      }\r\n    } catch (error: any) {\r\n      return {\r\n        passed: false,\r\n        message: 'Failed to check TypeScript compilation',\r\n        details: [error.message]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check test execution across all workspaces\r\n   */\r\n  private async checkTestExecution(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🧪 Checking test execution...');\r\n      \r\n      const testResults: string[] = [];\r\n      const errors: string[] = [];\r\n      \r\n      try {\r\n        const output = execSync('npm run test:unit', {\r\n          stdio: 'pipe',\r\n          encoding: 'utf8',\r\n          cwd: this.projectRoot\r\n        });\r\n        testResults.push('Unit tests: PASSED');\r\n      } catch (error: any) {\r\n        errors.push(`Unit tests: ${error.message}`);\r\n      }\r\n      \r\n      if (errors.length === 0) {\r\n        return {\r\n          passed: true,\r\n          message: 'All tests pass successfully',\r\n          details: testResults\r\n        };\r\n      } else {\r\n        return {\r\n          passed: false,\r\n          message: `Test execution failed`,\r\n          details: errors,\r\n          suggestions: [\r\n            'Run npm run test:unit to see detailed test failures',\r\n            'Check for breaking changes in implementation',\r\n            'Update tests if API changes are intentional'\r\n          ]\r\n        };\r\n      }\r\n    } catch (error: any) {\r\n      return {\r\n        passed: false,\r\n        message: 'Failed to execute tests',\r\n        details: [error.message]\r\n      };\r\n    }\r\n  }\r\n  /**\r\n   * Check lint compliance\r\n   */\r\n  private async checkLintCompliance(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('📋 Checking lint compliance...');\r\n      \r\n      const output = execSync('npm run lint:root', {\r\n        stdio: 'pipe',\r\n        encoding: 'utf8',\r\n        cwd: this.projectRoot\r\n      });\r\n      \r\n      return {\r\n        passed: true,\r\n        message: 'Code passes all linting rules',\r\n        details: ['No linting errors found']\r\n      };\r\n    } catch (error: any) {\r\n      const errorOutput = error.stdout || error.message;\r\n      const warningCount = (errorOutput.match(/warning/gi) || []).length;\r\n      const errorCount = (errorOutput.match(/error/gi) || []).length;\r\n      \r\n      return {\r\n        passed: errorCount === 0,\r\n        message: `Linting found ${errorCount} errors and ${warningCount} warnings`,\r\n        details: [errorOutput],\r\n        suggestions: [\r\n          'Run npm run lint:fix to automatically fix some issues',\r\n          'Review and fix remaining linting errors manually'\r\n        ]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check import resolution across workspaces\r\n   */\r\n  private async checkImportResolution(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔗 Checking import resolution...');\r\n      \r\n      const sourceFiles = this.getSourceFiles([\r\n        path.join(this.projectRoot, 'packages'),\r\n        path.join(this.projectRoot, 'scripts')\r\n      ]);\r\n      \r\n      const unresolvedImports: string[] = [];\r\n      \r\n      for (const file of sourceFiles) {\r\n        const content = fs.readFileSync(file, 'utf8');\r\n        const imports = content.match(/^import.*from\\s+['\"][^'\"]+['\"];?$/gm) || [];\r\n        \r\n        for (const importStatement of imports) {\r\n          const match = importStatement.match(/from\\s+['\"]([^'\"]+)['\"];?$/);\r\n          if (match) {\r\n            const importPath = match[1];\r\n            if (importPath.startsWith('.') || importPath.startsWith('@jabbr/')) {\r\n              // Check relative and workspace imports\r\n              const resolvedPath = this.resolveImportPath(file, importPath);\r\n              if (!resolvedPath) {\r\n                unresolvedImports.push(`${path.relative(this.projectRoot, file)}: ${importPath}`);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (unresolvedImports.length === 0) {\r\n        return {\r\n          passed: true,\r\n          message: 'All imports resolve correctly',\r\n          details: [`Checked ${sourceFiles.length} files`]\r\n        };\r\n      } else {\r\n        return {\r\n          passed: false,\r\n          message: `Found ${unresolvedImports.length} unresolved imports`,\r\n          details: unresolvedImports.slice(0, 10), // Limit output\r\n          suggestions: [\r\n            'Check file paths and ensure referenced files exist',\r\n            'Verify workspace package configurations',\r\n            'Update import paths if files were moved'\r\n          ]\r\n        };\r\n      }\r\n    } catch (error: any) {\r\n      return {\r\n        passed: false,\r\n        message: 'Failed to check import resolution',\r\n        details: [error.message]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check documentation synchronization\r\n   */\r\n  private async checkDocumentationSync(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('📖 Checking documentation synchronization...');\r\n      \r\n      const output = execSync('npx tsx scripts/validate-documentation-precise.ts', {\r\n        stdio: 'pipe',\r\n        encoding: 'utf8',\r\n        cwd: this.projectRoot\r\n      });\r\n      \r\n      return {\r\n        passed: true,\r\n        message: 'Documentation is synchronized and up-to-date',\r\n        details: ['All documentation validation checks passed']\r\n      };\r\n    } catch (error: any) {\r\n      const errorOutput = error.stdout || error.message;\r\n      const criticalIssues = (errorOutput.match(/critical issue/gi) || []).length;\r\n      \r\n      return {\r\n        passed: criticalIssues === 0,\r\n        message: `Documentation validation found ${criticalIssues} critical issues`,\r\n        details: [errorOutput],\r\n        suggestions: [\r\n          'Update documentation to reflect recent code changes',\r\n          'Check date stamps and version numbers',\r\n          'Ensure all referenced files exist'\r\n        ]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check security compliance\r\n   */\r\n  private async checkSecurityCompliance(): Promise<ValidationResult> {\r\n    try {\r\n      console.log('🔒 Checking security compliance...');\r\n      \r\n      const output = execSync('npm run security:check', {\r\n        stdio: 'pipe',\r\n        encoding: 'utf8',\r\n        cwd: this.projectRoot\r\n      });\r\n      \r\n      return {\r\n        passed: true,\r\n        message: 'No security violations detected',\r\n        details: ['Security checks passed']\r\n      };\r\n    } catch (error: any) {\r\n      const errorOutput = error.stdout || error.message;\r\n      const errorCount = (errorOutput.match(/error/gi) || []).length;\r\n      \r\n      return {\r\n        passed: errorCount === 0,\r\n        message: `Security check found ${errorCount} issues`,\r\n        details: [errorOutput],\r\n        suggestions: [\r\n          'Review and fix security violations',\r\n          'Consider using safer alternatives for flagged patterns',\r\n          'Add security exceptions if issues are false positives'\r\n        ]\r\n      };\r\n    }\r\n  }\r\n  /**\r\n   * Get all source files recursively\r\n   */\r\n  private getSourceFiles(dirs: string[], extensions: string[] = ['.ts', '.tsx', '.js', '.jsx']): string[] {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (currentDir: string) => {\r\n      if (!fs.existsSync(currentDir)) return;\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    for (const dir of dirs) {\r\n      scanDirectory(dir);\r\n    }\r\n    return files;\r\n  }\r\n\r\n  /**\r\n   * Resolve import path to actual file\r\n   */\r\n  private resolveImportPath(fromFile: string, importPath: string): string | null {\r\n    try {\r\n      if (importPath.startsWith('@jabbr/')) {\r\n        // Workspace import\r\n        const workspaceName = importPath.split('/')[1];\r\n        const workspacePath = path.join(this.projectRoot, 'packages', workspaceName);\r\n        const packageJson = path.join(workspacePath, 'package.json');\r\n        \r\n        if (fs.existsSync(packageJson)) {\r\n          const pkg = JSON.parse(fs.readFileSync(packageJson, 'utf8'));\r\n          const mainFile = pkg.main || 'dist/index.js';\r\n          return path.join(workspacePath, mainFile);\r\n        }\r\n        return null;\r\n      } else if (importPath.startsWith('.')) {\r\n        // Relative import\r\n        const basePath = path.dirname(fromFile);\r\n        const fullPath = path.resolve(basePath, importPath);\r\n        \r\n        // Try different extensions\r\n        const possibleFiles = [\r\n          fullPath,\r\n          fullPath + '.ts',\r\n          fullPath + '.tsx',\r\n          fullPath + '.js',\r\n          fullPath + '.jsx',\r\n          path.join(fullPath, 'index.ts'),\r\n          path.join(fullPath, 'index.tsx'),\r\n          path.join(fullPath, 'index.js'),\r\n          path.join(fullPath, 'index.jsx')\r\n        ];\r\n        \r\n        for (const file of possibleFiles) {\r\n          if (fs.existsSync(file)) {\r\n            return file;\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n      \r\n      return null; // External packages are not checked\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run all validation checks\r\n   */\r\n  async validate(): Promise<ValidationReport> {\r\n    console.log('🚀 Starting post-implementation validation...');\r\n    console.log('📁 Project:', this.projectRoot);\r\n    console.log('');\r\n    \r\n    const results: Array<{ rule: ValidationRule; result: ValidationResult }> = [];\r\n    let passed = 0;\r\n    let failed = 0;\r\n    let warnings = 0;\r\n    let errors = 0;\r\n    \r\n    for (const rule of this.rules) {\r\n      console.log(`🔍 Running: ${rule.name}...`);\r\n      const result = await rule.check();\r\n      results.push({ rule, result });\r\n      \r\n      if (result.passed) {\r\n        passed++;\r\n        console.log(`✅ ${rule.name}: PASSED`);\r\n      } else {\r\n        failed++;\r\n        if (rule.severity === 'error') {\r\n          errors++;\r\n          console.log(`❌ ${rule.name}: FAILED (ERROR)`);\r\n        } else {\r\n          warnings++;\r\n          console.log(`⚠️  ${rule.name}: FAILED (WARNING)`);\r\n        }\r\n      }\r\n      console.log('');\r\n    }\r\n    \r\n    const overallStatus = errors > 0 ? 'FAIL' : warnings > 0 ? 'WARNING' : 'PASS';\r\n    \r\n    const report: ValidationReport = {\r\n      timestamp: new Date().toISOString(),\r\n      project: 'JBR Trading Platform',\r\n      task: 'Task 53.4 - Post-Implementation Validation',\r\n      summary: {\r\n        totalChecks: this.rules.length,\r\n        passed,\r\n        failed,\r\n        warnings,\r\n        errors\r\n      },\r\n      results,\r\n      overallStatus\r\n    };\r\n    \r\n    // Save report\r\n    const reportPath = path.join(this.reportDir, `post-implementation-${this.timestamp}.json`);\r\n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\r\n    \r\n    // Display summary\r\n    console.log('🎯 POST-IMPLEMENTATION VALIDATION SUMMARY:');\r\n    console.log(`📊 Overall Status: ${overallStatus}`);\r\n    console.log(`✅ Passed: ${passed}/${this.rules.length}`);\r\n    console.log(`❌ Failed: ${failed}/${this.rules.length}`);\r\n    console.log(`🚨 Errors: ${errors}`);\r\n    console.log(`⚠️  Warnings: ${warnings}`);\r\n    console.log('');\r\n    \r\n    if (failed > 0) {\r\n      console.log('❌ FAILED CHECKS:');\r\n      for (const { rule, result } of results) {\r\n        if (!result.passed) {\r\n          console.log(`   ${rule.name}: ${result.message}`);\r\n          if (result.suggestions) {\r\n            result.suggestions.forEach(suggestion => {\r\n              console.log(`     💡 ${suggestion}`);\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`📋 Full report saved: ${reportPath}`);\r\n    \r\n    return report;\r\n  }\r\n}\r\n\r\n// Run validation if called directly\r\nif (require.main === module) {\r\n  const validator = new PostImplementationValidator();\r\n  validator.validate()\r\n    .then(report => {\r\n      process.exit(report.overallStatus === 'FAIL' ? 1 : 0);\r\n    })\r\n    .catch(error => {\r\n      console.error('❌ Validation failed:', error);\r\n      process.exit(1);\r\n    });\r\n}\r\n\r\nexport { PostImplementationValidator, ValidationReport, ValidationResult, ValidationRule };\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\production-violations-analyzer.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":95,"column":9,"nodeType":"CallExpression","endLine":95,"endColumn":38},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":96,"column":6,"nodeType":"CallExpression","endLine":96,"endColumn":55},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":209,"column":6,"nodeType":"CallExpression","endLine":209,"endColumn":52},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlinkSync from package \"fs\" with non literal argument at index 0","line":214,"column":6,"nodeType":"CallExpression","endLine":214,"endColumn":35},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":227,"column":10,"nodeType":"CallExpression","endLine":227,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlinkSync from package \"fs\" with non literal argument at index 0","line":228,"column":8,"nodeType":"CallExpression","endLine":228,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":353,"column":10,"nodeType":"MemberExpression","endLine":353,"endColumn":33},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":389,"column":4,"nodeType":"CallExpression","endLine":389,"endColumn":65},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":404,"column":10,"nodeType":"CallExpression","endLine":404,"endColumn":35},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":405,"column":26,"nodeType":"CallExpression","endLine":405,"endColumn":61},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":497,"column":4,"nodeType":"CallExpression","endLine":497,"endColumn":43},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":510,"column":11,"nodeType":"MemberExpression","endLine":510,"endColumn":25}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\nimport { execSync } from 'child_process';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n* Production Violations Analyzer\r\n* Implements Task 41.4 - Identify and Categorize Production Violations\r\n* \r\n* This script identifies and categorizes code violations that would prevent\r\n* the application from being production-ready, prioritizing critical issues.\r\n*/\r\n\r\ninterface ViolationCategories {\r\n CRITICAL: string;\r\n HIGH: string;\r\n MEDIUM: string;\r\n LOW: string;\r\n INFO: string;\r\n}\r\n\r\ninterface TypeScriptViolation {\r\n file: string;\r\n line: number;\r\n column: number;\r\n code: string;\r\n message: string;\r\n severity: string;\r\n}\r\n\r\ninterface ESLintViolation {\r\n file: string;\r\n line: number;\r\n column: number;\r\n level: string;\r\n message: string;\r\n rule: string;\r\n severity: string;\r\n}\r\n\r\ninterface CheckResult {\r\n category: string;\r\n status: string;\r\n violations: (TypeScriptViolation | ESLintViolation)[];\r\n message: string;\r\n}\r\n\r\ninterface CategoryStats {\r\n CRITICAL: number;\r\n HIGH: number;\r\n MEDIUM: number;\r\n LOW: number;\r\n INFO: number;\r\n}\r\n\r\ninterface DuplicationResults {\r\n summary?: {\r\n   totalIssues?: number;\r\n   severity?: string;\r\n };\r\n}\r\n\r\ninterface ProductionReport {\r\n timestamp: string;\r\n project: string;\r\n task: string;\r\n productionReadiness: string;\r\n checks: CheckResult[];\r\n violations: {\r\n   total: number;\r\n   byCategory: CategoryStats;\r\n   details: any[];\r\n };\r\n duplicationIssues: {\r\n   total: number;\r\n   severity: string;\r\n } | null;\r\n recommendations: string[];\r\n blockers: number;\r\n}\r\n\r\nclass ProductionViolationsAnalyzer {\r\n private projectRoot: string;\r\n private reportDir: string;\r\n private timestamp: string;\r\n private violationCategories: ViolationCategories;\r\n\r\n constructor() {\r\n   this.projectRoot = process.cwd();\r\n   this.reportDir = path.join(this.projectRoot, 'scripts', 'analysis', 'reports', 'quality');\r\n   this.timestamp = new Date().toISOString().split('T')[0];\r\n   \r\n   // Ensure reports directory exists\r\n   if (!fs.existsSync(this.reportDir)) {\r\n     fs.mkdirSync(this.reportDir, { recursive: true });\r\n   }\r\n   \r\n   // Production readiness categories\r\n   this.violationCategories = {\r\n     CRITICAL: 'Blocks production deployment',\r\n     HIGH: 'Significant production risk',\r\n     MEDIUM: 'Should be fixed before production',\r\n     LOW: 'Improve before production',\r\n     INFO: 'Consider for code quality'\r\n   };\r\n }\r\n\r\n /**\r\n  * Run TypeScript compilation check\r\n  */\r\n checkTypeScriptCompilation(): CheckResult {\r\n   console.log('🔍 Checking TypeScript compilation...');\r\n   \r\n   try {\r\n     execSync('npx tsc --noEmit', { stdio: 'pipe' });\r\n     return {\r\n       category: 'typescript',\r\n       status: 'pass',\r\n       violations: [],\r\n       message: 'TypeScript compilation successful'\r\n     };\r\n   } catch (error: any) {\r\n     const output: string = error.stdout?.toString() || error.stderr?.toString() || '';\r\n     const violations: TypeScriptViolation[] = this.parseTypeScriptErrors(output);\r\n     \r\n     return {\r\n       category: 'typescript',\r\n       status: 'fail',\r\n       violations,\r\n       message: `TypeScript compilation failed with ${violations.length} errors`\r\n     };\r\n   }\r\n }\r\n\r\n /**\r\n  * Parse TypeScript compilation errors\r\n  */\r\n parseTypeScriptErrors(output: string): TypeScriptViolation[] {\r\n   const violations: TypeScriptViolation[] = [];\r\n   const lines: string[] = output.split('\\n');\r\n   \r\n   for (const line of lines) {\r\n     if (line.includes('error TS')) {\r\n       const match: RegExpMatchArray | null = line.match(/(.+)\\((\\d+),(\\d+)\\): error (TS\\d+): (.+)/);\r\n       if (match) {\r\n         violations.push({\r\n           file: match[1],\r\n           line: parseInt(match[2]),\r\n           column: parseInt(match[3]),\r\n           code: match[4],\r\n           message: match[5],\r\n           severity: this.categorizeTypeScriptError(match[4])\r\n         });\r\n       }\r\n     }\r\n   }\r\n   \r\n   return violations;\r\n }\r\n\r\n /**\r\n  * Categorize TypeScript errors by production impact\r\n  */\r\n categorizeTypeScriptError(errorCode: string): string {\r\n   const criticalErrors: string[] = ['TS2304', 'TS2339', 'TS2345', 'TS2322', 'TS2532'];\r\n   const highErrors: string[] = ['TS2531', 'TS2538', 'TS2571', 'TS2749'];\r\n   \r\n   if (criticalErrors.includes(errorCode)) {return 'CRITICAL';}\r\n   if (highErrors.includes(errorCode)) {return 'HIGH';}\r\n   return 'MEDIUM';\r\n }\r\n\r\n /**\r\n  * Check for security violations\r\n  */\r\n checkSecurityViolations(): CheckResult {\r\n   console.log('🔒 Checking security violations...');\r\n   \r\n   try {\r\n     execSync('npm run security:check', { stdio: 'pipe' });\r\n     return {\r\n       category: 'security',\r\n       status: 'pass',\r\n       violations: [],\r\n       message: 'No security violations found'\r\n     };\r\n   } catch (error: any) {\r\n     const output: string = error.stdout?.toString() || error.stderr?.toString() || '';\r\n     return {\r\n       category: 'security',\r\n       status: 'fail',\r\n       violations: this.parseESLintOutput(output, 'security'),\r\n       message: 'Security violations found'\r\n     };\r\n   }\r\n }\r\n\r\n /**\r\n  * Check critical ESLint violations\r\n  */\r\n checkESLintViolations(): CheckResult {\r\n   console.log('📋 Checking ESLint violations...');\r\n   \r\n   try {\r\n     // Use a simplified ESLint config to avoid dependency issues\r\n     const simpleConfig: string = this.createSimpleESLintConfig();\r\n     const tempConfigPath: string = path.join(this.reportDir, 'temp-eslint.js');\r\n     fs.writeFileSync(tempConfigPath, simpleConfig);\r\n     \r\n     execSync(`npx eslint . --config \"${tempConfigPath}\" --ext .ts,.tsx,.js,.jsx`, { stdio: 'pipe' });\r\n     \r\n     // Clean up temp config\r\n     fs.unlinkSync(tempConfigPath);\r\n     \r\n     return {\r\n       category: 'eslint',\r\n       status: 'pass',\r\n       violations: [],\r\n       message: 'No ESLint violations found'\r\n     };\r\n   } catch (error: any) {\r\n     const output: string = error.stdout?.toString() || error.stderr?.toString() || '';\r\n     \r\n     // Clean up temp config if it exists\r\n     const tempConfigPath: string = path.join(this.reportDir, 'temp-eslint.js');\r\n     if (fs.existsSync(tempConfigPath)) {\r\n       fs.unlinkSync(tempConfigPath);\r\n     }\r\n     \r\n     return {\r\n       category: 'eslint',\r\n       status: 'fail',\r\n       violations: this.parseESLintOutput(output, 'eslint'),\r\n       message: 'ESLint violations found'\r\n     };\r\n   }\r\n }\r\n\r\n /**\r\n  * Create a simple ESLint config for production checks\r\n  */\r\n createSimpleESLintConfig(): string {\r\n   return `\r\nmodule.exports = {\r\n env: {\r\n   node: true,\r\n   es2022: true\r\n },\r\n extends: ['eslint:recommended'],\r\n parserOptions: {\r\n   ecmaVersion: 2022,\r\n   sourceType: 'module'\r\n },\r\n rules: {\r\n   'no-console': 'warn',\r\n   'no-debugger': 'error',\r\n   'no-alert': 'error',\r\n   'no-eval': 'error',\r\n   'no-implied-eval': 'error',\r\n   'no-new-func': 'error',\r\n   'no-script-url': 'error',\r\n   'no-throw-literal': 'error',\r\n   'no-unused-vars': 'error',\r\n   'no-undef': 'error'\r\n },\r\n ignorePatterns: [\r\n   'dist/',\r\n   'build/',\r\n   'node_modules/',\r\n   'coverage/',\r\n   '*.d.ts'\r\n ]\r\n};`;\r\n }\r\n\r\n /**\r\n  * Parse ESLint output to extract violations\r\n  */\r\n parseESLintOutput(output: string, type: string): ESLintViolation[] {\r\n   const violations: ESLintViolation[] = [];\r\n   const lines: string[] = output.split('\\n');\r\n   \r\n   for (const line of lines) {\r\n     if (line.includes('error') || line.includes('warning')) {\r\n       const match: RegExpMatchArray | null = line.match(/(.+):(\\d+):(\\d+): (error|warning) (.+) (.+)/);\r\n       if (match) {\r\n         violations.push({\r\n           file: match[1],\r\n           line: parseInt(match[2]),\r\n           column: parseInt(match[3]),\r\n           level: match[4],\r\n           message: match[5],\r\n           rule: match[6],\r\n           severity: this.categorizeESLintViolation(match[6], match[4])\r\n         });\r\n       }\r\n     }\r\n   }\r\n   \r\n   return violations;\r\n }\r\n\r\n /**\r\n  * Categorize ESLint violations by production impact\r\n  */\r\n categorizeESLintViolation(rule: string, level: string): string {\r\n   const criticalRules: string[] = ['no-eval', 'no-implied-eval', 'no-new-func', 'security/'];\r\n   const highRules: string[] = ['no-debugger', 'no-alert', 'no-unused-vars', 'no-undef'];\r\n   \r\n   if (level === 'error' && criticalRules.some(r => rule.includes(r))) {return 'CRITICAL';}\r\n   if (level === 'error' && highRules.some(r => rule.includes(r))) {return 'HIGH';}\r\n   if (level === 'error') {return 'MEDIUM';}\r\n   return 'LOW';\r\n }\r\n\r\n /**\r\n  * Generate comprehensive production violations report\r\n  */\r\n async generateProductionReport(): Promise<ProductionReport> {\r\n   console.log('📊 Generating comprehensive production violations report...');\r\n   \r\n   const checks: CheckResult[] = [\r\n     this.checkTypeScriptCompilation(),\r\n     this.checkSecurityViolations(),\r\n     this.checkESLintViolations()\r\n   ];\r\n   \r\n   // Analyze duplication results from previous tasks\r\n   const duplicationResults: DuplicationResults | null = this.loadDuplicationResults();\r\n   \r\n   const allViolations: any[] = [];\r\n   const categoryStats: CategoryStats = {\r\n     CRITICAL: 0,\r\n     HIGH: 0,\r\n     MEDIUM: 0,\r\n     LOW: 0,\r\n     INFO: 0\r\n   };\r\n   \r\n   // Process each check\r\n   for (const check of checks) {\r\n     for (const violation of check.violations || []) {\r\n       allViolations.push({\r\n         ...violation,\r\n         category: check.category,\r\n         checkStatus: check.status\r\n       });\r\n       \r\n       // Type-safe severity handling\r\n       const severity = violation.severity?.toUpperCase() as keyof CategoryStats;\r\n       if (severity && severity in categoryStats) {\r\n         categoryStats[severity]++;\r\n       } else {\r\n         // Default to MEDIUM for unknown severities\r\n         categoryStats.MEDIUM++;\r\n       }\r\n     }\r\n   }\r\n   \r\n   // Add duplication violations from Task 41.2\r\n   if (duplicationResults && duplicationResults.summary) {\r\n     const dupCount: number = duplicationResults.summary.totalIssues || 0;\r\n     if (dupCount > 0) {\r\n       categoryStats.HIGH += dupCount; // Duplication is HIGH severity for production\r\n     }\r\n   }\r\n   \r\n   const report: ProductionReport = {\r\n     timestamp: new Date().toISOString(),\r\n     project: 'JBR Trading Platform',\r\n     task: 'Task 41.4 - Identify and Categorize Production Violations',\r\n     productionReadiness: this.assessProductionReadiness(categoryStats),\r\n     checks,\r\n     violations: {\r\n       total: allViolations.length,\r\n       byCategory: categoryStats,\r\n       details: allViolations\r\n     },\r\n     duplicationIssues: duplicationResults ? {\r\n       total: duplicationResults.summary?.totalIssues || 0,\r\n       severity: duplicationResults.summary?.severity || 'unknown'\r\n     } : null,\r\n     recommendations: this.generateRecommendations(categoryStats, allViolations),\r\n     blockers: allViolations.filter(v => v.severity === 'CRITICAL').length\r\n   };\r\n   \r\n   const reportPath: string = path.join(this.reportDir, `production-violations-${this.timestamp}.json`);\r\n   fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\r\n   \r\n   // Generate HTML report\r\n   this.generateHTMLReport(report);\r\n   \r\n   console.log(`📋 Production violations report generated: ${reportPath}`);\r\n   return report;\r\n }\r\n\r\n /**\r\n  * Load duplication results from Task 41.2\r\n  */\r\n loadDuplicationResults(): DuplicationResults | null {\r\n   try {\r\n     const reportPath: string = path.join(this.reportDir.replace('quality', 'duplication'), `duplication-analysis-${this.timestamp}.json`);\r\n     if (fs.existsSync(reportPath)) {\r\n       return JSON.parse(fs.readFileSync(reportPath, 'utf8'));\r\n     }\r\n   } catch (error) {\r\n     console.warn('⚠️  Could not load duplication results');\r\n   }\r\n   return null;\r\n }\r\n\r\n /**\r\n  * Assess overall production readiness\r\n  */\r\n assessProductionReadiness(stats: CategoryStats): string {\r\n   if (stats.CRITICAL > 0) {return 'NOT_READY';}\r\n   if (stats.HIGH > 10) {return 'NOT_READY';}\r\n   if (stats.HIGH > 0) {return 'NEEDS_ATTENTION';}\r\n   if (stats.MEDIUM > 20) {return 'NEEDS_IMPROVEMENT';}\r\n   return 'READY';\r\n }\r\n\r\n /**\r\n  * Generate recommendations based on violations\r\n  */\r\n generateRecommendations(stats: CategoryStats, violations: any[]): string[] {\r\n   const recommendations: string[] = [];\r\n   \r\n   if (stats.CRITICAL > 0) {\r\n     recommendations.push(`URGENT: Fix ${stats.CRITICAL} critical violations before any deployment`);\r\n   }\r\n   \r\n   if (stats.HIGH > 0) {\r\n     recommendations.push(`Address ${stats.HIGH} high-severity violations for production readiness`);\r\n   }\r\n   \r\n   if (violations.some(v => v.category === 'typescript')) {\r\n     recommendations.push('Fix TypeScript compilation errors for type safety');\r\n   }\r\n   \r\n   if (violations.some(v => v.category === 'security')) {\r\n     recommendations.push('Resolve security violations immediately - these pose production risks');\r\n   }\r\n   \r\n   recommendations.push('Implement automated quality gates in CI/CD pipeline');\r\n   recommendations.push('Establish code review process requiring violation-free code');\r\n   \r\n   return recommendations;\r\n }\r\n\r\n /**\r\n  * Generate HTML report for easy viewing\r\n  */\r\n generateHTMLReport(report: ProductionReport): void {\r\n   const htmlContent: string = `\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n   <title>Production Violations Report</title>\r\n   <style>\r\n       body { font-family: Arial, sans-serif; margin: 20px; background: #f5f7fa; }\r\n       .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; }\r\n       .header { background: ${this.getReadinessColor(report.productionReadiness)}; color: white; padding: 20px; border-radius: 8px; margin-bottom: 30px; }\r\n       .status-${report.productionReadiness} { font-weight: bold; }\r\n       .violation { background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; }\r\n       .critical { border-left: 4px solid #dc3545; }\r\n       .high { border-left: 4px solid #fd7e14; }\r\n       .medium { border-left: 4px solid #ffc107; }\r\n       .low { border-left: 4px solid #28a745; }\r\n   </style>\r\n</head>\r\n<body>\r\n   <div class=\"container\">\r\n       <div class=\"header\">\r\n           <h1>Production Violations Report</h1>\r\n           <p>Status: <span class=\"status-${report.productionReadiness}\">${report.productionReadiness}</span></p>\r\n           <p>Generated: ${report.timestamp}</p>\r\n           <p>Total Violations: ${report.violations.total}</p>\r\n           <p>Critical Blockers: ${report.blockers}</p>\r\n       </div>\r\n       \r\n       <h2>Violation Summary</h2>\r\n       <ul>\r\n           <li>Critical: ${report.violations.byCategory.CRITICAL}</li>\r\n           <li>High: ${report.violations.byCategory.HIGH}</li>\r\n           <li>Medium: ${report.violations.byCategory.MEDIUM}</li>\r\n           <li>Low: ${report.violations.byCategory.LOW}</li>\r\n       </ul>\r\n       \r\n       <h2>Recommendations</h2>\r\n       ${report.recommendations.map(rec => `<p>💡 ${rec}</p>`).join('')}\r\n   </div>\r\n</body>\r\n</html>`;\r\n   const htmlPath: string = path.join(this.reportDir, `production-violations-${this.timestamp}.html`);\r\n   fs.writeFileSync(htmlPath, htmlContent);\r\n }\r\n\r\n /**\r\n  * Get color for readiness status\r\n  */\r\n getReadinessColor(status: string): string {\r\n   const colors: { [key: string]: string } = {\r\n     READY: '#28a745',\r\n     NEEDS_IMPROVEMENT: '#ffc107',\r\n     NEEDS_ATTENTION: '#fd7e14',\r\n     NOT_READY: '#dc3545'\r\n   };\r\n   return colors[status] || '#6c757d';\r\n }\r\n\r\n /**\r\n  * Run complete production violations analysis\r\n  */\r\n async analyze(): Promise<ProductionReport> {\r\n   console.log('🚀 Starting production violations analysis...');\r\n   console.log('📁 Project:', this.projectRoot);\r\n   console.log('');\r\n   const report: ProductionReport = await this.generateProductionReport();\r\n   \r\n   console.log('');\r\n   console.log('🎯 Production Readiness Analysis:');\r\n   console.log('📊 Overall Status:', report.productionReadiness);\r\n   console.log('🚨 Critical Violations:', report.violations.byCategory.CRITICAL);\r\n   console.log('⚠️  High Violations:', report.violations.byCategory.HIGH);\r\n   console.log('📋 Total Violations:', report.violations.total);\r\n   console.log('🚫 Production Blockers:', report.blockers);\r\n   console.log('');\r\n   \r\n   if (report.blockers > 0) {\r\n     console.log('❌ PRODUCTION DEPLOYMENT BLOCKED');\r\n     console.log('🔧 Fix critical violations before deployment');\r\n   } else if (report.productionReadiness === 'READY') {\r\n     console.log('✅ PRODUCTION READY');\r\n   } else {\r\n     console.log('⚠️  PRODUCTION NEEDS ATTENTION');\r\n   }\r\n   \r\n   console.log('');\r\n   console.log('✅ Task 41.4 - Identify and Categorize Production Violations: COMPLETED');\r\n   \r\n   return report;\r\n }\r\n}\r\n\r\n// Run analysis if called directly\r\nif (require.main === module) {\r\n const analyzer = new ProductionViolationsAnalyzer();\r\n analyzer.analyze().catch(console.error);\r\n}\r\n\r\nexport default ProductionViolationsAnalyzer;","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\monitoring\\validate-documentation.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":48,"column":10,"nodeType":"CallExpression","endLine":48,"endColumn":33},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":53,"column":29,"nodeType":"CallExpression","endLine":53,"endColumn":62},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":118,"column":18,"nodeType":"CallExpression","endLine":118,"endColumn":41}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\n/**\r\n * Documentation Validation Script\r\n * Validates consistency across all project documentation files\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n// Expected values for consistency checking\r\ninterface ExpectedValues {\r\n  version: string;\r\n  lastUpdated: string;\r\n  totalTasks: number;\r\n  completedTasks: number;\r\n  completionPercentage: string;\r\n}\r\n\r\nconst EXPECTED_VALUES: ExpectedValues = {  // check mcp get_tasks actuall tasks etc.\r\n  version: '1.0.0',\r\n  lastUpdated: 'July 3, 2025',\r\n  totalTasks: 37,\r\n  completedTasks: 20,\r\n  completionPercentage: '54%'\r\n};\r\n\r\n// Files to validate\r\nconst DOCS_TO_VALIDATE: string[] = [\r\n  'README.md',\r\n  'PROJECT_STATUS.md', \r\n  'PROJECT_STATUS_UPDATE.md',\r\n  'PRODUCTION_GUIDE.md',\r\n  'CONFIGURATION_GUIDE.md',\r\n  'docs/TASK_STATUS_REPORT.md',\r\n  'docs/DOCUMENTATION_MAINTENANCE.md',\r\n  'packages/backend/tests/README.md',\r\n  'packages/backend/tests/TESTING_GUIDELINES.md'\r\n];\r\n\r\nclass DocumentationValidator {\r\n  private issues: string[] = [];\r\n  private warnings: string[] = [];\r\n\r\n  validateFile(filePath: string): void {\r\n    console.log(`Validating: ${filePath}`);\r\n    \r\n    if (!fs.existsSync(filePath)) {\r\n      this.issues.push(`File not found: ${filePath}`);\r\n      return;\r\n    }\r\n\r\n    const content: string = fs.readFileSync(filePath, 'utf8');\r\n    this.validateContent(filePath, content);\r\n  }\r\n\r\n  private validateContent(filePath: string, content: string): void {\r\n    // Check for version consistency\r\n    const versionMatches: RegExpMatchArray | null = content.match(/Version:?\\s*([^\\s\\n]+)/gi);\r\n    if (versionMatches) {\r\n      versionMatches.forEach(match => {\r\n        if (!match.includes(EXPECTED_VALUES.version)) {\r\n          this.issues.push(`${filePath}: Inconsistent version found: ${match}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Check for date consistency\r\n    const dateMatches: RegExpMatchArray | null = content.match(/Last Updated:?\\s*([^\\n]+)/gi);\r\n    if (dateMatches) {\r\n      dateMatches.forEach(match => {\r\n        if (!match.includes(EXPECTED_VALUES.lastUpdated)) {\r\n          this.issues.push(`${filePath}: Inconsistent date found: ${match}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Check for task completion consistency\r\n    const taskMatches: RegExpMatchArray | null = content.match(/(\\d+)\\s*of\\s*(\\d+)\\s*tasks?/gi);\r\n    if (taskMatches) {\r\n      taskMatches.forEach(match => {\r\n        const numbers: RegExpMatchArray | null = match.match(/(\\d+)/g);\r\n        if (numbers && numbers.length >= 2) {\r\n          const completed: number = parseInt(numbers[0]);\r\n          const total: number = parseInt(numbers[1]);\r\n          \r\n          if (completed !== EXPECTED_VALUES.completedTasks || total !== EXPECTED_VALUES.totalTasks) {\r\n            this.issues.push(`${filePath}: Inconsistent task count: ${match} (expected: ${EXPECTED_VALUES.completedTasks} of ${EXPECTED_VALUES.totalTasks})`);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Check for completion percentage consistency\r\n    const percentMatches: RegExpMatchArray | null = content.match(/(\\d+)%\\s*complet/gi);\r\n    if (percentMatches) {\r\n      percentMatches.forEach(match => {\r\n        if (!match.includes('54%')) {\r\n          this.issues.push(`${filePath}: Inconsistent completion percentage: ${match} (expected: 54%)`);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Check for future dates (warning)\r\n    if (content.includes('2026') || content.includes('January 2025')) {\r\n      this.warnings.push(`${filePath}: Contains future dates that may need review`);\r\n    }\r\n\r\n    // Check for broken links (basic check)\r\n    const linkMatches: RegExpMatchArray | null = content.match(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g);\r\n    if (linkMatches) {\r\n      linkMatches.forEach(link => {\r\n        const urlMatch: RegExpMatchArray | null = link.match(/\\]\\(([^)]+)\\)/);\r\n        if (urlMatch) {\r\n          const url: string = urlMatch[1];\r\n          if (url.startsWith('./') || url.startsWith('../') || !url.startsWith('http')) {\r\n            const linkPath: string = path.resolve(path.dirname(filePath), url);\r\n            if (!fs.existsSync(linkPath)) {\r\n              this.warnings.push(`${filePath}: Potentially broken link: ${url}`);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  generateReport(): boolean {\r\n    console.log('\\n=== DOCUMENTATION VALIDATION REPORT ===\\n');\r\n\r\n    if (this.issues.length === 0 && this.warnings.length === 0) {\r\n      console.log('✅ All documentation appears consistent and valid!');\r\n      return true;\r\n    }\r\n\r\n    if (this.issues.length > 0) {\r\n      console.log(`❌ Found ${this.issues.length} issue(s):`);\r\n      this.issues.forEach(issue => console.log(`  - ${issue}`));\r\n      console.log('');\r\n    }\r\n\r\n    if (this.warnings.length > 0) {\r\n      console.log(`⚠️  Found ${this.warnings.length} warning(s):`);\r\n      this.warnings.forEach(warning => console.log(`  - ${warning}`));\r\n      console.log('');\r\n    }\r\n\r\n    return this.issues.length === 0;\r\n  }\r\n\r\n  validateAll(): boolean {\r\n    console.log('Starting documentation validation...\\n');\r\n    \r\n    DOCS_TO_VALIDATE.forEach(file => {\r\n      this.validateFile(file);\r\n    });\r\n\r\n    return this.generateReport();\r\n  }\r\n}\r\n\r\n// Run validation\r\nconst validator = new DocumentationValidator();\r\nconst isValid: boolean = validator.validateAll();\r\n\r\n// Exit with appropriate code\r\nprocess.exit(isValid ? 0 : 1);","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\orchestrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\fixed-sma-backtest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\backtest\\sma-backtest.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":72,"column":22,"nodeType":"MemberExpression","endLine":72,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SMA Strategy Backtest\r\n * \r\n * This script runs a backtest of the SMA signal processor against synthetic price data\r\n * to validate its performance and signal generation.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport { generateSyntheticCandles, type Candle } from '../../../shared/src/test-utils/data-generators';\r\nimport type { SMASignalConfig } from '../../src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalProcessor } from '../../src/JabbrLabs/signals/sma/sma-signal-processor';\r\n\r\n// Configuration\r\nconst config: SMASignalConfig = {\r\n  fastPeriod: 9,\r\n  slowPeriod: 21,\r\n  minChangePercent: 0.5,\r\n  confidenceThreshold: 0.4,\r\n  priceSource: 'close',\r\n  signalMode: 'crossover',\r\n  useEMA: false\r\n};\r\n\r\n// Main function to run the backtest\r\nasync function runBacktest() {\r\n  console.log('Starting SMA Backtest');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}, Threshold: ${config.confidenceThreshold}`);\r\n  \r\n  // Generate test data using shared utility\r\n  const candles = generateSyntheticCandles({\r\n    count: 200,\r\n    startPrice: 100,\r\n    trend: 'mixed',\r\n    timeframe: '15m'\r\n  });\r\n  \r\n  const processor = new SMASignalProcessor(config);\r\n  \r\n  interface SignalRecord {\r\n    timestamp: number;\r\n    price: number;\r\n    signal: 'buy' | 'sell';\r\n    confidence: number;\r\n    reason: string;\r\n  }\r\n\r\n  interface TradeRecord {\r\n    type: string;\r\n    timestamp: number;\r\n    price: number;\r\n    profit?: number;\r\n    reason?: string;\r\n  }\r\n  \r\n  const signals: SignalRecord[] = [];\r\n  const trades: TradeRecord[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      if (!candle) {continue;} // Skip if candle is undefined\r\n      \r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell' && position.entryPrice !== null) {\r\n          const profit = position.entryPrice - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy' && position.entryPrice !== null) {\r\n          const profit = candle.close - position.entryPrice;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null && position.entryPrice !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    if (lastCandle) {\r\n      let profit = 0;\r\n      \r\n      if (position.side === 'buy') {\r\n        profit = lastCandle.close - position.entryPrice;\r\n        trades.push({\r\n          type: 'Close Long (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      } else if (position.side === 'sell') {\r\n        profit = position.entryPrice - lastCandle.close;\r\n        trades.push({\r\n          type: 'Close Short (End)',\r\n          timestamp: lastCandle.timestamp,\r\n          price: lastCandle.close,\r\n          profit\r\n        });\r\n      }\r\n      \r\n      pnl += profit;\r\n    }\r\n  }\r\n  \r\n  // Log results\r\n  console.log(`Generated ${signals.length} signals and ${trades.length} trades`);\r\n  console.log(`Final P&L: ${pnl.toFixed(2)}`);\r\n  \r\n  // Generate report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      signalCount: signals.length,\r\n      tradeCount: trades.length,\r\n      pnl\r\n    },\r\n    signals,\r\n    trades\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-backtest-results.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Backtest complete. Results saved to sma-backtest-results.json');\r\n}\r\n\r\n// Run the backtest\r\nrunBacktest().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\compare-sma-processors.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":92,"column":22,"nodeType":"MemberExpression","endLine":92,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Compare original and improved SMA signal processors\r\n * \r\n * This script runs both the original and improved SMA signal processors\r\n * on the same data and compares their signal generation.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport { ImprovedSMASignalProcessor } from '../../src/JabbrLabs/signals/sma/improved-sma-signal-processor';\r\nimport type { SMASignalConfig} from '../../src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalOutput } from '../../src/JabbrLabs/signals/sma/models';\r\nimport { SMASignalProcessor } from '../../src/JabbrLabs/signals/sma/sma-signal-processor';\r\nimport type { Candle } from '../../src/JabbrLabs/target-reacher/interfaces';\r\n\r\n// Configuration\r\nconst config: SMASignalConfig = {\r\n  fastPeriod: 9,\r\n  slowPeriod: 21,\r\n  minChangePercent: 0.5,\r\n  confidenceThreshold: 0.4, // Lowered threshold for comparison\r\n  priceSource: 'close',\r\n  signalMode: 'crossover',\r\n  useEMA: false\r\n};\r\n\r\n// Generate synthetic price data for testing\r\nfunction generateSyntheticCandles(options: {\r\n  startPrice: number,\r\n  dataPoints: number,\r\n  volatility: number,\r\n  trendStrength: number,\r\n  trendChangeProbability: number\r\n}): Candle[] {\r\n  const candles: Candle[] = [];\r\n  let currentPrice = options.startPrice;\r\n  let trend = 1; // 1 = up, -1 = down\r\n\r\n  for (let i = 0; i < options.dataPoints; i++) {\r\n    // Potentially change trend\r\n    if (Math.random() < options.trendChangeProbability) {\r\n      trend *= -1;\r\n    }\r\n    \r\n    // Calculate price movement\r\n    const trendMovement = trend * options.trendStrength * currentPrice;\r\n    const randomMovement = (Math.random() * 2 - 1) * options.volatility * currentPrice;\r\n    const movement = trendMovement + randomMovement;\r\n    \r\n    // Calculate candle prices\r\n    const open = currentPrice;\r\n    const close = currentPrice + movement;\r\n    const high = Math.max(open, close) + Math.random() * options.volatility * currentPrice;\r\n    const low = Math.min(open, close) - Math.random() * options.volatility * currentPrice;\r\n    const volume = Math.random() * 100000 + 10000;\r\n    \r\n    // Create candle\r\n    candles.push({\r\n      timestamp: Date.now() + i * 900000, // 15-minute intervals\r\n      open,\r\n      high,\r\n      low,\r\n      close,\r\n      volume\r\n    });\r\n    \r\n    // Update current price for next iteration\r\n    currentPrice = close;\r\n  }\r\n  \r\n  return candles;\r\n}\r\n\r\n// Process signals and execute trades\r\nfunction processAndTrade(processor: SMASignalProcessor | ImprovedSMASignalProcessor, candles: Candle[]) {\r\n  const signals: any[] = [];\r\n  const trades: any[] = [];\r\n  let position: { side: 'buy' | 'sell' | null, entryPrice: number | null } = {\r\n    side: null,\r\n    entryPrice: null\r\n  };\r\n  \r\n  let pnl = 0;\r\n  \r\n  // Process each candle\r\n  for (let i = config.slowPeriod; i < candles.length; i++) {\r\n    const windowCandles = candles.slice(0, i + 1);\r\n    const output = processor.process(windowCandles);\r\n    \r\n    if (output && output.signal !== 0) {\r\n      const candle = candles[i];\r\n      signals.push({\r\n        timestamp: candle.timestamp,\r\n        price: candle.close,\r\n        signal: output.signal > 0 ? 'buy' : 'sell',\r\n        confidence: output.confidence,\r\n        reason: output.reason\r\n      });\r\n      \r\n      // Execute trades based on signals\r\n      if (output.signal > 0 && position.side !== 'buy') {\r\n        // Close existing position if any\r\n        if (position.side === 'sell') {\r\n          const profit = position.entryPrice! - candle.close;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Short',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open long position\r\n        position = { side: 'buy', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Long',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      } else if (output.signal < 0 && position.side !== 'sell') {\r\n        // Close existing position if any\r\n        if (position.side === 'buy') {\r\n          const profit = candle.close - position.entryPrice!;\r\n          pnl += profit;\r\n          trades.push({\r\n            type: 'Close Long',\r\n            timestamp: candle.timestamp,\r\n            price: candle.close,\r\n            profit\r\n          });\r\n        }\r\n        \r\n        // Open short position\r\n        position = { side: 'sell', entryPrice: candle.close };\r\n        trades.push({\r\n          type: 'Open Short',\r\n          timestamp: candle.timestamp,\r\n          price: candle.close,\r\n          reason: output.reason\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Close final position at the end of the test\r\n  if (position.side !== null) {\r\n    const lastCandle = candles[candles.length - 1];\r\n    let profit = 0;\r\n    \r\n    if (position.side === 'buy') {\r\n      profit = lastCandle.close - position.entryPrice!;\r\n      trades.push({\r\n        type: 'Close Long (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    } else {\r\n      profit = position.entryPrice! - lastCandle.close;\r\n      trades.push({\r\n        type: 'Close Short (End)',\r\n        timestamp: lastCandle.timestamp,\r\n        price: lastCandle.close,\r\n        profit\r\n      });\r\n    }\r\n    \r\n    pnl += profit;\r\n  }\r\n  \r\n  return {\r\n    signals,\r\n    trades,\r\n    pnl\r\n  };\r\n}\r\n\r\n// Main test function\r\nasync function runComparisonTest() {\r\n  console.log('Starting SMA Signal Processor Comparison Test');\r\n  console.log(`Configuration: Fast Period: ${config.fastPeriod}, Slow Period: ${config.slowPeriod}`);\r\n  \r\n  // Generate test data\r\n  const candles = generateSyntheticCandles({\r\n    startPrice: 100,\r\n    dataPoints: 200,\r\n    volatility: 0.01,\r\n    trendStrength: 0.005,\r\n    trendChangeProbability: 0.05\r\n  });\r\n  \r\n  // Create processors\r\n  const originalProcessor = new SMASignalProcessor(config);\r\n  const improvedProcessor = new ImprovedSMASignalProcessor(config);\r\n  \r\n  // Process with both implementations\r\n  console.log('\\nRunning Original SMA Signal Processor...');\r\n  const originalResults = processAndTrade(originalProcessor, candles);\r\n  \r\n  console.log('\\nRunning Improved SMA Signal Processor...');\r\n  const improvedResults = processAndTrade(improvedProcessor, candles);\r\n  \r\n  // Log comparison results\r\n  console.log('\\n===== COMPARISON RESULTS =====');\r\n  console.log(`Original: ${originalResults.signals.length} signals, ${originalResults.trades.length} trades, P&L: ${originalResults.pnl.toFixed(2)}`);\r\n  console.log(`Improved: ${improvedResults.signals.length} signals, ${improvedResults.trades.length} trades, P&L: ${improvedResults.pnl.toFixed(2)}`);\r\n  \r\n  // Generate comparison report\r\n  const report = {\r\n    config,\r\n    summary: {\r\n      original: {\r\n        signalCount: originalResults.signals.length,\r\n        tradeCount: originalResults.trades.length,\r\n        pnl: originalResults.pnl\r\n      },\r\n      improved: {\r\n        signalCount: improvedResults.signals.length,\r\n        tradeCount: improvedResults.trades.length,\r\n        pnl: improvedResults.pnl\r\n      },\r\n      comparison: {\r\n        signalDifference: improvedResults.signals.length - originalResults.signals.length,\r\n        pnlDifference: improvedResults.pnl - originalResults.pnl\r\n      }\r\n    },\r\n    details: {\r\n      original: {\r\n        signals: originalResults.signals,\r\n        trades: originalResults.trades\r\n      },\r\n      improved: {\r\n        signals: improvedResults.signals,\r\n        trades: improvedResults.trades\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Write report to file\r\n  fs.writeFileSync(\r\n    path.join(__dirname, 'sma-comparison-report.json'),\r\n    JSON.stringify(report, null, 2)\r\n  );\r\n  \r\n  console.log('Test complete. Comparison report saved to sma-comparison-report.json');\r\n}\r\n\r\nrunComparisonTest().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\debug-sma-signals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\debug\\simple-sma-debug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\performance\\performance-analyzer.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":110,"column":22,"nodeType":"MemberExpression","endLine":110,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":125,"column":71,"nodeType":"MemberExpression","endLine":125,"endColumn":80}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\n/**\r\n * Performance Analysis Script\r\n * \r\n * Runs comprehensive performance tests and analysis on the trading bot platform\r\n */\r\n\r\nimport * as path from 'path';\r\nimport * as fs from 'fs/promises';\r\nimport { performanceProfiler } from '../../src/utils/performance-profiler';\r\nimport SystemMonitorService from '../../src/services/system-monitor.service';\r\n\r\n// Import key components for testing\r\nimport { IndicatorService } from '../../src/services/indicator.service';\r\n\r\ninterface PerformanceTestSuite {\r\n  name: string;\r\n  description: string;\r\n  tests: PerformanceTest[];\r\n}\r\n\r\ninterface PerformanceTest {\r\n  name: string;\r\n  category: 'api' | 'database' | 'strategy' | 'websocket' | 'calculation' | 'other';\r\n  testFunction: () => Promise<any>;\r\n  iterations?: number;\r\n  warmupIterations?: number;\r\n}\r\n\r\nclass PerformanceAnalyzer {\r\n  private systemMonitor: SystemMonitorService;\r\n  private testResults: any[] = [];\r\n\r\n  constructor() {\r\n    this.systemMonitor = new SystemMonitorService({\r\n      collectInterval: 1000, // 1 second for detailed monitoring\r\n      enableAlerts: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Run all performance tests\r\n   */\r\n  async runAnalysis(): Promise<void> {\r\n    console.log('🚀 Starting Performance Analysis...\\n');\r\n    \r\n    // Start system monitoring\r\n    this.systemMonitor.start();\r\n    \r\n    try {\r\n      // Define test suites\r\n      const testSuites: PerformanceTestSuite[] = [\r\n        this.createCalculationTests(),\r\n        this.createIndicatorTests(),\r\n        this.createSignalProcessingTests(),\r\n        this.createMemoryTests()\r\n      ];\r\n\r\n      // Run each test suite\r\n      for (const suite of testSuites) {\r\n        await this.runTestSuite(suite);\r\n      }\r\n\r\n      // Generate comprehensive report\r\n      await this.generateReport();\r\n\r\n    } finally {\r\n      this.systemMonitor.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create calculation performance tests\r\n   */\r\n  private createCalculationTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Mathematical Calculations',\r\n      description: 'Tests performance of mathematical operations used in trading algorithms',\r\n      tests: [\r\n        {\r\n          name: 'Simple Moving Average Calculation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            \r\n            // Calculate SMA\r\n            const sma: number[] = [];\r\n            for (let i = period - 1; i < data.length; i++) {\r\n              const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\r\n              sma.push(sum / period);\r\n            }\r\n            \r\n            return sma.length;\r\n          },\r\n          iterations: 1000\r\n        },\r\n        {\r\n          name: 'Exponential Moving Average Calculation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const data = Array.from({ length: 1000 }, (_, i) => i + Math.random());\r\n            const period = 20;\r\n            const multiplier = 2 / (period + 1);\r\n            \r\n            // Calculate EMA\r\n            let ema = data[0];\r\n            for (let i = 1; i < data.length; i++) {\r\n              ema = (data[i] * multiplier) + (ema * (1 - multiplier));\r\n            }\r\n            \r\n            return ema;\r\n          },\r\n          iterations: 1000\r\n        },\r\n        {\r\n          name: 'RSI Calculation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const prices = Array.from({ length: 100 }, () => 100 + Math.random() * 50);\r\n            const period = 14;\r\n            \r\n            // Calculate price changes\r\n            const changes = prices.slice(1).map((price, i) => price - prices[i]);\r\n            \r\n            // Separate gains and losses\r\n            const gains = changes.map(change => change > 0 ? change : 0);\r\n            const losses = changes.map(change => change < 0 ? -change : 0);\r\n            \r\n            // Calculate average gain and loss\r\n            const avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;\r\n            const avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;\r\n            \r\n            // Calculate RS and RSI\r\n            const rs = avgGain / avgLoss;\r\n            const rsi = 100 - (100 / (1 + rs));\r\n            \r\n            return rsi;\r\n          },\r\n          iterations: 500\r\n        },\r\n        {\r\n          name: 'Large Array Processing',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const size = 100000;\r\n            const data = Array.from({ length: size }, (_, i) => Math.random() * 100);\r\n            \r\n            // Perform multiple operations\r\n            const filtered = data.filter(x => x > 50);\r\n            const mapped = filtered.map(x => x * 2);\r\n            const reduced = mapped.reduce((sum, x) => sum + x, 0);\r\n            \r\n            return reduced;\r\n          },\r\n          iterations: 100\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create indicator service tests\r\n   */\r\n  private createIndicatorTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Indicator Service Performance',\r\n      description: 'Tests performance of the indicator calculation service',\r\n      tests: [\r\n        {\r\n          name: 'Multiple Indicator Calculations',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const indicatorService = new IndicatorService();\r\n            const prices = Array.from({ length: 200 }, () => ({\r\n              timestamp: Date.now(),\r\n              open: 100 + Math.random() * 10,\r\n              high: 105 + Math.random() * 10,\r\n              low: 95 + Math.random() * 10,\r\n              close: 100 + Math.random() * 10,\r\n              volume: 1000 + Math.random() * 500\r\n            }));\r\n\r\n            // Calculate multiple indicators\r\n            const sma20 = indicatorService.calculateSMA(prices.map(p => p.close), 20);\r\n            const sma50 = indicatorService.calculateSMA(prices.map(p => p.close), 50);\r\n            const ema12 = indicatorService.calculateEMA(prices.map(p => p.close), 12);\r\n            const rsi = indicatorService.calculateRSI(prices.map(p => p.close), 14);\r\n\r\n            return { sma20: sma20.length, sma50: sma50.length, ema12: ema12.length, rsi: rsi.length };\r\n          },\r\n          iterations: 200\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create signal processing tests\r\n   */\r\n  private createSignalProcessingTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Signal Processing Performance',\r\n      description: 'Tests performance of signal processing algorithms',\r\n      tests: [\r\n        {\r\n          name: 'SMA Signal Generation',\r\n          category: 'calculation',\r\n          testFunction: async () => {\r\n            const prices = Array.from({ length: 500 }, () => Math.random() * 100);\r\n            const signals = [];\r\n            \r\n            for (let i = 20; i < prices.length; i++) {\r\n              const sma20 = prices.slice(i - 20, i).reduce((a, b) => a + b) / 20;\r\n              const sma50 = i >= 50 ? prices.slice(i - 50, i).reduce((a, b) => a + b) / 50 : 0;\r\n              \r\n              if (sma20 > sma50) {\r\n                signals.push('BUY');\r\n              } else if (sma20 < sma50) {\r\n                signals.push('SELL');\r\n              }\r\n            }\r\n            \r\n            return signals.length;\r\n          },\r\n          iterations: 100\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create memory usage tests\r\n   */\r\n  private createMemoryTests(): PerformanceTestSuite {\r\n    return {\r\n      name: 'Memory Usage Tests',\r\n      description: 'Tests memory usage and garbage collection performance',\r\n      tests: [\r\n        {\r\n          name: 'Large Array Processing',\r\n          category: 'other',\r\n          testFunction: async () => {\r\n            const initialMemory = process.memoryUsage();\r\n            const data = Array.from({ length: 100000 }, () => Math.random());\r\n            const processed = data.map(x => x * 2).filter(x => x > 1);\r\n            const finalMemory = process.memoryUsage();\r\n            \r\n            return {\r\n              processed: processed.length,\r\n              memoryDelta: finalMemory.heapUsed - initialMemory.heapUsed\r\n            };\r\n          },\r\n          iterations: 10\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Run a test suite\r\n   */\r\n  private async runTestSuite(suite: PerformanceTestSuite): Promise<void> {\r\n    console.log(`\\n📊 Running ${suite.name}`);\r\n    console.log(`   ${suite.description}\\n`);\r\n\r\n    for (const test of suite.tests) {\r\n      await this.runTest(test);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run an individual test\r\n   */\r\n  private async runTest(test: PerformanceTest): Promise<void> {\r\n    const iterations = test.iterations || 100;\r\n    const warmupIterations = test.warmupIterations || 10;\r\n    \r\n    console.log(`   🧪 ${test.name}`);\r\n    \r\n    // Warmup\r\n    for (let i = 0; i < warmupIterations; i++) {\r\n      await test.testFunction();\r\n    }\r\n    \r\n    // Actual test\r\n    const startTime = performanceProfiler.now();\r\n    const results = [];\r\n    \r\n    for (let i = 0; i < iterations; i++) {\r\n      const testStart = performanceProfiler.now();\r\n      const result = await test.testFunction();\r\n      const testEnd = performanceProfiler.now();\r\n      \r\n      results.push({\r\n        duration: testEnd - testStart,\r\n        result\r\n      });\r\n    }\r\n    \r\n    const endTime = performanceProfiler.now();\r\n    const totalDuration = endTime - startTime;\r\n    const avgDuration = totalDuration / iterations;\r\n    \r\n    this.testResults.push({\r\n      suiteName: test.category,\r\n      testName: test.name,\r\n      iterations,\r\n      totalDuration,\r\n      avgDuration,\r\n      minDuration: Math.min(...results.map(r => r.duration)),\r\n      maxDuration: Math.max(...results.map(r => r.duration)),\r\n      results\r\n    });\r\n    \r\n    console.log(`      ⏱️  Average: ${avgDuration.toFixed(2)}ms`);\r\n    console.log(`      📈 Total: ${totalDuration.toFixed(2)}ms`);\r\n  }\r\n\r\n  /**\r\n   * Generate comprehensive report\r\n   */\r\n  private async generateReport(): Promise<void> {\r\n    console.log('\\n📊 Generating Performance Report...\\n');\r\n    \r\n    const report = {\r\n      timestamp: new Date().toISOString(),\r\n      systemInfo: {\r\n        nodeVersion: process.version,\r\n        platform: process.platform,\r\n        arch: process.arch,\r\n        cpus: require('os').cpus().length,\r\n        memory: process.memoryUsage()\r\n      },\r\n      testResults: this.testResults,\r\n      summary: this.generateSummary()\r\n    };\r\n    \r\n    // Save report\r\n    const reportPath = path.join(__dirname, '../../reports/performance-report.json');\r\n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\r\n    \r\n    console.log(`📋 Performance report saved to: ${reportPath}`);\r\n    console.log('\\n📊 Performance Summary:');\r\n    console.log(this.generateSummary());\r\n  }\r\n\r\n  /**\r\n   * Generate performance summary\r\n   */\r\n  private generateSummary(): any {\r\n    const categories = {};\r\n    \r\n    for (const result of this.testResults) {\r\n      if (!categories[result.suiteName]) {\r\n        categories[result.suiteName] = {\r\n          testCount: 0,\r\n          totalAvgDuration: 0,\r\n          tests: []\r\n        };\r\n      }\r\n      \r\n      categories[result.suiteName].testCount++;\r\n      categories[result.suiteName].totalAvgDuration += result.avgDuration;\r\n      categories[result.suiteName].tests.push({\r\n        name: result.testName,\r\n        avgDuration: result.avgDuration,\r\n        iterations: result.iterations\r\n      });\r\n    }\r\n    \r\n    return categories;\r\n  }\r\n}\r\n\r\n// Run analysis if called directly\r\nif (require.main === module) {\r\n  const analyzer = new PerformanceAnalyzer();\r\n  analyzer.runAnalysis().catch(console.error);\r\n}\r\n\r\nexport default PerformanceAnalyzer;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\bot-trading-cycle-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\database-health-check.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\performance-monitoring-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\production-readiness-validation.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":65,"column":13,"nodeType":"CallExpression","endLine":65,"endColumn":31},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":91,"column":11,"nodeType":"CallExpression","endLine":91,"endColumn":33},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":92,"column":28,"nodeType":"CallExpression","endLine":92,"endColumn":60},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":117,"column":11,"nodeType":"CallExpression","endLine":117,"endColumn":40},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":133,"column":11,"nodeType":"CallExpression","endLine":133,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":159,"column":11,"nodeType":"CallExpression","endLine":159,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":185,"column":11,"nodeType":"CallExpression","endLine":185,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":211,"column":11,"nodeType":"CallExpression","endLine":211,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":239,"column":27,"nodeType":"CallExpression","endLine":239,"endColumn":83},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":270,"column":11,"nodeType":"CallExpression","endLine":270,"endColumn":36},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":275,"column":11,"nodeType":"CallExpression","endLine":275,"endColumn":33},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":290,"column":33,"nodeType":"CallExpression","endLine":290,"endColumn":49},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":312,"column":10,"nodeType":"CallExpression","endLine":312,"endColumn":28},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":314,"column":19,"nodeType":"CallExpression","endLine":314,"endColumn":38},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":318,"column":20,"nodeType":"CallExpression","endLine":318,"endColumn":41},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":333,"column":12,"nodeType":"CallExpression","endLine":333,"endColumn":42},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":335,"column":38,"nodeType":"CallExpression","endLine":335,"endColumn":78},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":350,"column":12,"nodeType":"CallExpression","endLine":350,"endColumn":40},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":352,"column":32,"nodeType":"CallExpression","endLine":352,"endColumn":70},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":368,"column":13,"nodeType":"CallExpression","endLine":368,"endColumn":37},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":369,"column":25,"nodeType":"CallExpression","endLine":369,"endColumn":50}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { execSync } from 'child_process';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\ninterface ValidationResult {\r\n  component: string;\r\n  status: 'pass' | 'fail' | 'warning';\r\n  message: string;\r\n  details?: any;\r\n}\r\n\r\ninterface ProductionReadinessReport {\r\n  overall: 'ready' | 'needs-attention' | 'not-ready';\r\n  validations: ValidationResult[];\r\n  summary: {\r\n    passed: number;\r\n    failed: number;\r\n    warnings: number;\r\n    total: number;\r\n  };\r\n  recommendations: string[];\r\n}\r\n\r\nclass ProductionReadinessValidator {\r\n  private results: ValidationResult[] = [];\r\n  private readonly projectRoot: string;\r\n\r\n  constructor() {\r\n    this.projectRoot = process.cwd();\r\n  }\r\n\r\n  private addResult(component: string, status: 'pass' | 'fail' | 'warning', message: string, details?: any): void {\r\n    this.results.push({ component, status, message, details });\r\n  }\r\n\r\n  private async validateTypeScriptCompilation(): Promise<void> {\r\n    console.log('1. Validating TypeScript Compilation...');\r\n    try {\r\n      // Check TypeScript compilation without building (faster for health check)\r\n      execSync('npx tsc --noEmit', { \r\n        stdio: 'pipe',\r\n        cwd: this.projectRoot,\r\n        timeout: 30000\r\n      });\r\n      this.addResult('TypeScript Compilation', 'pass', 'All TypeScript files compile successfully');\r\n    } catch (error: any) {\r\n      this.addResult('TypeScript Compilation', 'fail', 'TypeScript compilation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateTestSuite(): Promise<void> {\r\n    console.log('2. Validating Test Suite...');\r\n    try {\r\n      // Check if test files exist\r\n      const testDirs = [\r\n        path.join(this.projectRoot, 'packages/backend/tests'),\r\n        path.join(this.projectRoot, 'packages/frontend/tests'),\r\n        path.join(this.projectRoot, 'packages/shared/tests')\r\n      ];\r\n\r\n      const testFiles: string[] = [];\r\n      testDirs.forEach(dir => {\r\n        if (fs.existsSync(dir)) {\r\n          const files = this.getFilesRecursively(dir, '.test.ts');\r\n          testFiles.push(...files);\r\n        }\r\n      });\r\n\r\n      if (testFiles.length > 0) {\r\n        this.addResult('Test Suite', 'pass', `Found ${testFiles.length} test files`, {\r\n          testFiles: testFiles.slice(0, 10) // Show first 10 for brevity\r\n        });\r\n      } else {\r\n        this.addResult('Test Suite', 'warning', 'No test files found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Test Suite', 'fail', 'Test suite validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateEnvironmentConfiguration(): Promise<void> {\r\n    console.log('3. Validating Environment Configuration...');\r\n    try {\r\n      const envFile = path.join(this.projectRoot, '.env');\r\n      const envExampleFile = path.join(this.projectRoot, '.env.example');\r\n\r\n      if (fs.existsSync(envFile)) {\r\n        const envContent = fs.readFileSync(envFile, 'utf8');\r\n        const requiredVars = [\r\n          'NODE_ENV',\r\n          'DATABASE_URL',\r\n          'BYBIT_API_KEY',\r\n          'BYBIT_SECRET',\r\n          'REDIS_URL'\r\n        ];\r\n\r\n        const missingVars = requiredVars.filter(varName => \r\n          !envContent.includes(`${varName}=`) || envContent.includes(`${varName}=`)\r\n        );\r\n\r\n        if (missingVars.length === 0) {\r\n          this.addResult('Environment Configuration', 'pass', 'All required environment variables are configured');\r\n        } else {\r\n          this.addResult('Environment Configuration', 'warning', 'Some environment variables may need attention', {\r\n            requiredVars,\r\n            note: 'Please verify all environment variables are properly set'\r\n          });\r\n        }\r\n      } else {\r\n        this.addResult('Environment Configuration', 'fail', '.env file not found');\r\n      }\r\n\r\n      if (fs.existsSync(envExampleFile)) {\r\n        this.addResult('Environment Documentation', 'pass', '.env.example file exists for reference');\r\n      } else {\r\n        this.addResult('Environment Documentation', 'warning', '.env.example file not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Environment Configuration', 'fail', 'Environment validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateDatabaseConnectivity(): Promise<void> {\r\n    console.log('4. Validating Database Connectivity...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/database-health-check.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('Database Health Check Passed')) {\r\n          this.addResult('Database Connectivity', 'pass', 'Database health check passed');\r\n        } else {\r\n          this.addResult('Database Connectivity', 'warning', 'Database health check completed with warnings');\r\n        }\r\n      } else {\r\n        this.addResult('Database Connectivity', 'warning', 'Database health check script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Database Connectivity', 'fail', 'Database connectivity validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateSignalProcessing(): Promise<void> {\r\n    console.log('5. Validating Signal Processing...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/signal-processing-validation.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('All Signal Processing Validation Tests Passed')) {\r\n          this.addResult('Signal Processing', 'pass', 'Signal processing validation passed');\r\n        } else {\r\n          this.addResult('Signal Processing', 'warning', 'Signal processing validation completed with issues');\r\n        }\r\n      } else {\r\n        this.addResult('Signal Processing', 'warning', 'Signal processing validation script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Signal Processing', 'fail', 'Signal processing validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateTradingIntegration(): Promise<void> {\r\n    console.log('6. Validating Trading Integration...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/bot-trading-cycle-validation.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('All Bot Trading Cycle Validation Tests Passed')) {\r\n          this.addResult('Trading Integration', 'pass', 'Trading cycle validation passed');\r\n        } else {\r\n          this.addResult('Trading Integration', 'warning', 'Trading cycle validation completed with issues');\r\n        }\r\n      } else {\r\n        this.addResult('Trading Integration', 'warning', 'Trading cycle validation script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Trading Integration', 'fail', 'Trading integration validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validatePerformanceMonitoring(): Promise<void> {\r\n    console.log('7. Validating Performance Monitoring...');\r\n    try {\r\n      const scriptPath = path.join(this.projectRoot, 'dist/scripts/performance-monitoring-validation.js');\r\n      if (fs.existsSync(scriptPath)) {\r\n        const output = execSync(`node \"${scriptPath}\"`, { \r\n          encoding: 'utf8',\r\n          timeout: 30000,\r\n          cwd: this.projectRoot\r\n        });\r\n        \r\n        if (output.includes('All Performance Monitoring and Metrics Validation Tests Passed')) {\r\n          this.addResult('Performance Monitoring', 'pass', 'Performance monitoring validation passed');\r\n        } else {\r\n          this.addResult('Performance Monitoring', 'warning', 'Performance monitoring validation completed with issues');\r\n        }\r\n      } else {\r\n        this.addResult('Performance Monitoring', 'warning', 'Performance monitoring validation script not found');\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Performance Monitoring', 'fail', 'Performance monitoring validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateSecurityConfiguration(): Promise<void> {\r\n    console.log('8. Validating Security Configuration...');\r\n    try {\r\n      // Check for security-related files and configurations\r\n      const securityChecks = {\r\n        packageJsonSecurity: this.checkPackageJsonSecurity(),\r\n        gitignorePresent: fs.existsSync(path.join(this.projectRoot, '.gitignore')),\r\n        envInGitignore: this.checkEnvInGitignore(),\r\n        httpsConfiguration: this.checkHttpsConfiguration()\r\n      };\r\n\r\n      const passedChecks = Object.values(securityChecks).filter(Boolean).length;\r\n      const totalChecks = Object.keys(securityChecks).length;\r\n\r\n      if (passedChecks === totalChecks) {\r\n        this.addResult('Security Configuration', 'pass', 'All security checks passed');\r\n      } else if (passedChecks >= totalChecks * 0.8) {\r\n        this.addResult('Security Configuration', 'warning', `${passedChecks}/${totalChecks} security checks passed`);\r\n      } else {\r\n        this.addResult('Security Configuration', 'fail', `Only ${passedChecks}/${totalChecks} security checks passed`);\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Security Configuration', 'fail', 'Security validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private async validateDocumentation(): Promise<void> {\r\n    console.log('9. Validating Documentation...');\r\n    try {\r\n      const docsDir = path.join(this.projectRoot, 'docs');\r\n      const readmeFile = path.join(this.projectRoot, 'README.md');\r\n      \r\n      let docScore = 0;\r\n      const checks: string[] = [];\r\n\r\n      if (fs.existsSync(readmeFile)) {\r\n        docScore++;\r\n        checks.push('README.md present');\r\n      }\r\n\r\n      if (fs.existsSync(docsDir)) {\r\n        const docFiles = this.getFilesRecursively(docsDir, '.md');\r\n        if (docFiles.length > 0) {\r\n          docScore++;\r\n          checks.push(`${docFiles.length} documentation files found`);\r\n        }\r\n      }\r\n\r\n      // Check for API documentation\r\n      const apiDocPaths = [\r\n        path.join(this.projectRoot, 'docs/api'),\r\n        path.join(this.projectRoot, 'docs/API.md'),\r\n        path.join(docsDir, 'api.md')\r\n      ];\r\n\r\n      if (apiDocPaths.some(p => fs.existsSync(p))) {\r\n        docScore++;\r\n        checks.push('API documentation present');\r\n      }\r\n\r\n      if (docScore >= 2) {\r\n        this.addResult('Documentation', 'pass', 'Documentation is adequate', { checks });\r\n      } else if (docScore === 1) {\r\n        this.addResult('Documentation', 'warning', 'Documentation needs improvement', { checks });\r\n      } else {\r\n        this.addResult('Documentation', 'fail', 'Documentation is insufficient', { checks });\r\n      }\r\n    } catch (error: any) {\r\n      this.addResult('Documentation', 'fail', 'Documentation validation failed', {\r\n        error: error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private getFilesRecursively(dir: string, extension: string): string[] {\r\n    const files: string[] = [];\r\n    \r\n    if (!fs.existsSync(dir)) return files;\r\n    \r\n    const items = fs.readdirSync(dir);\r\n    \r\n    for (const item of items) {\r\n      const fullPath = path.join(dir, item);\r\n      const stat = fs.statSync(fullPath);\r\n      \r\n      if (stat.isDirectory()) {\r\n        files.push(...this.getFilesRecursively(fullPath, extension));\r\n      } else if (item.endsWith(extension)) {\r\n        files.push(fullPath);\r\n      }\r\n    }\r\n    \r\n    return files;\r\n  }\r\n\r\n  private checkPackageJsonSecurity(): boolean {\r\n    try {\r\n      const packageJsonPath = path.join(this.projectRoot, 'package.json');\r\n      if (!fs.existsSync(packageJsonPath)) return false;\r\n      \r\n      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\r\n      \r\n      // Check for security-related scripts or dependencies\r\n      const hasSecurityDeps = packageJson.devDependencies && \r\n        (packageJson.devDependencies['@types/node'] || packageJson.devDependencies['typescript']);\r\n      \r\n      return Boolean(hasSecurityDeps);\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private checkEnvInGitignore(): boolean {\r\n    try {\r\n      const gitignorePath = path.join(this.projectRoot, '.gitignore');\r\n      if (!fs.existsSync(gitignorePath)) return false;\r\n      \r\n      const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');\r\n      return gitignoreContent.includes('.env') || gitignoreContent.includes('*.env');\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private checkHttpsConfiguration(): boolean {\r\n    // This is a simplified check - in a real environment, you'd check actual server configuration\r\n    try {\r\n      const configFiles = [\r\n        path.join(this.projectRoot, 'packages/backend/src/config'),\r\n        path.join(this.projectRoot, 'config')\r\n      ];\r\n      \r\n      for (const configDir of configFiles) {\r\n        if (fs.existsSync(configDir)) {\r\n          const files = fs.readdirSync(configDir);\r\n          const hasServerConfig = files.some(file => \r\n            file.includes('server') || file.includes('express') || file.includes('app')\r\n          );\r\n          if (hasServerConfig) return true;\r\n        }\r\n      }\r\n      \r\n      return true; // Assume configured if config structure exists\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private generateRecommendations(): string[] {\r\n    const recommendations: string[] = [];\r\n    \r\n    const failures = this.results.filter(r => r.status === 'fail');\r\n    const warnings = this.results.filter(r => r.status === 'warning');\r\n    \r\n    if (failures.length > 0) {\r\n      recommendations.push('🔴 Address all failed validations before production deployment');\r\n      failures.forEach(f => {\r\n        recommendations.push(`   - Fix ${f.component}: ${f.message}`);\r\n      });\r\n    }\r\n    \r\n    if (warnings.length > 0) {\r\n      recommendations.push('🟡 Review and address warning items for optimal production readiness');\r\n      warnings.forEach(w => {\r\n        recommendations.push(`   - Review ${w.component}: ${w.message}`);\r\n      });\r\n    }\r\n    \r\n    // General recommendations\r\n    recommendations.push('📊 Set up monitoring and alerting for production environment');\r\n    recommendations.push('🔄 Implement automated backup and recovery procedures');\r\n    recommendations.push('📈 Configure performance monitoring and metrics collection');\r\n    recommendations.push('🔒 Review and audit security configurations regularly');\r\n    recommendations.push('📚 Keep documentation updated with any changes');\r\n    \r\n    return recommendations;\r\n  }\r\n\r\n  public async runFullValidation(): Promise<ProductionReadinessReport> {\r\n    console.log('🔍 Starting Production Readiness Validation...\\n');\r\n\r\n    // Run all validations\r\n    await this.validateTypeScriptCompilation();\r\n    await this.validateTestSuite();\r\n    await this.validateEnvironmentConfiguration();\r\n    await this.validateDatabaseConnectivity();\r\n    await this.validateSignalProcessing();\r\n    await this.validateTradingIntegration();\r\n    await this.validatePerformanceMonitoring();\r\n    await this.validateSecurityConfiguration();\r\n    await this.validateDocumentation();\r\n\r\n    // Calculate summary\r\n    const passed = this.results.filter(r => r.status === 'pass').length;\r\n    const failed = this.results.filter(r => r.status === 'fail').length;\r\n    const warnings = this.results.filter(r => r.status === 'warning').length;\r\n    const total = this.results.length;\r\n\r\n    // Determine overall status\r\n    let overall: 'ready' | 'needs-attention' | 'not-ready';\r\n    if (failed === 0 && warnings <= 2) {\r\n      overall = 'ready';\r\n    } else if (failed === 0) {\r\n      overall = 'needs-attention';\r\n    } else {\r\n      overall = 'not-ready';\r\n    }\r\n\r\n    const report: ProductionReadinessReport = {\r\n      overall,\r\n      validations: this.results,\r\n      summary: { passed, failed, warnings, total },\r\n      recommendations: this.generateRecommendations()\r\n    };\r\n\r\n    this.printReport(report);\r\n    return report;\r\n  }\r\n\r\n  private printReport(report: ProductionReadinessReport): void {\r\n    console.log('\\n' + '='.repeat(80));\r\n    console.log('📋 PRODUCTION READINESS VALIDATION REPORT');\r\n    console.log('='.repeat(80));\r\n\r\n    // Overall status\r\n    const statusEmoji = {\r\n      'ready': '✅',\r\n      'needs-attention': '⚠️',\r\n      'not-ready': '❌'\r\n    };\r\n\r\n    console.log(`\\n🎯 Overall Status: ${statusEmoji[report.overall]} ${report.overall.toUpperCase()}`);\r\n\r\n    // Summary\r\n    console.log(`\\n📊 Summary:`);\r\n    console.log(`   ✅ Passed: ${report.summary.passed}`);\r\n    console.log(`   ⚠️  Warnings: ${report.summary.warnings}`);\r\n    console.log(`   ❌ Failed: ${report.summary.failed}`);\r\n    console.log(`   📝 Total: ${report.summary.total}`);\r\n\r\n    // Detailed results\r\n    console.log(`\\n📋 Detailed Results:`);\r\n    report.validations.forEach(result => {\r\n      const emoji = result.status === 'pass' ? '✅' : result.status === 'warning' ? '⚠️' : '❌';\r\n      console.log(`   ${emoji} ${result.component}: ${result.message}`);\r\n    });\r\n\r\n    // Recommendations\r\n    console.log(`\\n💡 Recommendations:`);\r\n    report.recommendations.forEach(rec => {\r\n      console.log(`   ${rec}`);\r\n    });\r\n\r\n    console.log('\\n' + '='.repeat(80));\r\n  }\r\n}\r\n\r\n// Main execution\r\nasync function main(): Promise<void> {\r\n  const validator = new ProductionReadinessValidator();\r\n  const report = await validator.runFullValidation();\r\n  \r\n  // Exit with appropriate code\r\n  process.exit(report.overall === 'not-ready' ? 1 : 0);\r\n}\r\n\r\nif (require.main === module) {\r\n  main().catch(error => {\r\n    console.error('❌ Production readiness validation failed:', error);\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nexport { ProductionReadinessValidator };\r\nexport type { ProductionReadinessReport, ValidationResult };\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\signal-processing-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection-fixed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\testing\\validation\\test-db-connection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\scripts\\utilities\\naming-validator.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":63,"column":10,"nodeType":"CallExpression","endLine":63,"endColumn":39},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":64,"column":7,"nodeType":"CallExpression","endLine":64,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":147,"column":23,"nodeType":"CallExpression","endLine":147,"endColumn":56},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":167,"column":29,"nodeType":"Literal","endLine":167,"endColumn":167},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":240,"column":27,"nodeType":"Literal","endLine":240,"endColumn":149},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":304,"column":12,"nodeType":"CallExpression","endLine":304,"endColumn":37},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":306,"column":23,"nodeType":"CallExpression","endLine":306,"endColumn":74},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":390,"column":5,"nodeType":"CallExpression","endLine":390,"endColumn":66}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Naming Convention Validator\r\n * Enforces consistent naming conventions across the TypeScript codebase\r\n * Part of Task 53.5 - Implement Naming Validation Scripts\r\n */\r\n\r\ninterface NamingRule {\r\n  id: string;\r\n  name: string;\r\n  pattern: RegExp;\r\n  description: string;\r\n  severity: 'error' | 'warning';\r\n  applies: (element: CodeElement) => boolean;\r\n}\r\n\r\ninterface CodeElement {\r\n  type: 'variable' | 'function' | 'class' | 'interface' | 'enum' | 'type' | 'property' | 'method' | 'parameter';\r\n  name: string;\r\n  file: string;\r\n  line: number;\r\n  context?: string;\r\n}\r\n\r\ninterface NamingViolation {\r\n  rule: NamingRule;\r\n  element: CodeElement;\r\n  message: string;\r\n  suggestion?: string;\r\n}\r\n\r\ninterface NamingReport {\r\n  timestamp: string;\r\n  project: string;\r\n  task: string;\r\n  summary: {\r\n    filesScanned: number;\r\n    elementsChecked: number;\r\n    violations: number;\r\n    errors: number;\r\n    warnings: number;\r\n  };\r\n  violations: NamingViolation[];\r\n  overallStatus: 'PASS' | 'FAIL' | 'WARNING';\r\n}\r\n\r\nclass NamingConventionValidator {\r\n  private projectRoot: string;\r\n  private reportDir: string;\r\n  private timestamp: string;\r\n  private rules: NamingRule[];\r\n\r\n  constructor() {\r\n    this.projectRoot = process.cwd();\r\n    this.reportDir = path.join(this.projectRoot, 'scripts', 'analysis', 'reports', 'quality');\r\n    this.timestamp = new Date().toISOString().split('T')[0];\r\n    \r\n    // Ensure reports directory exists\r\n    if (!fs.existsSync(this.reportDir)) {\r\n      fs.mkdirSync(this.reportDir, { recursive: true });\r\n    }\r\n\r\n    this.rules = this.defineNamingRules();\r\n  }\r\n\r\n  /**\r\n   * Define naming convention rules\r\n   */\r\n  private defineNamingRules(): NamingRule[] {\r\n    return [\r\n      {\r\n        id: 'camelCase-variables',\r\n        name: 'Variable camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Variables should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'variable' && !element.name.startsWith('_')\r\n      },\r\n      {\r\n        id: 'camelCase-functions',\r\n        name: 'Function camelCase', \r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Functions should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'function'\r\n      },\r\n      {\r\n        id: 'PascalCase-classes',\r\n        name: 'Class PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Classes should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'class'\r\n      },\r\n      {\r\n        id: 'PascalCase-interfaces',\r\n        name: 'Interface PascalCase',\r\n        pattern: /^I?[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Interfaces should use PascalCase naming (optionally prefixed with I)',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'interface'\r\n      },\r\n      {\r\n        id: 'PascalCase-types',\r\n        name: 'Type PascalCase',\r\n        pattern: /^[A-Z][a-zA-Z0-9]*$/,\r\n        description: 'Type aliases should use PascalCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'type'\r\n      },\r\n      {\r\n        id: 'UPPER_SNAKE_CASE-enums',\r\n        name: 'Enum UPPER_SNAKE_CASE',\r\n        pattern: /^[A-Z][A-Z0-9_]*$/,\r\n        description: 'Enum values should use UPPER_SNAKE_CASE naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'enum'\r\n      },\r\n      {\r\n        id: 'camelCase-methods',\r\n        name: 'Method camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Methods should use camelCase naming',\r\n        severity: 'error',\r\n        applies: (element) => element.type === 'method'\r\n      },\r\n      {\r\n        id: 'camelCase-properties',\r\n        name: 'Property camelCase',\r\n        pattern: /^[a-z][a-zA-Z0-9]*$/,\r\n        description: 'Properties should use camelCase naming',\r\n        severity: 'warning',\r\n        applies: (element) => element.type === 'property' && !element.name.startsWith('_')\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Parse TypeScript file and extract code elements\r\n   */\r\n  private parseCodeElements(filePath: string): CodeElement[] {\r\n    try {\r\n      const content = fs.readFileSync(filePath, 'utf8');\r\n      const lines = content.split('\\n');\r\n      const elements: CodeElement[] = [];\r\n      const relativePath = path.relative(this.projectRoot, filePath);\r\n\r\n      // Extract variables (const, let, var)\r\n      const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      let match;\r\n      while ((match = variableRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'variable',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }\r\n\r\n      // Extract functions\r\n      const functionRegex = /(?:function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)|(?:const|let)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:async\\s*)?\\([^)]*\\)\\s*(?::\\s*[^=]+)?\\s*=>)/g;\r\n      while ((match = functionRegex.exec(content)) !== null) {\r\n        const funcName = match[1] || match[2];\r\n        if (funcName) {\r\n          const lineNumber = this.getLineNumber(content, match.index);\r\n          elements.push({\r\n            type: 'function',\r\n            name: funcName,\r\n            file: relativePath,\r\n            line: lineNumber,\r\n            context: lines[lineNumber - 1]?.trim()\r\n          });\r\n        }\r\n      }\r\n\r\n      // Extract classes\r\n      const classRegex = /class\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      while ((match = classRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'class',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }\r\n\r\n      // Extract interfaces\r\n      const interfaceRegex = /interface\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      while ((match = interfaceRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'interface',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }\r\n\r\n      // Extract type aliases\r\n      const typeRegex = /type\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\r\n      while ((match = typeRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        elements.push({\r\n          type: 'type',\r\n          name: match[1],\r\n          file: relativePath,\r\n          line: lineNumber,\r\n          context: lines[lineNumber - 1]?.trim()\r\n        });\r\n      }\r\n\r\n      // Extract enum values\r\n      const enumRegex = /enum\\s+[a-zA-Z_$][a-zA-Z0-9_$]*\\s*\\{([^}]+)\\}/g;\r\n      while ((match = enumRegex.exec(content)) !== null) {\r\n        const enumBody = match[1];\r\n        const enumValueRegex = /([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*(?:=|,|\\})/g;\r\n        let enumMatch;\r\n        while ((enumMatch = enumValueRegex.exec(enumBody)) !== null) {\r\n          const lineNumber = this.getLineNumber(content, match.index + enumMatch.index);\r\n          elements.push({\r\n            type: 'enum',\r\n            name: enumMatch[1],\r\n            file: relativePath,\r\n            line: lineNumber,\r\n            context: lines[lineNumber - 1]?.trim()\r\n          });\r\n        }\r\n      }\r\n\r\n      // Extract methods (within classes)\r\n      const methodRegex = /(?:public|private|protected)?\\s*(?:static\\s+)?(?:async\\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*(?::\\s*[^{]+)?\\s*\\{/g;\r\n      while ((match = methodRegex.exec(content)) !== null) {\r\n        const lineNumber = this.getLineNumber(content, match.index);\r\n        // Only count as method if inside a class\r\n        if (this.isInsideClass(content, match.index)) {\r\n          elements.push({\r\n            type: 'method',\r\n            name: match[1],\r\n            file: relativePath,\r\n            line: lineNumber,\r\n            context: lines[lineNumber - 1]?.trim()\r\n          });\r\n        }\r\n      }\r\n\r\n      return elements;\r\n    } catch (error) {\r\n      console.warn(`⚠️  Could not parse file: ${filePath}`);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get line number from character index\r\n   */\r\n  private getLineNumber(content: string, index: number): number {\r\n    return content.substring(0, index).split('\\n').length;\r\n  }\r\n\r\n  /**\r\n   * Check if position is inside a class definition\r\n   */\r\n  private isInsideClass(content: string, index: number): boolean {\r\n    const beforeIndex = content.substring(0, index);\r\n    const classMatches = beforeIndex.match(/class\\s+[a-zA-Z_$][a-zA-Z0-9_$]*/g) || [];\r\n    const braceMatches = beforeIndex.match(/[{}]/g) || [];\r\n    \r\n    let braceCount = 0;\r\n    let inClass = false;\r\n    \r\n    for (const brace of braceMatches) {\r\n      if (brace === '{') {\r\n        braceCount++;\r\n        if (classMatches.length > 0 && braceCount === 1) {\r\n          inClass = true;\r\n        }\r\n      } else {\r\n        braceCount--;\r\n        if (braceCount === 0) {\r\n          inClass = false;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return inClass;\r\n  }\r\n\r\n  /**\r\n   * Get all source files recursively\r\n   */\r\n  private getSourceFiles(dirs: string[], extensions: string[] = ['.ts', '.tsx']): string[] {\r\n    const files: string[] = [];\r\n    \r\n    const scanDirectory = (currentDir: string) => {\r\n      if (!fs.existsSync(currentDir)) return;\r\n      \r\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(currentDir, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Skip node_modules, dist, build, etc.\r\n          if (['node_modules', 'dist', 'build', 'coverage', '.next', 'out'].includes(entry.name)) {\r\n            continue;\r\n          }\r\n          scanDirectory(fullPath);\r\n        } else if (entry.isFile()) {\r\n          const ext = path.extname(entry.name);\r\n          if (extensions.includes(ext)) {\r\n            files.push(fullPath);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    for (const dir of dirs) {\r\n      scanDirectory(dir);\r\n    }\r\n    return files;\r\n  }\r\n\r\n  /**\r\n   * Validate naming conventions\r\n   */\r\n  async validate(): Promise<NamingReport> {\r\n    console.log('🚀 Starting naming convention validation...');\r\n    console.log('📁 Project:', this.projectRoot);\r\n    console.log('');\r\n\r\n    const sourceFiles = this.getSourceFiles([\r\n      path.join(this.projectRoot, 'packages'),\r\n      path.join(this.projectRoot, 'scripts')\r\n    ]);\r\n\r\n    console.log(`📋 Scanning ${sourceFiles.length} TypeScript files...`);\r\n\r\n    const violations: NamingViolation[] = [];\r\n    let totalElements = 0;\r\n\r\n    for (const file of sourceFiles) {\r\n      console.log(`🔍 Analyzing: ${path.relative(this.projectRoot, file)}`);\r\n      const elements = this.parseCodeElements(file);\r\n      totalElements += elements.length;\r\n\r\n      for (const element of elements) {\r\n        for (const rule of this.rules) {\r\n          if (rule.applies(element) && !rule.pattern.test(element.name)) {\r\n            violations.push({\r\n              rule,\r\n              element,\r\n              message: `${rule.description}: \"${element.name}\" violates ${rule.name}`,\r\n              suggestion: this.generateSuggestion(element.name, rule)\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const errors = violations.filter(v => v.rule.severity === 'error').length;\r\n    const warnings = violations.filter(v => v.rule.severity === 'warning').length;\r\n    const overallStatus = errors > 0 ? 'FAIL' : warnings > 0 ? 'WARNING' : 'PASS';\r\n\r\n    const report: NamingReport = {\r\n      timestamp: new Date().toISOString(),\r\n      project: 'JBR Trading Platform',\r\n      task: 'Task 53.5 - Naming Convention Validation',\r\n      summary: {\r\n        filesScanned: sourceFiles.length,\r\n        elementsChecked: totalElements,\r\n        violations: violations.length,\r\n        errors,\r\n        warnings\r\n      },\r\n      violations,\r\n      overallStatus\r\n    };\r\n\r\n    // Save report\r\n    const reportPath = path.join(this.reportDir, `naming-validation-${this.timestamp}.json`);\r\n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\r\n\r\n    // Display summary\r\n    console.log('');\r\n    console.log('🎯 NAMING CONVENTION VALIDATION SUMMARY:');\r\n    console.log(`📊 Overall Status: ${overallStatus}`);\r\n    console.log(`📁 Files Scanned: ${sourceFiles.length}`);\r\n    console.log(`🔍 Elements Checked: ${totalElements}`);\r\n    console.log(`❌ Violations Found: ${violations.length}`);\r\n    console.log(`🚨 Errors: ${errors}`);\r\n    console.log(`⚠️  Warnings: ${warnings}`);\r\n    console.log('');\r\n\r\n    if (violations.length > 0) {\r\n      console.log('❌ NAMING VIOLATIONS:');\r\n      // Group violations by file\r\n      const violationsByFile = new Map<string, NamingViolation[]>();\r\n      for (const violation of violations) {\r\n        const file = violation.element.file;\r\n        if (!violationsByFile.has(file)) {\r\n          violationsByFile.set(file, []);\r\n        }\r\n        violationsByFile.get(file)!.push(violation);\r\n      }\r\n\r\n      for (const [file, fileViolations] of violationsByFile.entries()) {\r\n        console.log(`📄 ${file}:`);\r\n        for (const violation of fileViolations.slice(0, 5)) { // Limit output\r\n          const severity = violation.rule.severity === 'error' ? '❌' : '⚠️ ';\r\n          console.log(`   ${severity} Line ${violation.element.line}: ${violation.message}`);\r\n          if (violation.suggestion) {\r\n            console.log(`     💡 Suggestion: ${violation.suggestion}`);\r\n          }\r\n        }\r\n        if (fileViolations.length > 5) {\r\n          console.log(`     ... and ${fileViolations.length - 5} more violations`);\r\n        }\r\n        console.log('');\r\n      }\r\n    }\r\n\r\n    console.log(`📋 Full report saved: ${reportPath}`);\r\n    return report;\r\n  }\r\n\r\n  /**\r\n   * Generate naming suggestion based on rule\r\n   */\r\n  private generateSuggestion(name: string, rule: NamingRule): string {\r\n    switch (rule.id) {\r\n      case 'camelCase-variables':\r\n      case 'camelCase-functions':\r\n      case 'camelCase-methods':\r\n      case 'camelCase-properties':\r\n        return this.toCamelCase(name);\r\n      case 'PascalCase-classes':\r\n      case 'PascalCase-interfaces':\r\n      case 'PascalCase-types':\r\n        return this.toPascalCase(name);\r\n      case 'UPPER_SNAKE_CASE-enums':\r\n        return this.toUpperSnakeCase(name);\r\n      default:\r\n        return 'Follow the naming convention for this element type';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert string to camelCase\r\n   */\r\n  private toCamelCase(str: string): string {\r\n    return str\r\n      .replace(/[-_\\s]+(.)?/g, (_, char) => char ? char.toUpperCase() : '')\r\n      .replace(/^[A-Z]/, char => char.toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Convert string to PascalCase\r\n   */\r\n  private toPascalCase(str: string): string {\r\n    return str\r\n      .replace(/[-_\\s]+(.)?/g, (_, char) => char ? char.toUpperCase() : '')\r\n      .replace(/^[a-z]/, char => char.toUpperCase());\r\n  }\r\n\r\n  /**\r\n   * Convert string to UPPER_SNAKE_CASE\r\n   */\r\n  private toUpperSnakeCase(str: string): string {\r\n    return str\r\n      .replace(/([a-z])([A-Z])/g, '$1_$2')\r\n      .replace(/[-\\s]+/g, '_')\r\n      .toUpperCase();\r\n  }\r\n}\r\n\r\n// Run validation if called directly\r\nasync function main() {\r\n  const validator = new NamingConventionValidator();\r\n  try {\r\n    const report = await validator.validate();\r\n    process.exit(report.overallStatus === 'FAIL' ? 1 : 0);\r\n  } catch (error: any) {\r\n    console.error('❌ Naming validation failed:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Execute if this file is run directly\r\nif (require.main === module || process.argv[1] === __filename) {\r\n  main();\r\n}\r\n\r\nexport { NamingConventionValidator, NamingReport, NamingViolation, NamingRule };\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\test-dependency-verification.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":42,"column":22,"nodeType":"CallExpression","endLine":42,"endColumn":44},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":49,"column":15,"nodeType":"CallExpression","endLine":49,"endColumn":45},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":50,"column":40,"nodeType":"CallExpression","endLine":50,"endColumn":80},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found writeFileSync from package \"fs\" with non literal argument at index 0","line":111,"column":7,"nodeType":"CallExpression","endLine":111,"endColumn":59},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":134,"column":11,"nodeType":"CallExpression","endLine":134,"endColumn":38},{"ruleId":"security/detect-non-literal-fs-filename","severity":2,"message":"Found unlinkSync from package \"fs\" with non literal argument at index 0","line":135,"column":9,"nodeType":"CallExpression","endLine":135,"endColumn":36}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Dependency Verification Test\r\n * Verifies Material-UI installation and creates isolated component tests\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { execSync } from 'child_process';\r\n\r\nclass DependencyVerifier {\r\n  private readonly frontendDir: string;\r\n\r\n  constructor() {\r\n    this.frontendDir = path.join(__dirname, 'packages/frontend');\r\n  }\r\n\r\n  public async runVerification(): Promise<void> {\r\n    console.log('🔍 Dependency Verification Test\\n');\r\n\r\n    await this.checkActualInstallation();\r\n    await this.createIsolatedComponentTest();\r\n    await this.testWebSocketHookIsolated();\r\n  }\r\n\r\n  /**\r\n   * Check if dependencies are actually installed\r\n   */\r\n  private async checkActualInstallation(): Promise<void> {\r\n    console.log('📦 Checking actual Material-UI installation...\\n');\r\n\r\n    const nodeModulesPath = path.join(this.frontendDir, 'node_modules');\r\n    \r\n    const requiredPackages = [\r\n      '@mui/material',\r\n      '@mui/icons-material', \r\n      '@emotion/react',\r\n      '@emotion/styled'\r\n    ];\r\n\r\n    requiredPackages.forEach(pkg => {\r\n      const pkgPath = path.join(nodeModulesPath, pkg);\r\n      const exists = fs.existsSync(pkgPath);\r\n      \r\n      console.log(`${pkg}: ${exists ? '✅' : '❌'}`);\r\n      \r\n      if (exists) {\r\n        try {\r\n          const packageJsonPath = path.join(pkgPath, 'package.json');\r\n          if (fs.existsSync(packageJsonPath)) {\r\n            const pkgInfo = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\r\n            console.log(`  Version: ${pkgInfo.version}`);\r\n          }\r\n        } catch (error) {\r\n          console.log(`  Version check failed: ${error}`);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create minimal isolated component test\r\n   */\r\n  private async createIsolatedComponentTest(): Promise<void> {\r\n    console.log('\\n🧪 Creating isolated component test...\\n');\r\n\r\n    const testComponentContent = `import React from 'react';\r\nimport { \r\n  Card,\r\n  CardContent,\r\n  Typography,\r\n  Box,\r\n  Grid,\r\n  Button\r\n} from '@mui/material';\r\nimport { Info as InfoIcon } from '@mui/icons-material';\r\n\r\n// Minimal test component using our required Material-UI elements\r\nconst TestLogViewerCore: React.FC = () => {\r\n  return (\r\n    <Card>\r\n      <CardContent>\r\n        <Box display=\"flex\" alignItems=\"center\" gap={1}>\r\n          <InfoIcon color=\"primary\" />\r\n          <Typography variant=\"h6\">\r\n            Log Viewer Test Component\r\n          </Typography>\r\n        </Box>\r\n        \r\n        <Grid container spacing={2} sx={{ mt: 2 }}>\r\n          <Grid size={{ xs: 12, md: 6 }}>\r\n            <Typography variant=\"body2\">\r\n              Testing Grid v2 syntax with size prop\r\n            </Typography>\r\n          </Grid>\r\n          <Grid size={{ xs: 12, md: 6 }}>\r\n            <Button variant=\"outlined\" fullWidth>\r\n              Test Button\r\n            </Button>\r\n          </Grid>\r\n        </Grid>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default TestLogViewerCore;`;\r\n\r\n    const testFilePath = path.join(this.frontendDir, 'test-component.tsx');\r\n    \r\n    try {\r\n      fs.writeFileSync(testFilePath, testComponentContent);\r\n      console.log('✅ Test component created');\r\n\r\n      // Try to compile it\r\n      const command = `cd \"${this.frontendDir}\" && npx tsc --noEmit --skipLibCheck --jsx react-jsx test-component.tsx`;\r\n      \r\n      try {\r\n        execSync(command, { stdio: 'pipe', encoding: 'utf8' });\r\n        console.log('✅ Isolated component compiles successfully');\r\n      } catch (error: any) {\r\n        console.log('❌ Compilation errors in isolated component:');\r\n        const errorOutput = error.stdout || error.stderr || '';\r\n        const errors = errorOutput.split('\\n').filter((line: string) => \r\n          line.includes('error TS')\r\n        ).slice(0, 3);\r\n        \r\n        errors.forEach((err: string) => console.log(`  ${err.trim()}`));\r\n      }\r\n\r\n    } catch (error) {\r\n      console.log('❌ Failed to create test component:', error);\r\n    } finally {\r\n      // Clean up\r\n      if (fs.existsSync(testFilePath)) {\r\n        fs.unlinkSync(testFilePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test WebSocket hook in isolation\r\n   */\r\n  private async testWebSocketHookIsolated(): Promise<void> {\r\n    console.log('\\n🔌 Testing WebSocket hook in isolation...\\n');\r\n\r\n    try {\r\n      const command = `cd \"${this.frontendDir}\" && npx tsc --noEmit --skipLibCheck --jsx react-jsx src/hooks/useWebSocket.ts`;\r\n      execSync(command, { stdio: 'pipe', encoding: 'utf8' });\r\n      console.log('✅ WebSocket hook compiles successfully');\r\n      console.log('✅ Our TypeScript implementation is solid');\r\n    } catch (error: any) {\r\n      console.log('❌ WebSocket hook compilation errors:');\r\n      const errorOutput = error.stdout || error.stderr || '';\r\n      console.log(errorOutput.split('\\n').slice(0, 5).join('\\n'));\r\n    }\r\n  }\r\n}\r\n\r\n// Run the verification\r\nconst verifier = new DependencyVerifier();\r\nverifier.runVerification().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\tests\\global-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\tests\\global-teardown.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\M.U. Kamal\\Programing\\0TS\\JBR\\tests\\jest.setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]