/**
 * AI Report Generator for TaskMaster
 * Generates comprehensive markdown reports from AI analysis
 */

import { AIProjectAnalysis, ProjectIssue, Recommendation, ProjectInsights } from './ai-project-analyzer';
import { writeFileSync } from 'fs';
import { join } from 'path';

export class AIReportGenerator {
  
  /**
   * Generate comprehensive markdown report
   */
  public generateMarkdownReport(analysis: AIProjectAnalysis): string {
    const { understanding, insights, issues, recommendations, architecture, codeQuality } = analysis;
    
    return `# 🧠 AI Project Analysis Report
*Generated on ${new Date(analysis.metadata.timestamp).toLocaleString()}*

## 📊 Executive Summary

${insights.summary}

**Overall Assessment:**
- **Code Quality Score:** ${codeQuality.overallScore}/100
- **Maintainability:** ${insights.maintainability.score}/100  
- **Technical Debt:** ${insights.technicalDebt.score}/100
- **Analysis Confidence:** ${Math.round(analysis.metadata.confidence * 100)}%

## 💪 Project Strengths

${insights.strengths.map(strength => `- ✅ ${strength}`).join('\n')}

## ⚠️ Areas for Improvement

${insights.weaknesses.map(weakness => `- ⚠️ ${weakness}`).join('\n')}

## 🔍 Detailed Analysis

### 📈 Codebase Statistics
- **Total Files:** ${understanding.codebase.totalFiles.toLocaleString()}
- **Lines of Code:** ${understanding.codebase.totalLines.toLocaleString()}
- **Primary Languages:** ${Object.entries(understanding.codebase.languages)
  .sort(([,a], [,b]) => b - a)
  .slice(0, 3)
  .map(([lang, count]) => `${lang} (${count} files)`)
  .join(', ')}

### 🏗️ Architecture Analysis
- **Pattern:** ${architecture.pattern}
- **Architectural Layers:** ${architecture.layers.length}
- **Design Principles Score:** ${Object.values(architecture.designPrinciples.solid).filter(Boolean).length}/5 SOLID principles followed

${this.generateArchitectureSection(architecture)}

### 📊 Code Quality Metrics
- **Maintainability Index:** ${codeQuality.metrics.maintainability}/100
- **Complexity Score:** ${codeQuality.metrics.complexity}
- **Code Duplication:** ${codeQuality.metrics.duplication}%
- **Testability:** ${codeQuality.metrics.testability}/100

### 🧪 Test Coverage Analysis
- **Coverage:** ${codeQuality.testCoverage.percentage}%
- **Critical Gaps:** ${codeQuality.testCoverage.criticalGaps.length > 0 ? 
  codeQuality.testCoverage.criticalGaps.join(', ') : 'None identified'}

## 🚨 Issues Detected

${this.generateIssuesSection(issues)}

## 🧠 AI-Generated Insights

${this.generateAIInsightsSection(insights)}

## 💡 AI Recommendations

${this.generateRecommendationsSection(recommendations)}

## 📚 Technical Debt Analysis

**Debt Score:** ${insights.technicalDebt.score}/100

**Key Indicators:**
${insights.technicalDebt.indicators.map(indicator => `- ${indicator}`).join('\n')}

**Estimated Resolution Time:** ${insights.technicalDebt.estimatedHours} hours

## 🎯 Next Steps

Based on the AI analysis, here are the recommended next steps in priority order:

${recommendations
  .sort((a, b) => this.getPriorityValue(a.priority) - this.getPriorityValue(b.priority))
  .slice(0, 5)
  .map((rec, index) => `${index + 1}. **${rec.title}** (${rec.priority} priority) - ${rec.estimatedEffort}`)
  .join('\n')}

## 📋 Detailed Findings

### Complexity Analysis
- **Cyclomatic Complexity:** ${insights.complexity.cyclomatic}
- **Cognitive Complexity:** ${insights.complexity.cognitive}
- **Maintainability Index:** ${insights.complexity.maintainabilityIndex}

### Documentation Analysis
- **Documentation Score:** ${codeQuality.documentation.score}/100
- **Missing Documentation:** ${codeQuality.documentation.missingDocs.length > 0 ? 
  codeQuality.documentation.missingDocs.join(', ') : 'None'}

## 🛡️ Security & Dependencies
- **Total Dependencies:** ${architecture.dependencies.totalDependencies}
- **Outdated Dependencies:** ${architecture.dependencies.outdated}
- **Vulnerable Dependencies:** ${architecture.dependencies.vulnerable}

---

*This report was generated by TaskMaster AI Analyzer v${analysis.metadata.version} in ${analysis.metadata.analysisTime}ms*
`;
  }

  /**
   * Generate architecture section
   */
  private generateArchitectureSection(architecture: any): string {
    let section = '\n**Architectural Layers:**\n';
    
    architecture.layers.forEach((layer: any) => {
      section += `- **${layer.name}:** ${layer.purpose}\n`;
    });

    section += '\n**Design Principles:**\n';
    const solid = architecture.designPrinciples.solid;
    section += `- Single Responsibility: ${solid.singleResponsibility ? '✅' : '❌'}\n`;
    section += `- Open/Closed: ${solid.openClosed ? '✅' : '❌'}\n`;
    section += `- Liskov Substitution: ${solid.liskovSubstitution ? '✅' : '❌'}\n`;
    section += `- Interface Segregation: ${solid.interfaceSegregation ? '✅' : '❌'}\n`;
    section += `- Dependency Inversion: ${solid.dependencyInversion ? '✅' : '❌'}\n`;

    return section;
  }

  /**
   * Generate issues section
   */
  private generateIssuesSection(issues: ProjectIssue[]): string {
    if (issues.length === 0) {
      return 'No critical issues detected! 🎉';
    }

    let section = '';
    
    // Group by severity
    const critical = issues.filter(i => i.type === 'critical');
    const warnings = issues.filter(i => i.type === 'warning');
    const suggestions = issues.filter(i => i.type === 'suggestion');

    if (critical.length > 0) {
      section += '\n### 🚨 Critical Issues\n';
      critical.forEach(issue => {
        section += `\n#### ${issue.title}\n`;
        section += `**Category:** ${issue.category} | **Impact:** ${issue.impact} | **Effort:** ${issue.effort}\n\n`;
        section += `${issue.description}\n\n`;
        section += '**Suggestions:**\n';
        issue.suggestions.forEach(suggestion => {
          section += `- ${suggestion}\n`;
        });
      });
    }

    if (warnings.length > 0) {
      section += '\n### ⚠️ Warnings\n';
      warnings.forEach(issue => {
        section += `\n#### ${issue.title}\n`;
        section += `**Impact:** ${issue.impact} | **Effort:** ${issue.effort}\n`;
        section += `${issue.description}\n\n`;
      });
    }

    if (suggestions.length > 0) {
      section += '\n### 💡 Suggestions\n';
      suggestions.forEach(issue => {
        section += `- **${issue.title}:** ${issue.description}\n`;
      });
    }

    return section;
  }

  /**
   * Generate AI insights section with real AI-generated insights
   */
  private generateAIInsightsSection(insights: ProjectInsights): string {
    if (!insights.aiGeneratedInsights || insights.aiGeneratedInsights.length === 0) {
      return '\n*AI analysis did not generate specific insights for this project.*\n';
    }

    let section = '\n**🤖 Deep AI Analysis Results:**\n\n';
    
    insights.aiGeneratedInsights.forEach((insight: string, index: number) => {
      section += `### 🎯 Critical Finding #${index + 1}\n\n`;
      section += `${insight.trim()}\n\n`;
    });

    return section;
  }

  /**
   * Generate recommendations section
   */
  private generateRecommendationsSection(recommendations: Recommendation[]): string {
    if (recommendations.length === 0) {
      return 'No specific recommendations at this time.';
    }

    let section = '';

    recommendations.forEach((rec, index) => {
      section += `\n### ${index + 1}. ${rec.title} (${rec.priority} priority)\n\n`;
      section += `**Category:** ${rec.category}\n`;
      section += `**Estimated Effort:** ${rec.estimatedEffort}\n\n`;
      section += `${rec.description}\n\n`;
      
      section += '**Benefits:**\n';
      rec.benefits.forEach(benefit => {
        section += `- ${benefit}\n`;
      });
      
      section += '\n**Implementation Steps:**\n';
      rec.implementation.forEach(step => {
        section += `- ${step}\n`;
      });
      
      section += '\n';
    });

    return section;
  }

  /**
   * Get numeric value for priority sorting
   */
  private getPriorityValue(priority: string): number {
    switch (priority) {
      case 'high': return 1;
      case 'medium': return 2;
      case 'low': return 3;
      default: return 4;
    }
  }

  /**
   * Save report to file
   */
  public saveReport(analysis: AIProjectAnalysis, outputPath: string): void {
    const report = this.generateMarkdownReport(analysis);
    writeFileSync(outputPath, report, 'utf-8');
  }
}
